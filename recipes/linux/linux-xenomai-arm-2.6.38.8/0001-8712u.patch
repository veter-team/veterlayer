From 20298ac61073b6207e884e739c69381da92e3cb8 Mon Sep 17 00:00:00 2001
From: Maksym Parkachov <mparkachov@gmail.com>
Date: Tue, 5 Jun 2012 10:33:17 +0200
Subject: [PATCH] 8712u

---
 drivers/net/wireless/8712u/Kconfig                 |    6 +
 drivers/net/wireless/8712u/Makefile                |  261 +
 .../wireless/8712u/autoconf_rtl8712_usb_linux.h    |  178 +
 drivers/net/wireless/8712u/clean                   |    7 +
 drivers/net/wireless/8712u/cmd/rtl8712_cmd.c       | 1417 +
 drivers/net/wireless/8712u/cmd/rtl871x_cmd.c       | 2061 ++
 drivers/net/wireless/8712u/config                  |   27 +
 .../net/wireless/8712u/crypto/rtl871x_security.c   | 1940 ++
 drivers/net/wireless/8712u/debug/rtl871x_debug.c   |   66 +
 drivers/net/wireless/8712u/eeprom/rtl871x_eeprom.c |  423 +
 drivers/net/wireless/8712u/efuse/rtl8712_efuse.c   |  976 +
 drivers/net/wireless/8712u/hal/rtl8712/hal_init.c  |  934 +
 .../net/wireless/8712u/hal/rtl8712/usb_halinit.c   |  461 +
 drivers/net/wireless/8712u/hal/rtl8712/usb_ops.c   |  312 +
 .../net/wireless/8712u/hal/rtl8712/usb_ops_linux.c | 1110 +
 drivers/net/wireless/8712u/ifcfg-wlan0             |    4 +
 drivers/net/wireless/8712u/include/autoconf.h      |  178 +
 drivers/net/wireless/8712u/include/basic_types.h   |  110 +
 .../wireless/8712u/include/byteorder/big_endian.h  |   87 +
 .../net/wireless/8712u/include/byteorder/generic.h |  209 +
 .../8712u/include/byteorder/little_endian.h        |   87 +
 .../net/wireless/8712u/include/byteorder/swab.h    |  128 +
 .../net/wireless/8712u/include/byteorder/swabb.h   |  156 +
 drivers/net/wireless/8712u/include/circ_buf.h      |   27 +
 drivers/net/wireless/8712u/include/cmd_osdep.h     |   36 +
 drivers/net/wireless/8712u/include/drv_conf.h      |   47 +
 drivers/net/wireless/8712u/include/drv_types.h     |  361 +
 drivers/net/wireless/8712u/include/drv_types_ce.h  |   92 +
 .../net/wireless/8712u/include/drv_types_linux.h   |   25 +
 drivers/net/wireless/8712u/include/drv_types_xp.h  |   95 +
 drivers/net/wireless/8712u/include/ethernet.h      |   41 +
 drivers/net/wireless/8712u/include/farray.h        |32312 ++++++++++++++++++++
 drivers/net/wireless/8712u/include/h2clbk.h        |   35 +
 drivers/net/wireless/8712u/include/hal_init.h      |   40 +
 drivers/net/wireless/8712u/include/ieee80211.h     | 1171 +
 drivers/net/wireless/8712u/include/ieee80211_ext.h |  477 +
 drivers/net/wireless/8712u/include/if_ether.h      |  131 +
 .../net/wireless/8712u/include/ioctl_cfg80211.h    |   60 +
 drivers/net/wireless/8712u/include/ip.h            |  157 +
 drivers/net/wireless/8712u/include/mlme_osdep.h    |   42 +
 drivers/net/wireless/8712u/include/mp_custom_oid.h |  353 +
 drivers/net/wireless/8712u/include/nic_spec.h      |   47 +
 .../net/wireless/8712u/include/osdep_ce_service.h  |  151 +
 drivers/net/wireless/8712u/include/osdep_intf.h    |  133 +
 drivers/net/wireless/8712u/include/osdep_service.h |  484 +
 drivers/net/wireless/8712u/include/recv_osdep.h    |   58 +
 .../net/wireless/8712u/include/rtl8712_bitdef.h    |   44 +
 drivers/net/wireless/8712u/include/rtl8712_cmd.h   |  338 +
 drivers/net/wireless/8712u/include/rtl8712_efuse.h |   56 +
 drivers/net/wireless/8712u/include/rtl8712_event.h |  109 +
 drivers/net/wireless/8712u/include/rtl8712_hal.h   |  175 +
 drivers/net/wireless/8712u/include/rtl8712_recv.h  |  301 +
 .../net/wireless/8712u/include/rtl8712_regdef.h    |   43 +
 drivers/net/wireless/8712u/include/rtl8712_rf.h    |   58 +
 drivers/net/wireless/8712u/include/rtl8712_spec.h  |  128 +
 .../ioreg_def/rtl8712_cmdctrl_bitdef.h             |  130 +
 .../ioreg_def/rtl8712_cmdctrl_regdef.h             |   34 +
 .../ioreg_def/rtl8712_debugctrl_bitdef.h           |   56 +
 .../ioreg_def/rtl8712_debugctrl_regdef.h           |   47 +
 .../ioreg_def/rtl8712_edcasetting_bitdef.h         |   72 +
 .../ioreg_def/rtl8712_edcasetting_regdef.h         |   39 +
 .../ioreg_def/rtl8712_fifoctrl_bitdef.h            |  145 +
 .../ioreg_def/rtl8712_fifoctrl_regdef.h            |   76 +
 .../rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h     |   85 +
 .../rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h     |   35 +
 .../ioreg_def/rtl8712_interrupt_bitdef.h           |   58 +
 .../ioreg_def/rtl8712_interrupt_regdef.h           |   30 +
 .../ioreg_def/rtl8712_macsetting_bitdef.h          |   49 +
 .../ioreg_def/rtl8712_macsetting_regdef.h          |   38 +
 .../ioreg_def/rtl8712_offload_bitdef.h             |   26 +
 .../ioreg_def/rtl8712_offload_regdef.h             |   29 +
 .../ioreg_def/rtl8712_powersave_bitdef.h           |   53 +
 .../ioreg_def/rtl8712_powersave_regdef.h           |   39 +
 .../ioreg_def/rtl8712_ratectrl_bitdef.h            |   48 +
 .../ioreg_def/rtl8712_ratectrl_regdef.h            |   50 +
 .../ioreg_def/rtl8712_security_bitdef.h            |   48 +
 .../ioreg_def/rtl8712_security_regdef.h            |   30 +
 .../rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h |  163 +
 .../rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h |   50 +
 .../ioreg_def/rtl8712_timectrl_bitdef.h            |   63 +
 .../ioreg_def/rtl8712_timectrl_regdef.h            |   41 +
 .../rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h   |   56 +
 .../rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h   |   44 +
 .../include/rtl8712_spec/ioreg_def/vssver.scc      |  Bin 0 -> 448 bytes
 .../rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h    |   61 +
 .../rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h    |   71 +
 drivers/net/wireless/8712u/include/rtl8712_xmit.h  |  312 +
 .../net/wireless/8712u/include/rtl871x_byteorder.h |   40 +
 drivers/net/wireless/8712u/include/rtl871x_cmd.h   | 1148 +
 drivers/net/wireless/8712u/include/rtl871x_debug.h |  262 +
 .../net/wireless/8712u/include/rtl871x_eeprom.h    |  128 +
 drivers/net/wireless/8712u/include/rtl871x_event.h |  185 +
 drivers/net/wireless/8712u/include/rtl871x_ht.h    |   39 +
 drivers/net/wireless/8712u/include/rtl871x_io.h    |  443 +
 drivers/net/wireless/8712u/include/rtl871x_ioctl.h |  264 +
 .../wireless/8712u/include/rtl871x_ioctl_query.h   |   36 +
 .../net/wireless/8712u/include/rtl871x_ioctl_rtl.h |   83 +
 .../net/wireless/8712u/include/rtl871x_ioctl_set.h |   77 +
 drivers/net/wireless/8712u/include/rtl871x_led.h   |  120 +
 drivers/net/wireless/8712u/include/rtl871x_mlme.h  |  412 +
 .../net/wireless/8712u/include/rtl871x_mlme_ext.h  |  385 +
 drivers/net/wireless/8712u/include/rtl871x_mp.h    |  459 +
 .../net/wireless/8712u/include/rtl871x_mp_ioctl.h  |  572 +
 .../wireless/8712u/include/rtl871x_mp_phy_regdef.h | 1068 +
 .../net/wireless/8712u/include/rtl871x_pwrctrl.h   |  179 +
 drivers/net/wireless/8712u/include/rtl871x_qos.h   |   40 +
 drivers/net/wireless/8712u/include/rtl871x_recv.h  |  514 +
 drivers/net/wireless/8712u/include/rtl871x_rf.h    |  110 +
 .../net/wireless/8712u/include/rtl871x_security.h  |  280 +
 .../net/wireless/8712u/include/rtl871x_wlan_mlme.h |   86 +
 .../net/wireless/8712u/include/rtl871x_wlan_sme.h  |   54 +
 drivers/net/wireless/8712u/include/rtl871x_xmit.h  |  471 +
 drivers/net/wireless/8712u/include/rtw_android.h   |   99 +
 drivers/net/wireless/8712u/include/sdio_hal.h      |   33 +
 drivers/net/wireless/8712u/include/sdio_ops.h      |   79 +
 drivers/net/wireless/8712u/include/sdio_ops_ce.h   |   55 +
 .../net/wireless/8712u/include/sdio_ops_linux.h    |   54 +
 drivers/net/wireless/8712u/include/sdio_ops_xp.h   |   55 +
 drivers/net/wireless/8712u/include/sdio_osintf.h   |   47 +
 drivers/net/wireless/8712u/include/sta_info.h      |  182 +
 drivers/net/wireless/8712u/include/usb_hal.h       |   28 +
 drivers/net/wireless/8712u/include/usb_ops.h       |   75 +
 drivers/net/wireless/8712u/include/usb_osintf.h    |   43 +
 .../net/wireless/8712u/include/usb_vendor_req.h    |   59 +
 drivers/net/wireless/8712u/include/version.h       |    1 +
 drivers/net/wireless/8712u/include/wifi.h          |  676 +
 drivers/net/wireless/8712u/include/wlan_bssdef.h   |  408 +
 drivers/net/wireless/8712u/include/xmit_osdep.h    |   87 +
 drivers/net/wireless/8712u/io/rtl8712_io.c         |  270 +
 drivers/net/wireless/8712u/io/rtl871x_io.c         |  571 +
 .../net/wireless/8712u/ioctl/rtl871x_ioctl_linux.c | 4082 +++
 .../net/wireless/8712u/ioctl/rtl871x_ioctl_query.c |  196 +
 .../net/wireless/8712u/ioctl/rtl871x_ioctl_rtl.c   | 1028 +
 .../net/wireless/8712u/ioctl/rtl871x_ioctl_set.c   | 1577 +
 drivers/net/wireless/8712u/led/rtl8712_led.c       | 2822 ++
 drivers/net/wireless/8712u/mlme/ieee80211.c        |  643 +
 drivers/net/wireless/8712u/mlme/rtl871x_mlme.c     | 3201 ++
 drivers/net/wireless/8712u/mp/rtl871x_mp.c         | 1523 +
 drivers/net/wireless/8712u/mp/rtl871x_mp_ioctl.c   | 3080 ++
 .../net/wireless/8712u/os_dep/linux/cmd_linux.c    |   49 +
 drivers/net/wireless/8712u/os_dep/linux/io_linux.c |  129 +
 .../wireless/8712u/os_dep/linux/ioctl_cfg80211.c   | 2402 ++
 .../net/wireless/8712u/os_dep/linux/mlme_linux.c   |  380 +
 .../net/wireless/8712u/os_dep/linux/recv_linux.c   |  287 +
 .../net/wireless/8712u/os_dep/linux/rtw_android.c  |  927 +
 .../net/wireless/8712u/os_dep/linux/xmit_linux.c   |  329 +
 .../net/wireless/8712u/os_intf/linux/os_intfs.c    | 1065 +
 .../net/wireless/8712u/os_intf/linux/usb_intf.c    | 1066 +
 drivers/net/wireless/8712u/os_intf/osdep_service.c |  670 +
 .../net/wireless/8712u/pwrctrl/rtl871x_pwrctrl.c   |  750 +
 drivers/net/wireless/8712u/recv/rtl8712_recv.c     | 2638 ++
 drivers/net/wireless/8712u/recv/rtl871x_recv.c     | 1522 +
 drivers/net/wireless/8712u/rf/rtl8712_rf.c         |  508 +
 drivers/net/wireless/8712u/rf/rtl871x_rf.c         |  529 +
 drivers/net/wireless/8712u/runwpa                  |   20 +
 .../net/wireless/8712u/sta_mgt/rtl871x_sta_mgt.c   |  555 +
 drivers/net/wireless/8712u/wlan0dhcp               |   16 +
 drivers/net/wireless/8712u/wpa1.conf               |   11 +
 drivers/net/wireless/8712u/xmit/rtl8712_xmit.c     | 2015 ++
 drivers/net/wireless/8712u/xmit/rtl871x_xmit.c     | 1999 ++
 drivers/net/wireless/Kconfig                       |    1 +
 drivers/net/wireless/Makefile                      |    3 +
 162 files changed, 97143 insertions(+)
 create mode 100755 drivers/net/wireless/8712u/Kconfig
 create mode 100755 drivers/net/wireless/8712u/Makefile
 create mode 100755 drivers/net/wireless/8712u/autoconf_rtl8712_usb_linux.h
 create mode 100755 drivers/net/wireless/8712u/clean
 create mode 100755 drivers/net/wireless/8712u/cmd/rtl8712_cmd.c
 create mode 100755 drivers/net/wireless/8712u/cmd/rtl871x_cmd.c
 create mode 100755 drivers/net/wireless/8712u/config
 create mode 100755 drivers/net/wireless/8712u/crypto/rtl871x_security.c
 create mode 100755 drivers/net/wireless/8712u/debug/rtl871x_debug.c
 create mode 100755 drivers/net/wireless/8712u/eeprom/rtl871x_eeprom.c
 create mode 100755 drivers/net/wireless/8712u/efuse/rtl8712_efuse.c
 create mode 100755 drivers/net/wireless/8712u/hal/rtl8712/hal_init.c
 create mode 100755 drivers/net/wireless/8712u/hal/rtl8712/usb_halinit.c
 create mode 100755 drivers/net/wireless/8712u/hal/rtl8712/usb_ops.c
 create mode 100755 drivers/net/wireless/8712u/hal/rtl8712/usb_ops_linux.c
 create mode 100755 drivers/net/wireless/8712u/ifcfg-wlan0
 create mode 100755 drivers/net/wireless/8712u/include/autoconf.h
 create mode 100755 drivers/net/wireless/8712u/include/basic_types.h
 create mode 100755 drivers/net/wireless/8712u/include/byteorder/big_endian.h
 create mode 100755 drivers/net/wireless/8712u/include/byteorder/generic.h
 create mode 100755 drivers/net/wireless/8712u/include/byteorder/little_endian.h
 create mode 100755 drivers/net/wireless/8712u/include/byteorder/swab.h
 create mode 100755 drivers/net/wireless/8712u/include/byteorder/swabb.h
 create mode 100755 drivers/net/wireless/8712u/include/circ_buf.h
 create mode 100755 drivers/net/wireless/8712u/include/cmd_osdep.h
 create mode 100755 drivers/net/wireless/8712u/include/drv_conf.h
 create mode 100755 drivers/net/wireless/8712u/include/drv_types.h
 create mode 100755 drivers/net/wireless/8712u/include/drv_types_ce.h
 create mode 100755 drivers/net/wireless/8712u/include/drv_types_linux.h
 create mode 100755 drivers/net/wireless/8712u/include/drv_types_xp.h
 create mode 100755 drivers/net/wireless/8712u/include/ethernet.h
 create mode 100755 drivers/net/wireless/8712u/include/farray.h
 create mode 100755 drivers/net/wireless/8712u/include/h2clbk.h
 create mode 100755 drivers/net/wireless/8712u/include/hal_init.h
 create mode 100755 drivers/net/wireless/8712u/include/ieee80211.h
 create mode 100755 drivers/net/wireless/8712u/include/ieee80211_ext.h
 create mode 100755 drivers/net/wireless/8712u/include/if_ether.h
 create mode 100755 drivers/net/wireless/8712u/include/ioctl_cfg80211.h
 create mode 100755 drivers/net/wireless/8712u/include/ip.h
 create mode 100755 drivers/net/wireless/8712u/include/mlme_osdep.h
 create mode 100755 drivers/net/wireless/8712u/include/mp_custom_oid.h
 create mode 100755 drivers/net/wireless/8712u/include/nic_spec.h
 create mode 100755 drivers/net/wireless/8712u/include/osdep_ce_service.h
 create mode 100755 drivers/net/wireless/8712u/include/osdep_intf.h
 create mode 100755 drivers/net/wireless/8712u/include/osdep_service.h
 create mode 100755 drivers/net/wireless/8712u/include/recv_osdep.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_cmd.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_efuse.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_event.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_hal.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_recv.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_rf.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/vssver.scc
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl8712_xmit.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_byteorder.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_cmd.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_debug.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_eeprom.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_event.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_ht.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_io.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_ioctl.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_ioctl_query.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_ioctl_rtl.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_ioctl_set.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_led.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_mlme.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_mlme_ext.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_mp.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_mp_ioctl.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_mp_phy_regdef.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_pwrctrl.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_qos.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_recv.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_rf.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_security.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_wlan_mlme.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_wlan_sme.h
 create mode 100755 drivers/net/wireless/8712u/include/rtl871x_xmit.h
 create mode 100755 drivers/net/wireless/8712u/include/rtw_android.h
 create mode 100755 drivers/net/wireless/8712u/include/sdio_hal.h
 create mode 100755 drivers/net/wireless/8712u/include/sdio_ops.h
 create mode 100755 drivers/net/wireless/8712u/include/sdio_ops_ce.h
 create mode 100755 drivers/net/wireless/8712u/include/sdio_ops_linux.h
 create mode 100755 drivers/net/wireless/8712u/include/sdio_ops_xp.h
 create mode 100755 drivers/net/wireless/8712u/include/sdio_osintf.h
 create mode 100755 drivers/net/wireless/8712u/include/sta_info.h
 create mode 100755 drivers/net/wireless/8712u/include/usb_hal.h
 create mode 100755 drivers/net/wireless/8712u/include/usb_ops.h
 create mode 100755 drivers/net/wireless/8712u/include/usb_osintf.h
 create mode 100755 drivers/net/wireless/8712u/include/usb_vendor_req.h
 create mode 100644 drivers/net/wireless/8712u/include/version.h
 create mode 100755 drivers/net/wireless/8712u/include/wifi.h
 create mode 100755 drivers/net/wireless/8712u/include/wlan_bssdef.h
 create mode 100755 drivers/net/wireless/8712u/include/xmit_osdep.h
 create mode 100755 drivers/net/wireless/8712u/io/rtl8712_io.c
 create mode 100755 drivers/net/wireless/8712u/io/rtl871x_io.c
 create mode 100755 drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_linux.c
 create mode 100755 drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_query.c
 create mode 100755 drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_rtl.c
 create mode 100755 drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_set.c
 create mode 100755 drivers/net/wireless/8712u/led/rtl8712_led.c
 create mode 100755 drivers/net/wireless/8712u/mlme/ieee80211.c
 create mode 100755 drivers/net/wireless/8712u/mlme/rtl871x_mlme.c
 create mode 100755 drivers/net/wireless/8712u/mp/rtl871x_mp.c
 create mode 100755 drivers/net/wireless/8712u/mp/rtl871x_mp_ioctl.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/cmd_linux.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/io_linux.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/ioctl_cfg80211.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/mlme_linux.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/recv_linux.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/rtw_android.c
 create mode 100755 drivers/net/wireless/8712u/os_dep/linux/xmit_linux.c
 create mode 100755 drivers/net/wireless/8712u/os_intf/linux/os_intfs.c
 create mode 100755 drivers/net/wireless/8712u/os_intf/linux/usb_intf.c
 create mode 100755 drivers/net/wireless/8712u/os_intf/osdep_service.c
 create mode 100755 drivers/net/wireless/8712u/pwrctrl/rtl871x_pwrctrl.c
 create mode 100755 drivers/net/wireless/8712u/recv/rtl8712_recv.c
 create mode 100755 drivers/net/wireless/8712u/recv/rtl871x_recv.c
 create mode 100755 drivers/net/wireless/8712u/rf/rtl8712_rf.c
 create mode 100755 drivers/net/wireless/8712u/rf/rtl871x_rf.c
 create mode 100755 drivers/net/wireless/8712u/runwpa
 create mode 100755 drivers/net/wireless/8712u/sta_mgt/rtl871x_sta_mgt.c
 create mode 100755 drivers/net/wireless/8712u/wlan0dhcp
 create mode 100755 drivers/net/wireless/8712u/wpa1.conf
 create mode 100755 drivers/net/wireless/8712u/xmit/rtl8712_xmit.c
 create mode 100755 drivers/net/wireless/8712u/xmit/rtl871x_xmit.c

diff --git a/drivers/net/wireless/8712u/Kconfig b/drivers/net/wireless/8712u/Kconfig
new file mode 100755
index 0000000..748bfcf
--- /dev/null
+++ b/drivers/net/wireless/8712u/Kconfig
@@ -0,0 +1,6 @@
+config RTL8712U
+	tristate "Realtek 8712 USB WiFi"
+	depends on USB
+	---help---
+	  Help message of RTL8712U
+
diff --git a/drivers/net/wireless/8712u/Makefile b/drivers/net/wireless/8712u/Makefile
new file mode 100755
index 0000000..8643565
--- /dev/null
+++ b/drivers/net/wireless/8712u/Makefile
@@ -0,0 +1,261 @@
+EXTRA_CFLAGS += -O1 -Wno-unused-variable -Wno-unused-value -Wno-unused-label -Wno-unused-parameter -Wno-uninitialized
+EXTRA_CFLAGS += -I$(src)/include  -Wno-unused -Wno-unused-function
+
+CONFIG_RTL8711                  =       n
+CONFIG_RTL8712                  =       y
+
+
+CONFIG_USB_HCI                  =       y
+CONFIG_SDIO_HCI                 =       n
+
+
+CONFIG_MP_INCLUDED              =       y
+
+CONFIG_PLATFORM_I386_PC         =       y
+CONFIG_PLATFORM_ANDROID_X86     =       n
+CONFIG_PLATFORM_ARM_S3C         =       n
+CONFIG_PLATFORM_ARM_PXA         =       n
+CONFIG_PLATFORM_MIPS_RMI        =       n
+CONFIG_PLATFORM_RTK_DMP         =       n
+CONFIG_PLATFORM_MIPS_PLM        =       n
+CONFIG_PLATFORM_RTD2880B        =       n
+CONFIG_PLATFORM_MSTAR389        =       n
+CONFIG_PLATFORM_ARM_TCC8900     =       n
+
+CONFIG_MLME_EXT                 =       n
+CONFIG_DRVEXT_MODULE    = n
+
+
+ifeq ($(CONFIG_RTL8711), y)
+RTL871X = rtl8711
+MODULE_NAME = 8711
+endif
+
+ifeq ($(CONFIG_RTL8712), y)
+
+RTL871X = rtl8712
+
+ifeq ($(CONFIG_SDIO_HCI), y)
+MODULE_NAME = 8712s
+endif
+ifeq ($(CONFIG_USB_HCI), y)
+MODULE_NAME = 8712u
+endif
+
+endif
+
+ifeq ($(CONFIG_SDIO_HCI), y)
+
+ 
+_OS_INTFS_FILES := os_intf/osdep_service.o \
+                    os_intf/linux/os_intfs.o \
+                    os_intf/osdep_sdio_intf.o \
+		    		os_intf/linux/sdio_intf.o \
+
+_HAL_INTFS_FILES := hal/$(RTL871X)/hal_init.o \
+		    hal/$(RTL871X)/sdio_halinit.o \
+		    hal/$(RTL871X)/sdio_ops.o \
+		    hal/$(RTL871X)/sdio_ops_linux.o    	
+
+endif
+
+
+ifeq ($(CONFIG_USB_HCI), y)
+ 
+
+_OS_INTFS_FILES := os_intf/osdep_service.o \
+					os_intf/linux/os_intfs.o \
+					os_intf/linux/usb_intf.o \
+					os_dep/linux/ioctl_cfg80211.o \
+					os_dep/linux/rtw_android.o \
+
+_HAL_INTFS_FILES := hal/$(RTL871X)/hal_init.o \
+					hal/$(RTL871X)/usb_ops.o \
+					hal/$(RTL871X)/usb_ops_linux.o \
+					hal/$(RTL871X)/usb_halinit.o \
+		
+endif
+
+
+
+ifeq ($(CONFIG_PLATFORM_I386_PC), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
+ARCH ?= $(SUBARCH)
+CROSS_COMPILE ?=
+KVER  := $(shell uname -r)
+KSRC := /lib/modules/$(KVER)/build
+MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
+INSTALL_PREFIX :=
+endif
+
+ifeq ($(CONFIG_PLATFORM_ANDROID_X86), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID
+SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
+ARCH := $(SUBARCH)
+CROSS_COMPILE := i686-unknown-linux-gnu-
+KSRC := /usr/src/froyo-x86/out/target/product/eeepc/obj/kernel
+MODULE_NAME = wlan
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_S3C), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH := arm
+CROSS_COMPILE := arm-linux-
+KVER  := 2.6.24.7_$(ARCH)
+KSRC := /usr/src/kernels/linux-$(KVER)
+endif
+
+ifeq ($(CONFIG_PLATFORM_RTD2880B), y)
+EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTD2880B
+ARCH:=
+CROSS_COMPILE:=
+KVER:=
+KSRC:=
+endif
+
+ifeq ($(CONFIG_PLATFORM_MT53XX), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MT53XX
+ARCH:= arm
+CROSS_COMPILE:= arm11_mtk_le-
+KVER:= 2.6.27
+KSRC:= /proj/mtk00802/BD_Compare/BDP/Dev/BDP_V301/BDP_Linux/linux-2.6.27
+endif
+
+ifeq ($(CONFIG_PLATFORM_MIPS_RMI), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH:=mips
+CROSS_COMPILE:=mipsisa32r2-uclibc-
+KVER:= 
+KSRC:= /root/work/kernel_realtek
+endif
+
+ifeq ($(CONFIG_PLATFORM_RTK_DMP), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DRTK_DMP_PLATFORM
+ARCH:=mips
+CROSS_COMPILE:=mipsel-linux-
+KVER:= 
+KSRC ?= /root/Desktop/SVN/linux-2.6.12
+endif
+
+ifeq ($(CONFIG_PLATFORM_MIPS_PLM), y)
+EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
+ARCH:=mips
+CROSS_COMPILE:=mipsisa32r2-uclibc-
+KVER:= 
+KSRC:= /root/work/kernel_realtek
+endif
+
+ifeq ($(CONFIG_PLATFORM_MSTAR389), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR389
+ARCH:=mips
+CROSS_COMPILE:= mips-linux-gnu-
+KVER:= 2.6.28.10
+KSRC:= /home/mstar/mstar_linux/2.6.28.9/
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_TCC8900), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN #-DCONFIG_MINIMAL_MEMORY_USAGE
+ARCH ?= arm
+CROSS_COMPILE ?= /media/DATA-1/telechips/SDK_2302_20110425/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
+KSRC ?=/media/DATA-1/telechips/SDK_2302_20110425/kernel
+MODULE_NAME := wlan
+endif
+
+ifneq ($(KERNELRELEASE),)
+
+
+$(MODULE_NAME)-y += cmd/rtl871x_cmd.o cmd/$(RTL871X)_cmd.o
+
+$(MODULE_NAME)-y += crypto/rtl871x_security.o 
+$(MODULE_NAME)-y += debug/rtl871x_debug.o 
+
+$(MODULE_NAME)-y += eeprom/rtl871x_eeprom.o efuse/rtl8712_efuse.o
+
+$(MODULE_NAME)-y += $(_HAL_INTFS_FILES)
+
+$(MODULE_NAME)-y += io/rtl871x_io.o \
+			io/$(RTL871X)_io.o
+
+$(MODULE_NAME)-y += ioctl/rtl871x_ioctl_query.o \
+          			ioctl/rtl871x_ioctl_set.o \
+	   				ioctl/rtl871x_ioctl_linux.o \
+					ioctl/rtl871x_ioctl_rtl.o
+
+$(MODULE_NAME)-y += led/rtl8712_led.o
+
+$(MODULE_NAME)-y += mlme/ieee80211.o mlme/rtl871x_mlme.o				
+$(MODULE_NAME)-$(CONFIG_MLME_EXT) += mlme/rtl871x_mlme_ext.o mlme/rtl871x_wlan_mlme.o mlme/rtl871x_wlan_sme.o
+
+$(MODULE_NAME)-$(CONFIG_MP_INCLUDED) += mp/rtl871x_mp.o \
+					mp/rtl871x_mp_ioctl.o
+
+$(MODULE_NAME)-y += os_dep/linux/io_linux.o \
+					os_dep/linux/xmit_linux.o \
+					os_dep/linux/cmd_linux.o \
+					os_dep/linux/mlme_linux.o \
+					os_dep/linux/recv_linux.o
+
+$(MODULE_NAME)-y += $(_OS_INTFS_FILES)
+
+$(MODULE_NAME)-y += pwrctrl/rtl871x_pwrctrl.o
+
+$(MODULE_NAME)-y += recv/rtl871x_recv.o recv/$(RTL871X)_recv.o
+
+$(MODULE_NAME)-y += rf/rtl871x_rf.o rf/$(RTL871X)_rf.o
+$(MODULE_NAME)-y += sta_mgt/rtl871x_sta_mgt.o
+
+$(MODULE_NAME)-y += xmit/rtl871x_xmit.o xmit/$(RTL871X)_xmit.o
+
+
+obj-$(CONFIG_RTL8712U) := $(MODULE_NAME).o
+
+else
+
+export CONFIG_RTL8712U = m
+
+all: modules
+
+modules:
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(shell pwd)  modules
+
+install:
+	install -p -m 644 $(MODULE_NAME).ko  $(MODDESTDIR)
+	/sbin/depmod -a ${KVER}
+
+uninstall:
+	rm -f $(MODDESTDIR)/$(MODULE_NAME).ko
+	/sbin/depmod -a ${KVER}
+	
+	
+config_r:
+	@echo "make config"
+	/bin/bash script/Configure script/config.in
+	
+.PHONY: modules clean
+
+clean:
+	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
+	rm .tmp_versions -fr ; rm Module.symvers -fr
+	cd cmd ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd crypto ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd debug ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd eeprom ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd hal/$(RTL871X) ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd io ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd ioctl ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd led ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd mlme ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd mp ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd os_dep/linux ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd os_intf ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd os_intf/linux ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd pwrctrl ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd recv ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd rf ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd sta_mgt ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd xmit; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd efuse; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+
+endif
+
diff --git a/drivers/net/wireless/8712u/autoconf_rtl8712_usb_linux.h b/drivers/net/wireless/8712u/autoconf_rtl8712_usb_linux.h
new file mode 100755
index 0000000..6589e10
--- /dev/null
+++ b/drivers/net/wireless/8712u/autoconf_rtl8712_usb_linux.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*
+ * Automatically generated C config: don't edit
+ */
+#define AUTOCONF_INCLUDED
+#define RTL871X_MODULE_NAME "RTL8712U-BGN"
+
+//#define CONFIG_DEBUG_RTL871X 1
+
+#define CONFIG_USB_HCI	1
+#undef  CONFIG_SDIO_HCI
+
+#undef CONFIG_RTL8711
+#define  CONFIG_RTL8712 1
+#undef  CONFIG_RTL8716
+
+
+#define CONFIG_IOCTL_CFG80211	1
+
+#ifdef CONFIG_IOCTL_CFG80211
+#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
+#endif //CONFIG_IOCTL_CFG80211
+
+//#define CONFIG_LITTLE_ENDIAN 1
+//#undef CONFIG_BIG_ENDIAN
+
+#undef PLATFORM_WINDOWS
+#undef PLATFORM_OS_XP 
+#undef PLATFORM_OS_CE
+
+
+#define PLATFORM_LINUX 1
+
+#define CONFIG_PWRCTRL	1
+//#define CONFIG_H2CLBK 1
+
+#define CONFIG_MP_INCLUDED
+
+//#undef CONFIG_EMBEDDED_FWIMG
+#define CONFIG_EMBEDDED_FWIMG 1
+
+#define CONFIG_R871X_TEST 1
+
+
+//#define CONFIG_DRVEXT_MODULE 1
+
+
+#ifdef CONFIG_RTL8712
+
+	#define CONFIG_DEBUG_RTL8712 1	
+
+	#define CONFIG_XMIT_ENQUEUE
+
+	//#define CONFIG_XMIT_DIRECT
+
+	#define CONFIG_80211N_HT 1
+
+	#define CONFIG_RECV_REORDERING_CTRL 1
+
+	#ifdef PLATFORM_LINUX
+
+		#define CONFIG_XMIT_BH 1
+		#define CONFIG_SKB_COPY 1
+
+		#define CONFIG_RECV_TASKLET 1		
+
+		#ifndef CONFIG_RECV_TASKLET
+			#define CONFIG_RECV_BH 1
+		#else			
+			#define CONFIG_PREALLOC_RECV_SKB 1
+		#endif
+	
+	#endif
+
+	#ifdef CONFIG_R871X_TEST
+
+		#define CONFIG_R8712_TEST 1
+
+		//#define CONFIG_MLME_EXT 1
+		//#define CONFIG_AP_MODE 1
+		//#define CONFIG_HOSTAPD_MODE 1	
+
+		#ifdef CONFIG_MLME_EXT
+			#define CONFIG_EVENT_THREAD_MODE 1
+		#endif  
+
+		//#define CONFIG_R8712_TEST_ASTA 1
+
+		#define CONFIG_R8712_TEST_BSTA 1			  
+
+	#endif
+
+	#define CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	#define CONFIG_REDUCE_USB_TX_INT
+
+#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+	//#define CONFIG_USB_TX_AGGREGATION	1
+	#define CONFIG_USB_RX_AGGREGATION	1
+#endif
+
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+
+	#define INTERNAL_MD5
+	#define INTERNAL_MD4
+	#define INTERNAL_DES
+	#define INTERNAL_SHA1
+	#define CONFIG_CRYPTO_INTERNAL
+	
+
+	#define CONFIG_INTERNAL_AES
+	#define CONFIG_INTERNAL_SHA1
+	#define CONFIG_INTERNAL_MD5
+	#define CONFIG_INTERNAL_SHA256
+
+	#define CONFIG_INTERNAL_LIBTOMMATH
+		
+	#define OPENSSL_NO_FP_API
+	#define OPENSSL_NO_ENGINE
+
+
+
+	#define CONFIG_NO_STDOUT_DEBUG 1
+
+	#define CONFIG_ETH_INTF	1
+
+	//#define CONFIG_WSC_CRYPTO_TEST	1
+	#ifdef CONFIG_WSC_CRYPTO_TEST
+	//#define CONFIG_WSC_CRYPTO_DH_TEST 1
+	//#define CONFIG_WSC_CRYPTO_SHA256_TEST 1
+	//#define CONFIG_WSC_CRYPTO_AES128_TEST 1
+	#endif
+
+
+	//#define CONFIG_DRVEXT_MODULE_WSC 1
+	
+	#ifdef CONFIG_DRVEXT_MODULE_WSC
+		//#define CONFIG_WSCCRYPTO_PREALLOC  1
+	#endif
+
+	//#define CONFIG_WSC_DEBUG 1  //for temmprarily setting debug
+	#ifdef CONFIG_WSC_DEBUG
+		#define allowed_ssid "802.11g-SSID"
+	#endif
+
+
+	#ifdef CONFIG_DEBUG_RTL871X
+
+		#define CONFIG_DEBUG_WSC 1
+		//#define CONFIG_DUMP_WSC_KEY	1
+
+		
+		#define CONFIG_DEBUG_WPA 1
+		//#define CONFIG_DUMP_WPA_KEY 1
+
+	#endif	
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/clean b/drivers/net/wireless/8712u/clean
new file mode 100755
index 0000000..7027242
--- /dev/null
+++ b/drivers/net/wireless/8712u/clean
@@ -0,0 +1,7 @@
+#!/bin/bash
+rmmod r8192s_usb
+rmmod ieee80211_rsl
+rmmod ieee80211_crypt_ccmp
+rmmod ieee80211_crypt_tkip
+rmmod ieee80211_crypt_wep
+rmmod ieee80211_crypt
diff --git a/drivers/net/wireless/8712u/cmd/rtl8712_cmd.c b/drivers/net/wireless/8712u/cmd/rtl8712_cmd.c
new file mode 100755
index 0000000..2e10021
--- /dev/null
+++ b/drivers/net/wireless/8712u/cmd/rtl8712_cmd.c
@@ -0,0 +1,1417 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL8712_CMD_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <cmd_osdep.h>
+#include <mlme_osdep.h>
+#include <rtl871x_byteorder.h>
+#include <circ_buf.h>
+#include <rtl871x_ioctl_set.h>
+
+
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_SDIO_HCI
+#include <linux/mmc/sdio_func.h>
+#endif
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/rtnetlink.h>
+#endif
+
+
+#ifdef CONFIG_MLME_EXT
+void mlme_cmd_hdl(_adapter *padapter, struct cmd_obj *pcmd)
+{
+	u8 ret;	
+	u8 (*cmd_hdl)(_adapter *padapter, u8* pbuf);
+	void (*pcmd_callback)(_adapter *padapter, struct cmd_obj *pcmd);
+	struct	cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	u8 *pcmdbuf = pcmdpriv->cmd_buf;
+	
+	if(pcmd)
+	{
+		pcmdpriv->cmd_issued_cnt++;
+
+		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
+
+		_memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+
+		cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
+		if(cmd_hdl)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("mlme_cmd_hdl(): cmd_hdl=0x%p, cmdcode=0x%x\n", cmd_hdl, pcmd->cmdcode));
+			ret = cmd_hdl(padapter, pcmdbuf);
+			pcmd->res = ret;
+		}
+		
+		//pcmdpriv->cmd_seq++;//skip
+
+		// invoke cmd->callback function		
+		pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+		if(pcmd_callback==NULL)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("mlme_cmd_hdl(): pcmd_callback=0x%p, cmdcode=0x%x\n", pcmd_callback, pcmd->cmdcode));
+			free_cmd_obj(pcmd);
+		}	
+		else
+		{
+			//need conider that free cmd_obj in cmd_callback
+			pcmd_callback(padapter, pcmd);
+		}	
+		
+	}
+
+}
+
+void start_hw_event_posting(_adapter *padapter)
+{	
+	struct	event_node *node;	
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	volatile int *head = &(pmlmeext->c2hevent.head);
+	volatile int *tail = &(pmlmeext->c2hevent.tail);
+	
+	
+	if (*head == *tail)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" hw event error! head:%d, tail:%d\n", *head, *tail));
+		return;	
+	}
+
+	node = &(pmlmeext->c2hevent.nodes[*tail]);
+
+	//assign event code, size...
+	
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("tail:%d, evt_code:%d, evt_sz:%d\n", *tail, node->evt_code, node->evt_sz)); 
+	
+	pmlmeext->c2h_res = ((node->evt_code << 24) | 
+	 					((node->evt_sz) << 8) | pmlmeext->c2hevent.seq++);
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("evt_sz = %d, val=%x\n", node->evt_sz, pmlmeext->c2h_res));
+	
+	pmlmeext->c2h_buf = node->node;
+	
+	evt_notify_isr(&padapter->evtpriv);
+
+		
+}
+
+int event_queuing (_adapter *padapter, struct event_node *evtnode)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	volatile int *head = &pmlmeext->c2hevent.head;
+	volatile int *tail = &pmlmeext->c2hevent.tail;
+	int res = SUCCESS, hwen = 0;		
+
+	if (CIRC_SPACE(*head, *tail, C2HEVENT_SZ))
+	{		
+		_memcpy(&(pmlmeext->c2hevent.nodes[*head]), evtnode, sizeof (struct event_node));	
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("event code: %x\n", evtnode->evt_code));
+		
+		if (*head == *tail)
+			hwen = 1;
+		
+		*head = (*head + 1) & (C2HEVENT_SZ - 1);
+		
+	}
+	else
+		res = FAIL;
+
+	
+	if (hwen) {
+		start_hw_event_posting(padapter);
+	}
+	
+	return res;
+	
+}
+
+void event_complete(_adapter *padapter)
+{
+	struct event_node *node;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	volatile int *head = &(pmlmeext->c2hevent.head);	
+	volatile int *tail = &(pmlmeext->c2hevent.tail);
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("+event_complete\n"));
+
+	node = &(pmlmeext->c2hevent.nodes[*tail]);
+
+	if (CIRC_CNT(*head, *tail, C2HEVENT_SZ) == 0) {
+		return;
+	}
+
+	caller_ff_tail = node->caller_ff_tail;
+	caller_ff_sz = node->caller_ff_sz;
+
+	if (caller_ff_tail)
+		*caller_ff_tail = ((*caller_ff_tail) + 1) & (caller_ff_sz - 1);
+	
+	*tail = ((*tail) + 1) & (C2HEVENT_SZ - 1);
+
+	if (CIRC_CNT(*head, *tail, C2HEVENT_SZ) == 0) {
+		return;
+	}
+
+	start_hw_event_posting(padapter);		
+
+}
+
+thread_return event_thread(thread_context context)
+{
+	unsigned int val, r_sz, ec;
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+	u8 	evt_seq, *peventbuf = NULL;
+	_adapter * padapter = (_adapter *)context;
+	struct evt_priv *pevt_priv = &(padapter->evtpriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+_func_enter_;
+	
+#ifdef PLATFORM_LINUX	
+	daemonize("%s", padapter->pnetdev->name);
+	allow_signal(SIGTERM);
+#endif	
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("@@@@@@@ start r871x event_thread @@@@@@@\n"));
+
+	evt_seq = 0;
+
+	while(1)
+	{		
+		if ((_down_sema(&(pevt_priv->evt_notify))) == _FAIL)
+			break;
+		
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE)){
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("event_thread:bDriverStopped or bSurpriseRemoved"));
+			break;
+		}
+					
+		val = pmlmeext->c2h_res;
+
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_, ("event_thread, c2h_res=%x, event_seq=%d\n", val, pevt_priv->event_seq));
+		
+		r_sz = (val >> 8) & 0xffff;
+		ec = (val >> 24);
+		
+		// checking event sequence...		
+		if ((val & 0x7f) != evt_seq/*pevt_priv->event_seq*/)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("Evetn Seq Error! %d vs %d\n", (val & 0xff), pevt_priv->event_seq));
+
+			//pevt_priv->event_seq = ((val+1)&0x7f); 
+			evt_seq = ((val+1)&0x7f); 	
+			
+			goto _abort_event_;
+		}
+
+		// checking if event code is valid
+		if (ec >= MAX_C2HEVT)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("Event Code(%d) mismatch!\n", (val >> 24)));
+			
+			evt_seq = ((val+1)&0x7f); 	
+			
+			goto _abort_event_;
+		}
+
+		// checking if event size match the event parm size	
+		if ((wlanevents[ec].parmsize != 0) && 
+			(wlanevents[ec].parmsize != r_sz))
+		{
+			
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("Event(%d) Parm Size mismatch (%d vs %d)!\n", 
+							ec, wlanevents[ec].parmsize, r_sz));
+			
+			evt_seq = ((val+1)&0x7f); 	
+			
+			goto _abort_event_;	
+			
+		}
+		
+		//update event sequence
+	        evt_seq++;//update evt_seq
+	        if(evt_seq > 127)
+		        evt_seq=0;
+		
+		peventbuf = pevt_priv->evt_buf;
+
+		if (peventbuf == NULL)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't allocate memory buf for event code:%d, len:%d\n", (val >> 24), r_sz));
+			goto _abort_event_;
+		}
+		
+		_memcpy(peventbuf, pmlmeext->c2h_buf, r_sz);
+
+		if(ec != GEN_EVT_CODE(_Survey))
+		{
+			_mfree(pmlmeext->c2h_buf, r_sz);
+		}	
+
+		if (peventbuf)
+		{
+			event_callback = wlanevents[ec].event_callback;
+			if(event_callback)
+			event_callback(padapter, peventbuf);
+		}
+		
+_abort_event_:
+	
+		event_complete(padapter);
+			
+		peventbuf = NULL;
+	
+#ifdef PLATFORM_LINUX
+		if (signal_pending (current)) {
+			flush_signals(current);
+        	}
+#endif       			
+		
+
+	}
+
+	_up_sema(&pevt_priv->terminate_evtthread_sema);
+	
+_func_exit_;	
+
+	thread_exit();
+	
+}
+#endif //end of CONFIG_MLME_EXT
+
+static void check_hw_pbc(_adapter *padapter)
+{
+	u8	tmp1byte;
+ 
+	write8(padapter, MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO)); 
+
+	tmp1byte = read8(padapter, GPIO_IO_SEL);
+
+	tmp1byte &= ~(HAL_8192S_HW_GPIO_WPS_BIT);
+
+	write8(padapter, GPIO_IO_SEL, tmp1byte);
+
+	tmp1byte = read8(padapter, GPIO_CTRL); 
+
+	//printk("CheckPbcGPIO - Ox%x\n", tmp1byte);
+ 
+	// Add by hpfan 2008.07.07 to fix read GPIO error from S3
+	if (tmp1byte == 0xff)
+		return ;
+ 
+	if (tmp1byte&HAL_8192S_HW_GPIO_WPS_BIT)
+	{
+		// Here we only set bPbcPressed to true
+		// After trigger PBC, the variable will be set to false
+
+		DBG_8712("CheckPbcGPIO - PBC is pressed !!!!\n");
+
+		//priv->bpbc_pressed = true;
+#ifdef RTK_DMP_PLATFORM
+		kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_NET_PBC);
+		//kobject_hotplug(&dev->class_dev.kobj, KOBJ_NET_PBC);
+#else
+		if ( padapter->pid == 0 )
+		{	//	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver.
+			return;
+		}
+
+#ifdef PLATFORM_LINUX
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		kill_pid(find_vpid(padapter->pid), SIGUSR1, 1);
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,26))
+		kill_proc(padapter->pid, SIGUSR1, 1);
+#endif
+
+#endif
+
+#endif
+	}
+}
+
+
+// query rx phy status from fw.
+// Adhoc mode: beacon.
+// Infrastructure mode: beacon , data.
+// added by thomas 2010-02-09
+static void query_fw_rx_phy_status(_adapter *padapter)
+{
+	u32	val32 =0;
+	int pollingcnts = 50;
+
+	if( check_fwstate(&padapter->mlmepriv, _FW_LINKED) == _TRUE) {
+		//write value 0xf4000001 to IOCMD_CTRL
+		write32(padapter, IOCMD_CTRL_REG, 0xf4000001);
+
+		usleep_os(100);
+
+		//Wait FW complete IO Cmd
+		while( (0 != read32(padapter, IOCMD_CTRL_REG) ) && (pollingcnts>0) ){
+			pollingcnts--;
+			usleep_os(10);
+		}
+
+		if( pollingcnts != 0){	
+			val32 = read32(padapter, IOCMD_DATA_REG);
+		}
+		else{//time out	
+			val32 = 0;
+			//DBG_8712 ("fw_iocmd_read timeout ........\n");
+		}
+
+		val32 = val32 >> 4;
+		padapter->recvpriv.fw_rssi = (u8)signal_scale_mapping(val32);
+		//printk("Get FW SignalStrength %d \n",padapter->recvpriv.fw_rssi);
+	}
+}
+
+
+// check mlme, hw, phy, or dynamic algorithm status.
+// added by thomas 2010-02-09
+static void StatusWatchdogCallback(_adapter *padapter)
+{
+	check_hw_pbc(padapter);
+	query_fw_rx_phy_status(padapter);
+}
+
+
+static void r871x_internal_cmd_hdl(_adapter *padapter, u8 *pbuf)
+{
+	struct drvint_cmd_parm *pdrvcmd;
+
+	if(!pbuf)
+		return;
+
+	pdrvcmd = (struct drvint_cmd_parm*)pbuf;
+	
+	switch(pdrvcmd->i_cid)
+	{
+		case WDG_WK_CID:
+			StatusWatchdogCallback(padapter);
+			break;
+		default:
+			break;
+
+	}
+
+	if(pdrvcmd->pbuf)
+	{
+		_mfree(pdrvcmd->pbuf, pdrvcmd->sz);
+	}
+
+	
+}
+
+u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf)
+{	
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+	//struct reg_rw_parm *pcmd_parm = (struct reg_rw_parm *)pbuf;
+
+
+	// invoke cmd->callback function		
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if(pcmd_callback==NULL)
+	{
+		free_cmd_obj(pcmd);
+	}	
+	else
+	{
+		//need conider that free cmd_obj in cmd_callback
+		pcmd_callback(padapter, pcmd);
+	}	
+
+	
+	return H2C_SUCCESS;
+	
+}
+
+u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf)
+{	
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+	//struct reg_rw_parm *pcmd_parm = (struct reg_rw_parm *)pbuf;
+
+
+	// invoke cmd->callback function		
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if(pcmd_callback==NULL)
+	{
+		free_cmd_obj(pcmd);
+	}	
+	else
+	{
+		//need conider that free cmd_obj in cmd_callback
+		pcmd_callback(padapter, pcmd);
+	}	
+	
+	return H2C_SUCCESS;
+}
+
+u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf)
+{
+	u32 val;
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+	//struct reg_rw_parm *pcmd_parm;
+	struct readBB_parm *prdbbparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+	
+
+	prdbbparm = (struct readBB_parm *)pcmd->parmbuf;
+
+	//val = QueryBBReg(padapter, prdbbparm->offset, 0xffffffff);
+
+	if(pcmd->rsp && pcmd->rspsz>0)
+	{
+		_memcpy(pcmd->rsp, (u8*)&val, pcmd->rspsz);
+	}
+
+	// invoke cmd->callback function		
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if(pcmd_callback==NULL)
+	{
+		free_cmd_obj(pcmd);
+	}	
+	else
+	{
+		//need conider that free cmd_obj in cmd_callback
+		pcmd_callback(padapter, pcmd);
+	}	
+
+	return H2C_SUCCESS;
+	
+}
+
+
+u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf)
+{	
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+	//struct reg_rw_parm *pcmd_parm;
+	struct writeBB_parm	*pwritebbparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	//pcmd_parm = (struct reg_rw_parm *)pcmd->parmbuf;
+	pwritebbparm = (struct writeBB_parm *)pcmd->parmbuf;
+
+	//SetBBReg(padapter, pwritebbparm->offset, 0xffffffff, pwritebbparm->value);
+
+	// invoke cmd->callback function		
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if(pcmd_callback==NULL)
+	{
+		free_cmd_obj(pcmd);
+	}	
+	else
+	{
+		//need conider that free cmd_obj in cmd_callback
+		pcmd_callback(padapter, pcmd);
+	}	
+
+	return H2C_SUCCESS;
+	
+}
+
+u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf)
+{
+	u32 val;
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+	//struct reg_rw_parm *pcmd_parm;
+	struct readRF_parm *prdrfparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	prdrfparm = (struct readRF_parm *)pcmd->parmbuf;
+
+	//val = QueryBBReg(padapter, prdrfparm->offset, 0xffffffff);
+
+	if(pcmd->rsp && pcmd->rspsz>0)
+	{
+		_memcpy(pcmd->rsp, (u8*)&val, pcmd->rspsz);
+	}
+
+	// invoke cmd->callback function		
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if(pcmd_callback==NULL)
+	{
+		free_cmd_obj(pcmd);
+	}	
+	else
+	{
+		//need conider that free cmd_obj in cmd_callback
+		pcmd_callback(padapter, pcmd);
+	}	
+
+	return H2C_SUCCESS;
+	
+}
+
+
+u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf)
+{	
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+	//struct reg_rw_parm *pcmd_parm;
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	//pcmd_parm = (struct reg_rw_parm *)pcmd->parmbuf;
+	pwriterfparm = (struct writeRF_parm *)pcmd->parmbuf;
+
+	//SetRFReg(padapter, pwriterfparm->offset, 0xffffffff, pwriterfparm->value);
+
+	// invoke cmd->callback function		
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if(pcmd_callback==NULL)
+	{
+		free_cmd_obj(pcmd);
+	}	
+	else
+	{
+		//need conider that free cmd_obj in cmd_callback
+		pcmd_callback(padapter, pcmd);
+	}	
+
+	return H2C_SUCCESS;
+	
+}
+
+
+/*
+void drv_cmd_hdl(_adapter *padapter, struct cmd_obj *pcmd)
+{	
+	u8 ret;	
+	u8 (*cmd_hdl)(_adapter *padapter, u8* pbuf);
+	void (*pcmd_callback)(_adapter *padapter, struct cmd_obj *pcmd);
+	struct	cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	u8 *pcmdbuf = pcmdpriv->cmd_buf;
+	
+	if(pcmd)
+	{
+		pcmdpriv->cmd_issued_cnt++;
+
+		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
+
+		_memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+
+		cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
+		if(cmd_hdl)
+		{
+			DBG_8712("mlme_cmd_hdl(): cmd_hdl=0x%p, cmdcode=0x%x\n", cmd_hdl, pcmd->cmdcode);
+			ret = cmd_hdl(padapter, pcmdbuf);
+			pcmd->res = ret;
+		}
+		
+		//pcmdpriv->cmd_seq++;//skip
+
+		// invoke cmd->callback function		
+		pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+		if(pcmd_callback==NULL)
+		{
+			DBG_8712("mlme_cmd_hdl(): pcmd_callback=0x%p, cmdcode=0x%x\n", pcmd_callback, pcmd->cmdcode);
+			free_cmd_obj(pcmd);
+		}	
+		else
+		{
+			//need conider that free cmd_obj in cmd_callback
+			pcmd_callback(padapter, pcmd);
+		}	
+		
+	}
+
+}
+*/
+
+u8 sys_suspend_hdl(_adapter *padapter, u8 *pbuf)
+{
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+	struct usb_suspend_parm *psetusbsuspend;
+
+	psetusbsuspend = (struct usb_suspend_parm *)pcmd->parmbuf;
+
+#ifdef PLATFORM_WINDOWS
+	if(psetusbsuspend->action == 1)
+	{
+		pnp_sleep_wk(padapter);
+	}
+	else
+	{
+		pnp_resume_wk(padapter);
+	}
+#endif
+		
+	free_cmd_obj(pcmd);	
+	
+	return H2C_SUCCESS;
+	
+}
+
+void read_cmd_rsp(_adapter *padapter, u16 rspaddr, uint *prspbuf)
+{
+	
+
+}
+
+
+struct cmd_obj *cmd_hdl_filter(_adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct cmd_obj *pcmd_r;
+	
+	if(pcmd == NULL)
+		return pcmd;
+
+	pcmd_r = NULL;
+
+#ifdef CONFIG_MLME_EXT
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("cmd_hdl_filter(): cmd_code=%d\n", pcmd->cmdcode));
+
+	switch(pcmd->cmdcode)
+	{
+		case GEN_CMD_CODE(_Read_MACREG):			
+		case GEN_CMD_CODE(_Write_MACREG):
+			
+			pcmd_r = pcmd;
+			
+			break;			
+			
+		case GEN_CMD_CODE(_CreateBss):
+
+			//pcmd->parmbuf = (u8*)&padapter->mlmepriv.cur_network.network;
+			//pcmd->cmdsz =  padapter->mlmepriv.cur_network.network.Length;					
+
+			//mlme_cmd_hdl(padapter, pcmd);
+
+			write32(padapter, RCR, read32(padapter, RCR)|0x00040000);//accept data frames;
+			DBG_8712("when create_bss, RCR=0x%08x\n", read32(padapter, RCR));
+			
+			pcmd_r = pcmd;
+
+			break;
+			
+		default:
+			
+			mlme_cmd_hdl(padapter, pcmd);
+
+			pcmd_r = NULL;
+			
+			break;			
+	}	
+
+#else
+
+	switch(pcmd->cmdcode)
+	{
+		case GEN_CMD_CODE(_Read_MACREG):
+			read_macreg_hdl(padapter, (u8*)pcmd);
+			pcmd_r = pcmd;			
+			break;			
+		case GEN_CMD_CODE(_Write_MACREG):
+			write_macreg_hdl(padapter, (u8*)pcmd);
+			pcmd_r = pcmd;
+			break;
+		case GEN_CMD_CODE(_Read_BBREG):
+			read_bbreg_hdl(padapter, (u8*)pcmd);			
+			break;	
+		case GEN_CMD_CODE(_Write_BBREG):
+			write_bbreg_hdl(padapter, (u8*)pcmd);			
+			break;
+		case GEN_CMD_CODE(_Read_RFREG):
+			read_rfreg_hdl(padapter, (u8*)pcmd);			
+			break;		
+		case GEN_CMD_CODE(_Write_RFREG):
+			write_rfreg_hdl(padapter, (u8*)pcmd);	
+			break;			
+		case GEN_CMD_CODE(_SetUsbSuspend):
+			sys_suspend_hdl(padapter, (u8*)pcmd);
+			break;
+		
+		case GEN_CMD_CODE(_JoinBss):
+
+			//reset reg/hw/network setting before join_bss
+			joinbss_reset(padapter);
+		
+#ifdef CONFIG_PWRCTRL
+			/* Before set JoinBss_CMD to FW, driver must ensure FW is in PS_MODE_ACTIVE.
+			Directly write rpwm to radio on and assign new pwr_mode to Driver, instead of use workitem to change state.*/
+			if(padapter->pwrctrlpriv.pwr_mode > PS_MODE_ACTIVE){
+				padapter->pwrctrlpriv.pwr_mode = PS_MODE_ACTIVE;
+				_enter_pwrlock(&(padapter->pwrctrlpriv.lock));
+				set_rpwm(padapter, PS_STATE_S4);
+				_exit_pwrlock(&(padapter->pwrctrlpriv.lock));
+			}
+#endif
+			pcmd_r = pcmd;
+
+			break;
+		case _DRV_INT_CMD_:		
+			r871x_internal_cmd_hdl(padapter, pcmd->parmbuf);
+			free_cmd_obj(pcmd);
+			pcmd_r = NULL;
+			break;
+		default:				
+		        pcmd_r = pcmd;
+		break;			
+		
+	}	
+
+#endif
+
+	return pcmd_r;//if returning the pcmd_r == NULL, you must confirm the pcmd has been free.
+	
+}
+u8 check_cmd_fifo(_adapter *padapter,uint sz){
+	u8 res=_SUCCESS;
+#ifdef CONFIG_SDIO_HCI
+	uint public_pg=0;
+	uint cmd_pg=0;
+	public_pg=read8(padapter, SDIO_BCNQ_FREEPG);
+	cmd_pg=read8(padapter, SDIO_CMDQ_FREEPG);
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("check_cmd_fifo, public_pg=%x  cmd_pg=%x\n",public_pg,cmd_pg));
+	cmd_pg=cmd_pg-public_pg;
+	res=_FAIL;
+	if((cmd_pg >2)||(public_pg >5)){
+		if((public_pg+cmd_pg)< (sz>>8)){
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("check_cmd_fifo, public_pg=0x%x  cmd_pg=0x%x  sz=0x%x\n",public_pg,cmd_pg,sz));
+		res=_FAIL;
+		}
+		else
+			res=_SUCCESS;
+	}else{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("check_cmd_fifo, public_pg=%x  cmd_pg=%d   cmd pg is not enough\n",public_pg,cmd_pg));
+		res= _FAIL;
+	}
+#endif	
+	return res;
+}
+
+u8 fw_cmd(PADAPTER pAdapter, u32 cmd)
+{
+	int pollingcnts = 50;
+
+	write32(pAdapter, IOCMD_CTRL_REG, cmd);
+	usleep_os(100);
+	while ((0 != read32(pAdapter, IOCMD_CTRL_REG)) && (pollingcnts > 0)) {
+		pollingcnts--;
+		usleep_os(10);
+	}
+
+	if (pollingcnts == 0) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("!!fw_cmd timeout ........\n"));
+		return _FALSE;
+	}
+
+	return _TRUE;
+}
+
+void fw_cmd_data(PADAPTER pAdapter, u32 *value, u8 flag)
+{
+	if (flag == 0)	// set
+		write32(pAdapter, IOCMD_DATA_REG, *value);
+	else		// query
+		*value = read32(pAdapter, IOCMD_DATA_REG);
+}
+
+thread_return cmd_thread(thread_context context)
+{
+	struct cmd_obj *pcmd;
+	unsigned int cmdsz, wr_sz, *pcmdbuf, *prspbuf;
+	struct tx_desc *pdesc;
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj	*pcmd);
+       _adapter *padapter = (_adapter *)context;
+	struct	cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	
+_func_enter_;
+
+	thread_enter(padapter);
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("start r8712 cmd_thread !!!!\n"));
+
+	while(1)
+	{
+		if ((_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
+			break;
+
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		{			
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+			break;
+		}
+		
+		if (register_cmd_alive(padapter) != _SUCCESS)
+		{
+			continue;
+		}
+_next:
+		if(!(pcmd = dequeue_cmd(&(pcmdpriv->cmd_queue)))) {
+			unregister_cmd_alive(padapter);
+			continue;
+		}
+
+		pcmdbuf = (unsigned int*)pcmdpriv->cmd_buf;
+		prspbuf = (unsigned int*)pcmdpriv->rsp_buf;
+
+		pdesc = (struct tx_desc *)pcmdbuf;
+
+		_memset(pdesc, 0, TXDESC_SIZE);
+
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("after dequeue_cmd\n"));
+
+		pcmd = cmd_hdl_filter(padapter, pcmd);
+	
+		if(pcmd)//if pcmd != NULL, the cmd will be handled by f/w
+		{
+                        struct dvobj_priv    *pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;
+			u8                           blnPending = 0;
+
+		 	pcmdpriv->cmd_issued_cnt++;
+			cmdsz = _RND8( (pcmd->cmdsz));//_RND8
+
+			wr_sz = TXDESC_SIZE + 8 + cmdsz;		 	
+			
+			if ( pdvobj->ishighspeed )
+			{
+				if ( ( wr_sz % 512 ) == 0 )
+				{
+					blnPending = 1;
+				}
+			}
+			else
+			{
+				if ( ( wr_sz % 64 ) == 0 )
+				{
+					blnPending = 1;
+				}
+			}
+			
+			pdesc->txdw0 |= cpu_to_le32((wr_sz-TXDESC_SIZE)&0x0000ffff);
+
+			if ( blnPending )
+			{
+				pdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ+8)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc with 8 bytes offset
+			}
+			else
+			{
+				pdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
+			}
+
+			pdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);			
+			pdesc->txdw1 |= cpu_to_le32((0x13<<QSEL_SHT)&0x00001f00);//QSEL=H2C-Command
+
+			
+			pcmdbuf += (TXDESC_SIZE>>2);		
+			*pcmdbuf = cpu_to_le32((cmdsz&0x0000ffff) | (pcmd->cmdcode << 16) | (pcmdpriv->cmd_seq <<24));
+			
+			pcmdbuf += 2 ;//8 bytes aligment			
+			_memcpy((u8*)pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+
+			while (check_cmd_fifo(padapter,wr_sz)==_FAIL){
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("cmd pg is not enough=>sleep 10 ms\n"));
+				if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+				{			
+					RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+					break;
+				}
+				msleep_os(100);
+				continue;
+			}
+			//write_mem(padapter, RTL8712_DMA_H2CCMD,  pcmd->cmdsz+4, pcmdpriv->cmd_buf);
+			if ( blnPending )
+			{
+				wr_sz += 8;   // Appending 8 bytes to the payload.
+			}
+			
+			write_mem(padapter, RTL8712_DMA_H2CCMD, wr_sz, (u8*)pdesc);
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("after dump cmd, code=%d\n", pcmd->cmdcode));
+			
+			pcmdpriv->cmd_seq++;
+
+			if(pcmd->cmdcode == GEN_CMD_CODE(_CreateBss))
+			{			
+				pcmd->res = H2C_SUCCESS;
+
+				pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+				if(pcmd_callback)
+				{
+					pcmd_callback(padapter, pcmd);
+				}
+				
+				continue;				
+			}
+#ifdef CONFIG_PWRCTRL
+#ifdef CONFIG_USB_HCI
+			if(pcmd->cmdcode == GEN_CMD_CODE(_SetPwrMode))
+			{
+				if(padapter->pwrctrlpriv.bSleep)
+				{				
+					_enter_pwrlock(&(padapter->pwrctrlpriv.lock));
+					set_rpwm(padapter, PS_STATE_S2);
+					_exit_pwrlock(&(padapter->pwrctrlpriv.lock));
+				}
+			}
+#endif
+#endif
+			free_cmd_obj(pcmd);
+
+			if(_queue_empty(&(pcmdpriv->cmd_queue))){
+				unregister_cmd_alive(padapter);
+				continue;
+			}
+			else{
+				//DbgPrint("cmd queue is not empty\n");
+				goto _next;
+			}
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("\nShall not be empty when dequeue cmd_queuu\n"));
+			goto _next;
+		}	
+		
+		flush_signals_thread();
+	}
+
+	// free all cmd_obj resources
+	do{
+
+		pcmd = dequeue_cmd(&(pcmdpriv->cmd_queue));
+		if(pcmd==NULL)
+			break;
+
+		free_cmd_obj(pcmd);
+		
+	}while(1);
+
+
+	_up_sema(&pcmdpriv->terminate_cmdthread_sema);
+
+_func_exit_;	
+
+	thread_exit();
+
+}
+
+void event_handle(_adapter *padapter, uint *peventbuf)
+{
+	u8 evt_code, evt_seq;
+	u16 evt_sz;		
+	void (*event_callback)(_adapter *dev, u8 *pbuf);	
+	struct	evt_priv	*pevt_priv = &(padapter->evtpriv);	
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("+event_handle\n"));
+
+	if(peventbuf == NULL)
+	{		
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("event_handle(): peventbuf is NULL !\n"));
+		goto _abort_event_;
+	}
+	
+	evt_sz = (u16)(le32_to_cpu(*peventbuf)&0xffff);
+	evt_seq = (u8)((le32_to_cpu(*peventbuf)>>24)&0x7f);
+	evt_code = (u8)((le32_to_cpu(*peventbuf)>>16)&0xff);
+	
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("event_handle(): evt_sz=%d, evt_seq=%d, evt_code=%d\n", evt_sz, evt_seq, evt_code));
+
+	// checking event sequence...		
+	if ((evt_seq & 0x7f) != pevt_priv->event_seq)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("Event Seq Error! %d vs %d\n", (evt_seq & 0xff), pevt_priv->event_seq));
+              pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+
+	// checking if event code is valid
+	if (evt_code >= MAX_C2HEVT)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("Event Code(%d) mismatch!\n", evt_code));
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+	else if((evt_code == GEN_EVT_CODE(_Survey)) && (evt_sz > sizeof(WLAN_BSSID_EX)))
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("_Survey Event SZ too big:%d\n", evt_sz));
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+		
+
+	// checking if event size match the event parm size	
+	if ((wlanevents[evt_code].parmsize != 0) && (wlanevents[evt_code].parmsize != evt_sz))
+	{			
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("Event(%d) Parm Size mismatch (%d vs %d)!\n", 
+					evt_code, wlanevents[evt_code].parmsize, evt_sz));
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;	
+			
+	}
+	else if( (evt_sz==0) && (evt_code != GEN_EVT_CODE(_WPS_PBC)))
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("return fail : evt_code=%d, evt_sz=%d\n", evt_code, evt_sz));
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;	
+	}
+
+	pevt_priv->event_seq++;	//update evt_seq
+	if(pevt_priv->event_seq >127)
+		pevt_priv->event_seq=0;
+
+	peventbuf = peventbuf+2;//move to event content, fw asks 8 bytes aligment				
+
+	if(peventbuf)
+	{
+		event_callback = wlanevents[evt_code].event_callback;
+		if(event_callback)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("before event_callback\n"));
+			event_callback(padapter, (u8*)peventbuf);				
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("\n After event_callback:evt code=%d\n",evt_code));
+		}
+	}
+
+	pevt_priv->evt_done_cnt++;
+
+_abort_event_:
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("-event_handle\n"));
+
+	return;
+
+}
+
+
+void fwdbg_event_callback(_adapter *adapter , u8 *pbuf)
+{
+	if(pbuf)
+	{	
+		pbuf[60]='\0';
+		if ( strlen( pbuf ) < 3 )
+			return;
+		
+#ifdef PLATFORM_LINUX
+                printk("fwdbg:%s\n", pbuf);      
+#endif
+
+                RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("fwdbg:%s\n", pbuf));
+	}	
+
+}
+
+
+void dummy_event_callback(_adapter *adapter , u8 *pbuf)
+{
+
+	//MSG_8712("+dummy_event_callback\n");
+	
+	
+	//read_macreg_cmd(adapter, 0xffffffff, (u8*)&val32);	
+
+	
+
+}
+
+u8 read_macreg_cmd(_adapter  *padapter, u32 offset, u8 *pval)
+{
+
+struct reg_rw_parm
+{
+	unsigned short	rw;	//0: read, 1: write
+	unsigned short	size;	//8, 16, 32 supported
+	unsigned int	addr;
+	unsigned int	value;
+	unsigned int	rsvd;
+};
+	
+	struct cmd_obj*			ph2c;
+	struct reg_rw_parm 		*pcmd_parm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));	
+	if(ph2c==NULL)
+	{
+		res=_FAIL;
+		goto exit;
+	}
+	
+	pcmd_parm = (struct reg_rw_parm*)_malloc(sizeof(struct reg_rw_parm)); 
+	if(pcmd_parm ==NULL)
+	{
+		_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		return _FAIL;
+	}
+
+	_init_listhead(&ph2c->list);
+	
+	ph2c->cmdcode = GEN_CMD_CODE(_Read_MACREG);
+	ph2c->parmbuf = (unsigned char *)pcmd_parm;
+	ph2c->cmdsz =  sizeof(struct reg_rw_parm);
+	ph2c->rsp = NULL;
+	ph2c->rspsz = 0;
+	
+	pcmd_parm ->addr = offset;
+	
+	enqueue_cmd(pcmdpriv, ph2c);	
+	
+exit:
+	
+_func_exit_;	
+
+	return res;
+	
+}
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+#ifndef CONFIG_MLME_EXT
+thread_return event_thread(thread_context context)
+{
+	u8 evt_code, evt_seq;
+	u16 evt_sz;		
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+	struct evt_obj *pevtobj;
+	uint 	*peventbuf;
+	_adapter * padapter = (_adapter *)context;
+	struct	evt_priv	*pevt_priv = &(padapter->evtpriv);
+
+_func_enter_;
+
+	
+#ifdef PLATFORM_LINUX	
+	daemonize("%s", padapter->pnetdev->name);
+	allow_signal(SIGTERM);
+#endif	
+
+		
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("@@@@@@@ start r8712 event_thread @@@@@@@\n"));
+
+	while(1)
+	{
+		
+		if ((_down_sema(&(pevt_priv->evt_notify))) == _FAIL)
+			break;
+
+_next_event:
+
+		pevtobj = NULL;
+		peventbuf = NULL;		
+	
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE)){		
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("event_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+			break;
+		}
+
+
+		if(!(pevtobj = dequeue_evt(&(pevt_priv->evt_queue)))) {		
+			continue;
+		}
+
+
+		peventbuf = (uint*)pevtobj->parmbuf;
+		evt_sz = (u16)(*peventbuf&0xffff);
+		evt_seq = (u8)((*peventbuf>>24)&0x7f);
+		evt_code = (u8)((*peventbuf>>16)&0xff);
+
+		peventbuf++;
+		
+		
+		// checking event sequence...		
+		if ((evt_seq & 0xff) == pevt_priv->event_seq)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("Evetn Seq Error! %d vs %d\n", (evt_seq & 0xff), pevt_priv->event_seq));
+			goto _abort_event_;
+		}
+
+		// checking if event code is valid
+		if (evt_code >= MAX_C2HEVT)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent Code(%d) mismatch!\n", evt_code));
+			goto _abort_event_;
+		}
+
+		// checking if event size match the event parm size	
+		if ((wlanevents[evt_code].parmsize != 0) && 
+			(wlanevents[evt_code].parmsize != evt_sz))
+		{
+			
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n", 
+			evt_code, wlanevents[evt_code].parmsize, evt_sz));
+			goto _abort_event_;	
+			
+		}
+
+	//	pevt_priv->event_seq = (evt_seq & 0xff);	//update evt_seq
+
+		if (peventbuf == NULL)
+		{
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't allocate memory buf for event code:%d, len:%d\n", evt_code, evt_sz));
+			goto _abort_event_;
+		}
+				
+		if(peventbuf)
+		{
+			event_callback = wlanevents[evt_code].event_callback;
+			event_callback(padapter, (u8*)peventbuf);				
+		}
+
+		//pevt_priv->evt_done_cnt++;
+		
+_abort_event_:
+
+#ifdef PLATFORM_LINUX
+		if (signal_pending (current)) {
+			flush_signals(current);
+        	}
+#endif       
+
+
+		if(peventbuf)
+			_mfree(pevtobj->parmbuf, evt_sz);
+
+		if(pevtobj)
+			_mfree((u8*)pevtobj, sizeof(struct evt_obj));
+		
+
+		goto _next_event;
+		
+
+	}
+
+#if 0
+	// free all evt_obj resources
+	do{	
+		pevtobj = dequeue_evt(&(pevt_priv->evt_queue));	
+		if(pevtobj==NULL)
+			break;
+		
+		peventbuf = (uint*)pevtobj->parmbuf;		
+		evt_sz = (u16)(*peventbuf&0xffff);
+
+		if(peventbuf)
+			_mfree((u8*)peventbuf, evt_sz);
+
+		_mfree((u8*)pevtobj, sizeof(struct evt_obj));
+		
+	}while(1);
+#endif
+
+	_up_sema(&pevt_priv->terminate_evtthread_sema);
+	
+_func_exit_;	
+
+	thread_exit();
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_RECV_BH
+#ifdef PLATFORM_LINUX
+void recv_event_bh(void *priv)
+{	
+	u8 evt_code, evt_seq;
+	u16 evt_sz;
+	struct evt_obj *pevtobj = NULL;
+	uint 	*peventbuf = NULL;
+	_adapter *padapter = (_adapter*)priv;
+	struct evt_priv *pevt_priv = &(padapter->evtpriv);
+
+	//printk("+recv_event_bh\n");
+
+	while(1)
+	{	
+		if(!(pevtobj = dequeue_evt(&(pevt_priv->evt_queue))))
+		{		
+			break;
+		}
+
+		peventbuf = (uint*)pevtobj->parmbuf;	
+
+		//printk("recv_event_bh(), pevtobj=%p, peventbuf=%p\n", pevtobj, peventbuf);
+
+		if(peventbuf)
+		{
+			evt_sz = (u16)(le32_to_cpu(*peventbuf)&0xffff);
+			evt_seq = (u8)((le32_to_cpu(*peventbuf)>>24)&0x7f);
+			evt_code = (u8)((le32_to_cpu(*peventbuf)>>16)&0xff);
+
+			if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+			{
+				event_handle(padapter, peventbuf);							
+			}
+			else
+			{
+				printk("recv_event_bh():bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved);
+			}
+
+			if(evt_sz<64)
+			{
+				_mfree((u8*)peventbuf, 64+8);
+			}
+			else
+			{
+				_mfree((u8*)peventbuf, evt_sz+8);
+			}	
+
+			if(pevtobj)
+			{
+				_mfree((u8 *)pevtobj, sizeof(struct evt_obj));			
+			}
+		
+		}	
+	
+	}	
+	
+}
+#endif
+#endif
+
+
diff --git a/drivers/net/wireless/8712u/cmd/rtl871x_cmd.c b/drivers/net/wireless/8712u/cmd/rtl871x_cmd.c
new file mode 100755
index 0000000..20c022a
--- /dev/null
+++ b/drivers/net/wireless/8712u/cmd/rtl871x_cmd.c
@@ -0,0 +1,2061 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_CMD_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <cmd_osdep.h>
+#include <mlme_osdep.h>
+#include <rtl871x_byteorder.h>
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/rtnetlink.h>
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#include <wlan_bssdef.h>
+#endif
+
+
+/*
+Caller and the cmd_thread can protect cmd_q by spin_lock.
+No irqsave is necessary.
+*/
+
+sint _init_cmd_priv (struct cmd_priv *pcmdpriv)
+{
+	sint res = _SUCCESS;
+
+_func_enter_;
+	_init_sema(&(pcmdpriv->cmd_queue_sema), 0);
+	//_init_sema(&(pcmdpriv->cmd_done_sema), 0);
+	_init_sema(&(pcmdpriv->terminate_cmdthread_sema), 0);
+
+
+	_init_queue(&(pcmdpriv->cmd_queue));
+
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+
+	pcmdpriv->cmd_seq = 1;
+
+	pcmdpriv->cmd_allocated_buf = _malloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+
+	if (pcmdpriv->cmd_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ( (uint)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
+
+	pcmdpriv->rsp_allocated_buf = _malloc(MAX_RSPSZ + 4);
+
+	if (pcmdpriv->rsp_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 - ( (uint)(pcmdpriv->rsp_allocated_buf) & 3);
+
+	pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_done_cnt = pcmdpriv->rsp_cnt = 0;
+
+exit:
+_func_exit_;
+	return res;
+}
+
+
+sint _init_evt_priv(struct evt_priv *pevtpriv)
+{
+	sint res=_SUCCESS;
+
+_func_enter_;
+#ifdef CONFIG_EVENT_THREAD_MODE
+	_init_sema(&(pevtpriv->evt_notify), 0);
+	_init_sema(&(pevtpriv->terminate_evtthread_sema), 0);
+#endif
+#ifdef CONFIG_H2CLBK
+	_init_sema(&(pevtpriv->lbkevt_done), 0);
+	pevtpriv->lbkevt_limit = 0;
+	pevtpriv->lbkevt_num = 0;
+	pevtpriv->cmdevt_parm = NULL;
+#endif
+
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+	pevtpriv->event_seq = 0;
+	pevtpriv->evt_allocated_buf = _malloc(MAX_EVTSZ + 4);
+
+	if (pevtpriv->evt_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 - ((unsigned int)(pevtpriv->evt_allocated_buf) & 3);
+
+	pevtpriv->evt_done_cnt = 0;
+#ifdef CONFIG_SDIO_HCI
+	pevtpriv->allocated_c2h_mem = _malloc(C2H_MEM_SZ +4);
+
+	if (pevtpriv->allocated_c2h_mem == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pevtpriv->c2h_mem = pevtpriv->allocated_c2h_mem +  4\
+	- ( (u32)(pevtpriv->allocated_c2h_mem) & 3);
+#ifdef PLATFORM_OS_XP
+	pevtpriv->pc2h_mdl= IoAllocateMdl((u8 *)pevtpriv->c2h_mem, C2H_MEM_SZ , FALSE, FALSE, NULL);
+
+	if(pevtpriv->pc2h_mdl == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	MmBuildMdlForNonPagedPool(pevtpriv->pc2h_mdl);
+#endif
+#endif
+
+exit:
+
+#ifdef CONFIG_RECV_BH
+
+	_init_queue(&(pevtpriv->evt_queue));
+
+#endif
+
+_func_exit_;
+
+	return res;
+}
+
+void _free_evt_priv (struct	evt_priv *pevtpriv)
+{
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("+_free_evt_priv \n"));
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	_free_sema(&(pevtpriv->evt_notify));
+	_free_sema(&(pevtpriv->terminate_evtthread_sema));
+#endif
+
+	if (pevtpriv->evt_allocated_buf)
+		_mfree(pevtpriv->evt_allocated_buf, MAX_EVTSZ + 4);
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("-_free_evt_priv \n"));
+
+_func_exit_;
+
+}
+void _free_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+_func_enter_;
+
+	if(pcmdpriv){
+		_spinlock_free(&(pcmdpriv->cmd_queue.lock));
+		_free_sema(&(pcmdpriv->cmd_queue_sema));
+		//_free_sema(&(pcmdpriv->cmd_done_sema));
+		_free_sema(&(pcmdpriv->terminate_cmdthread_sema));
+
+		if (pcmdpriv->cmd_allocated_buf)
+			_mfree(pcmdpriv->cmd_allocated_buf, MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+
+		if (pcmdpriv->rsp_allocated_buf)
+			_mfree(pcmdpriv->rsp_allocated_buf, MAX_RSPSZ + 4);
+	}
+_func_exit_;
+}
+
+/*
+Calling Context:
+
+enqueue_cmd can only be called between kernel thread,
+since only spin_lock is used.
+
+ISR/Call-Back functions can't call this sub-function.
+
+*/
+
+sint _enqueue_cmd(_queue *queue, struct cmd_obj *obj)
+{
+_func_enter_;
+
+	if (obj == NULL)
+		goto exit;
+
+	_spinlock(&queue->lock);
+
+	list_insert_tail(&obj->list, &queue->queue);
+
+	_spinunlock(&queue->lock);
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+struct cmd_obj* _dequeue_cmd(_queue *queue)
+{
+	struct cmd_obj *obj;
+
+_func_enter_;
+
+	_spinlock(&(queue->lock));
+
+	if (is_list_empty(&(queue->queue)))
+		obj = NULL;
+	else
+	{
+		obj = LIST_CONTAINOR(get_next(&(queue->queue)), struct cmd_obj, list);
+		list_delete(&obj->list);
+	}
+	_spinunlock(&(queue->lock));
+
+_func_exit_;
+
+	return obj;
+}
+
+u32 init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	u32	res;
+_func_enter_;
+	res = _init_cmd_priv (pcmdpriv);
+_func_exit_;
+	return res;
+}
+
+u32 init_evt_priv(struct evt_priv *pevtpriv)
+{
+	int res;
+_func_enter_;
+	res = _init_evt_priv(pevtpriv);
+_func_exit_;
+	return res;
+}
+
+void free_evt_priv(struct evt_priv *pevtpriv)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("free_evt_priv\n"));
+	_free_evt_priv(pevtpriv);
+_func_exit_;
+}
+
+void free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("free_cmd_priv\n"));
+	_free_cmd_priv(pcmdpriv);
+_func_exit_;
+}
+
+u32 enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	int res;
+
+_func_enter_;
+
+	if (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag == _TRUE) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("pcmdpriv->padapter->eeprompriv.bautoload_fail_flag=%x\n",
+			  pcmdpriv->padapter->eeprompriv.bautoload_fail_flag));
+		return _FAIL;
+	}
+
+	res = _enqueue_cmd(&pcmdpriv->cmd_queue, obj);
+
+	_up_sema(&pcmdpriv->cmd_queue_sema);
+
+_func_exit_;
+
+	return res;
+}
+
+u32 enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	_irqL irqL;
+	_queue *queue;
+
+_func_enter_;
+
+	if (obj == NULL)
+		goto exit;
+
+	if (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag == _TRUE)
+		return _FAIL;
+
+	queue = &pcmdpriv->cmd_queue;
+
+	_enter_critical(&queue->lock, &irqL);
+
+	list_insert_tail(&obj->list, &queue->queue);
+
+	_exit_critical(&queue->lock, &irqL);
+
+	_up_sema(&pcmdpriv->cmd_queue_sema);
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+struct cmd_obj* dequeue_cmd(_queue *queue)
+{
+	struct cmd_obj *pcmd;
+_func_enter_;
+	pcmd = _dequeue_cmd(queue);
+_func_exit_;
+	return pcmd;
+}
+
+u32 enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj)
+{
+	_irqL irqL;
+	int res;
+	_queue *queue = &pevtpriv->evt_queue;
+
+_func_enter_;
+
+	res = _SUCCESS;
+
+	if (obj == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	_enter_critical_ex(&queue->lock, &irqL);
+
+	list_insert_tail(&obj->list, &queue->queue);
+
+	_exit_critical_ex(&queue->lock, &irqL);
+
+	//evt_notify_isr(pevtpriv);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+struct evt_obj* dequeue_evt(_queue *queue)
+{
+	_irqL irqL;
+	struct	evt_obj	*pevtobj;
+
+_func_enter_;
+
+	_enter_critical_ex(&queue->lock, &irqL);
+
+	if (is_list_empty(&(queue->queue)))
+		pevtobj = NULL;
+	else
+	{
+		pevtobj = LIST_CONTAINOR(get_next(&(queue->queue)), struct evt_obj, list);
+		list_delete(&pevtobj->list);
+	}
+
+	_exit_critical_ex(&queue->lock, &irqL);
+
+_func_exit_;
+
+	return pevtobj;
+}
+
+void cmd_clr_isr(struct cmd_priv *pcmdpriv)
+{
+_func_enter_;
+	pcmdpriv->cmd_done_cnt++;
+	//_up_sema(&(pcmdpriv->cmd_done_sema));
+_func_exit_;
+}
+
+void evt_notify_isr(struct evt_priv *pevtpriv)
+{
+_func_enter_;
+	pevtpriv->evt_done_cnt++;
+#ifdef CONFIG_EVENT_THREAD_MODE
+	_up_sema(&(pevtpriv->evt_notify));
+#endif
+_func_exit_;
+}
+
+void free_cmd_obj(struct cmd_obj *pcmd)
+{
+_func_enter_;
+
+	if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
+	{
+		//free parmbuf in cmd_obj
+		_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
+	}
+
+	if(pcmd->rsp!=NULL)
+	{
+		if(pcmd->rspsz!= 0)
+		{
+			//free rsp in cmd_obj
+			_mfree((unsigned char*)pcmd->rsp, pcmd->rspsz);
+		}
+	}
+
+	//free cmd_obj
+	_mfree((unsigned char*)pcmd, sizeof(struct cmd_obj));
+
+_func_exit_;
+}
+
+void free_evt_obj(struct evt_obj *pevtobj)
+{
+_func_enter_;
+
+	if(pevtobj->parmbuf)
+		_mfree((unsigned char*)pevtobj->parmbuf, pevtobj->evtsz);
+
+	_mfree((unsigned char*)pevtobj, sizeof(struct evt_obj));
+
+_func_exit_;
+}
+
+/*
+u8 setstandby_cmd(unsigned char  *adapter)
+*/
+u8 setstandby_cmd(_adapter *padapter, uint action)
+{
+	struct cmd_obj		*ph2c;
+	struct usb_suspend_parm	*psetusbsuspend;
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+
+	u8 ret = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	psetusbsuspend = (struct usb_suspend_parm*)_malloc(sizeof(struct usb_suspend_parm));
+	if (psetusbsuspend == NULL) {
+		_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		ret = _FAIL;
+		goto exit;
+	}
+
+	psetusbsuspend->action = action;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend, GEN_CMD_CODE(_SetUsbSuspend));
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+/*
+sitesurvey_cmd(~)
+	### NOTE:#### (!!!!)
+	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+*/
+u8 sitesurvey_cmd(_adapter *padapter, NDIS_802_11_SSID *pssid)
+{
+	struct cmd_obj		*ph2c;
+	struct sitesurvey_parm	*psurveyPara;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+
+	_memset(ph2c, 0, sizeof(struct cmd_obj));
+
+	psurveyPara = (struct sitesurvey_parm*)_malloc(sizeof(struct sitesurvey_parm));
+	if (psurveyPara == NULL) {
+		_mfree((unsigned char*) ph2c, sizeof(struct cmd_obj));
+		return _FAIL;
+	}
+
+	_memset(psurveyPara, 0, sizeof(struct sitesurvey_parm));
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));
+
+	psurveyPara->bsslimit = cpu_to_le32(48);
+	psurveyPara->passive_mode = cpu_to_le32(pmlmepriv->passive_mode);
+	psurveyPara->ss_ssidlen= cpu_to_le32(0);// pssid->SsidLength;
+	_memset(psurveyPara->ss_ssid, 0, IW_ESSID_MAX_SIZE + 1);
+	if ((pssid != NULL) && (pssid->SsidLength)) {
+		_memcpy(psurveyPara->ss_ssid, pssid->Ssid, pssid->SsidLength);
+		psurveyPara->ss_ssidlen = cpu_to_le32(pssid->SsidLength);
+		// Commented by Kurt 20120323
+		// In Android 4.0 system, it would set passive scan cmd before set scan
+		// We have to change it to active scan to send probe request.
+		psurveyPara->passive_mode = 1;	// 1: active
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+	_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_SITE_SURVEY);
+	padapter->blnEnableRxFF0Filter = 0;
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+u8 setdatarate_cmd(_adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj		*ph2c;
+	struct setdatarate_parm	*pbsetdataratepara;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pbsetdataratepara = (struct setdatarate_parm*)_malloc(sizeof(struct setdatarate_parm));
+	if (pbsetdataratepara == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara, GEN_CMD_CODE(_SetDataRate));
+#ifdef MP_FIRMWARE_OFFLOAD
+	pbsetdataratepara->curr_rateidx = *(u32*)rateset;
+//	_memcpy(pbsetdataratepara, rateset, sizeof(u32));
+#else
+	pbsetdataratepara->mac_id = 5;
+	_memcpy(pbsetdataratepara->datarates, rateset, NumRates);
+#endif
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 set_chplan_cmd(_adapter *padapter, int chplan)
+{
+	struct cmd_obj		*ph2c;
+	struct SetChannelPlan_param *psetchplanpara;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	//check input parameter
+	if(!rtw_is_channel_plan_valid(chplan)) {
+		res = _FAIL;
+		goto exit;
+	}
+	
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetchplanpara= (struct SetChannelPlan_param*)_malloc(sizeof(struct SetChannelPlan_param));
+	if (psetchplanpara== NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetchplanpara, GEN_CMD_CODE(_SetChannelPlan));
+	
+#ifdef MP_FIRMWARE_OFFLOAD
+
+#else
+	psetchplanpara->ChannelPlan= chplan;
+#endif
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setbasicrate_cmd(_adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj*			ph2c;
+	struct setbasicrate_parm*	pssetbasicratepara;
+	struct cmd_priv*		pcmdpriv=&padapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+	pssetbasicratepara = (struct setbasicrate_parm*)_malloc(sizeof(struct setbasicrate_parm));
+
+	if (pssetbasicratepara == NULL) {
+		_mfree((u8*) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara, _SetBasicRate_CMD_);
+
+	_memcpy(pssetbasicratepara->basicrates, rateset, NumRates);
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+
+/*
+unsigned char setphy_cmd(unsigned char  *adapter)
+
+1.  be called only after update_registrypriv_dev_network( ~) or mp testing program
+2.  for AdHoc/Ap mode or mp mode?
+
+*/
+u8 setphy_cmd(_adapter *padapter, u8 modem, u8 ch)
+{
+	struct cmd_obj		*ph2c;
+	struct setphy_parm	*psetphypara;
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+//	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+//	struct registry_priv	*pregistry_priv = &padapter->registrypriv;
+//	NDIS_WLAN_BSSID_EX	*dev_network = &padapter->registrypriv.dev_network;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	psetphypara = (struct setphy_parm*)_malloc(sizeof(struct setphy_parm));
+
+	if(psetphypara==NULL){
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetphypara, _SetPhy_CMD_);
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("CH=%d, modem=%d", ch, modem));
+
+	psetphypara->modem = modem;
+	psetphypara->rfchannel = ch;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+}
+
+//power tracking mechanism setting
+u8 setptm_cmd(_adapter*padapter, u8 type)
+{
+	struct cmd_obj*			ph2c;
+	struct writePTM_parm*		pwriteptmparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwriteptmparm = (struct writePTM_parm*)_malloc(sizeof(struct writePTM_parm));
+
+	if(pwriteptmparm==NULL){
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetPT));
+
+	pwriteptmparm->type= type;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+_func_exit_;
+
+	return res;
+
+}
+
+u8 setfwdig_cmd(_adapter*padapter, u8 type)
+{
+
+	struct cmd_obj*			ph2c;
+	struct writePTM_parm*		pwriteptmparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwriteptmparm = (struct writePTM_parm*)_malloc(sizeof(struct setdig_parm));
+
+	if(pwriteptmparm==NULL){
+		_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetDIG));
+
+	pwriteptmparm->type= type;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setfwra_cmd(_adapter*padapter, u8 type)
+{
+
+	struct cmd_obj*			ph2c;
+	struct writePTM_parm*		pwriteptmparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwriteptmparm = (struct writePTM_parm*)_malloc(sizeof(struct setra_parm));
+
+	if(pwriteptmparm==NULL){
+		_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetRA));
+
+	pwriteptmparm->type= type;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setbbreg_cmd(_adapter*padapter, u8 offset, u8 val)
+{
+	struct cmd_obj*			ph2c;
+	struct writeBB_parm*		pwritebbparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+_func_enter_;
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwritebbparm = (struct writeBB_parm*)_malloc(sizeof(struct writeBB_parm));
+
+	if(pwritebbparm==NULL){
+		_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwritebbparm, GEN_CMD_CODE(_SetBBReg));
+
+	pwritebbparm->offset = offset;
+	pwritebbparm->value = val;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+}
+
+u8 getbbreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_obj*			ph2c;
+	struct readBB_parm*		prdbbparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res=_FAIL;
+		goto exit;
+		}
+	prdbbparm = (struct readBB_parm*)_malloc(sizeof(struct readBB_parm));
+
+	if(prdbbparm ==NULL){
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		return _FAIL;
+	}
+
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_GetBBReg);
+	ph2c->parmbuf = (unsigned char *)prdbbparm;
+	ph2c->cmdsz =  sizeof(struct readBB_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readBB_rsp);
+
+	prdbbparm ->offset = offset;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+}
+
+u8 setrfreg_cmd(_adapter  *padapter, u8 offset, u32 val)
+{
+	struct cmd_obj*			ph2c;
+	struct writeRF_parm*		pwriterfparm;
+	struct cmd_priv 		*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+_func_enter_;
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	pwriterfparm = (struct writeRF_parm*)_malloc(sizeof(struct writeRF_parm));
+
+	if(pwriterfparm==NULL){
+		_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));
+
+	pwriterfparm->offset = offset;
+	pwriterfparm->value = val;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+}
+
+u8 getrfreg_cmd(_adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_obj		*ph2c;
+	struct readRF_parm	*prdrfparm;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	prdrfparm = (struct readRF_parm*)_malloc(sizeof(struct readRF_parm));
+	if (prdrfparm == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_GetRFReg);
+	ph2c->parmbuf = (unsigned char *)prdrfparm;
+	ph2c->cmdsz =  sizeof(struct readRF_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readRF_rsp);
+
+	prdrfparm ->offset = offset;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+void getbbrfreg_cmdrsp_callback(_adapter *padapter, struct cmd_obj *pcmd)
+{
+_func_enter_;
+
+	//free_cmd_obj(pcmd);
+	_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
+	_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+
+#ifdef CONFIG_MP_INCLUDED
+	padapter->mppriv.workparam.bcompleted= _TRUE;
+#endif
+
+_func_exit_;
+}
+
+void readtssi_cmdrsp_callback(_adapter *padapter,  struct cmd_obj *pcmd)
+{
+ _func_enter_;
+
+	_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
+	_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+
+	padapter->mppriv.workparam.bcompleted = _TRUE;
+
+_func_exit_;
+}
+
+u8 createbss_cmd(_adapter *padapter)
+{
+	struct cmd_obj		*pcmd;
+	struct cmd_priv		*pcmdpriv=&padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	WLAN_BSSID_EX		*pdev_network = &padapter->registrypriv.dev_network;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for Any SSid:%s\n",pmlmepriv->assoc_ssid.Ssid));
+	} else {
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _CreateBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)pdev_network;
+	pcmd->cmdsz = get_NDIS_WLAN_BSSID_EX_sz((NDIS_WLAN_BSSID_EX*)pdev_network);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	//notes: translate IELength & Length after assign the Length to cmdsz;
+	pdev_network->Length = cpu_to_le32(pcmd->cmdsz);
+	pdev_network->IELength = cpu_to_le32(pdev_network->IELength);
+	pdev_network->Ssid.SsidLength = cpu_to_le32(pdev_network->Ssid.SsidLength);
+
+	enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 createbss_cmd_ex(_adapter *padapter, unsigned char *pbss, unsigned int sz)
+{
+	struct cmd_obj	*pcmd;
+	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = GEN_CMD_CODE(_CreateBss);
+	pcmd->parmbuf = pbss;
+	pcmd->cmdsz = sz;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
+{
+	u8 *auth, res = _SUCCESS;
+	uint t_len = 0;
+	NDIS_WLAN_BSSID_EX	*psecnetwork;
+	struct cmd_obj		*pcmd;
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv   	*pqospriv = &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->network.InfrastructureMode;
+
+_func_enter_;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid=[%s]\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
+		goto exit;
+	}
+
+	t_len = sizeof (ULONG) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 +
+			sizeof (NDIS_802_11_SSID) + sizeof (ULONG) +
+			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) +
+			sizeof (NDIS_802_11_CONFIGURATION) +
+			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof (NDIS_802_11_RATES_EX)+ sizeof(ULONG) + MAX_IE_SZ;
+
+	//for hidden ap to set fw_state here
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != _TRUE)
+	{
+		switch(ndis_network_mode)
+		{
+			case Ndis802_11IBSS:
+				pmlmepriv->fw_state |=WIFI_ADHOC_STATE;
+				break;
+
+			case Ndis802_11Infrastructure:
+				pmlmepriv->fw_state |= WIFI_STATION_STATE;
+				break;
+
+			case Ndis802_11APMode:
+			case Ndis802_11AutoUnknown:
+			case Ndis802_11InfrastructureMax:
+				break;
+
+		}
+	}
+
+	psecnetwork = (NDIS_WLAN_BSSID_EX *)&psecuritypriv->sec_bss;
+	if (psecnetwork == NULL)
+	{
+		if (pcmd != NULL)
+			_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
+
+		res = _FAIL;
+
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("joinbss_cmd :psecnetwork==NULL!!!\n"));
+
+		goto exit;
+	}
+
+	_memset(psecnetwork, 0, t_len);
+
+	_memcpy(psecnetwork, &pnetwork->network, t_len);
+
+	auth = &psecuritypriv->authenticator_ie[0];
+	psecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->IELength;
+
+	if((psecnetwork->IELength-12) < (256-1)) {
+		_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);
+	} else {
+		_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
+	}
+
+	psecnetwork->IELength = 0;
+        // Added by Albert 2009/02/18
+        // If the the driver wants to use the bssid to create the connection.
+        // If not,  we have to copy the connecting AP's MAC address to it so that
+        // the driver just has the bssid information for PMKIDList searching.
+
+        if (pmlmepriv->assoc_by_bssid == _FALSE )
+        {
+            _memcpy( &pmlmepriv->assoc_bssid[ 0 ], &pnetwork->network.MacAddress[ 0 ], ETH_ALEN );
+        }
+
+	psecnetwork->IELength = restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
+
+
+	pqospriv->qos_option = 0;
+
+	if (pregistrypriv->wmm_enable)
+	{
+		u32 tmp_len;
+
+		tmp_len = restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);
+
+		if (psecnetwork->IELength != tmp_len)
+		{
+			psecnetwork->IELength = tmp_len;
+			pqospriv->qos_option = 1; //There is WMM IE in this corresp. beacon
+		}
+		else
+		{
+			pqospriv->qos_option = 0;//There is no WMM IE in this corresp. beacon
+		}
+	}
+
+#ifdef CONFIG_80211N_HT
+
+	if (pregistrypriv->ht_enable)
+	{
+		//	Added by Albert 2010/06/23
+		//	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue.
+		//	Especially for Realtek 8192u SoftAP.
+		if (( padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_ ) &&
+			( padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_ ))
+		{
+			//restructure_ht_ie
+			restructure_ht_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0],
+								pnetwork->network.IELength, &psecnetwork->IELength);
+		}
+	}
+
+#endif
+
+	psecuritypriv->supplicant_ie[0] = (u8)psecnetwork->IELength;
+
+	if(psecnetwork->IELength < (256-1))
+	{
+	_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], psecnetwork->IELength);
+	}
+	else
+	{
+		_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], (256-1));
+	}
+
+	pcmd->cmdsz = get_NDIS_WLAN_BSSID_EX_sz(psecnetwork);//get cmdsz before endian conversion
+
+	//wlan_network endian conversion
+	psecnetwork->Length = cpu_to_le32(psecnetwork->Length);
+	psecnetwork->Ssid.SsidLength= cpu_to_le32(psecnetwork->Ssid.SsidLength);
+	psecnetwork->Privacy = cpu_to_le32(psecnetwork->Privacy);
+	psecnetwork->Rssi = cpu_to_le32(psecnetwork->Rssi);
+	psecnetwork->NetworkTypeInUse = cpu_to_le32(psecnetwork->NetworkTypeInUse);
+	psecnetwork->Configuration.ATIMWindow = cpu_to_le32(psecnetwork->Configuration.ATIMWindow);
+	psecnetwork->Configuration.BeaconPeriod = cpu_to_le32(psecnetwork->Configuration.BeaconPeriod);
+	psecnetwork->Configuration.DSConfig = cpu_to_le32(psecnetwork->Configuration.DSConfig);
+	psecnetwork->Configuration.FHConfig.DwellTime=cpu_to_le32(psecnetwork->Configuration.FHConfig.DwellTime);
+	psecnetwork->Configuration.FHConfig.HopPattern=cpu_to_le32(psecnetwork->Configuration.FHConfig.HopPattern);
+	psecnetwork->Configuration.FHConfig.HopSet=cpu_to_le32(psecnetwork->Configuration.FHConfig.HopSet);
+	psecnetwork->Configuration.FHConfig.Length=cpu_to_le32(psecnetwork->Configuration.FHConfig.Length);
+	psecnetwork->Configuration.Length = cpu_to_le32(psecnetwork->Configuration.Length);
+	psecnetwork->InfrastructureMode = cpu_to_le32(psecnetwork->InfrastructureMode);
+	psecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);
+
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _JoinBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)psecnetwork;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 disassoc_cmd(_adapter*padapter) // for sta_mode
+{
+	struct cmd_obj		*pdisconnect_cmd;
+	struct disconnect_parm	*pdisconnect;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+disassoc_cmd\n"));
+
+	//if ((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) {
+
+		pdisconnect_cmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+		if (pdisconnect_cmd == NULL) {
+			res = _FAIL;
+			goto exit;
+		}
+
+		pdisconnect = (struct disconnect_parm*)_malloc(sizeof(struct disconnect_parm));
+		if (pdisconnect == NULL) {
+			_mfree((u8 *)pdisconnect_cmd, sizeof(struct cmd_obj));
+			res = _FAIL;
+			goto exit;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(pdisconnect_cmd, pdisconnect, _DisConnect_CMD_);
+		enqueue_cmd(pcmdpriv, pdisconnect_cmd);
+	//}
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setopmode_cmd(_adapter *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct cmd_obj		*ph2c;
+	struct setopmode_parm	*psetop;
+	struct cmd_priv		*pcmdpriv= &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FALSE;
+		goto exit;
+	}
+	psetop = (struct setopmode_parm*)_malloc(sizeof(struct setopmode_parm));
+
+	if (psetop == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FALSE;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);
+	psetop->mode = (u8)networktype;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key)
+{
+	struct cmd_obj		*ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct set_stakey_rsp	*psetstakey_rsp = NULL;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct sta_info		*sta = (struct sta_info*)psta;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)_malloc(sizeof(struct set_stakey_parm));
+	if (psetstakey_para == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetstakey_rsp = (struct set_stakey_rsp*)_malloc(sizeof(struct set_stakey_rsp));
+	if (psetstakey_rsp == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+	ph2c->rsp = (u8 *) psetstakey_rsp;
+	ph2c->rspsz = sizeof(struct set_stakey_rsp);
+
+	_memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		psetstakey_para->algorithm =(unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
+	else
+		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, _FALSE);
+
+	if (unicast_key == _TRUE) {
+		_memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
+        } else {
+		_memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid-1].skey, 16);
+        }
+
+	//jeff: set this becasue at least sw key is ready
+	padapter->securitypriv.busetkipkey=_TRUE;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setrfintfs_cmd(_adapter *padapter, u8 mode)
+{
+	struct cmd_obj		*ph2c;
+	struct setrfintfs_parm	*psetrfintfsparm;
+	struct cmd_priv		*pcmdpriv=&padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetrfintfsparm = (struct setrfintfs_parm*)_malloc(sizeof(struct setrfintfs_parm));
+	if (psetrfintfsparm == NULL) {
+		_mfree((unsigned char *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrfintfsparm, GEN_CMD_CODE(_SetRFIntFs));
+	psetrfintfsparm->rfintfs = mode;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setrttbl_cmd(_adapter *padapter, struct setratable_parm *prate_table)
+{
+	struct cmd_obj		*ph2c;
+	struct setratable_parm	*psetrttblparm;
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	psetrttblparm = (struct setratable_parm*)_malloc(sizeof(struct setratable_parm));
+
+	if(psetrttblparm==NULL){
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
+
+	_memcpy(psetrttblparm,prate_table,sizeof(struct setratable_parm));
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+
+}
+
+u8 getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval)
+{
+	struct cmd_obj		*ph2c;
+	struct getratable_parm	*pgetrttblparm;
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	pgetrttblparm = (struct getratable_parm*)_malloc(sizeof(struct getratable_parm));
+
+	if(pgetrttblparm==NULL){
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+//	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
+
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_GetRaTable);
+	ph2c->parmbuf = (unsigned char *)pgetrttblparm;
+	ph2c->cmdsz =  sizeof(struct getratable_parm);
+	ph2c->rsp = (u8*)pval;
+	ph2c->rspsz = sizeof(struct getratable_rsp);
+
+	pgetrttblparm ->rsvd = 0x0;
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+
+}
+
+u8 gettssi_cmd(_adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj		*ph2c;
+	struct readTSSI_parm	*prdtssiparm;
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	prdtssiparm = (struct readTSSI_parm*)_malloc(sizeof(struct readTSSI_parm));
+	if (prdtssiparm == NULL) {
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		return _FAIL;
+	}
+
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_ReadTSSI);
+	ph2c->parmbuf = (unsigned char *)prdtssiparm;
+	ph2c->cmdsz =sizeof(struct readTSSI_parm);;
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readTSSI_rsp);
+
+	prdtssiparm ->offset = offset;
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 setMacAddr_cmd(_adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv 		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj			*ph2c;
+	struct SetMacAddr_param	*psetMacAddr_para;
+
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetMacAddr_para = (struct SetMacAddr_param*)_malloc(sizeof(struct SetMacAddr_param));
+	if (psetMacAddr_para == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetMacAddr_para, _SetMacAddress_CMD_);
+
+	_memcpy(psetMacAddr_para->MacAddr, mac_addr,ETH_ALEN);
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+ }
+
+u8 setassocsta_cmd(_adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv 		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj			*ph2c;
+	struct set_assocsta_parm	*psetassocsta_para;
+	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
+	u8	res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetassocsta_para = (struct set_assocsta_parm*)_malloc(sizeof(struct set_assocsta_parm));
+	if (psetassocsta_para == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetassocsta_rsp = (struct set_stakey_rsp*)_malloc(sizeof(struct set_assocsta_rsp));
+	if (psetassocsta_rsp == NULL) {
+		_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		_mfree((u8 *) psetassocsta_para, sizeof(struct set_assocsta_parm));
+		return _FAIL;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SetAssocSta_CMD_);
+	ph2c->rsp = (u8 *) psetassocsta_rsp;
+	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
+
+	_memcpy(psetassocsta_para->addr, mac_addr,ETH_ALEN);
+
+	enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+ }
+
+u8 addbareq_cmd(_adapter *padapter, u8 tid)
+{
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj		*ph2c;
+	struct addBaReq_parm	*paddbareq_parm;
+	u8	res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm = (struct addBaReq_parm*)_malloc(sizeof(struct addBaReq_parm));
+	if (paddbareq_parm == NULL) {
+		_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm->tid = tid;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_AddBAReq));
+
+	//printk("addbareq_cmd, tid=%d\n", tid);
+
+	//enqueue_cmd(pcmdpriv, ph2c);
+	enqueue_cmd_ex(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 wdg_wk_cmd(_adapter*padapter)
+{
+	struct cmd_obj*		ph2c;
+	struct drvint_cmd_parm  *pdrvintcmd_param;	
+	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+	
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));	
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	
+	pdrvintcmd_param = (struct drvint_cmd_parm*)_malloc(sizeof(struct drvint_cmd_parm)); 
+	if(pdrvintcmd_param==NULL){
+		_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvintcmd_param->i_cid = WDG_WK_CID;
+	pdrvintcmd_param->sz = 0;
+	pdrvintcmd_param->pbuf = NULL;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvintcmd_param, _DRV_INT_CMD_);
+
+	
+	//enqueue_cmd(pcmdpriv, ph2c);	
+	enqueue_cmd_ex(pcmdpriv, ph2c);
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+
+}
+
+void survey_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	if (pcmd->res != H2C_SUCCESS) {
+		clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nsurvey_cmd_callback : clr _FW_UNDER_SURVEY "));
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: MgntActSet_802_11_BSSID_LIST_SCAN Fail ************\n\n."));
+	}
+
+	// free cmd
+	free_cmd_obj(pcmd);
+
+_func_exit_;
+}
+void disassoc_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
+{
+	_irqL	irqL;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	if (pcmd->res != H2C_SUCCESS)
+	{
+		_enter_critical(&pmlmepriv->lock, &irqL);
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		_exit_critical(&pmlmepriv->lock, &irqL);
+
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
+
+		goto exit;
+	}
+
+	// free cmd
+	free_cmd_obj(pcmd);
+
+exit:
+
+_func_exit_;
+}
+
+
+void joinbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	if ((pcmd->res != H2C_SUCCESS))
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("********Error:select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	}
+
+	free_cmd_obj(pcmd);
+
+_func_exit_;
+}
+
+void createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
+{
+	_irqL	irqL;
+	u8	timer_cancelled;
+	struct sta_info		*psta = NULL;
+	struct wlan_network	*pwlan = NULL;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	NDIS_WLAN_BSSID_EX	*pnetwork = (NDIS_WLAN_BSSID_EX *)pcmd->parmbuf;
+	struct wlan_network	*tgt_network = &(pmlmepriv->cur_network);
+
+_func_enter_;
+
+	if((pcmd->res != H2C_SUCCESS))
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: createbss_cmd_callback  Fail ************\n\n."));
+		_set_timer(&pmlmepriv->assoc_timer, 1 );
+	}
+
+	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+
+       //endian_convert
+        pnetwork->Length = le32_to_cpu(pnetwork->Length);
+  	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy =le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	//pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+
+	if((pmlmepriv->fw_state) & WIFI_AP_STATE)
+	{
+		psta = get_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+		if(!psta)
+		{
+			psta = alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+			if (psta == NULL) 
+			{ 
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when createbss_cmd_callback\n"));
+				goto createbss_cmd_fail ;
+			}
+		}	
+			
+		indicate_connect( padapter);
+	}
+	else
+	{
+		pwlan = _alloc_network(pmlmepriv);
+
+		if ( pwlan == NULL)
+		{
+			pwlan = get_oldest_wlan_network(&pmlmepriv->scanned_queue);
+			if( pwlan == NULL)
+			{
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n Error:  can't get pwlan in joinbss_event_callback \n"));
+				goto createbss_cmd_fail;
+			}
+			pwlan->last_scanned = get_current_time();
+		}
+		else
+		{
+			list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+		}
+
+		pnetwork->Length = get_NDIS_WLAN_BSSID_EX_sz(pnetwork);
+		_memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
+		pwlan->fixed = _TRUE;
+
+		//list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+
+		// copy pdev_network information to 	pmlmepriv->cur_network
+		_memcpy(&tgt_network->network, pnetwork, (get_NDIS_WLAN_BSSID_EX_sz(pnetwork)));
+
+		// reset DSConfig
+		//tgt_network->network.Configuration.DSConfig = (u32)ch2freq(pnetwork->Configuration.DSConfig);
+
+
+		if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+		    pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+
+#if 0
+		if((pmlmepriv->fw_state) & WIFI_AP_STATE)
+		{
+			psta = alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+
+			if (psta == NULL) { // for AP Mode & Adhoc Master Mode
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when createbss_cmd_callback\n"));
+				goto createbss_cmd_fail ;
+			}
+
+			indicate_connect( padapter);
+		}
+		else {
+
+			//indicate_disconnect(dev);
+		}
+#endif
+
+		// we will set _FW_LINKED when there is one more sat to join us (stassoc_event_callback)
+
+	}
+
+createbss_cmd_fail:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	free_cmd_obj(pcmd);
+
+_func_exit_;
+
+}
+
+
+
+void setstaKey_cmdrsp_callback(_adapter*	padapter ,  struct cmd_obj *pcmd)
+{
+
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct set_stakey_rsp	*psetstakey_rsp = (struct set_stakey_rsp*) (pcmd->rsp);
+	struct sta_info		*psta = get_stainfo(pstapriv, psetstakey_rsp->addr);
+
+_func_enter_;
+
+	if(psta==NULL)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: setstaKey_cmdrsp_callback => can't get sta_info \n\n"));
+		goto exit;
+	}
+
+	psta->aid = psta->mac_id = psetstakey_rsp->keyid; //CAM_ID(CAM_ENTRY)
+
+exit:
+
+	free_cmd_obj(pcmd);
+
+_func_exit_;
+
+}
+void setassocsta_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+	_irqL	irqL;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct set_assocsta_parm	*passocsta_parm = (struct set_assocsta_parm*)(pcmd->parmbuf);
+	struct set_assocsta_rsp	*passocsta_rsp = (struct set_assocsta_rsp*) (pcmd->rsp);
+	struct sta_info		*psta = get_stainfo(pstapriv, passocsta_parm->addr);
+
+_func_enter_;
+
+	if(psta==NULL)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info \n\n"));
+		goto exit;
+	}
+
+	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE))
+		pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	free_cmd_obj(pcmd);
+exit:
+_func_exit_;
+}
+
+void getrttbl_cmd_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+_func_enter_;
+
+	free_cmd_obj(pcmd);
+#ifdef CONFIG_MP_INCLUDED
+	padapter->mppriv.workparam.bcompleted=_TRUE;
+#endif
+
+_func_exit_;
+
+}
+
+#ifdef CONFIG_PWRCTRL
+u8  setatim_cmd(_adapter* adapter, u8 add, u8 txid)
+{
+
+	struct	cmd_obj*	ph2c;
+	struct	setatim_parm* psetatim;
+	struct	cmd_priv   *pcmdpriv= &( adapter->cmdpriv);
+	u8	res=_SUCCESS;
+_func_enter_;
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		goto exit;
+		res= _FAIL;
+	}
+	psetatim = (struct setatim_parm*)_malloc(sizeof(struct setatim_parm));
+
+	if(psetatim == NULL){
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	//NdisZeroMemory();
+	psetatim->op = add;
+	psetatim->txid = txid;
+
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetatim, _SetAtim_CMD_);
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+}
+
+u8 setpwrmode_cmd(_adapter* adapter, u32 ps_mode, u32 smart_ps)
+{
+	struct	cmd_obj*	ph2c;
+	struct	setpwrmode_parm* psetpwr;
+	struct	cmd_priv   *pcmdpriv= &( adapter->cmdpriv);
+	u8 res=_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("setpwrmode_cmd mode  = %x, smart_ps = %x", ps_mode,smart_ps));
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+
+	psetpwr = (struct setpwrmode_parm*)_malloc(sizeof(struct setpwrmode_parm));
+	if(psetpwr == NULL){
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	_memset(psetpwr, 0, sizeof(struct setpwrmode_parm));
+
+	psetpwr->mode = (unsigned char)ps_mode;
+	psetpwr->bcn_pass_cnt = 0;
+	psetpwr->smart_ps = (unsigned char)smart_ps;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetpwr, _SetPwrMode_CMD_);
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+}
+#endif
+
+u8 disconnectCtrlEx_cmd(_adapter* adapter, u32 enableDrvCtrl, u32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO){
+	struct	cmd_obj*	ph2c;
+	struct	DisconnectCtrlEx_param * param;
+	struct	cmd_priv   *pcmdpriv= &( adapter->cmdpriv);
+	u8 res=_SUCCESS;
+
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,
+		("%s  = %x, TryPktCnt = %x, TryPktInterval = %x, FirstStageTO = %x"
+		, __function__ , enableDrvCtrl, tryPktCnt, tryPktInterval, firstStageTO)
+	);
+
+	ph2c = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	param = (struct DisconnectCtrlEx_param *)_malloc(sizeof(struct DisconnectCtrlEx_param));
+	if(param == NULL){
+		_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	_memset(param, 0, sizeof(struct DisconnectCtrlEx_param));
+
+	param->EnableDrvCtrl = (unsigned char)enableDrvCtrl;
+	param->TryPktCnt = (unsigned char)tryPktCnt;
+	param->TryPktInterval = (unsigned char)tryPktInterval;
+	param->FirstStageTO = (unsigned int)firstStageTO;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, param, GEN_CMD_CODE(_DisconnectCtrlEx));
+
+	enqueue_cmd(pcmdpriv, ph2c);
+exit:
+_func_exit_;
+	return res;
+
+}
+
diff --git a/drivers/net/wireless/8712u/config b/drivers/net/wireless/8712u/config
new file mode 100755
index 0000000..eb2b362
--- /dev/null
+++ b/drivers/net/wireless/8712u/config
@@ -0,0 +1,27 @@
+
+#
+# Automatically generated make config: don't edit
+#
+
+CONFIG_RTL8711			=	n
+CONFIG_RTL8712			=	y
+
+
+CONFIG_USB_HCI			=	y
+CONFIG_SDIO_HCI			= 	n
+
+
+CONFIG_MP_INCLUDED		=	y
+
+CONFIG_PLATFORM_I386_PC		=	y
+CONFIG_PLATFORM_ANDROID_X86	=	n
+CONFIG_PLATFORM_ARM_S3C		= 	n
+CONFIG_PLATFORM_ARM_PXA		= 	n
+CONFIG_PLATFORM_MIPS_RMI	= 	n
+CONFIG_PLATFORM_RTK_DMP		= 	n
+CONFIG_PLATFORM_MIPS_PLM	= 	n
+CONFIG_PLATFORM_RTD2880B	=	n
+CONFIG_PLATFORM_MSTAR389	=	n
+
+CONFIG_MLME_EXT			= 	n
+CONFIG_DRVEXT_MODULE	= n
diff --git a/drivers/net/wireless/8712u/crypto/rtl871x_security.c b/drivers/net/wireless/8712u/crypto/rtl871x_security.c
new file mode 100755
index 0000000..dc71b42
--- /dev/null
+++ b/drivers/net/wireless/8712u/crypto/rtl871x_security.c
@@ -0,0 +1,1940 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define  _RTL871X_SECURITY_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+
+
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+
+//=====WEP related===== 
+
+#define CRC32_POLY 0x04c11db7
+
+struct arc4context
+{
+	u32 x;
+	u32 y;
+	u8 state[256];
+};
+
+
+void arcfour_init(struct arc4context 	*parc4ctx, u8 * key,u32	key_len)
+{
+	u32	t, u;
+	u32	keyindex;
+	u32	stateindex;
+	u8 * state;
+	u32	counter;
+_func_enter_;
+	state = parc4ctx->state;
+	parc4ctx->x = 0;
+	parc4ctx->y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (u8)counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++)
+	{
+		t = state[counter];
+		stateindex = (stateindex + key[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = (u8)t;
+		state[counter] = (u8)u;
+		if (++keyindex >= key_len)
+			keyindex = 0;
+	}
+_func_exit_;	
+}
+u32 arcfour_byte(	struct arc4context	*parc4ctx)
+{
+	u32 x;
+	u32 y;
+	u32 sx, sy;
+	u8 * state;
+_func_enter_;
+	state = parc4ctx->state;
+	x = (parc4ctx->x + 1) & 0xff;
+	sx = state[x];
+	y = (sx + parc4ctx->y) & 0xff;
+	sy = state[y];
+	parc4ctx->x = x;
+	parc4ctx->y = y;
+	state[y] = (u8)sx;
+	state[x] = (u8)sy;
+_func_exit_;	
+	return state[(sx + sy) & 0xff];
+}
+              
+           
+void arcfour_encrypt(	struct arc4context	*parc4ctx, 
+	u8 * dest,
+	u8 * src, 
+	u32 len)
+{
+	u32	i;
+_func_enter_;	
+	for (i = 0; i < len; i++)
+		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
+_func_exit_;		
+}
+
+sint bcrc32initialized = 0;
+u32 crc32_table[256];
+
+
+u8 crc32_reverseBit( u8 data)
+{
+	return( (u8)((data<<7)&0x80) | ((data<<5)&0x40) | ((data<<3)&0x20) | ((data<<1)&0x10) | ((data>>1)&0x08) | ((data>>3)&0x04) | ((data>>5)&0x02) | ((data>>7)&0x01) );
+}
+
+void crc32_init(void)
+{
+_func_enter_;	
+	if (bcrc32initialized == 1) 
+		goto exit;
+	else{
+		sint i, j;
+		u32 c;
+		u8 *p=(u8 *)&c, *p1;
+		u8 k;
+
+		c = 0x12340000;
+
+		for (i = 0; i < 256; ++i) 
+		{
+			k = crc32_reverseBit((u8)i);
+			for (c = ((u32)k) << 24, j = 8; j > 0; --j){
+				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);
+			}
+			p1 = (u8 *)&crc32_table[i];
+
+			p1[0] = crc32_reverseBit(p[3]);
+			p1[1] = crc32_reverseBit(p[2]);
+			p1[2] = crc32_reverseBit(p[1]);
+			p1[3] = crc32_reverseBit(p[0]);
+		}
+		bcrc32initialized= 1;
+	}
+exit:	
+_func_exit_;			
+}
+
+u32 getcrc32(u8 *buf, sint len)
+{
+	u8 *p;
+	u32  crc;
+_func_enter_;	
+	if (bcrc32initialized == 0) crc32_init();
+
+	crc = 0xffffffff;       /* preload shift register, per CRC-32 spec */
+
+	for (p = buf; len > 0; ++p, --len) 
+	{
+		crc = crc32_table[ (crc ^ *p) & 0xff] ^ (crc >> 8);
+	}
+_func_exit_;				
+	return ~crc;    /* transmit complement, per CRC-32 spec */
+}
+
+
+/*
+	Need to consider the fragment  situation
+*/
+void wep_encrypt(_adapter *padapter, u8 *pxmitframe)
+{																	// exclude ICV
+	
+	unsigned char	crc[4];
+	struct arc4context	 mycontext;
+
+	sint 			curfragnum,length;
+	u32	keylength;
+
+	u8	*pframe, *payload,*iv;    //,*wepkey
+	u8	wepkey[16];
+	struct	pkt_attrib	 *pattrib = &((struct xmit_frame*)pxmitframe)->attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	
+_func_enter_;	
+
+	
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return;
+
+	//pframe=(unsigned char *)(((struct xmit_frame*)pxmitframe)->mem) + WLANHDR_OFFSET + TXDESC_OFFSET;
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr+TXDESC_OFFSET;
+	
+	//start to encrypt each fragment
+	if((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
+	{
+		keylength=psecuritypriv->dot11DefKeylen[psecuritypriv->dot11PrivacyKeyIndex];
+
+		for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++)
+		{
+			iv=pframe+pattrib->hdrlen;
+			_memcpy(&wepkey[0], iv, 3);
+			_memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);
+			payload=pframe+pattrib->iv_len+pattrib->hdrlen;
+
+			if((curfragnum+1)==pattrib->nr_frags)
+			{	//the last fragment
+			
+				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+				*((unsigned long *)crc)= cpu_to_le32(getcrc32(payload,length));
+				arcfour_init(&mycontext, wepkey,3+keylength);
+				arcfour_encrypt(&mycontext, payload, payload, length);
+				arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+			}
+			else
+			{
+				length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+				*((unsigned long *)crc)= cpu_to_le32(getcrc32(payload,length));
+				arcfour_init(&mycontext, wepkey,3+keylength);
+				arcfour_encrypt(&mycontext, payload, payload, length);
+				arcfour_encrypt(&mycontext, payload+length, crc, 4);
+	
+			pframe+=pxmitpriv->frag_len;
+			pframe=(u8 *)RND4((uint)(pframe));
+
+			}
+			
+		}		
+						
+	}
+	
+_func_exit_;						
+
+}
+
+void wep_decrypt(_adapter  *padapter, u8 *precvframe)
+{								
+	// exclude ICV
+	u8	crc[4];
+	struct arc4context	 mycontext;
+	sint 	length;
+	u32	keylength;
+	u8	*pframe, *payload,*iv,wepkey[16];
+	u8	 keyindex;
+	struct	rx_pkt_attrib	 *prxattrib = &(((union recv_frame*)precvframe)->u.hdr.attrib);
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+
+_func_enter_;	
+
+	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
+	
+	//start to decrypt recvframe
+	if((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
+	{
+		iv=pframe+prxattrib->hdrlen;
+		keyindex=(iv[3]&0x3);
+		keylength=psecuritypriv->dot11DefKeylen[keyindex];
+		_memcpy(&wepkey[0], iv, 3);
+		_memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);	
+		length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+
+		payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
+		
+		//decrypt payload include icv
+		arcfour_init(&mycontext, wepkey,3+keylength);
+		arcfour_encrypt(&mycontext, payload, payload,  length);
+				
+		//calculate icv and compare the icv
+		*((unsigned long *)crc)=cpu_to_le32(getcrc32(payload,length-4));
+		
+		if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+		{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
+						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
+		}	
+						
+	}
+	
+_func_exit_;		
+
+	return;
+	
+}
+
+//3 		=====TKIP related=====
+
+u32 secmicgetuint32( u8 * p )
+// Convert from Byte[] to Us4Byte32 in a portable way
+{
+	s32 i;
+	u32 res = 0;
+_func_enter_;		
+	for( i=0; i<4; i++ )
+	{
+		res |= ((u32)(*p++)) << (8*i);
+	}
+_func_exit_;		
+	return res;
+}
+
+void secmicputuint32( u8 * p, u32 val )
+// Convert from Us4Byte32 to Byte[] in a portable way
+{
+	long i;
+_func_enter_;			
+	for( i=0; i<4; i++ )
+	{
+		*p++ = (u8) (val & 0xff);
+		val >>= 8;
+	}
+_func_exit_;		
+}
+
+void secmicclear(struct mic_data *pmicdata)
+{
+// Reset the state to the empty message.
+_func_enter_;	
+	pmicdata->L = pmicdata->K0;
+	pmicdata->R = pmicdata->K1;
+	pmicdata->nBytesInM = 0;
+	pmicdata->M = 0;
+_func_exit_;	
+}
+
+void secmicsetkey(struct mic_data *pmicdata, u8 * key )
+{
+	// Set the key
+_func_enter_;		
+	pmicdata->K0 = secmicgetuint32( key );
+	pmicdata->K1 = secmicgetuint32( key + 4 );
+	// and reset the message
+	secmicclear(pmicdata);
+_func_exit_;		
+}
+
+void secmicappendbyte(struct mic_data *pmicdata, u8 b )
+{
+_func_enter_;	
+	// Append the byte to our word-sized buffer
+	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
+	pmicdata->nBytesInM++;
+	// Process the word if it is full.
+	if( pmicdata->nBytesInM >= 4 )
+	{
+		pmicdata->L ^= pmicdata->M;
+		pmicdata->R ^= ROL32( pmicdata->L, 17 );
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->L & 0x00ff00ff) << 8);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROL32( pmicdata->L, 3 );
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROR32( pmicdata->L, 2 );
+		pmicdata->L += pmicdata->R;
+		// Clear the buffer
+		pmicdata->M = 0;
+		pmicdata->nBytesInM = 0;
+	}
+_func_exit_;			
+}
+
+void secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes )
+{
+_func_enter_;	
+	// This is simple
+	while( nbytes > 0 )
+	{
+		secmicappendbyte(pmicdata, *src++ );
+		nbytes--;
+	}
+_func_exit_;			
+}
+
+void secgetmic(struct mic_data *pmicdata, u8 * dst )
+{
+_func_enter_;	
+	// Append the minimum padding
+	secmicappendbyte(pmicdata, 0x5a );
+	secmicappendbyte(pmicdata, 0 );
+	secmicappendbyte(pmicdata, 0 );
+	secmicappendbyte(pmicdata, 0 );
+	secmicappendbyte(pmicdata, 0 );
+	// and then zeroes until the length is a multiple of 4
+	while( pmicdata->nBytesInM != 0 )
+	{
+		secmicappendbyte(pmicdata, 0 );
+	}
+	// The appendByte function has already computed the result.
+	secmicputuint32( dst, pmicdata->L );
+	secmicputuint32( dst+4, pmicdata->R );
+	// Reset to the empty message.
+	secmicclear(pmicdata);
+_func_exit_;		
+}
+
+
+void seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code, u8 pri)
+{
+
+	struct mic_data	micdata;
+	u8 priority[4]={0x0,0x0,0x0,0x0};
+_func_enter_;		
+	secmicsetkey(&micdata, key);
+	priority[0]=pri;
+	
+	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
+	if(header[1]&1){   //ToDS==1
+			secmicappend(&micdata, &header[16], 6);  //DA
+		if(header[1]&2)  //From Ds==1
+			secmicappend(&micdata, &header[24], 6);
+		else
+			secmicappend(&micdata, &header[10], 6);		
+	}	
+	else{	//ToDS==0
+		secmicappend(&micdata, &header[4], 6);   //DA
+		if(header[1]&2)  //From Ds==1
+			secmicappend(&micdata, &header[16], 6);
+		else
+			secmicappend(&micdata, &header[10], 6);
+
+	}
+	secmicappend(&micdata, &priority[0], 4);
+
+	
+	secmicappend(&micdata, data, data_len);
+
+	secgetmic(&micdata,mic_code);
+_func_exit_;	
+}
+
+
+
+
+/* macros for extraction/creation of unsigned char/unsigned short values  */
+#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
+#define   Lo8(v16)   ((u8)( (v16)       & 0x00FF))
+#define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))
+#define  Lo16(v32)   ((u16)( (v32)       & 0xFFFF))
+#define  Hi16(v32)   ((u16)(((v32) >>16) & 0xFFFF))
+#define  Mk16(hi,lo) ((lo) ^ (((u16)(hi)) << 8))
+
+/* select the Nth 16-bit word of the temporal key unsigned char array TK[]   */
+#define  TK16(N)     Mk16(tk[2*(N)+1],tk[2*(N)])
+
+/* S-box lookup: 16 bits --> 16 bits */
+#define _S_(v16)     (Sbox1[0][Lo8(v16)] ^ Sbox1[1][Hi8(v16)])
+
+/* fixed algorithm "parameters" */
+#define PHASE1_LOOP_CNT   8    /* this needs to be "big enough"     */
+#define TA_SIZE           6    /*  48-bit transmitter address       */
+#define TK_SIZE          16    /* 128-bit temporal key              */
+#define P1K_SIZE         10    /*  80-bit Phase1 key                */
+#define RC4_KEY_SIZE     16    /* 128-bit RC4KEY (104 bits unknown) */
+
+
+/* 2-unsigned char by 2-unsigned char subset of the full AES S-box table */
+const unsigned short Sbox1[2][256]=       /* Sbox for hash (can be in ROM)     */
+{ {
+   0xC6A5,0xF884,0xEE99,0xF68D,0xFF0D,0xD6BD,0xDEB1,0x9154,
+   0x6050,0x0203,0xCEA9,0x567D,0xE719,0xB562,0x4DE6,0xEC9A,
+   0x8F45,0x1F9D,0x8940,0xFA87,0xEF15,0xB2EB,0x8EC9,0xFB0B,
+   0x41EC,0xB367,0x5FFD,0x45EA,0x23BF,0x53F7,0xE496,0x9B5B,
+   0x75C2,0xE11C,0x3DAE,0x4C6A,0x6C5A,0x7E41,0xF502,0x834F,
+   0x685C,0x51F4,0xD134,0xF908,0xE293,0xAB73,0x6253,0x2A3F,
+   0x080C,0x9552,0x4665,0x9D5E,0x3028,0x37A1,0x0A0F,0x2FB5,
+   0x0E09,0x2436,0x1B9B,0xDF3D,0xCD26,0x4E69,0x7FCD,0xEA9F,
+   0x121B,0x1D9E,0x5874,0x342E,0x362D,0xDCB2,0xB4EE,0x5BFB,
+   0xA4F6,0x764D,0xB761,0x7DCE,0x527B,0xDD3E,0x5E71,0x1397,
+   0xA6F5,0xB968,0x0000,0xC12C,0x4060,0xE31F,0x79C8,0xB6ED,
+   0xD4BE,0x8D46,0x67D9,0x724B,0x94DE,0x98D4,0xB0E8,0x854A,
+   0xBB6B,0xC52A,0x4FE5,0xED16,0x86C5,0x9AD7,0x6655,0x1194,
+   0x8ACF,0xE910,0x0406,0xFE81,0xA0F0,0x7844,0x25BA,0x4BE3,
+   0xA2F3,0x5DFE,0x80C0,0x058A,0x3FAD,0x21BC,0x7048,0xF104,
+   0x63DF,0x77C1,0xAF75,0x4263,0x2030,0xE51A,0xFD0E,0xBF6D,
+   0x814C,0x1814,0x2635,0xC32F,0xBEE1,0x35A2,0x88CC,0x2E39,
+   0x9357,0x55F2,0xFC82,0x7A47,0xC8AC,0xBAE7,0x322B,0xE695,
+   0xC0A0,0x1998,0x9ED1,0xA37F,0x4466,0x547E,0x3BAB,0x0B83,
+   0x8CCA,0xC729,0x6BD3,0x283C,0xA779,0xBCE2,0x161D,0xAD76,
+   0xDB3B,0x6456,0x744E,0x141E,0x92DB,0x0C0A,0x486C,0xB8E4,
+   0x9F5D,0xBD6E,0x43EF,0xC4A6,0x39A8,0x31A4,0xD337,0xF28B,
+   0xD532,0x8B43,0x6E59,0xDAB7,0x018C,0xB164,0x9CD2,0x49E0,
+   0xD8B4,0xACFA,0xF307,0xCF25,0xCAAF,0xF48E,0x47E9,0x1018,
+   0x6FD5,0xF088,0x4A6F,0x5C72,0x3824,0x57F1,0x73C7,0x9751,
+   0xCB23,0xA17C,0xE89C,0x3E21,0x96DD,0x61DC,0x0D86,0x0F85,
+   0xE090,0x7C42,0x71C4,0xCCAA,0x90D8,0x0605,0xF701,0x1C12,
+   0xC2A3,0x6A5F,0xAEF9,0x69D0,0x1791,0x9958,0x3A27,0x27B9,
+   0xD938,0xEB13,0x2BB3,0x2233,0xD2BB,0xA970,0x0789,0x33A7,
+   0x2DB6,0x3C22,0x1592,0xC920,0x8749,0xAAFF,0x5078,0xA57A,
+   0x038F,0x59F8,0x0980,0x1A17,0x65DA,0xD731,0x84C6,0xD0B8,
+   0x82C3,0x29B0,0x5A77,0x1E11,0x7BCB,0xA8FC,0x6DD6,0x2C3A,
+  },
+ 
+
+  {  /* second half of table is unsigned char-reversed version of first! */
+   0xA5C6,0x84F8,0x99EE,0x8DF6,0x0DFF,0xBDD6,0xB1DE,0x5491,
+   0x5060,0x0302,0xA9CE,0x7D56,0x19E7,0x62B5,0xE64D,0x9AEC,
+   0x458F,0x9D1F,0x4089,0x87FA,0x15EF,0xEBB2,0xC98E,0x0BFB,
+   0xEC41,0x67B3,0xFD5F,0xEA45,0xBF23,0xF753,0x96E4,0x5B9B,
+   0xC275,0x1CE1,0xAE3D,0x6A4C,0x5A6C,0x417E,0x02F5,0x4F83,
+   0x5C68,0xF451,0x34D1,0x08F9,0x93E2,0x73AB,0x5362,0x3F2A,
+   0x0C08,0x5295,0x6546,0x5E9D,0x2830,0xA137,0x0F0A,0xB52F,
+   0x090E,0x3624,0x9B1B,0x3DDF,0x26CD,0x694E,0xCD7F,0x9FEA,
+   0x1B12,0x9E1D,0x7458,0x2E34,0x2D36,0xB2DC,0xEEB4,0xFB5B,
+   0xF6A4,0x4D76,0x61B7,0xCE7D,0x7B52,0x3EDD,0x715E,0x9713,
+   0xF5A6,0x68B9,0x0000,0x2CC1,0x6040,0x1FE3,0xC879,0xEDB6,
+   0xBED4,0x468D,0xD967,0x4B72,0xDE94,0xD498,0xE8B0,0x4A85,
+   0x6BBB,0x2AC5,0xE54F,0x16ED,0xC586,0xD79A,0x5566,0x9411,
+   0xCF8A,0x10E9,0x0604,0x81FE,0xF0A0,0x4478,0xBA25,0xE34B,
+   0xF3A2,0xFE5D,0xC080,0x8A05,0xAD3F,0xBC21,0x4870,0x04F1,
+   0xDF63,0xC177,0x75AF,0x6342,0x3020,0x1AE5,0x0EFD,0x6DBF,
+   0x4C81,0x1418,0x3526,0x2FC3,0xE1BE,0xA235,0xCC88,0x392E,
+   0x5793,0xF255,0x82FC,0x477A,0xACC8,0xE7BA,0x2B32,0x95E6,
+   0xA0C0,0x9819,0xD19E,0x7FA3,0x6644,0x7E54,0xAB3B,0x830B,
+   0xCA8C,0x29C7,0xD36B,0x3C28,0x79A7,0xE2BC,0x1D16,0x76AD,
+   0x3BDB,0x5664,0x4E74,0x1E14,0xDB92,0x0A0C,0x6C48,0xE4B8,
+   0x5D9F,0x6EBD,0xEF43,0xA6C4,0xA839,0xA431,0x37D3,0x8BF2,
+   0x32D5,0x438B,0x596E,0xB7DA,0x8C01,0x64B1,0xD29C,0xE049,
+   0xB4D8,0xFAAC,0x07F3,0x25CF,0xAFCA,0x8EF4,0xE947,0x1810,
+   0xD56F,0x88F0,0x6F4A,0x725C,0x2438,0xF157,0xC773,0x5197,
+   0x23CB,0x7CA1,0x9CE8,0x213E,0xDD96,0xDC61,0x860D,0x850F,
+   0x90E0,0x427C,0xC471,0xAACC,0xD890,0x0506,0x01F7,0x121C,
+   0xA3C2,0x5F6A,0xF9AE,0xD069,0x9117,0x5899,0x273A,0xB927,
+   0x38D9,0x13EB,0xB32B,0x3322,0xBBD2,0x70A9,0x8907,0xA733,
+   0xB62D,0x223C,0x9215,0x20C9,0x4987,0xFFAA,0x7850,0x7AA5,
+   0x8F03,0xF859,0x8009,0x171A,0xDA65,0x31D7,0xC684,0xB8D0,
+   0xC382,0xB029,0x775A,0x111E,0xCB7B,0xFCA8,0xD66D,0x3A2C,
+  }
+};
+ 
+ /*
+**********************************************************************
+* Routine: Phase 1 -- generate P1K, given TA, TK, IV32
+*
+* Inputs:
+*     tk[]      = temporal key                         [128 bits]
+*     ta[]      = transmitter's MAC address            [ 48 bits]
+*     iv32      = upper 32 bits of IV                  [ 32 bits]
+* Output:
+*     p1k[]     = Phase 1 key                          [ 80 bits]
+*
+* Note:
+*     This function only needs to be called every 2**16 packets,
+*     although in theory it could be called every packet.
+*
+**********************************************************************
+*/
+void phase1(u16 *p1k,const u8 *tk,const u8 *ta,u32 iv32)
+{
+	sint  i;
+_func_enter_;
+	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
+	p1k[0]      = Lo16(iv32);
+	p1k[1]      = Hi16(iv32);
+	p1k[2]      = Mk16(ta[1],ta[0]); /* use TA[] as little-endian */
+	p1k[3]      = Mk16(ta[3],ta[2]);
+	p1k[4]      = Mk16(ta[5],ta[4]);
+
+	/* Now compute an unbalanced Feistel cipher with 80-bit block */
+	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
+	for (i=0; i < PHASE1_LOOP_CNT ;i++)
+	{                 /* Each add operation here is mod 2**16 */
+      		p1k[0] += _S_(p1k[4] ^ TK16((i&1)+0));
+		p1k[1] += _S_(p1k[0] ^ TK16((i&1)+2));
+		p1k[2] += _S_(p1k[1] ^ TK16((i&1)+4));
+		p1k[3] += _S_(p1k[2] ^ TK16((i&1)+6));
+		p1k[4] += _S_(p1k[3] ^ TK16((i&1)+0));
+		p1k[4] +=  (unsigned short)i;                    /* avoid "slide attacks" */
+        }
+_func_exit_;
+}
+ 
+
+/*
+**********************************************************************
+* Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
+*
+* Inputs:
+*     tk[]      = Temporal key                         [128 bits]
+*     p1k[]     = Phase 1 output key                   [ 80 bits]
+*     iv16      = low 16 bits of IV counter            [ 16 bits]
+* Output:
+*     rc4key[]  = the key used to encrypt the packet   [128 bits]
+*
+* Note:
+*     The value {TA,IV32,IV16} for Phase1/Phase2 must be unique
+*     across all packets using the same key TK value. Then, for a
+*     given value of TK[], this TKIP48 construction guarantees that
+*     the final RC4KEY value is unique across all packets.
+*
+* Suggested implementation optimization: if PPK[] is "overlaid"
+*     appropriately on RC4KEY[], there is no need for the final
+*     for loop below that copies the PPK[] result into RC4KEY[].
+*
+**********************************************************************
+*/
+void phase2(u8 *rc4key,const u8 *tk,const u16 *p1k,u16 iv16)
+{
+	sint  i;
+	u16 PPK[6];                          /* temporary key for mixing    */
+_func_enter_;
+	/* Note: all adds in the PPK[] equations below are mod 2**16         */
+	for (i=0;i<5;i++) PPK[i]=p1k[i];      /* first, copy P1K to PPK      */
+		PPK[5]  =  p1k[4] +iv16;             /* next,  add in IV16          */
+
+	/* Bijective non-linear mixing of the 96 bits of PPK[0..5]           */
+	PPK[0] +=    _S_(PPK[5] ^ TK16(0));   /* Mix key in each "round"     */
+	PPK[1] +=    _S_(PPK[0] ^ TK16(1));
+	PPK[2] +=    _S_(PPK[1] ^ TK16(2));
+	PPK[3] +=    _S_(PPK[2] ^ TK16(3));
+	PPK[4] +=    _S_(PPK[3] ^ TK16(4));
+	PPK[5] +=    _S_(PPK[4] ^ TK16(5));   /* Total # S-box lookups == 6  */
+
+	/* Final sweep: bijective, "linear". Rotates kill LSB correlations   */
+	PPK[0] +=  RotR1(PPK[5] ^ TK16(6));
+	PPK[1] +=  RotR1(PPK[0] ^ TK16(7));   /* Use all of TK[] in Phase2   */
+	PPK[2] +=  RotR1(PPK[1]);
+	PPK[3] +=  RotR1(PPK[2]);
+	PPK[4] +=  RotR1(PPK[3]);
+	PPK[5] +=  RotR1(PPK[4]);
+	/* Note: At this point, for a given key TK[0..15], the 96-bit output */
+	/*       value PPK[0..5] is guaranteed to be unique, as a function   */
+	/*       of the 96-bit "input" value   {TA,IV32,IV16}. That is, P1K  */
+	/*       is now a keyed permutation of {TA,IV32,IV16}.               */
+
+	/* Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   */
+	rc4key[0] = Hi8(iv16);                /* RC4KEY[0..2] is the WEP IV  */
+	rc4key[1] =(Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
+	rc4key[2] = Lo8(iv16);
+	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
+	 
+
+	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       */
+	for (i=0;i<6;i++)
+	{
+		rc4key[4+2*i] = Lo8(PPK[i]);
+		rc4key[5+2*i] = Hi8(PPK[i]);
+	}
+_func_exit_;	
+}
+
+
+//The hlen isn't include the IV
+u32	tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
+{																	// exclude ICV
+	u16	pnl;
+	u32	pnh;
+	u8	rc4key[16];
+	u8   ttkey[16];
+	u8	crc[4];
+	struct arc4context mycontext;
+	sint 			curfragnum,length;
+	u32	prwskeylen;
+
+	u8	*pframe, *payload,*iv,*prwskey;
+	union pn48 dot11txpn;
+	struct	sta_info		*stainfo;
+	struct	pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	//struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	u32	res=_SUCCESS;
+_func_enter_;
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return _FAIL;
+
+	//pframe=(u8 *)(((struct xmit_frame*)pxmitframe)->mem) + WLANHDR_OFFSET + TXDESC_OFFSET;
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr+TXDESC_OFFSET;
+
+	//4 start to encrypt each fragment
+	if(pattrib->encrypt==_TKIP_){
+
+		if(pattrib->psta)
+		{
+			stainfo = pattrib->psta;
+		}
+		else
+		{
+		stainfo=get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
+		}	
+		
+		if (stainfo!=NULL){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("tkip_encrypt: stainfo!=NULL!!!\n"));
+			prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			prwskeylen=16;
+
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+				iv=pframe+pattrib->hdrlen;
+				payload=pframe+pattrib->iv_len+pattrib->hdrlen;
+				
+				GET_TKIP_PN(iv, dot11txpn);
+
+				pnl=(u16)(dot11txpn.val);
+				pnh=(u32)(dot11txpn.val>>16);
+
+				phase1((u16 *)&ttkey[0],prwskey,&pattrib->ta[0],pnh);
+
+				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);	
+
+				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("pattrib->iv_len =%x, pattrib->icv_len =%x\n", pattrib->iv_len,pattrib->icv_len));
+					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
+
+					arcfour_init(&mycontext, rc4key,16);
+					arcfour_encrypt(&mycontext, payload, payload, length);
+					arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
+					arcfour_init(&mycontext,rc4key,16);
+					arcfour_encrypt(&mycontext, payload, payload, length);
+					arcfour_encrypt(&mycontext, payload+length, crc, 4);
+	
+				pframe+=pxmitpriv->frag_len;
+				pframe=(u8 *)RND4((uint)(pframe));
+
+				}
+			}
+
+
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("tkip_encrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+_func_exit_;	
+	return res;
+				
+}
+
+
+//The hlen isn't include the IV
+u32 tkip_decrypt(_adapter *padapter, u8 *precvframe)
+{																	// exclude ICV
+	u16 pnl;
+	u32 pnh;
+	u8   rc4key[16];
+	u8   ttkey[16];
+	u8	crc[4];
+	struct arc4context mycontext;
+	sint 			length;
+	u32	prwskeylen;
+
+	u8	*pframe, *payload,*iv,*prwskey,idx=0;
+	union pn48 dot11txpn;
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	 *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+//	struct	recv_priv		*precvpriv=&padapter->recvpriv;
+	u32		res=_SUCCESS;
+
+_func_enter_;
+
+	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
+	
+	//4 start to decrypt recvframe
+	if(prxattrib->encrypt==_TKIP_){
+
+		stainfo=get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
+		if (stainfo!=NULL){
+			
+			iv=pframe+prxattrib->hdrlen;
+			payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
+			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+
+			if(IS_MCAST(prxattrib->ra)){
+				idx=iv[3];
+				prwskey=&psecuritypriv->dot118021XGrpKey[( (idx>>6)&0x3 )-1].skey[0];
+				if((( (idx>>6)&0x3 )-1)!= psecuritypriv->dot118021XGrpKeyid ){
+					RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("\n tkip_decrypt: bcmc key  psecuritypriv->dot118021XGrpKeyid =%x, idx in frame iv is %x  \n",psecuritypriv->dot118021XGrpKeyid,idx ));
+
+				}
+				RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("\n tkip_decrypt: bcmc key \n"));
+				if(psecuritypriv->binstallGrpkey==_FALSE){
+					res=_FAIL;
+					RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("\n tkip_decrypt:didn't install group key!!!!!!!!!!\n"));
+					goto exit;
+				}
+
+			}
+			else{
+				RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("tkip_decrypt: stainfo!=NULL!!!\n"));
+				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			}
+			prwskeylen=16;
+			
+				
+			GET_TKIP_PN(iv, dot11txpn);
+
+			pnl=(u16)(dot11txpn.val);
+			pnh=(u32)(dot11txpn.val>>16);
+
+			phase1((u16 *)&ttkey[0],prwskey,&prxattrib->ta[0],pnh);
+			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);	
+
+			//4 decrypt payload include icv
+					
+			arcfour_init(&mycontext, rc4key,16);
+			arcfour_encrypt(&mycontext, payload, payload, length);
+
+			*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length-4));
+			if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4]){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
+						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
+				res=_FAIL;
+			}
+						
+		
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("tkip_decrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+exit:
+_func_exit_;	
+	return res;
+				
+}
+
+
+//3			=====AES related=====
+
+
+
+#define MAX_MSG_SIZE	2048
+/*****************************/
+/******** SBOX Table *********/
+/*****************************/
+
+    u8 sbox_table[256] =
+    {
+        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+    };
+
+/*****************************/
+/**** Function Prototypes ****/
+/*****************************/
+
+void bitwise_xor(u8 *ina, u8 *inb, u8 *out);
+void construct_mic_iv(
+                        u8 *mic_header1,
+                        sint qc_exists,
+                        sint a4_exists,
+                        u8 *mpdu,
+                        uint payload_length,
+                        u8 * pn_vector);
+void construct_mic_header1(
+                        u8 *mic_header1,
+                        sint header_length,
+                        u8 *mpdu);
+void construct_mic_header2(
+                    u8 *mic_header2,
+                    u8 *mpdu,
+                    sint a4_exists,
+                    sint qc_exists);
+void construct_ctr_preload(
+                        u8 *ctr_preload,
+                        sint a4_exists,
+                        sint qc_exists,
+                        u8 *mpdu,
+                        u8 *pn_vector,
+                        sint c);
+void xor_128(u8 *a, u8 *b, u8 *out);
+void xor_32(u8 *a, u8 *b, u8 *out);
+u8 sbox(u8 a);
+void next_key(u8 *key, sint round);
+void byte_sub(u8 *in, u8 *out);
+void shift_row(u8 *in, u8 *out);
+void mix_column(u8 *in, u8 *out);
+void add_round_key( u8 *shiftrow_in,
+                    u8 *mcol_in,
+                    u8 *block_in,
+                    sint round,
+                    u8 *out);
+void aes128k128d(u8 *key, u8 *data, u8 *ciphertext);
+
+
+/****************************************/
+/* aes128k128d()                        */
+/* Performs a 128 bit AES encrypt with  */
+/* 128 bit data.                        */
+/****************************************/
+void xor_128(u8 *a, u8 *b, u8 *out)
+{
+    sint i;
+_func_enter_;	
+    for (i=0;i<16; i++)
+    {
+        out[i] = a[i] ^ b[i];
+    }
+_func_exit_;		
+}
+
+
+void xor_32(u8 *a, u8 *b, u8 *out)
+{
+    sint i;
+_func_enter_;		
+    for (i=0;i<4; i++)
+    {
+        out[i] = a[i] ^ b[i];
+    }
+_func_exit_;		
+}
+
+
+u8 sbox(u8 a)
+{
+    return sbox_table[(sint)a];
+}
+
+
+void next_key(u8 *key, sint round)
+{
+    u8 rcon;
+    u8 sbox_key[4];
+    u8 rcon_table[12] =
+    {
+        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+        0x1b, 0x36, 0x36, 0x36
+    };
+_func_enter_;		
+    sbox_key[0] = sbox(key[13]);
+    sbox_key[1] = sbox(key[14]);
+    sbox_key[2] = sbox(key[15]);
+    sbox_key[3] = sbox(key[12]);
+
+    rcon = rcon_table[round];
+
+    xor_32(&key[0], sbox_key, &key[0]);
+    key[0] = key[0] ^ rcon;
+
+    xor_32(&key[4], &key[0], &key[4]);
+    xor_32(&key[8], &key[4], &key[8]);
+    xor_32(&key[12], &key[8], &key[12]);
+_func_exit_;		
+}
+
+
+void byte_sub(u8 *in, u8 *out)
+{
+    sint i;
+_func_enter_;			
+    for (i=0; i< 16; i++)
+    {
+        out[i] = sbox(in[i]);
+    }
+_func_exit_;	
+}
+
+
+void shift_row(u8 *in, u8 *out)
+{
+_func_enter_;	
+    out[0] =  in[0];
+    out[1] =  in[5];
+    out[2] =  in[10];
+    out[3] =  in[15];
+    out[4] =  in[4];
+    out[5] =  in[9];
+    out[6] =  in[14];
+    out[7] =  in[3];
+    out[8] =  in[8];
+    out[9] =  in[13];
+    out[10] = in[2];
+    out[11] = in[7];
+    out[12] = in[12];
+    out[13] = in[1];
+    out[14] = in[6];
+    out[15] = in[11];
+_func_exit_;		
+}
+
+
+void mix_column(u8 *in, u8 *out)
+{
+    sint i;
+    u8 add1b[4];
+    u8 add1bf7[4];
+    u8 rotl[4];
+    u8 swap_halfs[4];
+    u8 andf7[4];
+    u8 rotr[4];
+    u8 temp[4];
+    u8 tempb[4];
+_func_enter_;	
+    for (i=0 ; i<4; i++)
+    {
+        if ((in[i] & 0x80)== 0x80)
+            add1b[i] = 0x1b;
+        else
+            add1b[i] = 0x00;
+    }
+
+    swap_halfs[0] = in[2];    /* Swap halfs */
+    swap_halfs[1] = in[3];
+    swap_halfs[2] = in[0];
+    swap_halfs[3] = in[1];
+
+    rotl[0] = in[3];        /* Rotate left 8 bits */
+    rotl[1] = in[0];
+    rotl[2] = in[1];
+    rotl[3] = in[2];
+
+    andf7[0] = in[0] & 0x7f;
+    andf7[1] = in[1] & 0x7f;
+    andf7[2] = in[2] & 0x7f;
+    andf7[3] = in[3] & 0x7f;
+
+    for (i = 3; i>0; i--)    /* logical shift left 1 bit */
+    {
+        andf7[i] = andf7[i] << 1;
+        if ((andf7[i-1] & 0x80) == 0x80)
+        {
+            andf7[i] = (andf7[i] | 0x01);
+        }
+    }
+    andf7[0] = andf7[0] << 1;
+    andf7[0] = andf7[0] & 0xfe;
+
+    xor_32(add1b, andf7, add1bf7);
+
+    xor_32(in, add1bf7, rotr);
+
+    temp[0] = rotr[0];         /* Rotate right 8 bits */
+    rotr[0] = rotr[1];
+    rotr[1] = rotr[2];
+    rotr[2] = rotr[3];
+    rotr[3] = temp[0];
+
+    xor_32(add1bf7, rotr, temp);
+    xor_32(swap_halfs, rotl,tempb);
+    xor_32(temp, tempb, out);
+_func_exit_;		
+}
+
+
+void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
+{
+    sint round;
+    sint i;
+    u8 intermediatea[16];
+    u8 intermediateb[16];
+    u8 round_key[16];
+_func_enter_;	
+    for(i=0; i<16; i++) round_key[i] = key[i];
+
+    for (round = 0; round < 11; round++)
+    {
+        if (round == 0)
+        {
+            xor_128(round_key, data, ciphertext);
+            next_key(round_key, round);
+        }
+        else if (round == 10)
+        {
+            byte_sub(ciphertext, intermediatea);
+            shift_row(intermediatea, intermediateb);
+            xor_128(intermediateb, round_key, ciphertext);
+        }
+        else    /* 1 - 9 */
+        {
+            byte_sub(ciphertext, intermediatea);
+            shift_row(intermediatea, intermediateb);
+            mix_column(&intermediateb[0], &intermediatea[0]);
+            mix_column(&intermediateb[4], &intermediatea[4]);
+            mix_column(&intermediateb[8], &intermediatea[8]);
+            mix_column(&intermediateb[12], &intermediatea[12]);
+            xor_128(intermediatea, round_key, ciphertext);
+            next_key(round_key, round);
+        }
+    }
+_func_exit_;	
+}
+
+
+/************************************************/
+/* construct_mic_iv()                           */
+/* Builds the MIC IV from header fields and PN  */
+/************************************************/
+void construct_mic_iv(
+                        u8 *mic_iv,
+                        sint qc_exists,
+                        sint a4_exists,
+                        u8 *mpdu,
+                        uint payload_length,
+                        u8 *pn_vector
+                        )
+{
+    sint i;
+_func_enter_;	
+    mic_iv[0] = 0x59;
+    if (qc_exists && a4_exists) mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
+    if (qc_exists && !a4_exists) mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
+    if (!qc_exists) mic_iv[1] = 0x00;
+    for (i = 2; i < 8; i++)
+        mic_iv[i] = mpdu[i + 8];                    /* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
+    #ifdef CONSISTENT_PN_ORDER
+        for (i = 8; i < 14; i++)
+            mic_iv[i] = pn_vector[i - 8];           /* mic_iv[8:13] = PN[0:5] */
+    #else
+        for (i = 8; i < 14; i++)
+            mic_iv[i] = pn_vector[13 - i];          /* mic_iv[8:13] = PN[5:0] */
+    #endif
+    mic_iv[14] = (unsigned char) (payload_length / 256);
+    mic_iv[15] = (unsigned char) (payload_length % 256);
+_func_exit_;		
+}
+
+
+/************************************************/
+/* construct_mic_header1()                      */
+/* Builds the first MIC header block from       */
+/* header fields.                               */
+/************************************************/
+void construct_mic_header1(
+                        u8 *mic_header1,
+                        sint header_length,
+                        u8 *mpdu
+                        )
+{
+_func_enter_;	
+    mic_header1[0] = (u8)((header_length - 2) / 256);
+    mic_header1[1] = (u8)((header_length - 2) % 256);
+    mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
+    mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
+    mic_header1[4] = mpdu[4];       /* A1 */
+    mic_header1[5] = mpdu[5];
+    mic_header1[6] = mpdu[6];
+    mic_header1[7] = mpdu[7];
+    mic_header1[8] = mpdu[8];
+    mic_header1[9] = mpdu[9];
+    mic_header1[10] = mpdu[10];     /* A2 */
+    mic_header1[11] = mpdu[11];
+    mic_header1[12] = mpdu[12];
+    mic_header1[13] = mpdu[13];
+    mic_header1[14] = mpdu[14];
+    mic_header1[15] = mpdu[15];
+_func_exit_;	
+}
+
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+void construct_mic_header2(
+                u8 *mic_header2,
+                u8 *mpdu,
+                sint a4_exists,
+                sint qc_exists
+                )
+{
+    sint i;
+_func_enter_;	
+    for (i = 0; i<16; i++) mic_header2[i]=0x00;
+
+    mic_header2[0] = mpdu[16];    /* A3 */
+    mic_header2[1] = mpdu[17];
+    mic_header2[2] = mpdu[18];
+    mic_header2[3] = mpdu[19];
+    mic_header2[4] = mpdu[20];
+    mic_header2[5] = mpdu[21];
+
+    //mic_header2[6] = mpdu[22] & 0xf0;   /* SC */
+    mic_header2[6] = 0x00;
+    mic_header2[7] = 0x00; /* mpdu[23]; */
+
+
+    if (!qc_exists && a4_exists)
+    {
+        for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+
+    }
+
+    if (qc_exists && !a4_exists)
+    {
+        mic_header2[8] = mpdu[24] & 0x0f; /* mute bits 15 - 4 */
+        mic_header2[9] = mpdu[25] & 0x00;
+    }
+
+    if (qc_exists && a4_exists)
+    {
+        for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+
+        mic_header2[14] = mpdu[30] & 0x0f;
+        mic_header2[15] = mpdu[31] & 0x00;
+    }
+
+_func_exit_;	
+}
+
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+void construct_ctr_preload(
+                        u8 *ctr_preload,
+                        sint a4_exists,
+                        sint qc_exists,
+                        u8 *mpdu,
+                        u8 *pn_vector,
+                        sint c
+                        )
+{
+    sint i = 0;
+_func_enter_;		
+    for (i=0; i<16; i++) ctr_preload[i] = 0x00;
+    i = 0;
+
+    ctr_preload[0] = 0x01;                                  /* flag */
+    if (qc_exists && a4_exists) 
+		ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control */
+    if (qc_exists && !a4_exists) 
+		ctr_preload[1] = mpdu[24] & 0x0f;
+
+    for (i = 2; i < 8; i++)
+        ctr_preload[i] = mpdu[i + 8];                       /* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
+    #ifdef CONSISTENT_PN_ORDER
+      for (i = 8; i < 14; i++)
+            ctr_preload[i] =    pn_vector[i - 8];           /* ctr_preload[8:13] = PN[0:5] */
+    #else
+      for (i = 8; i < 14; i++)
+            ctr_preload[i] =    pn_vector[13 - i];          /* ctr_preload[8:13] = PN[5:0] */
+    #endif
+    ctr_preload[14] =  (unsigned char) (c / 256); /* Ctr */
+    ctr_preload[15] =  (unsigned char) (c % 256);
+_func_exit_;		
+}
+
+
+/************************************/
+/* bitwise_xor()                    */
+/* A 128 bit, bitwise exclusive or  */
+/************************************/
+void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
+{
+    sint i;
+_func_enter_;		
+    for (i=0; i<16; i++)
+    {
+        out[i] = ina[i] ^ inb[i];
+    }
+_func_exit_;		
+}
+
+
+sint aes_cipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+//	/*static*/ unsigned char	message[MAX_MSG_SIZE];
+	uint	qc_exists, a4_exists, i, j, payload_remainder,
+		num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+//	uint	offset = 0;
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+	
+_func_enter_;		
+	frsubtype=frsubtype>>4;
+
+
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if (
+		(frtype == WIFI_DATA_CFACK) ||
+		(frtype == WIFI_DATA_CFPOLL)||
+		(frtype == WIFI_DATA_CFACKPOLL))
+		{
+			qc_exists = 1;
+					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+		}
+	else if (
+		(frsubtype == 0x08) ||
+		(frsubtype == 0x09)||
+		(frsubtype == 0x0a)||
+		(frsubtype == 0x0b))
+		{
+			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+			qc_exists = 1;
+		}
+	else
+		qc_exists = 0;
+
+	pn_vector[0]=pframe[hdrlen];
+	pn_vector[1]=pframe[hdrlen+1];
+	pn_vector[2]=pframe[hdrlen+4];
+	pn_vector[3]=pframe[hdrlen+5];
+	pn_vector[4]=pframe[hdrlen+6];
+	pn_vector[5]=pframe[hdrlen+7];
+	
+	construct_mic_iv(
+                        mic_iv,
+                        qc_exists,
+                        a4_exists,
+                        pframe,	 //message,
+                        plen,
+                        pn_vector
+                        );
+
+    construct_mic_header1(
+                            mic_header1,
+                            hdrlen,
+                            pframe	//message
+                            );
+    construct_mic_header2(
+                            mic_header2,
+                            pframe,	//message,
+                            a4_exists,
+                            qc_exists
+                            );
+
+
+	payload_remainder = plen % 16;
+    num_blocks = plen / 16;
+
+    /* Find start of payload */
+    payload_index = (hdrlen + 8);
+
+    /* Calculate MIC */
+    aes128k128d(key, mic_iv, aes_out);
+    bitwise_xor(aes_out, mic_header1, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+    bitwise_xor(aes_out, mic_header2, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++)
+    {
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+        payload_index += 16;
+        aes128k128d(key, chain_buffer, aes_out);
+    }
+
+    /* Add on the final payload block if it needs padding */
+    if (payload_remainder > 0)
+    {
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index++];//padded_buffer[j] = message[payload_index++];
+        }
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        aes128k128d(key, chain_buffer, aes_out);
+
+    }
+
+    for (j = 0 ; j < 8; j++) mic[j] = aes_out[j];
+
+    /* Insert MIC into payload */
+    for (j = 0; j < 8; j++)
+    	pframe[payload_index+j] = mic[j];	//message[payload_index+j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,	//message,
+                                pn_vector,
+                                i+1);
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,	//message,
+                                pn_vector,
+                                num_blocks+1);
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index+j];//padded_buffer[j] = message[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    /* Encrypt the MIC */
+    construct_ctr_preload(
+                        ctr_preload,
+                        a4_exists,
+                        qc_exists,
+                        pframe,	//message,
+                        pn_vector,
+                        0);
+
+    for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+    for (j = 0; j < 8; j++)
+    {
+        padded_buffer[j] = pframe[j+hdrlen+8+plen];//padded_buffer[j] = message[j+hdrlen+8+plen];
+    }
+
+    aes128k128d(key, ctr_preload, aes_out);
+    bitwise_xor(aes_out, padded_buffer, chain_buffer);
+    for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+_func_exit_;		
+	return _SUCCESS;
+}
+
+
+
+
+u32	aes_encrypt(_adapter *padapter, u8 *pxmitframe)
+{	// exclude ICV
+
+
+	/*static*/ 
+//	unsigned char	message[MAX_MSG_SIZE];
+
+    	/* Intermediate Buffers */
+	sint 	curfragnum,length;
+	u32	prwskeylen;
+	u8	*pframe,*prwskey;	//, *payload,*iv
+	struct	sta_info		*stainfo;
+	struct	pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+//	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+
+//	uint	offset = 0;
+	u32 res=_SUCCESS;
+_func_enter_;		
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return _FAIL;
+
+	//pframe=(u8*)(((struct xmit_frame*)pxmitframe)->mem) + WLANHDR_OFFSET + TXDESC_OFFSET;
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr+TXDESC_OFFSET;
+
+	//4 start to encrypt each fragment
+	if((pattrib->encrypt==_AES_)){
+
+		if(pattrib->psta)
+		{
+			stainfo = pattrib->psta;
+		}
+		else
+		{
+		stainfo=get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
+		}	
+		
+		if (stainfo!=NULL){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_encrypt: stainfo!=NULL!!!\n"));
+			prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			prwskeylen=16;
+	
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+			
+				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+				
+					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+				
+					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
+				pframe+=pxmitpriv->frag_len;
+				pframe=(u8*)RND4((uint)(pframe));
+
+				}
+			}
+
+
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_encrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+
+
+
+_func_exit_;
+		return res;
+}
+
+sint aes_decipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+	static u8	message[MAX_MSG_SIZE];
+	uint	qc_exists, a4_exists, i, j, payload_remainder,
+			num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+    /* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+
+
+//	uint	offset = 0;
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+_func_enter_;			
+	frsubtype=frsubtype>>4;
+
+
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	//start to decrypt the payload
+
+	num_blocks = (plen-8) / 16; //(plen including llc, payload_length and mic )
+
+	payload_remainder = (plen-8) % 16;
+
+	pn_vector[0]  = pframe[hdrlen];
+	pn_vector[1]  = pframe[hdrlen+1];
+	pn_vector[2]  = pframe[hdrlen+4];
+	pn_vector[3]  = pframe[hdrlen+5];
+	pn_vector[4]  = pframe[hdrlen+6];
+	pn_vector[5]  = pframe[hdrlen+7];
+
+	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if (
+		(frtype == WIFI_DATA_CFACK) ||
+		(frtype == WIFI_DATA_CFPOLL)||
+		(frtype == WIFI_DATA_CFACKPOLL))
+		{
+			qc_exists = 1;
+					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+		}
+	else if (
+		(frsubtype == 0x08) ||
+		(frsubtype == 0x09)||
+		(frsubtype == 0x0a)||
+		(frsubtype == 0x0b))
+		{
+			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+			qc_exists = 1;
+		}
+	else
+		qc_exists = 0;
+
+
+	// now, decrypt pframe with hdrlen offset and plen long
+
+	payload_index = hdrlen + 8; // 8 is for extiv
+	
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,
+                                pn_vector,
+                                i+1
+                            );
+
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,
+                                pn_vector,
+                                num_blocks+1
+                            );
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];
+    }
+
+	//start to calculate the mic	
+
+	memcpy((void *)message, pframe, (hdrlen +plen+8)); //8 is for ext iv len
+
+
+	pn_vector[0]=pframe[hdrlen];
+	pn_vector[1]=pframe[hdrlen+1];
+	pn_vector[2]=pframe[hdrlen+4];
+	pn_vector[3]=pframe[hdrlen+5];
+	pn_vector[4]=pframe[hdrlen+6];
+	pn_vector[5]=pframe[hdrlen+7];
+
+
+	
+	construct_mic_iv(
+                        mic_iv,
+                        qc_exists,
+                        a4_exists,
+                        message,
+                        plen-8,
+                        pn_vector
+                        );
+
+    construct_mic_header1(
+                            mic_header1,
+                            hdrlen,
+                            message
+                            );
+    construct_mic_header2(
+                            mic_header2,
+                            message,
+                            a4_exists,
+                            qc_exists
+                            );
+
+
+	payload_remainder = (plen-8) % 16;
+    num_blocks = (plen-8) / 16;
+
+    /* Find start of payload */
+    payload_index = (hdrlen + 8);
+
+    /* Calculate MIC */
+    aes128k128d(key, mic_iv, aes_out);
+    bitwise_xor(aes_out, mic_header1, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+    bitwise_xor(aes_out, mic_header2, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++)
+    {
+        bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+        payload_index += 16;
+        aes128k128d(key, chain_buffer, aes_out);
+    }
+
+    /* Add on the final payload block if it needs padding */
+    if (payload_remainder > 0)
+    {
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = message[payload_index++];
+        }
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        aes128k128d(key, chain_buffer, aes_out);
+
+    }
+
+    for (j = 0 ; j < 8; j++) mic[j] = aes_out[j];
+
+    /* Insert MIC into payload */
+    for (j = 0; j < 8; j++)
+    	message[payload_index+j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                message,
+                                pn_vector,
+                                i+1);
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                message,
+                                pn_vector,
+                                num_blocks+1);
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = message[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    /* Encrypt the MIC */
+    construct_ctr_preload(
+                        ctr_preload,
+                        a4_exists,
+                        qc_exists,
+                        message,
+                        pn_vector,
+                        0);
+
+    for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+    for (j = 0; j < 8; j++)
+    {
+        padded_buffer[j] = message[j+hdrlen+8+plen-8];
+    }
+
+    aes128k128d(key, ctr_preload, aes_out);
+    bitwise_xor(aes_out, padded_buffer, chain_buffer);
+    for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+
+	//compare the mic
+	for(i=0;i<8;i++){
+		if(pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x) \n",
+						i,pframe[hdrlen+8+plen-8+i],message[hdrlen+8+plen-8+i]));
+	}
+_func_exit_;	
+	return _SUCCESS;
+}
+
+u32	aes_decrypt(_adapter *padapter, u8 *precvframe)
+{	// exclude ICV
+
+
+	/*static*/ 
+//	unsigned char	message[MAX_MSG_SIZE];
+
+
+    	/* Intermediate Buffers */
+
+
+	sint 		length;
+	u32	prwskeylen;
+	u8	*pframe,*prwskey,*iv,idx;	//, *payload,*iv
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	 *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+//	struct	recv_priv		*precvpriv=&padapter->recvpriv;
+	u32	res=_SUCCESS;
+_func_enter_;	 
+	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
+	//4 start to encrypt each fragment
+	if((prxattrib->encrypt==_AES_)){
+
+		stainfo=get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
+		if (stainfo!=NULL){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_decrypt: stainfo!=NULL!!!\n"));
+			if(IS_MCAST(prxattrib->ra)){
+				iv=pframe+prxattrib->hdrlen;
+				idx=iv[3];
+				prwskey=&psecuritypriv->dot118021XGrpKey[( (idx>>6)&0x3 )-1].skey[0];
+				if((( (idx>>6)&0x3 )-1)!= psecuritypriv->dot118021XGrpKeyid ){
+					RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("\n tkip_decrypt: bcmc key  psecuritypriv->dot118021XGrpKeyid =%x, idx in frame iv is %x  \n",psecuritypriv->dot118021XGrpKeyid,idx ));
+
+				}
+				RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("\n tkip_decrypt: bcmc key \n"));
+				if(psecuritypriv->binstallGrpkey==_FALSE){
+					res=_FAIL;
+					RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("\n tkip_decrypt:didn't install group key!!!!!!!!!!\n"));
+					goto exit;
+				}
+
+			}
+			else{
+				RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("tkip_decrypt: stainfo!=NULL!!!\n"));
+				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			}
+			prwskeylen=16;
+	
+			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+				
+			aes_decipher(prwskey,prxattrib->hdrlen,pframe, length);
+
+
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_encrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+exit:
+_func_exit_;		
+	return res;
+}
+
+
+
+#ifdef PLATFORM_WINDOWS
+void use_tkipkey_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	)
+#endif
+#ifdef PLATFORM_LINUX
+void use_tkipkey_handler(void *FunctionContext)
+#endif
+{
+        _adapter *padapter = (_adapter *)FunctionContext;
+
+
+_func_enter_;			
+
+	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^use_tkipkey_handler ^^^\n"));
+	
+/*
+	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^use_tkipkey_handler (padapter->bDriverStopped %d)(padapter->bSurpriseRemoved %d)^^^\n",padapter->bDriverStopped,padapter->bSurpriseRemoved));
+
+		return;
+	}
+	*/
+	
+	padapter->securitypriv.busetkipkey=_TRUE;
+
+	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
+
+_func_exit_;	
+
+}
+
diff --git a/drivers/net/wireless/8712u/debug/rtl871x_debug.c b/drivers/net/wireless/8712u/debug/rtl871x_debug.c
new file mode 100755
index 0000000..cadae0f
--- /dev/null
+++ b/drivers/net/wireless/8712u/debug/rtl871x_debug.c
@@ -0,0 +1,66 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#define _RTL871X_DEBUG_C_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+		
+#ifdef CONFIG_DEBUG_RTL871X
+
+	u32 GlobalDebugLevel = _drv_info_;
+
+	u64 GlobalDebugComponents	= \
+			_module_rtl871x_xmit_c_ |
+			_module_xmit_osdep_c_ 	|
+			_module_rtl871x_recv_c_ |
+			_module_recv_osdep_c_ 	|
+			_module_rtl871x_mlme_c_ |
+			_module_mlme_osdep_c_ 	|
+			_module_rtl871x_sta_mgt_c_ |
+			_module_rtl871x_cmd_c_ 	|
+			_module_cmd_osdep_c_ 	|
+			_module_rtl871x_io_c_   | 
+			_module_io_osdep_c_ 	|
+			_module_os_intfs_c_|
+			_module_rtl871x_security_c_|
+			_module_rtl871x_eeprom_c_|
+			_module_hal_init_c_|
+			_module_hci_hal_init_c_|
+			_module_rtl871x_ioctl_c_|
+			_module_rtl871x_ioctl_set_c_|
+			_module_rtl871x_ioctl_query_c_|
+			_module_rtl871x_pwrctrl_c_|
+			_module_hci_intfs_c_|
+			_module_hci_ops_c_|
+			_module_rtl871x_mp_ioctl_c_|
+			_module_hci_ops_os_c_|
+			_module_rtl871x_ioctl_os_c|
+			_module_rtl871x_mp_c_ |		
+			_module_rtl8712_cmd_c_|		
+			_module_rtl8712_xmit_c_|
+			_module_rtl8712_efuse_c_|
+			_module_rtl8712_recv_c_;
+
+									
+#endif
+
diff --git a/drivers/net/wireless/8712u/eeprom/rtl871x_eeprom.c b/drivers/net/wireless/8712u/eeprom/rtl871x_eeprom.c
new file mode 100755
index 0000000..a948e67
--- /dev/null
+++ b/drivers/net/wireless/8712u/eeprom/rtl871x_eeprom.c
@@ -0,0 +1,423 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_EEPROM_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+void up_clk(_adapter*	padapter,	 u16 *x)
+{
+_func_enter_;
+	*x = *x | _EESK;
+	write8(padapter, EE_9346CR, (u8)*x);
+	udelay_os(CLOCK_RATE);
+
+_func_exit_;
+	
+}
+
+void down_clk(_adapter *	padapter, u16 *x	)
+{
+_func_enter_;
+	*x = *x & ~_EESK;
+	write8(padapter, EE_9346CR, (u8)*x);
+	udelay_os(CLOCK_RATE);
+_func_exit_;	
+}
+
+void shift_out_bits(_adapter * padapter, u16 data, u16 count)
+{
+	u16 x,mask;
+_func_enter_;
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	mask = 0x01 << (count - 1);
+	x = read8(padapter, EE_9346CR);
+
+	x &= ~(_EEDO | _EEDI);
+
+	do
+	{
+		x &= ~_EEDI;
+		if(data & mask)
+			x |= _EEDI;
+		if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+		}
+		write8(padapter, EE_9346CR, (u8)x);
+		udelay_os(CLOCK_RATE);
+		up_clk(padapter, &x);
+		down_clk(padapter, &x);
+		mask = mask >> 1;
+	} while(mask);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x &= ~_EEDI;
+	write8(padapter, EE_9346CR, (u8)x);
+out:	
+_func_exit_;		
+}
+
+u16 shift_in_bits (_adapter * padapter)
+{
+	u16 x,d=0,i;
+_func_enter_;	
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x = read8(padapter, EE_9346CR);
+
+	x &= ~( _EEDO | _EEDI);
+	d = 0;
+
+	for(i=0; i<16; i++)
+	{
+		d = d << 1;
+		up_clk(padapter, &x);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+		x = read8(padapter, EE_9346CR);
+
+		x &= ~(_EEDI);
+		if(x & _EEDO)
+		d |= 1;
+
+		down_clk(padapter, &x);
+	}
+out:	
+_func_exit_;		
+
+	return d;
+}
+
+void standby(_adapter *	padapter	)
+{
+	u8   x;
+_func_enter_;	
+	x = read8(padapter, EE_9346CR);
+
+	x &= ~(_EECS | _EESK);
+	write8(padapter, EE_9346CR,x);
+
+	udelay_os(CLOCK_RATE);
+	x |= _EECS;
+	write8(padapter, EE_9346CR, x);
+	udelay_os(CLOCK_RATE);
+_func_exit_;		
+}
+
+u16 wait_eeprom_cmd_done(_adapter* padapter)
+{
+	u8 	x;
+	u16	i,res=_FALSE;
+_func_enter_;	
+	standby(padapter );
+	for (i=0; i<200; i++) 
+	{
+		x = read8(padapter, EE_9346CR);
+		if (x & _EEDO){
+			res=_TRUE;
+			goto exit;
+			}
+		udelay_os(CLOCK_RATE);
+	}
+exit:	
+_func_exit_;			
+	return res;
+}
+
+void eeprom_clean(_adapter * padapter)
+{
+	u16 x;
+_func_enter_;		
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x = read8(padapter, EE_9346CR);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x &= ~(_EECS | _EEDI);
+	write8(padapter, EE_9346CR, (u8)x);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	up_clk(padapter, &x);
+		if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	down_clk(padapter, &x);
+out:	
+_func_exit_;			
+}
+
+void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
+{
+	u8 x;
+	#ifdef CONFIG_RTL8712
+	u8	tmp8_ori,tmp8_new,tmp8_clk_ori,tmp8_clk_new;
+	tmp8_ori=read8(padapter, 0x102502f1);
+	tmp8_new=tmp8_ori & 0xf7;
+	if(tmp8_ori != tmp8_new){	
+		write8(padapter, 0x102502f1, tmp8_new);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x102502f1=====\n"));
+	}
+	tmp8_clk_ori=read8(padapter,0x10250003);
+	tmp8_clk_new=tmp8_clk_ori|0x20;
+	if(tmp8_clk_new!=tmp8_clk_ori){
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x10250003=====\n"));
+		write8(padapter, 0x10250003, tmp8_clk_new);
+	}	
+#endif
+_func_enter_;		
+	
+	x = read8(padapter, EE_9346CR);
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	write8(padapter, EE_9346CR, x);
+
+	shift_out_bits(padapter, EEPROM_EWEN_OPCODE, 5);
+	
+	if(padapter->EepromAddressSize==8)	//CF+ and SDIO
+		shift_out_bits(padapter, 0, 6);
+	else									//USB
+		shift_out_bits(padapter, 0, 4);
+	
+	standby( padapter);
+
+// Commented out by rcnjko, 2004.0
+//	// Erase this particular word.  Write the erase opcode and register
+//	// number in that order. The opcode is 3bits in length; reg is 6 bits long.
+//	shift_out_bits(Adapter, EEPROM_ERASE_OPCODE, 3);
+//	shift_out_bits(Adapter, reg, Adapter->EepromAddressSize);
+//
+//	if (wait_eeprom_cmd_done(Adapter ) == FALSE) 
+//	{
+//		return;
+//	}
+
+
+	standby(padapter );
+
+	// write the new word to the EEPROM
+
+	// send the write opcode the EEPORM
+	shift_out_bits(padapter, EEPROM_WRITE_OPCODE, 3);
+
+	// select which word in the EEPROM that we are writing to.
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+
+	// write the data to the selected EEPROM word.
+	shift_out_bits(padapter, data, 16);
+
+	if (wait_eeprom_cmd_done(padapter ) == _FALSE) 
+	{
+
+		goto exit;
+	}
+
+	standby(padapter );
+
+	shift_out_bits(padapter, EEPROM_EWDS_OPCODE, 5);
+	shift_out_bits(padapter, reg, 4);
+
+	eeprom_clean(padapter );
+exit:	
+	#ifdef CONFIG_RTL8712
+	if(tmp8_clk_new!=tmp8_clk_ori)
+		write8(padapter, 0x10250003, tmp8_clk_ori);
+	if(tmp8_new!=tmp8_ori)
+		write8(padapter, 0x102502f1, tmp8_ori);
+
+	#endif
+_func_exit_;	
+	return;
+}
+
+u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
+{
+
+	u16 x;
+	u16 data=0;
+	#ifdef CONFIG_RTL8712
+	u8	tmp8_ori,tmp8_new,tmp8_clk_ori,tmp8_clk_new;
+	tmp8_ori= read8(padapter, 0x102502f1);
+	tmp8_new = tmp8_ori & 0xf7;
+	if(tmp8_ori != tmp8_new){	
+		write8(padapter, 0x102502f1, tmp8_new);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x102502f1=====\n"));
+	}
+	tmp8_clk_ori=read8(padapter,0x10250003);
+	tmp8_clk_new=tmp8_clk_ori|0x20;
+	if(tmp8_clk_new!=tmp8_clk_ori){
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x10250003=====\n"));
+		write8(padapter, 0x10250003, tmp8_clk_new);
+	}	
+	#endif
+_func_enter_;		
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	// select EEPROM, reset bits, set _EECS
+	x = read8(padapter, EE_9346CR);
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	write8(padapter, EE_9346CR, (unsigned char)x);
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+
+	// Now read the data (16 bits) in from the selected EEPROM word
+	data = shift_in_bits(padapter);
+
+	eeprom_clean(padapter);
+out:	
+	#ifdef CONFIG_RTL8712
+	if(tmp8_clk_new!=tmp8_clk_ori)
+		write8(padapter, 0x10250003, tmp8_clk_ori);
+	if(tmp8_new!=tmp8_ori)
+		write8(padapter, 0x102502f1, tmp8_ori);
+
+	#endif
+_func_exit_;		
+	return data;
+
+
+}
+
+
+
+
+//From even offset
+void eeprom_read_sz(_adapter * padapter, u16 reg, u8* data, u32 sz) 
+{
+
+	u16 x, data16;
+	u32 i;
+_func_enter_;		
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	// select EEPROM, reset bits, set _EECS
+	x = read8(padapter, EE_9346CR);
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	write8(padapter, EE_9346CR, (unsigned char)x);
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+
+
+	for(i=0; i<sz; i+=2)
+	{
+		data16 = shift_in_bits(padapter);
+		data[i] = data16 & 0xff;
+		data[i+1] = data16 >>8;		
+	}
+
+	eeprom_clean(padapter);
+out:	
+_func_exit_;		
+
+
+
+}
+
+
+//addr_off : address offset of the entry in eeprom (not the tuple number of eeprom (reg); that is addr_off !=reg)
+u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
+{
+	u8 quotient, remainder, addr_2align_odd;
+	u16 reg, stmp , i=0, idx = 0;
+_func_enter_;		
+	reg = (u16)(addr_off >> 1);
+	addr_2align_odd = (u8)(addr_off & 0x1);
+
+	if(addr_2align_odd) //read that start at high part: e.g  1,3,5,7,9,...
+	{
+		stmp = eeprom_read16(padapter, reg);
+		rbuf[idx++] = (u8) ((stmp>>8)&0xff); //return hogh-part of the short
+		reg++; sz--;
+	}
+	
+	quotient = sz >> 1;
+	remainder = sz & 0x1;
+
+	for( i=0 ; i < quotient; i++)
+	{
+		stmp = eeprom_read16(padapter, reg+i);
+		rbuf[idx++] = (u8) (stmp&0xff);
+		rbuf[idx++] = (u8) ((stmp>>8)&0xff);
+	}
+	
+	reg = reg+i;
+	if(remainder){ //end of read at lower part of short : 0,2,4,6,...
+		stmp = eeprom_read16(padapter, reg);
+		rbuf[idx] = (u8)(stmp & 0xff); 
+	}
+_func_exit_;		
+	return _TRUE;
+}
+
+
+
+VOID read_eeprom_content(_adapter *	padapter	)
+{
+
+_func_enter_;		
+
+
+_func_exit_;		
+}
+
diff --git a/drivers/net/wireless/8712u/efuse/rtl8712_efuse.c b/drivers/net/wireless/8712u/efuse/rtl8712_efuse.c
new file mode 100755
index 0000000..ac1956b
--- /dev/null
+++ b/drivers/net/wireless/8712u/efuse/rtl8712_efuse.c
@@ -0,0 +1,976 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL8712_EFUSE_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <rtl8712_efuse.h>
+//------------------------------------------------------------------------------
+//#define _PRE_EXECUTE_READ_CMD_
+#if 0
+#define PG_STATE_HEADER 	0x01
+#define PG_STATE_DATA		0x20
+#endif
+//------------------------------------------------------------------------------
+static int EFUSE_AVAILABLE_MAX_SIZE = EFUSE_MAX_SIZE - 3/*0x1FD*/; //reserve 3 bytes for HW stop read
+//------------------------------------------------------------------------------
+static void efuse_reg_ctrl(_adapter *padapter, u8 bPowerOn)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8 tmpu8 = 0;
+
+	if (_TRUE == bPowerOn)
+	{
+#if 0
+		// -----------------SYS_FUNC_EN Digital Core Vdd enable ---------------------------------
+		tmpu8 = read8(padapter, SYS_FUNC_EN + 1);
+		if (!(tmpu8 & 0x20)) {
+			tmpu8 |= 0x20;	// Loader Power Enable
+			write8(padapter, SYS_FUNC_EN + 1, tmpu8); // PWC_DV2LDR, 10250002:13
+			msleep_os(10);
+		}
+
+		//EE Loader to Retention path1: attach 0x1[0]=0
+		tmpu8 = read8(padapter, SYS_ISO_CTRL + 1);
+		if (tmpu8 & 0x01) {
+			tmpu8 &= 0xFE;
+			write8(padapter, SYS_ISO_CTRL + 1, tmpu8); // iso_LDR2RP, 10250000:8
+		}
+#endif
+
+		// -----------------e-fuse pwr & clk reg ctrl ---------------------------------
+		// Enable LDOE25 Macro Block
+		tmpu8 = read8(padapter, EFUSE_TEST + 3);
+		tmpu8 |= 0x80;
+		write8(padapter, EFUSE_TEST + 3, tmpu8);// 2.5v LDO, LDOE25_EN, 10250034:31
+		mdelay_os(1);//for some platform , need some delay time
+		// Change Efuse Clock for write action to 40MHZ
+		//write8(padapter, EFUSE_CLK_CTRL, (read8(padapter, EFUSE_CLK_CTRL)|0x03));
+		write8(padapter, EFUSE_CLK_CTRL, 0x03);
+		mdelay_os(10);//for some platform , need some delay time
+
+#ifdef _PRE_EXECUTE_READ_CMD_
+		if (efuse_one_byte_read(padapter, 0, &tmpu8) == _TRUE) {
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_alert_,("efuse_reg_ctrl: read EFuse fail!!\n"));
+		}
+#endif
+	}
+	else {
+		// -----------------e-fuse pwr & clk reg ctrl ---------------------------------
+		// Disable LDOE25 Macro Block
+		tmpu8 = read8(padapter, EFUSE_TEST + 3);
+		tmpu8 &= 0x7F;
+		write8(padapter, EFUSE_TEST + 3, tmpu8);
+
+		// Change Efuse Clock for write action to 500K
+		//write8(padapter, EFUSE_CLK_CTRL, read8(padapter, EFUSE_CLK_CTRL)&0xFE);
+		write8(padapter, EFUSE_CLK_CTRL, 0x02);
+#if 0
+		// -----------------SYS_FUNC_EN Digital Core Vdd disable ---------------------------------
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE) {
+			write8(padapter, SYS_FUNC_EN+1,  read8(padapter,SYS_FUNC_EN+1)&0xDF);
+		}
+#endif
+	}
+}
+
+/*
+ * Before write E-Fuse, this function must be called.
+ */
+u8 efuse_reg_init(_adapter *padapter)
+{
+	//u8 value;
+
+	efuse_reg_ctrl(padapter, _TRUE);
+
+	// check if E-Fuse Clock Enable and E-Fuse Clock is 40M
+	/*value = read8(padapter, EFUSE_CLK_CTRL);
+	if (value != 0x03) {
+		RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_,("EFUSE_CLK_CTRL=0x%2x != 0x03", value));
+		efuse_reg_uninit(padapter);
+		return _FALSE;
+	}*/
+
+	return _TRUE;
+}
+
+void efuse_reg_uninit(_adapter *padapter)
+{
+	efuse_reg_ctrl(padapter, _FALSE);
+}
+//------------------------------------------------------------------------------
+static u8 efuse_one_byte_read(_adapter *padapter, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, bResult;
+
+	// -----------------e-fuse reg ctrl ---------------------------------
+	write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); //address
+	write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) | (read8(padapter, EFUSE_CTRL+2)&0xFC));
+	write8(padapter, EFUSE_CTRL+3, 0x72);//read cmd
+
+	// wait for complete
+	while (!(0x80 & read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+
+	if (tmpidx < 100) {
+		*data = read8(padapter, EFUSE_CTRL);
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_info_,("====Read Efuse addr=0x%x value=0x%x=====\n", addr, *data));
+		bResult = _TRUE;
+	} else {
+		*data = 0xff;
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Read Efuse fail!!! addr=0x%x=====\n", addr));
+		bResult = _FALSE;
+	}
+	return bResult;
+}
+//------------------------------------------------------------------------------
+static u8 efuse_one_byte_write(_adapter *padapter, u16 addr, u8 data)
+{
+	u8 tmpidx = 0, bResult;
+
+	// -----------------e-fuse reg ctrl ---------------------------------
+	write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); //address
+	write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) | (read8(padapter, EFUSE_CTRL+2)&0xFC));
+	write8(padapter, EFUSE_CTRL, data); //data
+	write8(padapter, EFUSE_CTRL+3, 0xF2); //write cmd
+
+	// wait for complete
+	while ((0x80 &  read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+
+	if (tmpidx < 100) {
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_info_,("====Write Efuse addr=0x%x value=0x%x=====\n", addr, data));
+		bResult = _TRUE;
+	} else {
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Write Efuse fail!! addr=0x%x value=0x%x=====\n", addr, data));
+		bResult = _FALSE;
+	}
+
+	return bResult;
+}
+//------------------------------------------------------------------------------
+static u8 efuse_one_byte_rw(_adapter *padapter, u8 bRead, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, tmpv8 = 0, bResult;
+
+	// -----------------e-fuse reg ctrl ---------------------------------
+	write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); //address
+	tmpv8 = ((u8)((addr>>8)&0x03)) | (read8(padapter, EFUSE_CTRL+2)&0xFC);
+	write8(padapter, EFUSE_CTRL+2, tmpv8);
+
+	if (_TRUE == bRead) {
+		write8(padapter, EFUSE_CTRL+3,  0x72);//read cmd
+
+		while (!(0x80 & read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+			tmpidx++;
+
+		if (tmpidx < 100) {
+			*data = read8(padapter, EFUSE_CTRL);
+			bResult = _TRUE;
+		} else {
+			*data = 0;
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Read Efuse Fail!! addr=0x%x =====\n", addr));
+			bResult = _FALSE;
+		}
+	} else {
+		write8(padapter, EFUSE_CTRL, *data);//data
+		write8(padapter, EFUSE_CTRL+3, 0xF2);//write cmd
+
+		while ((0x80 & read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+			tmpidx++;
+
+		if (tmpidx < 100) {
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_info_,("====Write Efuse addr=0x%x value=0x%x =====\n", addr, *data));
+			bResult = _TRUE;
+		} else {
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Write Efuse Fail!! addr =0x%x value=0x%x =====\n", addr, *data));
+			bResult = _FALSE;
+		}
+	}
+
+	return bResult;
+}
+//------------------------------------------------------------------------------
+static u8 efuse_is_empty(_adapter *padapter, u8 *empty)
+{
+	u8 value, ret = _TRUE;
+
+	// read one byte to check if E-Fuse is empty
+	if (efuse_one_byte_rw(padapter, _TRUE, 0, &value) == _TRUE) {
+		if (0xFF == value) *empty = _TRUE;
+		else *empty = _FALSE;
+	} else {
+		// read fail
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_emerg_,
+			("efuse_is_empty: fail!!=====\n"));
+		ret = _FALSE;
+	}
+
+	return ret;
+}
+//------------------------------------------------------------------------------
+void efuse_change_max_size(_adapter *padapter)
+{
+	u16 pre_pg_data_saddr = 0x1FB;
+#if 1
+	u16 i;
+	u16 pre_pg_data_size = 5;
+	u8 pre_pg_data[5];
+
+	for (i = 0; i < pre_pg_data_size; i++)
+		efuse_one_byte_read(padapter, pre_pg_data_saddr+i, &pre_pg_data[i]);
+
+	if ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) && (pre_pg_data[2] == 0x00) &&
+		(pre_pg_data[3] == 0x00) && (pre_pg_data[4] == 0x0C)) {
+		EFUSE_AVAILABLE_MAX_SIZE -= pre_pg_data_size;//0x1F8;
+	}
+#else
+	u8 efuse_data;
+
+	efuse_one_byte_read(padapter, pre_pg_data_saddr,&efuse_data);
+	if(efuse_data != 0xFF){
+		EFUSE_AVAILABLE_MAX_SIZE = 0x1F8; //reserve :3 bytes
+	}
+	RT_TRACE(_module_rtl8712_efuse_c_,_drv_alert_,("efuse_change_max_size , EFUSE_MAX_SIZE = %d\n",EFUSE_AVAILABLE_MAX_SIZE));
+#endif
+
+}
+
+int efuse_get_max_size(_adapter *padapter)
+{
+	return 	EFUSE_AVAILABLE_MAX_SIZE;
+}
+//------------------------------------------------------------------------------
+static u8 calculate_word_cnts(const u8 word_en)
+{
+	u8 word_cnts = 0;
+	u8 word_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en & BIT(word_idx))) word_cnts++; // 0 : write enable
+	}
+	return word_cnts;
+}
+//------------------------------------------------------------------------------
+static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata, u8 *targetdata)
+{
+	u8 tmpindex = 0;
+	u8 word_idx, byte_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en&BIT(word_idx))) {
+			byte_idx = word_idx * 2;
+			targetdata[byte_idx] = sourdata[tmpindex++];
+			targetdata[byte_idx + 1] = sourdata[tmpindex++];
+		}
+	}
+}
+//------------------------------------------------------------------------------
+u16 efuse_get_current_size(_adapter *padapter)
+{
+	int bContinual = _TRUE;
+
+	u16 efuse_addr = 0;
+	u8 hoffset = 0, hworden = 0;
+	u8 efuse_data, word_cnts = 0;
+
+	while (bContinual && efuse_one_byte_read(padapter, efuse_addr, &efuse_data) &&
+	       (efuse_addr < EFUSE_AVAILABLE_MAX_SIZE))
+	{
+		if (efuse_data != 0xFF) {
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			//read next header
+			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
+		} else {
+			bContinual = _FALSE ;
+		}
+	}
+
+	return efuse_addr;
+}
+//------------------------------------------------------------------------------
+u8 efuse_pg_packet_read(_adapter *padapter, u8 offset, u8 *data)
+{
+#if 0
+	u8 ReadState = PG_STATE_HEADER;
+
+	int bContinual = _TRUE;
+#endif
+	u8 hoffset = 0, hworden = 0, word_cnts = 0;
+	u16 efuse_addr = 0;
+	u8 efuse_data;
+
+	u8 tmpidx = 0;
+	u8 tmpdata[PGPKT_DATA_SIZE];
+
+	u8 ret = _TRUE;
+
+
+	if (data == NULL) return _FALSE;
+	if (offset > 0x0f) return _FALSE;
+
+	_memset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);
+#if 1
+	while (efuse_addr < EFUSE_AVAILABLE_MAX_SIZE)
+	{
+		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) == _TRUE)
+		{
+			if (efuse_data == 0xFF) break;
+
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+
+			if (hoffset == offset) {
+				_memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);
+				for (tmpidx = 0; tmpidx < word_cnts*2; tmpidx++) {
+					if (efuse_one_byte_read(padapter, efuse_addr+1+tmpidx, &efuse_data) == _TRUE) {
+						tmpdata[tmpidx] = efuse_data;
+					} else ret = _FALSE;
+				}
+				pgpacket_copy_data(hworden, tmpdata, data);
+			}
+
+			efuse_addr += 1 + (word_cnts*2);
+		} else {
+			ret = _FALSE;
+			break;
+		}
+	}
+#else
+	while (bContinual && (efuse_addr < EFUSE_AVAILABLE_MAX_SIZE))
+	{
+		//-------  Header Read -------------
+		if (ReadState & PG_STATE_HEADER)
+		{
+			if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) && (efuse_data != 0xFF))
+			{
+				hoffset = (efuse_data >> 4) & 0x0F;
+				hworden =  efuse_data & 0x0F;
+				word_cnts = calculate_word_cnts(hworden);
+
+				if (hoffset == offset) {
+					_memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);
+					for (tmpidx = 0; tmpidx < word_cnts*2; tmpidx++) {
+						if (efuse_one_byte_read(padapter, efuse_addr+1+tmpidx, &efuse_data)) {
+							tmpdata[tmpidx] = efuse_data;
+						}
+					}
+					ReadState = PG_STATE_DATA;
+				} else {//read next header
+					efuse_addr = efuse_addr + (word_cnts*2) + 1;
+					ReadState = PG_STATE_HEADER;
+				}
+			} else {
+				bContinual = _FALSE ;
+			}
+		}
+		//-------  Data section Read -------------
+		else if (ReadState & PG_STATE_DATA) {
+			pgpacket_copy_data(hworden, tmpdata, data);
+			efuse_addr = efuse_addr + (word_cnts*2) + 1;
+			ReadState = PG_STATE_HEADER;
+		}
+	}
+
+	if(	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
+		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
+		ret = _FALSE;
+	else
+		ret = _TRUE;
+#endif
+
+	return ret;
+}
+//------------------------------------------------------------------------------
+static u8 pgpacket_write_data(_adapter *padapter, const u16 efuse_addr, const u8 word_en, const u8 *data)
+{
+	u16 start_addr = efuse_addr;
+
+	u8 badworden = 0x0F;
+
+	u8 word_idx, byte_idx;
+
+	u16 tmpaddr = 0;
+	u8 tmpdata[PGPKT_DATA_SIZE];
+
+
+	_memset(tmpdata, 0xff, PGPKT_DATA_SIZE);
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en & BIT(word_idx))) {
+			tmpaddr = start_addr;
+			byte_idx = word_idx * 2;
+			efuse_one_byte_write(padapter, start_addr++, data[byte_idx]);
+			efuse_one_byte_write(padapter, start_addr++, data[byte_idx + 1]);
+
+			efuse_one_byte_read(padapter, tmpaddr, &tmpdata[byte_idx]);
+			efuse_one_byte_read(padapter, tmpaddr + 1, &tmpdata[byte_idx+1]);
+			if ((data[byte_idx] != tmpdata[byte_idx]) || (data[byte_idx+1] != tmpdata[byte_idx+1])) {
+				badworden &= (~BIT(word_idx));
+			}
+		}
+	}
+
+	return badworden;
+}
+//------------------------------------------------------------------------------
+static u8 fix_header(_adapter *padapter, u8 header, u16 header_addr)
+{
+	PGPKT_STRUCT pkt;
+	u8 offset, word_en, value;
+	u16 addr;
+
+	int i;
+
+	u8 ret = _TRUE;
+
+	pkt.offset = GET_EFUSE_OFFSET(header);
+	pkt.word_en = GET_EFUSE_WORD_EN(header);
+
+	addr = header_addr + 1 + calculate_word_cnts(pkt.word_en)*2;
+	if (addr > EFUSE_AVAILABLE_MAX_SIZE)
+		return _FALSE;
+
+	// retrieve original data
+	addr = 0;
+	while (addr < header_addr) {
+		if (efuse_one_byte_read(padapter, addr++, &value) == _FALSE) {
+			ret = _FALSE;
+			break;
+		}
+
+		offset = GET_EFUSE_OFFSET(value);
+		word_en = GET_EFUSE_WORD_EN(value);
+
+		if (pkt.offset == offset) {
+			for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+				if (BIT(i) & word_en) {
+					if (BIT(i) & pkt.word_en) {
+						if (efuse_one_byte_read(padapter, addr, &value) == _TRUE)
+							pkt.data[i*2] = value;
+						else return _FALSE;
+
+						if (efuse_one_byte_read(padapter, addr+1, &value) == _TRUE)
+							pkt.data[i*2 + 1] = value;
+						else return _FALSE;
+					}
+					addr += 2;
+				}
+			}
+		} else
+			addr += calculate_word_cnts(word_en)*2;
+	}
+
+	if (addr == header_addr) {
+		addr++;
+		// fill original data
+		for (i = 0; i < PGPKG_MAX_WORDS; i++)
+		{
+			if (BIT(i) & pkt.word_en)
+			{
+				efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
+				efuse_one_byte_write(padapter, addr+1, pkt.data[i*2 + 1]);
+
+				// additional check
+				if (efuse_one_byte_read(padapter, addr, &value) == _FALSE)
+					ret = _FALSE;
+				else if (pkt.data[i*2] != value) {
+					ret = _FALSE;
+					if (0xFF == value) // write again
+						efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
+				}
+
+				if (efuse_one_byte_read(padapter, addr+1, &value) == _FALSE)
+					ret = _FALSE;
+				else if (pkt.data[i*2 + 1] != value) {
+					ret = _FALSE;
+					if (0xFF == value) // write again
+						efuse_one_byte_write(padapter, addr+1, pkt.data[i*2 + 1]);
+				}
+			}
+			addr += 2;
+		}
+	}
+	else ret = _FALSE;
+
+	return ret;
+}
+//------------------------------------------------------------------------------
+u8 efuse_pg_packet_write(_adapter *padapter, const u8 offset, const u8 word_en, const u8 *data)
+{
+#if 0
+	u8 WriteState = PG_STATE_HEADER;
+
+	int bContinual = _TRUE, bDataEmpty = _TRUE;
+
+	u16 remain_size = 0;
+	u16 tmp_addr = 0;
+
+	u8 tmp_word_cnts = 0;
+	u8 tmp_header, match_word_en, tmp_word_en;
+
+	u8 word_idx;
+
+	PGPKT_STRUCT target_pkt;
+	PGPKT_STRUCT tmp_pkt;
+
+	u8 originaldata[sizeof(u8) * PGPKT_DATA_SIZE];
+	u8 tmpindex = 0, badworden = 0x0F;
+#endif
+	u8 pg_header = 0;
+	u16 efuse_addr = 0, curr_size = 0;
+	u8 efuse_data, target_word_cnts = 0;
+
+	static int repeat_times = 0;
+	int sub_repeat;
+
+	u8 bResult = _TRUE;
+
+	// check if E-Fuse Clock Enable and E-Fuse Clock is 40M
+	efuse_data = read8(padapter, EFUSE_CLK_CTRL);
+	if (efuse_data != 0x03) {
+		RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_,("efuse_pg_packet_write: EFUSE_CLK_CTRL=0x%2x != 0x03", efuse_data));
+		return _FALSE;
+	}
+
+#if 1
+	pg_header = MAKE_EFUSE_HEADER(offset, word_en);
+
+	target_word_cnts = calculate_word_cnts(word_en);
+
+	repeat_times = 0;
+	efuse_addr = 0;
+	while (efuse_addr < EFUSE_AVAILABLE_MAX_SIZE)
+	{
+		curr_size = efuse_get_current_size(padapter);
+		RT_TRACE(_module_rtl8712_efuse_c_, _drv_info_,
+			 ("====efuse_pg_packet_write: max=%d current=%d cnts=%d=====\n",
+			  EFUSE_AVAILABLE_MAX_SIZE, curr_size, (1+target_word_cnts*2)));
+		if ((curr_size + 1 + target_word_cnts*2) > EFUSE_AVAILABLE_MAX_SIZE) {
+			RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_,
+				 ("efuse_pg_packet_write: size not enough!!!!\n"));
+			return _FALSE; //target_word_cnts + pg header(1 byte)
+		}
+
+		efuse_addr = curr_size; // current size is also the last address
+		efuse_one_byte_write(padapter, efuse_addr, pg_header); // write header
+
+		sub_repeat = 0;
+		// check if what we read is what we write
+		while (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) == _FALSE) {
+			if (++sub_repeat > _REPEAT_THRESHOLD_) {
+				RT_TRACE(_module_rtl8712_efuse_c_, _drv_emerg_,
+					 ("====efuse_pg_packet_write: can't read written header!!!!\n"));
+				bResult = _FALSE; // continue to blind write
+//				return bResult; // no rescue can be done, exit.
+				break; // continue to blind write
+			}
+		}
+
+		if ((sub_repeat > _REPEAT_THRESHOLD_) || (pg_header == efuse_data))
+		{
+			// write header ok OR can't check header(creep)
+			u8 i;
+
+			// go to next address
+			efuse_addr++;
+
+			for (i = 0; i < target_word_cnts*2; i++) {
+				efuse_one_byte_write(padapter, efuse_addr+i, *(data+i));
+				if (efuse_one_byte_read(padapter, efuse_addr+i, &efuse_data) == _FALSE)
+					bResult = _FALSE;
+				else if (*(data+i) != efuse_data) // write data fail
+					bResult = _FALSE;
+			}
+			break;
+		} else { // write header fail
+			bResult = _FALSE;
+
+			if (0xFF == efuse_data)
+				return bResult; // not thing damaged.
+
+			/* call rescue procedure */
+			if (fix_header(padapter, efuse_data, efuse_addr) == _FALSE)
+				return _FALSE; // rescue fail, face the music
+
+			if (++repeat_times > _REPEAT_THRESHOLD_) { // fail to write too many times
+				RT_TRACE(_module_rtl8712_efuse_c_, _drv_emerg_,
+					 ("====efuse_pg_packet_write: can't write header for too many times(%d)!!!!\n", _REPEAT_THRESHOLD_));
+				break;
+			}
+			// otherwise, take another risk...
+		}
+	}
+#else
+	if ((curr_size = efuse_get_current_size(padapter)) >= EFUSE_AVAILABLE_MAX_SIZE)
+		return _FALSE;
+
+	remain_size = EFUSE_AVAILABLE_MAX_SIZE - curr_size;
+
+	target_word_cnts = calculate_word_cnts(word_en);
+	RT_TRACE(_module_rtl8712_efuse_c_, _drv_info_,
+		("====efuse_pg_packet_write max=%d remain=%d cnts=%d=====\n", EFUSE_AVAILABLE_MAX_SIZE, remain_size, (target_word_cnts*2+1)));
+	if (remain_size < (target_word_cnts * 2 + 1)){
+		RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_,
+			 ("====efuse size is not enough !!!!\n"));
+		return _FALSE; //target_word_cnts + pg header(1 byte)
+	}
+
+	target_pkt.offset = offset;
+	target_pkt.word_en = word_en;
+	memset(target_pkt.data, 0xFF, sizeof(u8)*8);
+	pgpacket_copy_data(word_en, data, target_pkt.data);
+
+	while (bContinual && (efuse_addr < EFUSE_AVAILABLE_MAX_SIZE))
+	{
+		if (WriteState == PG_STATE_HEADER)
+		{
+			bDataEmpty = _TRUE;
+			badworden = 0x0F;
+			//************  so *******************
+			if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) && (efuse_data != 0xFF))
+			{
+				tmp_header = efuse_data;
+
+				tmp_pkt.offset = (tmp_header >> 4) & 0x0F;
+				tmp_pkt.word_en = tmp_header & 0x0F;
+				tmp_word_cnts = calculate_word_cnts(tmp_pkt.word_en);
+
+				//************  so-1 *******************
+				if (tmp_pkt.offset != target_pkt.offset) {
+					efuse_addr = efuse_addr + (tmp_word_cnts * 2) + 1; //Next pg_packet
+					WriteState = PG_STATE_HEADER;
+				} else {
+					//************  so-2 *******************
+					for (tmpindex = 0; tmpindex < (tmp_word_cnts*2); tmpindex++) {
+						if (efuse_one_byte_read(padapter, (efuse_addr+1+tmpindex), &efuse_data) && (efuse_data != 0xFF)){
+							bDataEmpty = _FALSE;
+						}
+					}
+					//************  so-2-1 *******************
+					if (bDataEmpty == _FALSE) {
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) + 1; //Next pg_packet
+						WriteState = PG_STATE_HEADER;
+					}
+					else {//************  so-2-2 *******************
+						match_word_en = 0x0F;
+						for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+							if (!((target_pkt.word_en & BIT(word_idx)) | (tmp_pkt.word_en & BIT(word_idx)))) {
+								 match_word_en &= (~BIT(word_idx));
+							}
+						}
+						//************  so-2-2-A *******************
+						if ((match_word_en & 0x0F) != 0x0F)
+						{
+							badworden = pgpacket_write_data(padapter, efuse_addr + 1, tmp_pkt.word_en, target_pkt.data);
+
+							//************  so-2-2-A-1 *******************
+							//############################
+							if (0x0F != (badworden & 0x0F)) {
+								u8 reorg_offset = offset;
+								u8 reorg_worden = badworden;
+								efuse_pg_packet_write(padapter, reorg_offset, reorg_worden, originaldata);
+							}
+							//############################
+
+							tmp_word_en = 0x0F;
+							for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+								if ((target_pkt.word_en & BIT(word_idx))^(match_word_en & BIT(word_idx))) {
+									tmp_word_en &= (~BIT(word_idx));
+								}
+							}
+							//************  so-2-2-A-2 *******************
+							if ((tmp_word_en & 0x0F) != 0x0F) {
+								//reorganize other pg packet
+								efuse_addr = efuse_get_current_size(padapter);
+								//===========================
+								target_pkt.offset = offset;
+								target_pkt.word_en= tmp_word_en;
+								//===========================
+							} else {
+								bContinual = _FALSE;
+							}
+							WriteState = PG_STATE_HEADER;
+							repeat_times++;
+							if (repeat_times > _REPEAT_THRESHOLD_) {
+								bContinual = _FALSE;
+								bResult = _FALSE;
+							}
+						}
+						else {//************  so-2-2-B *******************
+							//reorganize other pg packet
+							efuse_addr = efuse_addr + (2*tmp_word_cnts) + 1;//next pg packet addr
+							//===========================
+							target_pkt.offset = offset;
+							target_pkt.word_en= target_pkt.word_en;
+							//===========================
+							WriteState = PG_STATE_HEADER;
+						}
+					}
+				}
+			}
+			else { //************  s1: header == oxff  *******************
+				curr_size = efuse_get_current_size(padapter);
+				remain_size = EFUSE_AVAILABLE_MAX_SIZE - curr_size;
+				RT_TRACE(_module_rtl8712_efuse_c_,_drv_alert_,("====efuse write header state remain_size =%d, target_word_cnts=%d=====\n", remain_size,(target_word_cnts*2+1)));
+				if (remain_size < (target_word_cnts*2+1)) //target_word_cnts + pg header(1 byte)
+				{
+					RT_TRACE(_module_rtl8712_efuse_c_,_drv_alert_,("====efuse size isnot enough !!!!\n"));
+					bContinual = _FALSE;
+					bResult = _FALSE;
+				} else {
+					pg_header = ((target_pkt.offset << 4) & 0xf0) | target_pkt.word_en;
+
+					efuse_one_byte_write(padapter, efuse_addr, pg_header);
+					efuse_one_byte_read(padapter, efuse_addr, &tmp_header);
+
+					if (tmp_header == pg_header) { //************  s1-1 *******************
+						WriteState = PG_STATE_DATA;
+					} else if (tmp_header == 0xFF) {//************  s1-3: if Write or read func doesn't work *******************
+						//efuse_addr doesn't change
+						WriteState = PG_STATE_HEADER;
+						repeat_times++;
+						if (repeat_times > _REPEAT_THRESHOLD_) {
+							bContinual = _FALSE;
+							bResult = _FALSE;
+						}
+					}
+					else {//************  s1-2 : fixed the header procedure *******************
+						RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_, ("====efuse write header fail write=0x%02x read=0x%02x!!\n", pg_header, tmp_header));
+						tmp_pkt.offset = (tmp_header>>4) & 0x0F;
+						tmp_pkt.word_en = tmp_header & 0x0F;
+						tmp_word_cnts = calculate_word_cnts(tmp_pkt.word_en);
+
+						//************  s1-2-A :cover the exist data *******************
+						memset(originaldata, 0xff, sizeof(u8)*8);
+
+						if (efuse_pg_packet_read(padapter, tmp_pkt.offset, originaldata))
+						{	//check if data exist
+							badworden = pgpacket_write_data(padapter, efuse_addr + 1, tmp_pkt.word_en, originaldata);
+							//############################
+							if (0x0F != (badworden & 0x0F)) {
+								u8 reorg_offset = tmp_pkt.offset;
+								u8 reorg_worden = badworden;
+								efuse_pg_packet_write(padapter, reorg_offset, reorg_worden, originaldata);
+								efuse_addr = efuse_get_current_size(padapter);
+							}
+							//############################
+							else {
+								efuse_addr = efuse_addr + (tmp_word_cnts * 2) + 1; //Next pg_packet
+							}
+						}
+						 //************  s1-2-B: wrong address*******************
+						else {
+							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+						}
+						WriteState = PG_STATE_HEADER;
+						repeat_times++;
+						if (repeat_times > _REPEAT_THRESHOLD_) {
+							bContinual = _FALSE;
+							bResult = _FALSE;
+						}
+					}
+				}
+			}
+		}
+		//write data state
+		else if (WriteState == PG_STATE_DATA) {//************  s1-1  *******************
+			badworden = 0x0f;
+			badworden = pgpacket_write_data(padapter, efuse_addr+1, target_pkt.word_en, target_pkt.data);
+			if((badworden&0x0F)==0x0F){ //************  s1-1-A *******************
+				bContinual = _FALSE;
+			}
+			else{//reorganize other pg packet //************  s1-1-B *******************
+				efuse_addr = efuse_addr + (2*target_word_cnts) +1;//next pg packet addr
+
+				//===========================
+				target_pkt.offset = offset;
+				target_pkt.word_en= badworden;
+				target_word_cnts = calculate_word_cnts(target_pkt.word_en);
+				//===========================
+				WriteState=PG_STATE_HEADER;
+				repeat_times++;
+				if (repeat_times > _REPEAT_THRESHOLD_) {
+					bContinual = _FALSE;
+					bResult = _FALSE;
+				}
+			}
+		}
+	}
+#endif
+
+	return bResult;
+}
+//------------------------------------------------------------------------------
+u8 efuse_access(_adapter *padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data)
+{
+	int i = 0;
+	u8 res;
+
+	if (start_addr > EFUSE_MAX_SIZE)
+		return _FALSE;
+
+	if ((bRead == _FALSE) && ((start_addr + cnts) > EFUSE_AVAILABLE_MAX_SIZE))
+		return _FALSE;
+
+	if ((_FALSE == bRead) && (efuse_reg_init(padapter) == _FALSE))
+		return _FALSE;
+
+	//-----------------e-fuse one byte read / write ------------------------------
+	for (i = 0; i < cnts; i++) {
+		if ((start_addr + i) > EFUSE_MAX_SIZE) {
+			res = _FALSE;
+			break;
+		}
+		res = efuse_one_byte_rw(padapter, bRead, start_addr + i, data + i);
+//		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("==>efuse_access addr:0x%02x value:0x%02x\n",data+i,*(data+i)));
+		if ((_FALSE == bRead) && (_FALSE == res)) break;
+	}
+
+	if (_FALSE == bRead) efuse_reg_uninit(padapter);
+
+	return res;
+}
+//------------------------------------------------------------------------------
+u8 efuse_map_read(_adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, ret = _TRUE;
+	u8 pktdata[PGPKT_DATA_SIZE];
+	int i, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return _FALSE;
+
+	if ((efuse_is_empty(padapter, &offset) == _TRUE) && (offset == _TRUE)) {
+		for (i = 0; i < cnts; i++)
+			data[i] = 0xFF;
+		return ret;
+	}
+
+	offset = (addr >> 3) & 0xF;
+	ret = efuse_pg_packet_read(padapter, offset, pktdata);
+	i = addr & 0x7;	// pktdata index
+	idx = 0;	// data index
+
+	do {
+		for (; i < PGPKT_DATA_SIZE; i++) {
+			data[idx++] = pktdata[i];
+			if (idx == cnts) return ret;
+		}
+
+		offset++;
+//		if (offset > 0xF) break; // no need to check
+		if (efuse_pg_packet_read(padapter, offset, pktdata) == _FALSE)
+			ret = _FALSE;
+		i = 0;
+	} while (1);
+
+	return ret;
+}
+//------------------------------------------------------------------------------
+u8 efuse_map_write(_adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, word_en, empty;
+	u8 pktdata[PGPKT_DATA_SIZE], newdata[PGPKT_DATA_SIZE];
+	int i, j, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return _FALSE;
+
+	// check if E-Fuse Clock Enable and E-Fuse Clock is 40M
+	empty = read8(padapter, EFUSE_CLK_CTRL);
+	if (empty != 0x03) {
+		RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_,("efuse_map_write: EFUSE_CLK_CTRL=0x%2x != 0x03", empty));
+		return _FALSE;
+	}
+
+	if (efuse_is_empty(padapter, &empty) == _TRUE) {
+		if (_TRUE == empty)
+			_memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
+	} else
+		return _FALSE;
+
+	offset = (addr >> 3) & 0xF;
+	if (empty == _FALSE)
+		if (efuse_pg_packet_read(padapter, offset, pktdata) == _FALSE)
+			return _FALSE;
+
+	word_en = 0xF;
+	_memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	i = addr & 0x7;	// pktdata index
+	j = 0;		// newdata index
+	idx = 0;	// data index
+
+	if (i & 0x1) {
+		// odd start
+		if (data[idx] != pktdata[i]) {
+			word_en &= ~BIT(i >> 1);
+			newdata[j++] = pktdata[i - 1];
+			newdata[j++] = data[idx];
+		}
+		i++;
+		idx++;
+	}
+	do {
+		for (; i < PGPKT_DATA_SIZE; i += 2) {
+			if ((cnts - idx) == 1) {
+				if (data[idx] != pktdata[i]) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = pktdata[1 + 1];
+				}
+				idx++;
+				break;
+			} else {
+				if ((data[idx] != pktdata[i]) || (data[idx+1] != pktdata[i+1])) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = data[idx + 1];
+				}
+				idx += 2;
+			}
+			if (idx == cnts) break;
+		}
+
+		if (word_en != 0xF)
+			if (efuse_pg_packet_write(padapter, offset, word_en, newdata) == _FALSE)
+				return _FALSE;
+
+		if (idx == cnts) break;
+
+		offset++;
+		if (empty == _FALSE)
+			if (efuse_pg_packet_read(padapter, offset, pktdata) == _FALSE)
+				return _FALSE;
+		i = 0;
+		j = 0;
+		word_en = 0xF;
+		_memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	} while (1);
+
+	return _TRUE;
+}
+//------------------------------------------------------------------------------
+
diff --git a/drivers/net/wireless/8712u/hal/rtl8712/hal_init.c b/drivers/net/wireless/8712u/hal/rtl8712/hal_init.c
new file mode 100755
index 0000000..462cf7c
--- /dev/null
+++ b/drivers/net/wireless/8712u/hal/rtl8712/hal_init.c
@@ -0,0 +1,934 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#define _HAL_INIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_byteorder.h>
+
+#include <hal_init.h>
+
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_hal.h>
+#ifdef PLATFORM_LINUX
+#include <linux/mmc/sdio_func.h>
+#endif
+#elif defined(CONFIG_USB_HCI)
+#include <usb_hal.h>
+#endif	
+
+#ifdef PLATFORM_OS_CE
+#define FWBUFF_ALIGN_SZ 4
+#else
+#define FWBUFF_ALIGN_SZ 512
+#endif
+
+#if defined(PLATFORM_OS_CE) && defined(CONFIG_USB_HCI)
+#define MAX_DUMP_FWSZ	2000
+#else
+#define MAX_DUMP_FWSZ	3072  /*default = 49152 (48k)*/
+#endif
+
+void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv)
+{
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+
+	_memset(pfwpriv, 0, sizeof(struct fw_priv));
+
+#ifdef CONFIG_USB_HCI
+        //todo: check if needs endian conversion
+	pfwpriv->hci_sel =  RTL8712_HCI_TYPE_72USB;
+	pfwpriv->usb_ep_num = (u8)pdvobj->nr_endpoint;
+#endif	
+
+#ifdef CONFIG_SDIO_HCI
+	pfwpriv->hci_sel =  RTL8712_HCI_TYPE_72SDIO;
+#endif
+
+#ifdef CONFIG_80211N_HT
+	pfwpriv->bw_40MHz_en = pregpriv->cbw40_enable;
+#else
+	pfwpriv->bw_40MHz_en = 0;
+#endif
+
+	switch (pregpriv->rf_config) {
+		case RTL8712_RF_1T1R:
+			pfwpriv->rf_config = RTL8712_RFCONFIG_1T1R;
+			RT_TRACE(_module_hal_init_c_,_drv_info_,("== fill_fwpriv: RF_CONFIG=1T1R \n"));
+			break;
+		case RTL8712_RF_2T2R:
+			pfwpriv->rf_config = RTL8712_RFCONFIG_2T2R;
+			RT_TRACE(_module_hal_init_c_,_drv_info_,("== fill_fwpriv: RF_CONFIG=2T2R \n"));
+			break;
+		case RTL8712_RF_1T2R:
+		default:
+			pfwpriv->rf_config = RTL8712_RFCONFIG_1T2R;
+			RT_TRACE(_module_hal_init_c_,_drv_info_,("== fill_fwpriv: RF_CONFIG=1T2R \n"));
+	}
+
+	pfwpriv->mp_mode =  ( pregpriv->mp_mode == 1)?1 :0 ;	
+
+	pfwpriv->vcsType = pregpriv->vrtl_carrier_sense; /* 0:off 1:on 2:auto */
+	pfwpriv->vcsMode = pregpriv->vcs_type; /* 1:RTS/CTS 2:CTS to self */
+
+	pfwpriv->turboMode = ( ( pregpriv->wifi_test == 1 ) ? 0 : 1 ) ;	//default enable it
+
+	pfwpriv->lowPowerMode = pregpriv->low_power;
+	pfwpriv->rsvd024 = 1;	//	F/W will issue two probe request. One is with ssid ( if exists ), another is with the wildcard ssid.
+	RT_TRACE(_module_hal_init_c_,_drv_err_,("== fill_fwpriv: pfwpriv->lowPowerMode=%d [0:normal / 1:low power]\n",pfwpriv->lowPowerMode ));
+}
+
+void update_fwhdr(struct fw_hdr	* pfwhdr, u8* pmappedfw)
+{
+	pfwhdr->signature = le16_to_cpu(*(u16 *)pmappedfw);
+	pfwhdr->version = le16_to_cpu(*(u16 *)(pmappedfw+2));
+	
+	pfwhdr->dmem_size = le32_to_cpu(*(uint *)(pmappedfw+4));    //define the size of boot loader
+	
+	pfwhdr->img_IMEM_size = le32_to_cpu(*(uint *)(pmappedfw+8));    //define the size of FW in IMEM
+	
+	pfwhdr->img_SRAM_size = le32_to_cpu(*(uint *)(pmappedfw+12));    //define the size of FW in SRAM
+	
+	pfwhdr->fw_priv_sz = le32_to_cpu(*(uint *)(pmappedfw+16));      //define the size of DMEM variable 
+	
+	
+	//_memcpy(&pfwhdr->fwpriv, pmappedfw+16 + sizeof(uint)*4, sizeof(struct fw_priv));
+
+	RT_TRACE(_module_hal_init_c_,_drv_info_,("update_fwhdr:sig=%x;ver=%x;dmem_size=%d;IMEMsz=%d;SRAMsz=%d;fwprivsz=%d;struct_fwprivsz=%d\n",
+					pfwhdr->signature, pfwhdr->version,pfwhdr->dmem_size,pfwhdr->img_IMEM_size,pfwhdr->img_SRAM_size, pfwhdr->fw_priv_sz, sizeof(struct fw_priv)));
+
+}
+
+u8 chk_fwhdr(struct fw_hdr *pfwhdr, u32 ulfilelength)
+{
+	u32	fwhdrsz, fw_sz;
+	u8 intf, rfconf;
+
+	//check signature
+	if ((pfwhdr->signature != 0x8712) && (pfwhdr->signature != 0x8192))
+	{
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("Signature does not match (Signature %x != 8712)! Issue complaints for fw coder\n", pfwhdr->signature));
+		return _FAIL;
+	}
+
+	//check fw_version
+	RT_TRACE(_module_hal_init_c_,_drv_info_,("FW_VER=%X\n", pfwhdr->version&0x0FFF));
+	
+	//check interface
+	intf = (u8)((pfwhdr->version&0x3000) >> 12);
+	RT_TRACE(_module_hal_init_c_,_drv_info_,("Interface=%X", intf));		
+
+	//check rf_conf
+	rfconf = (u8)((pfwhdr->version&0xC000) >> 14);
+	RT_TRACE(_module_hal_init_c_,_drv_info_,("chk_fwhdr RF_Configure=%X", rfconf));	
+
+	//check fw_priv_sze & sizeof(struct fw_priv)
+	if(pfwhdr->fw_priv_sz != sizeof(struct fw_priv))
+	{
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("fw_priv size mismatch between fw(%d) and driver(%d)\n", pfwhdr->fw_priv_sz, sizeof(struct fw_priv)));		
+		return _FAIL;
+	}
+	
+
+	//check fw_sz & image_fw_sz
+	fwhdrsz = FIELD_OFFSET(struct fw_hdr, fwpriv) + pfwhdr->fw_priv_sz;	
+	fw_sz =  fwhdrsz + pfwhdr->img_IMEM_size +pfwhdr->img_SRAM_size + pfwhdr->dmem_size;	
+	if (fw_sz != ulfilelength)
+	{			
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("FW image size dismatch! fw_sz=%d != image_fw_sz = %d!\n", fw_sz, ulfilelength));		
+		return _FAIL;
+	}
+
+	return _SUCCESS;
+
+}
+
+u8 rtl8712_dl_fw(_adapter *padapter)
+{
+	sint	i;
+	u8	tmp8, tmp8_a;
+	u16	tmp16;
+	u32	maxlen = 0, tmp32; //for compare usage
+
+	uint	dump_imem_sz, imem_sz, dump_emem_sz, emem_sz; // max = 49152;
+	struct fw_hdr	fwhdr;
+	u32	ulfilelength;	//FW file size
+	void	*phfwfile_hdl = NULL;
+	u8	*pmappedfw = NULL, *ptmpchar = NULL, *ppayload, *ptr;
+	u8	ret8 = _SUCCESS;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+
+	struct tx_desc	*ptx_desc;
+	u32	txdscp_sz = sizeof(struct tx_desc);
+	u32	addr = 0;
+	struct dvobj_priv *pdvobjpriv = &padapter->dvobjpriv;
+
+_func_enter_;
+
+	RT_TRACE(_module_hal_init_c_, _drv_notice_, ("rtl8712_dl_fw \n"));
+
+	ulfilelength = rtl871x_open_fw(padapter, &phfwfile_hdl, &pmappedfw);
+	if(pmappedfw && (ulfilelength>0))
+	{
+		update_fwhdr(&fwhdr, pmappedfw);
+
+		if(chk_fwhdr(&fwhdr, ulfilelength)== _FAIL)
+		{
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("CHK FWHDR fail!\n"));
+			ret8 = _FAIL;
+			goto exit;
+		}
+
+		fill_fwpriv(padapter, &fwhdr.fwpriv);
+
+		//firmware check ok
+		//RT_TRACE(_module_hal_init_c_,_drv_info_,("Downloading RTL8712 firmware major(%d)/minor(%d) version...\n", fwhdr.version >>8, fwhdr.version & 0xff));
+
+		maxlen = (fwhdr.img_IMEM_size > fwhdr.img_SRAM_size)? fwhdr.img_IMEM_size : fwhdr.img_SRAM_size;
+		maxlen += txdscp_sz;
+		//ptmpchar = _malloc(maxlen + FWBUFF_ALIGN_SZ);
+		ptmpchar = _malloc(4*1024);
+
+		if (ptmpchar==NULL) {
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("can't alloc resources when dl_fw\n"));
+			ret8 = _FAIL;
+			goto exit;
+		}
+
+		ptx_desc = (struct tx_desc *)(ptmpchar + FWBUFF_ALIGN_SZ - ((u32 )(ptmpchar )&(FWBUFF_ALIGN_SZ-1)));
+		ppayload = (u8*)(ptx_desc) + txdscp_sz;
+		//ptr = pmappedfw+sizeof(struct fw_hdr)+fwhdr.dmem_size;
+		ptr = pmappedfw + FIELD_OFFSET(struct fw_hdr, fwpriv) + fwhdr.fw_priv_sz ;//+ fwhdr.dmem_size;
+
+		//Download FirmWare
+
+		// 1. determine IMEM code size and Load IMEM Code Section
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("=============STEP1.================\n"));
+		
+		//_memcpy(ppayload, ptr, fwhdr.img_IMEM_size);
+		//ptx_desc->linip=1;
+		//ptx_desc->txpktsize = fwhdr.img_IMEM_size;
+		//ptx_desc->qsel=3;//not necessary
+
+		//_memset(ptx_desc, 0, TXDESC_SIZE);
+		
+#if 1
+		imem_sz = fwhdr.img_IMEM_size;
+
+		do {
+			_memset(ptx_desc, 0, TXDESC_SIZE);
+
+			if(imem_sz >  MAX_DUMP_FWSZ) {
+				dump_imem_sz = MAX_DUMP_FWSZ;
+			} else {
+				dump_imem_sz = imem_sz;
+				ptx_desc->txdw0 |= cpu_to_le32(BIT(28));	
+			}
+
+			ptx_desc->txdw0 |= cpu_to_le32(dump_imem_sz&0x0000ffff);
+
+			_memcpy(ppayload, ptr, dump_imem_sz);
+#ifdef CONFIG_USB_HCI
+			write_mem(padapter, RTL8712_DMA_VOQ, dump_imem_sz+TXDESC_SIZE, (u8*)ptx_desc);
+#endif
+#ifdef CONFIG_SDIO_HCI
+			write_port(padapter, RTL8712_DMA_VOQ,  dump_imem_sz+TXDESC_SIZE ,(u8*) ptx_desc);
+#endif
+			ptr += dump_imem_sz;
+
+			imem_sz -= dump_imem_sz;
+
+		}while (imem_sz > 0);
+#endif
+
+		//ptx_desc->txdw0 |= (fwhdr.img_IMEM_size&0x0000ffff);
+		//ptx_desc->txdw0 |= BIT(28);
+		//ptx_desc->txdw1 |= ((3<<8)&0x00001f00);
+
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,(" WT IMEM ; txpktsize = %x\n", ptx_desc->txdw0));
+		//write_port(padapter, RTL8712_DMA_VOQ, ptx_desc->txpktsize+32 ,(u8*) ptx_desc);
+		//write_mem(padapter, RTL8712_DMA_VOQ, ptx_desc->txpktsize+32 ,(u8*)ptx_desc);
+		//write_mem(padapter, RTL8712_DMA_VOQ, fwhdr.img_IMEM_size+TXDESC_SIZE, (u8*)ptx_desc);
+
+		//ptr = ptr + fwhdr.img_IMEM_size;
+		i = 10;
+		tmp16=read16(padapter,TCR);
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("TCR val = %x\n", tmp16));
+		while(((tmp16 & _IMEM_CODE_DONE)==0) && (i>0))
+		{
+			//delay
+			udelay_os(10);
+			tmp16=read16(padapter,TCR);
+			RT_TRACE(_module_hal_init_c_, _drv_notice_, ("TCR val = %x\n", tmp16));						
+			i--;
+		}
+		if (i == 0) {
+			RT_TRACE(_module_hal_init_c_, _drv_err_, ("Error => Pollin _IMEM_CODE_DONE Fail\n"));
+			ret8=_FAIL;
+			goto exit;
+		}
+
+		if((tmp16 & _IMEM_CHK_RPT) == 0) {
+			RT_TRACE(_module_hal_init_c_, _drv_err_, ("_IMEM_CHK_RPT = 0\n"));
+			ret8 = _FAIL;
+			goto exit;
+		}
+
+		// 2.Download EMEM code size and Load EMEM Code Section
+
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("=============STEP2.================\n"));
+
+		//ptr = ptr + fwhdr.img_IMEM_size;
+		//ptx_desc->linip=1;
+		//ptx_desc->txpktsize =  fwhdr.img_SRAM_size ;		
+
+		emem_sz = fwhdr.img_SRAM_size;
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("WT SRAM ; txpktsize = 0x%x  fwhdr.img_SRAM_size=0x%x\n", emem_sz,fwhdr.img_SRAM_size));
+		
+		do{
+	
+			_memset(ptx_desc, 0, TXDESC_SIZE);
+
+			if(emem_sz >  MAX_DUMP_FWSZ/*49152*/) //max=48k
+			{
+				dump_emem_sz = MAX_DUMP_FWSZ;//49152
+			}
+			else
+			{
+				dump_emem_sz = emem_sz;
+				ptx_desc->txdw0 |= cpu_to_le32(BIT(28));		
+				
+			}			
+
+			ptx_desc->txdw0 |= cpu_to_le32(dump_emem_sz&0x0000ffff); 
+			
+			_memcpy(ppayload, ptr, dump_emem_sz);
+			write_mem(padapter, RTL8712_DMA_VOQ, dump_emem_sz+TXDESC_SIZE, (u8*)ptx_desc);
+			ptr +=dump_emem_sz;	
+			
+			emem_sz -= dump_emem_sz;
+
+		}while(emem_sz>0);
+			
+		//ptx_desc->txdw1 |= ((3<<QSEL_SHT)&0x00001f00);
+		
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("WT SRAM; txpktsize = %x\n", ptx_desc->txdw0));	
+		//_memcpy(ppayload, ptr, fwhdr.img_SRAM_size);
+		//write_port(padapter, RTL8712_DMA_VOQ, ptx_desc->txpktsize+32, (u8*)ptx_desc);
+		//write_mem(padapter, RTL8712_DMA_VOQ, ptx_desc->txpktsize+32 ,(u8*) ptx_desc);
+		//write_mem(padapter, RTL8712_DMA_VOQ, fwhdr.img_SRAM_size+TXDESC_SIZE, (u8*)ptx_desc);
+		
+
+		i = 5;
+		tmp16=read16(padapter,TCR);
+			RT_TRACE(_module_hal_init_c_, _drv_notice_,("TCR val = %x\n", tmp16));
+		while(((tmp16 & _EMEM_CODE_DONE)==0) && ( i>0))
+		{
+			udelay_os(10);
+			tmp16=read16(padapter,TCR);
+			RT_TRACE(_module_hal_init_c_, _drv_notice_,("TCR val = %x\n", tmp16));
+			i--;
+		}
+		if (i == 0) {
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Error => Pollin _EMEM_CODE_DONE Fail\n"));
+			ret8=_FAIL;
+			goto exit;
+		}
+
+		if ((tmp16 & _EMEM_CHK_RPT) == 0) {
+			ret8 = _FAIL;
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("_EMEM_CHK_RPT = 0\n"));
+			goto exit;
+		}
+
+		// 3.Enable CPU
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("=============STEP3.================\n"));
+
+		tmp8 = read8(padapter, SYS_CLKR);
+
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("WT SYS_CLKR to 0x%x(ori=0x%x)\n", (u32)(tmp8|BIT(2)),tmp8) );
+
+		write8(padapter, SYS_CLKR, tmp8|BIT(2));
+		tmp8_a = read8(padapter, SYS_CLKR);
+
+		if (tmp8_a != (tmp8|BIT(2))) {
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Error=> WT SYS_FUNC_EN fail; SYS_CLKR = %x;  target_val = %x\n", tmp8_a, tmp8));
+			ret8 = _FAIL;
+			goto exit;
+		}
+
+		tmp8 = read8(padapter, SYS_FUNC_EN + 1);
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("WT SYS_FUNC_EN+1 to 0x%x[ori=0x%x]\n",(u32)(tmp8|BIT(2)),tmp8));
+		write8(padapter, SYS_FUNC_EN+1, tmp8|BIT(2)); 
+		tmp8_a = read8(padapter, SYS_FUNC_EN + 1); 
+		if (tmp8_a != (tmp8|BIT(2))) {
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Error=> WT SYS_FUNC_EN fail; SYS_FUNC_EN=%x; target_val=%x\n", tmp8_a, tmp8));
+			ret8=_FAIL;
+			goto exit;
+		}
+
+		//---
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("WT TCR |_BASECHG\n"));
+
+		tmp32 = read32(padapter, TCR);
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("RD TCR = %x\n", tmp32));
+
+		// 4.polling IMEM Ready
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("=============STEP4.================\n"));
+
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,(" polling IMEM Ready\n"));
+#ifdef CONFIG_USB_HCI
+		//write8(padapter, 0xb025003a, 0x3e);
+		//RT_TRACE(_module_hal_init_c_,_drv_info_,("RD DBS = %x \n", read8(padapter, 0xb025003a)));
+#endif
+		i = 100;
+		tmp16 = read16(padapter, TCR);
+		while (((tmp16 & _IMEM_RDY) == 0) && (i > 0)) 
+		{
+			udelay_os(1000);
+			tmp16 = read16(padapter,TCR);
+			RT_TRACE(_module_hal_init_c_, _drv_notice_,("TCR val = %x\n", tmp16));
+			i--;
+		}
+		if (i == 0)
+		{
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("Error => Pollin _IMEM_RDY Fail\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("\nread  0x10250318=0x%x\n",read32(padapter,0x10250318)));
+			write16(padapter, 0x10250348, 0xc000);
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("write 0x10250348 0xc000\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250340=0x%x\n",read32(padapter,0x10250340)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250344=0x%x\n",read32(padapter,0x10250344)));
+			write16(padapter, 0x10250348, 0xc001);
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("write 0x10250348 0xc001\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250340=0x%x\n",read32(padapter,0x10250340)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250344=0x%x\n",read32(padapter,0x10250344)));
+			write16(padapter, 0x10250348, 0x2000);
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("write 0x10250348 0x2000\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250340=0x%x\n",read32(padapter,0x10250340)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250344=0x%x\n",read32(padapter,0x10250344)));
+			write16(padapter, 0x10250348, 0x2001);
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("write 0x10250348 0x2001\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250340=0x%x\n",read32(padapter,0x10250340)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250344=0x%x\n",read32(padapter,0x10250344)));
+			write16(padapter, 0x10250348, 0x2002);
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("write 0x10250348 0x2002\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250340=0x%x\n",read32(padapter,0x10250340)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250344=0x%x\n",read32(padapter,0x10250344)));
+			write16(padapter, 0x10250348, 0x2003);
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("write 0x10250348 0x2003\n"));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250340=0x%x\n",read32(padapter,0x10250340)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("read  0x10250344=0x%x\n",read32(padapter,0x10250344)));
+	{
+			u32 i;
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("==dump register[0-44]===\n"));
+			for (i = 0; i < 0x48; i = i+4)
+				RT_TRACE(_module_hal_init_c_,_drv_emerg_,("[%x]=0x%x\n",i,read32(padapter,0x10250000+i)));
+			RT_TRACE(_module_hal_init_c_,_drv_emerg_,("===dump end===\n"));
+	}
+			ret8 = _FAIL;
+			goto exit;
+		}
+
+		//5.Download DMEM code size and Load EMEM Code Section
+		//tx_desc.linip=1;
+		//tx_desc.qsel=3;	//not necessary		
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,("=============STEP5.================\n"));
+
+		_memset(ptx_desc, 0, TXDESC_SIZE);
+
+		ptx_desc->txdw0 |= cpu_to_le32(fwhdr.fw_priv_sz&0x0000ffff);		
+		ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+		
+		_memcpy(ppayload, &fwhdr.fwpriv, fwhdr.fw_priv_sz);
+
+		RT_TRACE(_module_hal_init_c_, _drv_notice_,(" Download fwpriv; txpktsize=0x%x ptx_desc->txdw0=0x%x\n", fwhdr.fw_priv_sz,ptx_desc->txdw0));
+#ifdef CONFIG_USB_HCI		
+		write_mem(padapter, RTL8712_DMA_VOQ, fwhdr.fw_priv_sz+TXDESC_SIZE, (u8*)ptx_desc);
+#endif
+#ifdef CONFIG_SDIO_HCI
+		write_port(padapter, RTL8712_DMA_VOQ,  fwhdr.fw_priv_sz+TXDESC_SIZE, (u8*)ptx_desc);
+		RT_TRACE(_module_hal_init_c_,_drv_err_,(" Download fwpriv; fwhdr.fw_priv_sz+TXDESC_SIZE= 0x%x\n", fwhdr.fw_priv_sz+TXDESC_SIZE));
+
+#endif
+		//polling dmem code done
+		i = 100;
+		tmp16=read16(padapter,TCR);
+		while(((tmp16 & _DMEM_CODE_DONE)==0) && ( i>0))
+		{
+			udelay_os(1000);
+			tmp16=read16(padapter,TCR);
+			RT_TRACE(_module_hal_init_c_, _drv_notice_,("TCR val=%x\n", tmp16));
+			i--;
+		}
+		if(i==0)
+		{
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Error => Pollin _DMEM_CODE_DONE Fail\n"));
+			ret8=_FAIL;
+			goto exit;
+		}
+
+#if 1
+	        RT_TRACE(_module_hal_init_c_, _drv_notice_,("====STEP6.==Polling _FWRDY if ready==\n"));
+
+		tmp8 = read8(padapter, 0x1025000A);
+
+		if(tmp8 & BIT(4))//When boot from EEPROM , FW need more time to read EEPROM 	
+			i = 60;
+		else 			//boot from EFUSE
+			i = 30;
+		
+		tmp16=read16(padapter,TCR);
+		while(((tmp16 & _FWRDY)==0) && ( i>0))
+		{
+			//udelay_os(1000);
+			msleep_os(100);
+			tmp16=read16(padapter,TCR);
+			RT_TRACE(_module_hal_init_c_, _drv_notice_,("TCR val=%x\n", tmp16));
+			i--;			
+		}
+		
+		if(i==0)
+		{
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Error => Pollin _FWRDY Fail\n"));
+			ret8=_FAIL;
+			goto exit;
+		}
+		else
+		{
+			RT_TRACE(_module_hal_init_c_, _drv_notice_,("Polling _FWRDY r_cnt=%d\n", i));
+		}
+#endif	
+		
+	}
+	else
+	{
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("rtl8712_dl_fw=> can't open fwfile\n"));
+		ret8 = _FAIL;
+	}
+
+exit:
+	rtl871x_close_fw(padapter, phfwfile_hdl);
+
+	if (ptmpchar != NULL)
+		_mfree(ptmpchar, maxlen + FWBUFF_ALIGN_SZ);
+
+_func_exit_;
+
+	return ret8;
+}	
+
+extern void hw_init(_adapter *padapter);
+uint rtl8712_hal_init(_adapter *padapter)
+{
+	u32	val32;
+	u8	val8;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct eeprom_priv *peeprompriv = &padapter->eeprompriv;	 
+	uint status = _SUCCESS;
+
+_func_enter_;
+
+	//r8712 firmware download
+	RT_TRACE(_module_hal_init_c_, _drv_alert_, ("rtl8712_hal_init #1 == SYS_FUNC_EN:0x%08x\n", read8(padapter,0x10250003)));
+	val8 = rtl8712_dl_fw( padapter);
+	if (val8 == _FAIL){
+		RT_TRACE(_module_hal_init_c_, _drv_err_, ("FW Download fail!\n"));
+		status = _FAIL;
+		goto exit;
+	}
+        RT_TRACE(_module_hal_init_c_, _drv_alert_, ("rtl8712_hal_init #2 == SYS_FUNC_EN:0x%08x\n", read8(padapter,0x10250003)));
+
+	//register setting after firmware download
+	//val32 = 0;
+	//val32 = read32(padapter, RCR);//RCR
+	//write32(padapter, RCR, (val32|BIT(0)));
+	//RT_TRACE(_module_hal_init_c_,_drv_err_,("RCR=0x%x \n",  read32(padapter, RCR)));
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	printk("1 RCR=0x%x\n",  read32(padapter, RCR));
+	val32 = read32(padapter, RCR);//RCR
+	write32(padapter, RCR, (val32|BIT(26))); //Enable RX TCP Checksum offload
+	RT_TRACE(_module_hal_init_c_,_drv_err_,("RCR=0x%x\n",  read32(padapter, RCR)));
+	printk("2 RCR=0x%x \n",  read32(padapter, RCR));
+#endif	
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	printk("1 TCR=0x%x \n",  read32(padapter, TCR));
+	val32 = read32(padapter, TCR);
+	write32(padapter, TCR, (val32|BIT(25))); //Enable TX TCP Checksum offload
+	RT_TRACE(_module_hal_init_c_,_drv_err_,("TCR=0x%x \n",  read32(padapter, TCR)));
+	printk("2 TCR=0x%x \n",  read32(padapter, TCR));
+#endif	
+	val32 = read32(padapter, RCR);
+	write32(padapter, RCR, (val32|BIT(25))); //Append PHY status
+
+	val32 = 0;
+	val32 = read32(padapter, 0x10250040);
+	write32(padapter,  0x10250040, (val32&0x00FFFFFF));
+
+#ifdef CONFIG_SDIO_HCI
+	write8(padapter, 0x10250006, 0x3B);
+//	write8(padapter, 0x1025003a, 0x72);
+	write8(padapter, 0x10250040, 0xFC);
+
+	write8(padapter, TXPAUSE, 0x00); // 0x10250042
+
+	write8(padapter, SDIO_DBG_SEL, 0x0); // RTL8712_SDIO_LOCAL_BASE + 0xFF
+
+	// enable interrupt
+	write16(padapter, SDIO_HIMR, 0xF);
+	RT_TRACE(_module_hal_init_c_, _drv_debug_, ("write SDIO_HIMR 0xF\n"));
+#endif
+
+#ifdef CONFIG_USB_HCI
+	//for usb rx aggregation	
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x102500B5=0x%x\n", read8(padapter, 0x102500B5)));
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x102500D9=0x%x\n", read8(padapter, 0x102500D9)));
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x102500BD=0x%x\n", read8(padapter, 0x102500BD)));
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x1025FE5B=0x%x\n", read8(padapter, 0x1025FE5B)));
+	
+	write8(padapter, 0x102500B5, read8(padapter, 0x102500B5)|BIT(0));//page = 128bytes
+#ifdef CONFIG_USB_RX_AGGREGATION
+	write8(padapter, 0x102500BD, read8(padapter, 0x102500BD)|BIT(7));//enable usb rx aggregation
+#else
+	write8(padapter, 0x102500BD, read8(padapter, 0x102500BD) & (~ BIT(7) ) );//disable usb rx aggregation
+#endif //CONFIG_USB_RX_AGGREGATION
+	//write8(padapter, 0x102500D9, 48);//TH = 48 pages, 6k
+	write8(padapter, 0x102500D9, 1);// TH=1 => means that invalidate  usb rx aggregation
+	//write8(padapter, 0x1025FE5B, 0x02);// 1.7ms/2
+	write8(padapter, 0x1025FE5B, 0x04);// 1.7ms/4
+
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x102500B5=0x%x\n", read8(padapter, 0x102500B5)));
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x102500D9=0x%x\n", read8(padapter, 0x102500D9)));
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x102500BD=0x%x\n", read8(padapter, 0x102500BD)));
+	RT_TRACE(_module_hal_init_c_,_drv_debug_,("0x1025FE5B=0x%x\n", read8(padapter, 0x1025FE5B)));
+
+	// Fix the RX FIFO issue(USB error), Rivesed by Roger, 2008-06-14
+	val8 = read8(padapter, 0x1025fe5C);
+	write8(padapter, 0x1025fe5C, val8|BIT(7));
+#endif
+
+	//read hw_mac address
+	//val32 = read32(padapter, MACID);
+	//_memcpy(padapter->eeprompriv.mac_addr, &val32, 4);
+	//val32 = read32(padapter, MACID+4);
+	//_memcpy(padapter->eeprompriv.mac_addr+4, &val32, 2);
+
+	{
+		int i;
+		u8 val8;
+		for (i = 0; i < 6; i++) {
+			val8 = read8(padapter, MACID+i);
+			padapter->eeprompriv.mac_addr[i] = val8;			
+		}
+#if 0
+		printk("MAC Address = %x-%x-%x-%x-%x-%x\n", 
+				 peeprompriv->mac_addr[0],	peeprompriv->mac_addr[1],
+				 peeprompriv->mac_addr[2],	peeprompriv->mac_addr[3],
+			peeprompriv->mac_addr[4],	peeprompriv->mac_addr[5]);
+#endif
+	}
+				 
+	RT_TRACE(_module_hal_init_c_, _drv_debug_,
+		 ("MAC Address=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  peeprompriv->mac_addr[0], peeprompriv->mac_addr[1], peeprompriv->mac_addr[2],
+		  peeprompriv->mac_addr[3], peeprompriv->mac_addr[4], peeprompriv->mac_addr[5]));
+
+exit:
+
+_func_exit_;
+
+	return status;
+}
+
+uint rtl8712_hal_deinit(_adapter *padapter)
+{
+#ifdef CONFIG_USB_HCI
+	RT_TRACE(_module_hal_init_c_,_drv_info_,("+rtl8712_hal_deinit\n"));
+
+	//write8(padapter, 0x1025004c, 0x0);
+
+	//write hw_mac address back
+	
+	//write32(padapter, MACID, *((u32*)padapter->eeprompriv.mac_addr));
+	
+	//write32(padapter, MACID+4, *((u32*)(padapter->eeprompriv.mac_addr+4)));
+	
+	//write32(padapter, 0x102502ec, 0x00ff0000);
+	
+#if 0
+	// Turn off RF
+	PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					0x00, bMask20Bits, 0x00000);
+#else
+	write8(padapter, RF_CTRL, 0x00);
+#endif
+
+	// Turn off BB	
+	//write8(padapter, CR+1, 0x07);
+	mdelay_os(5);
+
+	// Turn off MAC	
+	//write8(padapter, SYS_CLKR+1, 0x78); // Switch Control Path
+	write8(padapter, SYS_CLKR+1, 0x38); // Switch Control Path	
+	write8(padapter, SYS_FUNC_EN+1, 0x70); // Reset MACTOP, IOREG, 4181
+	write8(padapter, PMC_FSM, 0x06);  // Enable Loader Data Keep
+	write8(padapter, SYS_ISO_CTRL, 0xF9); // Isolation signals from CORE, PLL
+	write8(padapter, SYS_ISO_CTRL+1, 0xe8); // Enable EFUSE 1.2V(LDO) 
+	//write8(padapter, SYS_ISO_CTRL+1, 0x69); // Isolation signals from Loader
+	write8(padapter, AFE_PLL_CTRL, 0x00); // Disable AFE PLL.
+	write8(padapter, LDOA15_CTRL, 0x54);  // Disable A15V
+	write8(padapter, SYS_FUNC_EN+1, 0x50); // Disable E-Fuse 1.2V
+
+	//write8(padapter, SPS1_CTRL, 0x64); // Disable LD12 & SW12 (for IT)
+	write8(padapter, LDOV12D_CTRL, 0x24); // Disable LDO12(for CE)
+	
+	write8(padapter, AFE_MISC, 0x30); // Disable AFE BG&MB
+
+
+	// <Roger_Notes> The following  options are alternative.
+	// Disable 1.6V LDO or  1.8V Switch. 2008.09.26.
+
+	// Option for Disable 1.6V LDO.	
+	write8(padapter, SPS0_CTRL, 0x56); // Disable 1.6V LDO
+	write8(padapter, SPS0_CTRL+1, 0x43);  // Set SW PFM 
+
+	// Option for Disable 1.8V Switch.	
+	//write8(padapter, SPS0_CTRL, 0x55); // Disable SW 1.8V
+	
+#if 0
+	//
+	// HCT12.0
+	//
+	for(idx = 0; idx < 6; idx++)
+	{
+		PlatformEFIOWrite1Byte(padapter, (IDR0+idx), Adapter->PermanentAddress[idx]);
+	}
+#endif
+
+	RT_TRACE(_module_hal_init_c_,_drv_info_,("-rtl8712_hal_deinit, success!\n"));
+
+	//NdisMDeregisterAdapterShutdownHandler(padapter->hndis_adapter);
+
+	return _SUCCESS;
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+	u8 i = 60;
+
+	write16(padapter, SDIO_HIMR, 0x00);	// Disable interrupt
+
+	write8(padapter, RF_CTRL, 0x00);
+	usleep_os(100);
+	write8(padapter, SYS_CLKR+1, 0x38); // Switch Control Path
+	while (((read8(padapter, SYS_CLKR+1) & 0x40) != BIT(6)) && (i > 0)) {
+		msleep_os(10);
+		i--;
+	}
+
+	write8(padapter, SYS_FUNC_EN+1, 0x70); // Reset MACTOP, IOREG, 4181
+
+	write8(padapter, PMC_FSM, 0x06);  // Enable Loader Data Keep
+
+	write8(padapter, SYS_ISO_CTRL, 0xFF); // Isolation signals from CORE, PLL
+
+	write8(padapter, SYS_ISO_CTRL+1, 0xF6); // Enable EFUSE 1.2V(LDO) (E8)
+
+
+	write8(padapter, AFE_PLL_CTRL, 0x00); // Disable AFE PLL.
+
+	write8(padapter, LDOA15_CTRL, 0x54);  // Disable A15V
+
+	write8(padapter, SYS_FUNC_EN+1, 0x50); // Disable E-Fuse 1.2V
+
+	write8(padapter, AFE_MISC, 0x0); // Disable AFE BG&MB  (30)
+
+	RT_TRACE(_module_hal_init_c_, _drv_notice_, ("-rtl8712_hal_deinit, success!\n"));
+
+	return _SUCCESS;
+
+#endif	
+}
+
+//#define _DO_SRAM_TEST_
+
+#ifdef _DO_SRAM_TEST_
+
+/*
+BISR Test flow:
+1. write 0x310[3] = 1, Mbist clock enable
+2. write 0x310[11:8] = 0000: Mbist report select
+    0x310[3:0] = 1011           : Mbist mode = BISR
+3. wait mbisr done ( about 10ms)
+4. Read 0x310[31:16] to check report
+    0x310[25]: iram_bisr_done
+    0x310[26]: iram_bisr_fail
+    0x310[27]: iram_bisr_repaired
+    0x310[28]: iram_bisr_out_diff
+    0x310[29]: iram_bisr_unrepairable
+0x310[25] = 1 and 0x310[26] = 0,SRAM bisr pass
+5. write 0x310[3:0] =  0000 : leave mbisr mode
+*/
+
+#define BIST_REG 0x10250310
+
+#define IRAM_BISR_DONE				BIT(25)
+#define IRAM_BISR_FAIL				BIT(26)
+#define IRAM_BISR_REPAIRED			BIT(27)
+#define IRAM_BISR_OUT_DIFF			BIT(28)
+#define IRAM_BISR_UNREPAIRABLE	BIT(29)
+
+static uint iram_test(_adapter *padapter) 
+{
+	u32 val32;
+	u32 report = 0;
+
+	RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ iram_test !!!!!\n"));	
+
+	//step 1.Mbist clock enable,write 0x310[3] = 1
+	val32 = read32(padapter, BIST_REG);	
+	val32|= BIT(3);
+	RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ iram_test !!!!! #step 1 - Mbist clock enable (0x%08x)\n",val32));	
+	write32(padapter,  BIST_REG, val32);
+
+
+	//step 2.Mbist report select,write 0x310[11:8] = 0000
+	val32 = read32(padapter, BIST_REG);	
+	val32 &= 0xFFFFF0FF;
+	RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ iram_test !!!!! #step 2 - Mbist report select (0x%08x)\n",val32));	
+	write32(padapter,  BIST_REG, val32);	
+
+
+	//step 3.Mbist mode = BISR,0x310[3:0] = 1011
+	val32 = read32(padapter, BIST_REG);	
+	val32 &= 0xFFFFFFFB;
+	RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ iram_test !!!!! #step 3 -Mbist mode (0x%08x)\n",val32));	
+	write32(padapter,  BIST_REG, val32);		
+
+	msleep_os(100);//delay 10 mini seconds
+
+	//step 4.Read 0x310[31:16] to check report
+	val32 = read32(padapter, BIST_REG);
+		
+	report =(val32 & 0xFFFF0000);
+	
+	if((report& IRAM_BISR_DONE ) && (!(report&IRAM_BISR_FAIL))){ 
+		RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@  Internal SRAM- bisr test pass !!!!! (0x%08x)\n",val32));
+	}
+	if(report&IRAM_BISR_FAIL){ 
+		RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@  Internal SRAM- bisr test fail !!!!!! (0x%08x)\n",val32));		
+	}
+	if(report&IRAM_BISR_REPAIRED){
+		RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@  Internal SRAM - bisr test fail - repaired !!!!! (0x%08x)\n",val32));
+	}
+	if(report&IRAM_BISR_OUT_DIFF){
+		RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@  Internal SRAM  bisr test fail - out diff !!!!! (0x%08x)\n",val32));
+	}
+	if(report&IRAM_BISR_UNREPAIRABLE){
+		RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ Internal SRAM - bisr test fail - unrepairable !!!!! (0x%08x)\n",val32));		
+	}
+	RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ iram_test !!!!! #step 4 - check report (0x%08x) \n",report));		
+
+	//step 5.leave mbisr mode: write 0x310[3:0] = 0000 
+	val32 = read32(padapter, BIST_REG);	
+	val32  &= 0xFFFFFFF0;
+	RT_TRACE(_module_hal_init_c_,_drv_alert_,("@@@@@ iram_test !!!!! #step 5 - leave mbisr mode  (0x%08x)\n",val32));	
+	write32(padapter,  BIST_REG, val32);
+
+	return _SUCCESS;
+}
+#endif
+
+uint rtl871x_hal_init(_adapter *padapter)
+{
+	u8 val8;	 
+	uint status = _SUCCESS;
+	
+	 padapter->hw_init_completed=_FALSE;
+	if(padapter->halpriv.hal_bus_init ==NULL)
+	{
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("\nInitialize halpriv.hal_bus_init error!!!\n"));
+		status = _FAIL;
+		goto exit;
+	}
+	else
+	{
+		val8=padapter->halpriv.hal_bus_init(padapter);
+		if(val8==_FAIL)
+		{
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("rtl871x_hal_init: hal_bus_init fail\n"));
+			status= _FAIL;
+			goto exit;
+		}
+	}
+
+#ifdef _DO_SRAM_TEST_
+	iram_test(padapter) ;	
+#endif
+
+	status = rtl8712_hal_init(padapter);
+	if( status==_SUCCESS)
+		padapter->hw_init_completed=_TRUE;
+	else
+		padapter->hw_init_completed=_FALSE;
+exit:
+
+	RT_TRACE(_module_hal_init_c_,_drv_err_,("-rtl871x_hal_init:status=0x%x\n",status));
+
+	return status;
+
+}	
+
+uint rtl871x_hal_deinit(_adapter *padapter)
+{
+	u8	val8;
+	uint	res=_SUCCESS;
+
+_func_enter_;
+
+	if (padapter->halpriv.hal_bus_deinit == NULL) {
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("\nInitialize halpriv.hal_bus_init error!!!\n"));
+		res = _FAIL;
+		goto exit;
+	} else {
+		val8=padapter->halpriv.hal_bus_deinit(padapter);
+
+		if (val8 ==_FAIL) {
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtl871x_hal_init: hal_bus_init fail\n"));		
+			res= _FAIL;
+			goto exit;
+
+		}
+	}
+
+	res = rtl8712_hal_deinit(padapter);
+
+	padapter->hw_init_completed = _FALSE;
+
+exit:
+
+_func_exit_;
+	
+	return res;
+}
+
diff --git a/drivers/net/wireless/8712u/hal/rtl8712/usb_halinit.c b/drivers/net/wireless/8712u/hal/rtl8712/usb_halinit.c
new file mode 100755
index 0000000..55355e3
--- /dev/null
+++ b/drivers/net/wireless/8712u/hal/rtl8712/usb_halinit.c
@@ -0,0 +1,461 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _HCI_HAL_INIT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <hal_init.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#ifndef CONFIG_USB_HCI
+
+#error "CONFIG_USB_HCI shall be on!\n"
+
+#endif
+
+
+#include <usb_ops.h>
+#include <usb_hal.h>
+#include <usb_osintf.h>
+
+
+u8 usb_hal_bus_init(_adapter * padapter)
+{
+	u8	val8 = 0;
+	u8	ret;
+	u8			PollingCnt = 20;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	
+	ret =_SUCCESS;
+
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_,("chip_version=%d\n", pregistrypriv->chip_version));	
+	
+	//pregistrypriv->chip_version = RTL8712_2ndCUT;//RTL8712_1stCUT;
+
+	
+	if(pregistrypriv->chip_version == RTL8712_FPGA)
+	{
+		val8 = 0x01;
+		write8(padapter, SYS_CLKR, val8);//switch to 80M clock
+
+		val8 = read8(padapter, SPS1_CTRL);
+		val8 = val8 |0x01;
+		write8(padapter, SPS1_CTRL, val8);//enable VSPS12 LDO Macro block
+
+		val8 = read8(padapter, AFE_MISC);
+		val8 = val8 |0x01;
+		write8(padapter, AFE_MISC, val8);//Enable AFE Macro Block's Bandgap
+
+		val8 = read8(padapter, LDOA15_CTRL);
+		val8 = val8 |0x01;
+		write8(padapter, LDOA15_CTRL, val8);//enable LDOA15 block
+
+		val8 = read8(padapter, SPS1_CTRL);
+		val8 = val8 |0x02;
+		write8(padapter, SPS1_CTRL, val8);//Enable VSPS12_SW Macro Block
+
+		val8 = read8(padapter, AFE_MISC);
+		val8 = val8 |0x02;
+		write8(padapter, AFE_MISC, val8);//Enable AFE Macro Block's Mbias
+
+
+		val8 = read8(padapter, SYS_ISO_CTRL+1);
+		val8 = val8 |0x08;
+		write8(padapter, SYS_ISO_CTRL+1, val8);//isolate PCIe Analog 1.2V to PCIe 3.3V and PCIE Digital
+
+		val8 = read8(padapter, SYS_ISO_CTRL+1);
+		val8 = val8 & 0xEF;
+		write8(padapter, SYS_ISO_CTRL+1, val8);//attatch AFE PLL to MACTOP/BB/PCIe Digital
+
+
+		val8 = read8(padapter, AFE_XTAL_CTRL+1);
+		val8 = val8 & 0xFB;
+		write8(padapter, AFE_XTAL_CTRL+1, val8);//enable AFE clock
+
+		val8 = read8(padapter, AFE_PLL_CTRL);
+		val8 = val8 |0x01;
+		write8(padapter, AFE_PLL_CTRL, val8);//Enable AFE PLL Macro Block
+
+	
+		val8 = 0xEE;
+		write8(padapter, SYS_ISO_CTRL, val8);//release isolation AFE PLL & MD
+
+		val8 = read8(padapter, SYS_CLKR+1);
+		val8 = val8 |0x08;
+		write8(padapter, SYS_CLKR+1, val8);//enable MAC clock
+
+		val8 = read8(padapter, SYS_FUNC_EN+1);
+		val8 = val8 |0x08;
+		write8(padapter, SYS_FUNC_EN+1, val8);//enable Core digital and enable IOREG R/W
+
+		val8 = val8 |0x80;
+		write8(padapter, SYS_FUNC_EN+1, val8);//enable REG_EN
+		
+	
+		val8 = read8(padapter, SYS_CLKR+1);
+		val8 = (val8 |0x80)&0xBF;
+		write8(padapter, SYS_CLKR + 1, val8);//switch the control path
+
+
+		val8 = 0xFC;
+		write8(padapter, CR, val8);	
+
+		val8 = 0x37;
+		write8(padapter, CR+1, val8);		
+
+#define USE_SIX_USB_ENDPOINT		
+#ifdef USE_SIX_USB_ENDPOINT
+		//reduce EndPoint & init it
+    	   	write8(padapter, 0x102500ab, read8(padapter, 0x102500ab)|BIT(6)|BIT(7));
+#endif
+
+		//consideration of power consumption - init
+		write8(padapter, 0x10250008, read8(padapter, 0x10250008)&0xfffffffb);       
+
+	
+
+	}
+	else if(pregistrypriv->chip_version == RTL8712_1stCUT)
+	{
+		//Initialization for power on sequence, Revised by Roger. 2008.09.03.
+
+		//Revised POS, suggested by SD1 Alex, 2008.09.27.
+		write8(padapter, SPS0_CTRL+1, 0x53);
+		write8(padapter, SPS0_CTRL, 0x57);
+
+		//Enable AFE Macro Block's Bandgap adn Enable AFE Macro Block's Mbias
+		val8 = read8(padapter, AFE_MISC);	
+		write8(padapter, AFE_MISC, (val8|AFE_MISC_BGEN|AFE_MISC_MBEN));
+
+		//Enable LDOA15 block
+		val8 = read8(padapter, LDOA15_CTRL);	
+		write8(padapter, LDOA15_CTRL, (val8|LDA15_EN));
+
+		val8 = read8(padapter, SPS1_CTRL);	
+		write8(padapter, SPS1_CTRL, (val8|SPS1_LDEN));
+
+		msleep_os(2);
+
+		//Enable Switch Regulator Block
+		val8 = read8(padapter, SPS1_CTRL);	
+		write8(padapter, SPS1_CTRL, (val8|SPS1_SWEN));
+
+		write32(padapter, SPS1_CTRL, 0x00a7b267);//?
+ 	
+		val8 = read8(padapter, SYS_ISO_CTRL+1);	
+		write8(padapter, SYS_ISO_CTRL+1, (val8|0x08));
+
+		//Engineer Packet CP test Enable
+		val8 = read8(padapter, SYS_FUNC_EN+1);	
+		write8(padapter, SYS_FUNC_EN+1, (val8|0x20));
+
+		val8 = read8(padapter, SYS_ISO_CTRL+1);	
+		write8(padapter, SYS_ISO_CTRL+1, (val8& 0x6F));
+
+		//Enable AFE clock
+		val8 = read8(padapter, AFE_XTAL_CTRL+1);	
+		write8(padapter, AFE_XTAL_CTRL+1, (val8& 0xfb));
+
+		//Enable AFE PLL Macro Block
+		val8 = read8(padapter, AFE_PLL_CTRL);	
+		write8(padapter, AFE_PLL_CTRL, (val8|0x11));
+
+		//Attatch AFE PLL to MACTOP/BB/PCIe Digital
+		val8 = read8(padapter, SYS_ISO_CTRL);	
+		write8(padapter, SYS_ISO_CTRL, (val8&0xEE));
+
+		// Switch to 40M clock
+		val8 = read8(padapter, SYS_CLKR);
+		write8(padapter, SYS_CLKR, val8 & (~ SYS_CLKSEL));
+
+		//SSC Disable
+		val8 = read8(padapter, SYS_CLKR);	
+		//write8(padapter, SYS_CLKR, (val8&0x5f));
+
+		//Enable MAC clock
+		val8 = read8(padapter, SYS_CLKR+1);	
+		write8(padapter, SYS_CLKR+1, (val8|0x18));
+
+		//Revised POS, suggested by SD1 Alex, 2008.09.27.
+		write8(padapter, PMC_FSM, 0x02);
+	
+		//Enable Core digital and enable IOREG R/W
+		val8 = read8(padapter, SYS_FUNC_EN+1);	
+		write8(padapter, SYS_FUNC_EN+1, (val8|0x08));
+
+		//Enable REG_EN
+		val8 = read8(padapter, SYS_FUNC_EN+1);	
+		write8(padapter, SYS_FUNC_EN+1, (val8|0x80));
+
+		//Switch the control path to FW
+		val8 = read8(padapter, SYS_CLKR+1);	
+		write8(padapter, SYS_CLKR+1, (val8|0x80)& 0xBF);
+
+		write8(padapter, CR, 0xFC);	
+		
+		write8(padapter, CR+1, 0x37);	
+
+		//Fix the RX FIFO issue(usb error), 970410
+		val8 = read8(padapter, 0x1025FE5c);	
+		write8(padapter, 0x1025FE5c, (val8|BIT(7)));
+
+#define USE_SIX_USB_ENDPOINT		
+#ifdef USE_SIX_USB_ENDPOINT
+		val8 = read8(padapter, 0x102500ab);	
+		write8(padapter, 0x102500ab, (val8|BIT(6)|BIT(7)));
+#endif
+
+	 	//For power save, used this in the bit file after 970621
+		val8 = read8(padapter, SYS_CLKR);	
+		write8(padapter, SYS_CLKR, val8&(~CPU_CLKSEL));
+
+	}
+	else if(pregistrypriv->chip_version == RTL8712_2ndCUT || pregistrypriv->chip_version == RTL8712_3rdCUT)
+	{
+		//Initialization for power on sequence, Revised by Roger. 2008.09.03.
+
+		//E-Fuse leakage prevention sequence
+		write8(padapter, 0x37, 0xb0);
+		msleep_os(10);
+		write8(padapter, 0x37, 0x30);
+		
+
+		//
+		//<Roger_Notes> Set control path switch to HW control and reset Digital Core,  CPU Core and 
+		// MAC I/O to solve FW download fail when system from resume sate.
+		// 2008.11.04.
+		//
+		val8 = read8(padapter, SYS_CLKR+1);
+		//DbgPrint("SYS_CLKR+1=0x%x\n", val8);
+		if(val8 & 0x80)
+		{
+       			val8 &= 0x3f;
+              		write8(padapter, SYS_CLKR+1, val8);
+		}
+	   
+      		val8 = read8(padapter, SYS_FUNC_EN+1);
+		val8 &= 0x73;
+		write8(padapter, SYS_FUNC_EN+1, val8);
+		udelay_os(1000);
+
+		//Revised POS, suggested by SD1 Alex, 2008.09.27.
+		write8(padapter, SPS0_CTRL+1, 0x53); // Switching 18V to PWM.
+
+		write8(padapter, SPS0_CTRL, 0x57);
+
+		//Enable AFE Macro Block's Bandgap adn Enable AFE Macro Block's Mbias
+		val8 = read8(padapter, AFE_MISC);	
+		write8(padapter, AFE_MISC, (val8|AFE_MISC_BGEN)); //Bandgap
+		//write8(padapter, AFE_MISC, (val8|AFE_MISC_BGEN|AFE_MISC_MBEN));
+		write8(padapter, AFE_MISC, (val8|AFE_MISC_BGEN|AFE_MISC_MBEN | AFE_MISC_I32_EN)); //Mbios
+		
+		//Enable PLL Power (LDOA15V)
+		val8 = read8(padapter, LDOA15_CTRL);	
+		write8(padapter, LDOA15_CTRL, (val8|LDA15_EN));
+
+		//Enable LDOV12D block
+		val8 = read8(padapter, LDOV12D_CTRL);	
+		write8(padapter, LDOV12D_CTRL, (val8|LDV12_EN));	
+	
+		val8 = read8(padapter, SYS_ISO_CTRL+1);	
+		write8(padapter, SYS_ISO_CTRL+1, (val8|0x08));
+
+		//Engineer Packet CP test Enable
+		val8 = read8(padapter, SYS_FUNC_EN+1);	
+		write8(padapter, SYS_FUNC_EN+1, (val8|0x20));
+
+		//Support 64k IMEM, suggested by SD1 Alex.
+		val8 = read8(padapter, SYS_ISO_CTRL+1);	
+		write8(padapter, SYS_ISO_CTRL+1, (val8&0x68));
+
+		//Enable AFE clock
+		val8 = read8(padapter, AFE_XTAL_CTRL+1);	
+		write8(padapter, AFE_XTAL_CTRL+1, (val8& 0xfb));
+
+		//Enable AFE PLL Macro Block
+		val8 = read8(padapter, AFE_PLL_CTRL);	
+		write8(padapter, AFE_PLL_CTRL, (val8|0x11));
+
+		//(20090928) for some sample will download fw failure
+		// Added comment by Albert 2010/02/24
+		// The clock will be stable with 500 us delay after reset the PLL
+		udelay_os(500);
+		write8(padapter, AFE_PLL_CTRL, (val8|0x51));
+		udelay_os(500);
+		write8(padapter, AFE_PLL_CTRL, (val8|0x11));
+		udelay_os(500);		
+
+		//Attatch AFE PLL to MACTOP/BB/PCIe Digital
+		val8 = read8(padapter, SYS_ISO_CTRL);	
+		write8(padapter, SYS_ISO_CTRL, (val8&0xEE));
+
+		// Switch to 40M clock
+		write8(padapter, SYS_CLKR, 0x00);
+
+		//CPU Clock and 80M Clock SSC Disable to overcome FW download fail timing issue.
+		val8 = read8(padapter, SYS_CLKR);	
+		write8(padapter, SYS_CLKR, (val8|0xa0));
+
+		//Enable MAC clock
+		val8 = read8(padapter, SYS_CLKR+1);	
+		write8(padapter, SYS_CLKR+1, (val8|0x18));
+
+		//Revised POS, suggested by SD1 Alex, 2008.09.27.
+		write8(padapter, PMC_FSM, 0x02);
+	
+		//Enable Core digital and enable IOREG R/W
+		val8 = read8(padapter, SYS_FUNC_EN+1);	
+		write8(padapter, SYS_FUNC_EN+1, (val8|0x08));
+
+		//Enable REG_EN
+		val8 = read8(padapter, SYS_FUNC_EN+1);	
+		write8(padapter, SYS_FUNC_EN+1, (val8|0x80));
+
+		//Switch the control path to FW
+		val8 = read8(padapter, SYS_CLKR+1);	
+		write8(padapter, SYS_CLKR+1, (val8|0x80)& 0xBF);
+
+		write8(padapter, CR, 0xFC);	
+		write8(padapter, CR+1, 0x37);	
+
+		//Fix the RX FIFO issue(usb error), 970410
+		val8 = read8(padapter, 0x1025FE5c);	
+		write8(padapter, 0x1025FE5c, (val8|BIT(7)));
+
+#if 0	//fw will help set it depending on the fwpriv.
+#define USE_SIX_USB_ENDPOINT		
+#ifdef USE_SIX_USB_ENDPOINT
+		val8 = read8(padapter, 0x102500ab);	
+		write8(padapter, 0x102500ab, (val8|BIT(6)|BIT(7)));
+#endif
+#endif
+	 	//For power save, used this in the bit file after 970621
+		val8 = read8(padapter, SYS_CLKR);	
+		write8(padapter, SYS_CLKR, val8&(~CPU_CLKSEL));
+
+		// Revised for 8051 ROM code wrong operation. Added by Roger. 2008.10.16. 
+		write8(padapter, 0x1025fe1c, 0x80);
+
+		//
+		// <Roger_EXP> To make sure that TxDMA can ready to download FW.
+		// We should reset TxDMA if IMEM RPT was not ready.
+		// Suggested by SD1 Alex. 2008.10.23.
+		//
+		do
+		{
+			val8 = read8(padapter, TCR);
+			if((val8 & _TXDMA_INIT_VALUE) == _TXDMA_INIT_VALUE)
+				break;	
+			
+			udelay_os(5);//PlatformStallExecution(5);
+		}while(PollingCnt--);	// Delay 1ms
+	
+		if(PollingCnt <= 0 )
+		{
+			//ERR_8712("MacConfigBeforeFwDownloadASIC(): Polling _TXDMA_INIT_VALUE timeout!! Current TCR(%#x)\n", val8);
+
+			val8 = read8(padapter, CR);	
+			
+			write8(padapter, CR, val8&(~_TXDMA_EN));
+			
+			udelay_os(2);//PlatformStallExecution(2);
+			
+			write8(padapter, CR, val8|_TXDMA_EN);// Reset TxDMA
+		}
+	}
+	else
+	{
+		ret = _FAIL;
+	}
+	
+	return ret;
+
+}
+ u8 usb_hal_bus_deinit(_adapter * padapter)
+ {
+
+_func_enter_;
+
+_func_exit_;
+	
+	return _SUCCESS;
+ }
+
+unsigned int usb_inirp_init(_adapter * padapter)
+{	
+	u8 i;	
+	struct recv_buf *precvbuf;
+	uint	status;
+	struct dvobj_priv *pdev=&padapter->dvobjpriv;
+	struct intf_hdl * pintfhdl=&padapter->pio_queue->intf;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+_func_enter_;
+
+	status = _SUCCESS;
+
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
+		
+	precvpriv->ff_hwaddr = RTL8712_DMA_RX0FF;//mapping rx fifo address
+	
+	//issue Rx irp to receive data	
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
+	for(i=0; i<NR_RECVBUFF; i++)
+	{
+		if(usb_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
+		{
+			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
+			status = _FAIL;
+			goto exit;
+		}
+		
+		precvbuf++;		
+		precvpriv->free_recv_buf_queue_cnt--;
+	}
+	
+		
+exit:
+	
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
+
+_func_exit_;
+
+	return status;
+
+}
+
+unsigned int usb_inirp_deinit(_adapter * padapter)
+{	
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
+	
+	usb_read_port_cancel(padapter);
+
+
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
+
+	return _SUCCESS;
+}
+
diff --git a/drivers/net/wireless/8712u/hal/rtl8712/usb_ops.c b/drivers/net/wireless/8712u/hal/rtl8712/usb_ops.c
new file mode 100755
index 0000000..1ff55f6
--- /dev/null
+++ b/drivers/net/wireless/8712u/hal/rtl8712/usb_ops.c
@@ -0,0 +1,312 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _HCI_OPS_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+#include <usb_ops.h>
+#include <recv_osdep.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+	#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifndef CONFIG_USB_HCI
+	#error "CONFIG_USB_HCI shall be on!\n"
+#endif
+
+
+#ifdef PLATFORM_LINUX
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#ifdef PLATFORM_OS_XP
+#include <usb.h>
+#include <usbdlib.h>
+#include <usbioctl.h>
+#endif
+#endif
+
+#include <rtl871x_byteorder.h>
+
+u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x01;//read_in
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;	
+	
+	usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len, requesttype);
+
+	_func_exit_;
+
+	return (u8)(le32_to_cpu(data)&0x0ff);
+		
+}
+u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
+{       
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x01;//read_in
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;	
+	
+	usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len, requesttype);
+
+	_func_exit_;
+
+	return (u16)(le32_to_cpu(data)&0xffff);
+	
+}
+u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x01;//read_in
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;	
+	
+	usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len, requesttype);
+
+	_func_exit_;
+
+	return le32_to_cpu(data);
+	
+}
+void usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+	
+	data = val;
+	data = cpu_to_le32(data&0x000000ff);
+	
+	usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len, requesttype);
+	
+	_func_exit_;
+	
+}
+void usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
+{	
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+	
+	data = val;
+	data = cpu_to_le32(data&0x0000ffff);
+	
+	usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len, requesttype);
+	
+	_func_exit_;
+	
+}
+
+void usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	data = cpu_to_le32(val);	
+	
+	usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len, requesttype);
+	
+	_func_exit_;
+	
+}
+
+void usb_set_intf_option(u32 *poption)
+{
+	
+	*poption = ((*poption) | _INTF_ASYNC_);
+	_func_enter_;
+	_func_exit_;
+	
+}
+
+void usb_intf_hdl_init(u8 *priv)
+{
+	_func_enter_;
+	_func_exit_;
+	
+	
+}
+
+void usb_intf_hdl_unload(u8 *priv)
+{
+	
+	_func_enter_;
+	_func_exit_;
+	
+}
+void usb_intf_hdl_open(u8 *priv)
+{
+	_func_enter_;
+	_func_exit_;
+	
+	
+}
+
+void usb_intf_hdl_close(u8 *priv)
+{
+	
+	_func_enter_;
+	_func_exit_;
+	
+	
+}
+
+
+void usb_set_intf_funs(struct intf_hdl *pintf_hdl)
+{
+	
+	pintf_hdl->intf_hdl_init = &usb_intf_hdl_init;
+	pintf_hdl->intf_hdl_unload = &usb_intf_hdl_unload;
+	pintf_hdl->intf_hdl_open = &usb_intf_hdl_open;
+	pintf_hdl->intf_hdl_close = &usb_intf_hdl_close;
+	
+	_func_enter_;
+
+	_func_exit_;
+}
+
+void usb_set_intf_ops(struct _io_ops	*pops)
+{
+	_func_enter_;
+	
+	_memset((u8 *)pops, 0, sizeof(struct _io_ops));	
+
+	pops->_read8 = &usb_read8;
+	pops->_read16 = &usb_read16;
+	pops->_read32 = &usb_read32;
+	pops->_read_mem = &usb_read_mem;
+	pops->_read_port = &usb_read_port;	
+	
+	pops->_write8 = &usb_write8;
+	pops->_write16 = &usb_write16;
+	pops->_write32 = &usb_write32;
+	pops->_write_mem = &usb_write_mem;
+	pops->_write_port = &usb_write_port;	   
+
+	_func_exit_;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+void io_irp_timeout_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	)
+#endif
+#ifdef PLATFORM_LINUX
+void io_irp_timeout_handler(void *FunctionContext)
+#endif
+{
+       struct intf_priv *pintfpriv= ( struct intf_priv *)FunctionContext;
+
+
+_func_enter_;		
+	RT_TRACE(_module_hci_ops_c_,_drv_err_,("^^^io_irp_timeout_handler ^^^\n"));
+	
+#ifdef PLATFORM_LINUX
+	//pintfpriv->bio_irp_timeout=_TRUE;
+	usb_kill_urb(pintfpriv->piorw_urb);
+#endif		
+_func_exit_;	
+
+}
+
diff --git a/drivers/net/wireless/8712u/hal/rtl8712/usb_ops_linux.c b/drivers/net/wireless/8712u/hal/rtl8712/usb_ops_linux.c
new file mode 100755
index 0000000..9a4d268
--- /dev/null
+++ b/drivers/net/wireless/8712u/hal/rtl8712/usb_ops_linux.c
@@ -0,0 +1,1110 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _HCI_OPS_OS_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+#include <usb_ops.h>
+#include <circ_buf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#define	RTL871X_VENQT_READ	0xc0
+#define	RTL871X_VENQT_WRITE	0x40
+
+struct zero_bulkout_context
+{
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+
+#define usb_write_cmd usb_write_mem 
+//#define usb_read_cmd usb_read_mem
+#define usb_write_cmd_complete usb_write_mem_complete
+//#define usb_read_cmd_complete usb_read_mem_complete
+
+#define RTW_USB_CONTROL_MSG_TIMEOUT		500
+#define RTW_USB_CONTROL_RETRY_CNT		10
+
+uint usb_init_intf_priv(struct intf_priv *pintfpriv)
+{
+_func_enter_;
+	
+	//pintfpriv->intf_status = _IOREADY;
+
+	//_init_timer(&pintfpriv->io_timer, padapter->pnetdev, io_irp_timeout_handler, pintfpriv);
+	
+	pintfpriv->piorw_urb = usb_alloc_urb(0, GFP_ATOMIC);	
+	if(pintfpriv->piorw_urb==NULL)
+	{		
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("pintfpriv->piorw_urb==NULL!!!\n"));
+		goto usb_init_intf_priv_fail;
+	}	
+	
+	_init_sema(&(pintfpriv->io_retevt), 0);
+
+_func_exit_;
+
+	return _SUCCESS;
+
+usb_init_intf_priv_fail:
+
+	if(pintfpriv->piorw_urb)
+	{
+		usb_free_urb(pintfpriv->piorw_urb);
+	}	
+
+_func_exit_;
+
+	return _FAIL;
+		
+}
+
+void usb_unload_intf_priv(struct intf_priv *pintfpriv)
+{
+
+_func_enter_;
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("+usb_unload_intf_priv\n"));
+
+	if(pintfpriv->piorw_urb)
+	{
+		usb_kill_urb(pintfpriv->piorw_urb);
+		usb_free_urb(pintfpriv->piorw_urb);
+	}
+
+	_free_sema(&(pintfpriv->io_retevt));
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("-usb_unload_intf_priv\n"));
+
+_func_exit_;
+	
+}
+
+int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
+{
+	int pipe=0;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	
+	if(pdvobj->nr_endpoint == 11)
+	{		
+		switch(addr)
+		{	    
+			case RTL8712_DMA_BKQ:
+			 	pipe=usb_sndbulkpipe(pusbd, 0x07);
+				break;
+	     		case RTL8712_DMA_BEQ:
+		 		pipe=usb_sndbulkpipe(pusbd, 0x06);
+				break;	     		
+	     		case RTL8712_DMA_VIQ:
+		 		pipe=usb_sndbulkpipe(pusbd, 0x05);
+				break;
+	    		case RTL8712_DMA_VOQ:
+				pipe=usb_sndbulkpipe(pusbd, 0x04);
+				break;					
+                     case RTL8712_DMA_BCNQ:	
+				pipe=usb_sndbulkpipe(pusbd, 0x0a);
+				break;	 	
+			case RTL8712_DMA_BMCQ:	//HI Queue
+				pipe=usb_sndbulkpipe(pusbd, 0x0b);
+				break;	
+			case RTL8712_DMA_MGTQ:				
+		 		pipe=usb_sndbulkpipe(pusbd, 0x0c);
+				break;
+                     case RTL8712_DMA_RX0FF:
+				pipe=usb_rcvbulkpipe(pusbd, 0x03);//in
+				break;	 	
+			case RTL8712_DMA_C2HCMD:		 	
+				pipe=usb_rcvbulkpipe(pusbd, 0x09);//in
+				break;
+			case RTL8712_DMA_H2CCMD:
+				pipe=usb_sndbulkpipe(pusbd, 0x0d);
+				break;	
+				
+		}
+
+	}
+	else if(pdvobj->nr_endpoint == 6)
+	{
+		switch(addr)
+		{	    
+	     		case RTL8712_DMA_BKQ:
+			 	pipe=usb_sndbulkpipe(pusbd, 0x07);
+				break;
+	     		case RTL8712_DMA_BEQ:
+		 		pipe=usb_sndbulkpipe(pusbd, 0x06);
+				break;	     		
+	     		case RTL8712_DMA_VIQ:
+		 		pipe=usb_sndbulkpipe(pusbd, 0x05);
+				break;
+	    		case RTL8712_DMA_VOQ:
+				pipe=usb_sndbulkpipe(pusbd, 0x04);
+				break;					
+                     case RTL8712_DMA_RX0FF:
+			case RTL8712_DMA_C2HCMD:		 	
+				pipe=usb_rcvbulkpipe(pusbd, 0x03);//in
+				break;
+			case RTL8712_DMA_H2CCMD:
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:			
+				pipe=usb_sndbulkpipe(pusbd, 0x0d);
+				break;	
+				
+		}
+
+	}
+	else if(pdvobj->nr_endpoint == 4)
+	{
+		switch(addr)
+		{		        
+	     		case RTL8712_DMA_BEQ:
+		 	//case RTL8712_DMA_BKQ:
+			 	//pipe=usb_sndbulkpipe(pusbd, 0x05);
+			 	pipe=usb_sndbulkpipe(pusbd, 0x06);	
+				break;		
+	     		//case RTL8712_DMA_VIQ:
+		 	case RTL8712_DMA_VOQ:					
+		 		pipe=usb_sndbulkpipe(pusbd, 0x04);
+				break;
+			case RTL8712_DMA_RX0FF:
+			case RTL8712_DMA_C2HCMD:		 	
+				pipe=usb_rcvbulkpipe(pusbd, 0x03);//in
+				break;
+			case RTL8712_DMA_H2CCMD:	
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:				
+				pipe=usb_sndbulkpipe(pusbd, 0x0d);
+				break;	
+		}
+	
+	}
+	else
+	{
+	   RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pdvobj->nr_endpoint));
+	   pipe = 0;
+	}
+		
+	return pipe;
+
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+static void usb_bulkout_zero_complete(struct urb *purb)
+#else
+static void usb_bulkout_zero_complete(struct urb *purb, struct pt_regs *regs)
+#endif
+{	
+	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
+
+	//printk("+usb_bulkout_zero_complete\n");
+	
+	if(pcontext)
+	{
+		if(pcontext->pbuf)
+		{			
+			_mfree(pcontext->pbuf, sizeof(int));	
+		}	
+
+		if(pcontext->purb && (pcontext->purb==purb))
+		{
+			usb_free_urb(pcontext->purb);
+		}
+
+	
+		_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));	
+	}	
+	
+
+}
+
+u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
+{	
+	int pipe, status, len;
+	u32 ret;
+	unsigned char *pbuf;
+	struct zero_bulkout_context *pcontext;
+	PURB	purb = NULL;	
+	_adapter *padapter = (_adapter *)pintfhdl->adapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;	
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	//printk("+usb_bulkout_zero\n");
+	
+		
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{		
+		return _FAIL;
+	}
+	
+
+	pcontext = (struct zero_bulkout_context *)_malloc(sizeof(struct zero_bulkout_context));
+
+	pbuf = (unsigned char *)_malloc(sizeof(int));	
+    	purb = usb_alloc_urb(0, GFP_ATOMIC);
+      	
+	len = 0;
+	pcontext->pbuf = pbuf;
+	pcontext->purb = purb;
+	pcontext->pirp = NULL;
+	pcontext->padapter = padapter;
+
+	
+	//translate DMA FIFO addr to pipehandle
+	pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+	usb_fill_bulk_urb(purb, pusbd, pipe, 
+       				pbuf,
+              			len,
+              			usb_bulkout_zero_complete,
+              			pcontext);//context is pcontext
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+
+	if (!status)
+	{		
+		ret= _SUCCESS;
+	}
+	else
+	{
+		ret= _FAIL;
+	}
+	
+	
+	return _SUCCESS;
+
+}
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	_func_enter_;
+	
+
+	
+	_func_exit_;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+static void usb_write_mem_complete(struct urb *purb)
+#else
+static void usb_write_mem_complete(struct urb *purb, struct pt_regs *regs)
+#endif
+{		
+	_irqL irqL;
+	_list	*head, *plist;
+	struct io_queue *pio_q = (struct io_queue *)purb->context;
+	struct intf_hdl *pintf = &(pio_q->intf);	
+	struct intf_priv *pintfpriv = pintf->pintfpriv;	
+	_adapter *padapter = (_adapter *)pintf->adapter;
+	struct xmit_priv * pxmitpriv = &padapter->xmitpriv;
+	struct dvobj_priv * pdvobjpriv = (struct dvobj_priv *)&padapter->dvobjpriv;
+        struct usb_device       *pusbd = pdvobjpriv->pusbdev;
+	
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("+usb_write_mem_complete\n"));
+
+	if(padapter->bSurpriseRemoved || padapter->bDriverStopped)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("usb_write_mem_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+	}
+	
+	if(purb->status==0)
+	{
+
+	}
+	else
+	{
+		printk("wm_comp: status:%d\n",purb->status);
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem_complete : purb->status(%d) != 0 \n", purb->status));
+		
+		if(purb->status == (-ESHUTDOWN))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem_complete: ESHUTDOWN\n"));
+			
+			padapter->bDriverStopped=_TRUE;
+			
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem_complete:bDriverStopped=TRUE\n"));
+			
+		}
+		else if(purb->status==-EPIPE||purb->status == -EPROTO)
+		{
+
+			//printk("wm_comp: work around for pipe error (%d)!\n", purb->status);
+
+			//if(purb->pipe == usb_sndbulkpipe(pusbd, 0x04))
+			//	_set_workitem(&pxmitpriv->xmit_pipe4_reset_wi);
+			//if(purb->pipe == usb_sndbulkpipe(pusbd, 0x06))
+			//	_set_workitem(&pxmitpriv->xmit_pipe6_reset_wi);			
+			//if(purb->pipe == usb_sndbulkpipe(pusbd, 0x0d))
+			//	_set_workitem(&pxmitpriv->xmit_piped_reset_wi);
+		}
+		else
+		{			
+			padapter->bSurpriseRemoved=_TRUE;
+			
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem_complete:bSurpriseRemoved=TRUE\n"));
+		}		
+
+	}
+	
+	_up_sema(&pintfpriv->io_retevt);
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_mem_complete\n"));
+
+_func_exit_;	
+
+}
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	_irqL	irqL;
+	int status, pipe;
+	struct io_req *pio_req=NULL;	
+	_adapter *padapter = (_adapter *)pintfhdl->adapter;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	struct io_queue *pio_queue = (struct io_queue *)padapter->pio_queue;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	PURB piorw_urb = pintfpriv->piorw_urb;
+	
+_func_enter_;	
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_mem\n"));
+
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		goto exit;
+	}
+
+	//translate DMA FIFO addr to pipehandle
+	pipe = ffaddr2pipehdl(pdvobj, addr);
+	if(pipe==0)
+	{
+	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem, pipe=%x\n", pipe));	
+		goto exit;
+	}
+	
+	usb_fill_bulk_urb(piorw_urb, pusbd, pipe, 
+       			    wmem,
+              		    cnt,
+              		    usb_write_mem_complete,
+              		    pio_queue);
+	
+
+        //piorw_urb->transfer_flags |= URB_ZERO_PACKET;
+      
+	status = usb_submit_urb(piorw_urb, GFP_ATOMIC);
+
+	if (!status)
+	{		
+		
+	}
+	else
+	{
+		//TODO:		
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("usb_write_mem(): usb_submit_urb err, status=%x\n", status));
+	}
+
+	_down_sema(&pintfpriv->io_retevt);
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_mem\n"));
+	
+exit:
+	
+_func_exit_;
+	
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+static void usb_read_port_complete(struct urb *purb)
+#else
+static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
+#endif
+{
+	_irqL irqL;
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;	
+	_adapter 			*padapter =(_adapter *)precvbuf->adapter;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;	
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
+	
+	//Useless for linux usb driver.
+	//2010-03-10 by Thomas
+	//_enter_critical(&precvpriv->lock, &irqL);
+	//precvbuf->irp_pending=_FALSE;
+	//precvpriv->rx_pending_cnt --;
+	//_exit_critical(&precvpriv->lock, &irqL);
+
+	//if(precvpriv->rx_pending_cnt== 0)
+	//{		
+	//	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
+	//	_up_sema(&precvpriv->allrxreturnevt);
+	//}
+
+	if(padapter->bSurpriseRemoved ||padapter->bDriverStopped)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		goto exit;
+	}
+
+	if(purb->status==0)//SUCCESS
+	{
+		if((purb->actual_length>(MAX_RECVBUF_SZ)) || (purb->actual_length < RXDESC_SIZE)) 
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
+			precvbuf->reuse = _TRUE;
+			read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		}
+		else 
+		{	
+			precvbuf->transfer_len = purb->actual_length;
+
+			pbuf = (uint*)precvbuf->pbuf;
+
+			if((isevt = le32_to_cpu(*(pbuf+1))&0x1ff) == 0x1ff)
+			{				
+				//_irqL  irqL;
+					
+				//_enter_critical( &padapter->lockRxFF0Filter, &irqL );
+				//if ( padapter->blnEnableRxFF0Filter )
+				//{
+				//	padapter->blnEnableRxFF0Filter = 0;
+				//}
+				//_exit_critical( &padapter->lockRxFF0Filter, &irqL );
+					
+				//MSG_8712("usb_read_port_complete():rxcmd_event_hdl\n");
+
+				rxcmd_event_hdl(padapter, pbuf);//rx c2h events
+
+				precvbuf->reuse = _TRUE;
+
+				read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+			}
+			else
+			{
+	#ifdef CONFIG_RECV_TASKLET
+					
+				_pkt *pskb = precvbuf->pskb;				
+
+				skb_put(pskb, purb->actual_length);	
+				skb_queue_tail(&precvpriv->rx_skb_queue, pskb);
+					
+				tasklet_hi_schedule(&precvpriv->recv_tasklet);
+
+				precvbuf->pskb = NULL;
+				precvbuf->reuse = _FALSE;
+				read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+	#else
+				if(recvbuf2recvframe(padapter, precvbuf)==_FAIL)//rx packets
+				{
+					precvbuf->reuse = _TRUE;		
+					read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+				}
+	#endif
+			}
+		}	
+		
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
+		printk( "[%s] purb->status(%d) != 0\n", __FUNCTION__, purb->status );
+		switch(purb->status) {
+			case -EINVAL:
+			case -EPIPE:			
+			case -ENODEV:
+			case -ESHUTDOWN:
+				//padapter->bSurpriseRemoved=_TRUE;
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
+			case -ENOENT:
+				padapter->bDriverStopped=_TRUE;
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
+				break;
+			case -EPROTO:
+				precvbuf->reuse = _TRUE;
+				read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+				break;
+			case -EINPROGRESS:
+				printk("ERROR: URB IS IN PROGRESS!/n");
+				break;
+			default:
+				break;
+		}
+	}	
+
+exit:	
+	
+_func_exit_;
+	
+}
+
+u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{	
+	_irqL irqL;
+	int err, pipe;
+	u32 tmpaddr=0;
+        int alignment=0;
+	u32 ret = _SUCCESS;
+	PURB purb = NULL;	
+	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
+	struct intf_priv	*pintfpriv = pintfhdl->pintfpriv;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;
+	_adapter			*adapter = (_adapter *)pdvobj->padapter;
+	struct recv_priv	*precvpriv = &adapter->recvpriv;
+	struct usb_device	*pusbd = pdvobj->pusbdev;
+	
+
+_func_enter_;
+	
+	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+	if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
+	{
+		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
+		{
+			precvbuf->reuse = _TRUE;
+		}
+	}
+#endif
+	
+
+	if(precvbuf !=NULL)
+	{	
+		init_recvbuf(adapter, precvbuf);		
+
+		//re-assign for linux based on skb
+		if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
+		{
+			//precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#else			
+			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#endif			
+			if(precvbuf->pskb == NULL)		
+			{
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
+				return _FAIL;
+			}	
+
+			tmpaddr = (u32)precvbuf->pskb->data;
+	        	alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+	       	        skb_reserve(precvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));			
+
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = precvbuf->pskb->tail;
+			precvbuf->pend = precvbuf->pskb->end;
+
+       		precvbuf->pbuf = precvbuf->pskb->data;		
+		
+		}	
+		else//reuse skb
+		{
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = precvbuf->pskb->tail;
+			precvbuf->pend = precvbuf->pskb->end;
+
+       		precvbuf->pbuf = precvbuf->pskb->data;
+		
+			precvbuf->reuse = _FALSE;
+		}
+	
+		//Useless for linux usb driver.
+		//2010-03-10 by Thomas
+		//_enter_critical(&precvpriv->lock, &irqL);
+		//precvpriv->rx_pending_cnt++;
+		//precvbuf->irp_pending = _TRUE;
+		//_exit_critical(&precvpriv->lock, &irqL);
+		
+		purb = precvbuf->purb;		
+
+		//translate DMA FIFO addr to pipehandle
+		pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+		usb_fill_bulk_urb(purb, pusbd, pipe, 
+						precvbuf->pbuf,
+                				MAX_RECVBUF_SZ,
+                				usb_read_port_complete,
+                				precvbuf);//context is precvbuf
+
+		err = usb_submit_urb(purb, GFP_ATOMIC);	
+
+		if((err) && (err != (-EPERM)))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
+			ret = _FAIL;
+		}
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
+		ret = _FAIL;
+	}
+
+_func_exit_;
+	
+	return ret;
+	
+}
+
+void usb_read_port_cancel(_adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+
+	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_read_port_cancel\n"));
+
+	for(i=0; i < NR_RECVBUFF ; i++)
+	{
+		precvbuf->reuse == _TRUE;
+		if(precvbuf->purb)
+		{
+			usb_kill_urb(precvbuf->purb);
+		}
+		precvbuf++;	
+	}
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_read_port_cancel\n"));
+}
+
+void xmit_bh(void *priv)
+{	
+	int ret = _FALSE;
+	_adapter *padapter = (_adapter*)priv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	
+	//while(1)
+	//{
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		{
+			printk("xmit_bh => bDriverStopped or bSurpriseRemoved \n");
+			return;
+			//break;
+		}
+
+		ret = xmitframe_complete(padapter, pxmitpriv, NULL);
+
+		if(ret==_FALSE)
+			return;
+			//break;
+		else
+			tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	//}
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+static void usb_write_port_complete(struct urb *purb)
+#else
+static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
+#endif
+{
+	_irqL irqL;
+	int i;
+	struct xmit_frame	*pxmitframe = (struct xmit_frame *)purb->context;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	_adapter			*padapter = pxmitframe->padapter;		
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;		
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	struct dvobj_priv * pdvobjpriv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct usb_device *pusbd=pdvobjpriv->pusbdev;	   
+
+_func_enter_;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port_complete\n"));
+
+	//_enter_critical(&pxmitpriv->lock, &irqL);
+	
+	switch(pattrib->priority) 
+	{
+		case 1:				
+		case 2:
+			pxmitpriv->bkq_cnt--;
+			//printk("pxmitpriv->bkq_cnt=%d\n", pxmitpriv->bkq_cnt);
+			break;
+		case 4:
+		case 5:
+			pxmitpriv->viq_cnt--;
+			//printk("pxmitpriv->viq_cnt=%d\n", pxmitpriv->viq_cnt);
+			break;
+		case 6:
+		case 7:
+			pxmitpriv->voq_cnt--;
+			//printk("pxmitpriv->voq_cnt=%d\n", pxmitpriv->voq_cnt);
+			break;
+		case 0:
+		case 3:			
+		default:
+			pxmitpriv->beq_cnt--;
+			//printk("pxmitpriv->beq_cnt=%d\n", pxmitpriv->beq_cnt);
+			break;
+			
+	}
+	
+	pxmitpriv->txirp_cnt--;
+
+	for(i=0; i< 8; i++)
+	{
+            if(purb == pxmitframe->pxmit_urb[i])
+            {
+		    pxmitframe->bpending[i] = _FALSE;//		  
+		    break;		  
+            }
+	}
+	
+	//_exit_critical(&pxmitpriv->lock, &irqL);
+	
+	//Useless for linux usb driver.
+	//2010-03-10 by Thomas
+	//if(pxmitpriv->txirp_cnt==0)
+	//{
+	//	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
+	//	_up_sema(&(pxmitpriv->tx_retevt));
+	//}
+	
+	if(padapter->bSurpriseRemoved)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		goto exit;
+	}
+
+	if(purb->status==0||purb->status==-EPIPE||purb->status==-EPROTO)
+	{
+		if(purb->status == -EPIPE|| purb->status == -EPROTO)
+		{
+			printk("wp_comp: work around for pipe error (%d)!\n", purb->status);
+
+			//if(purb->pipe == usb_sndbulkpipe(pusbd, 0x04))
+			//	_set_workitem(&pxmitpriv->xmit_pipe4_reset_wi);
+			//if(purb->pipe == usb_sndbulkpipe(pusbd, 0x06))
+			//	_set_workitem(&pxmitpriv->xmit_pipe6_reset_wi);			
+			//if(purb->pipe == usb_sndbulkpipe(pusbd, 0x0d))
+			//	_set_workitem(&pxmitpriv->xmit_piped_reset_wi);
+			
+			//usb_clear_halt(pusbdev,purb->pipe);
+
+			//int result;
+			//result = usb_control_msg(pusbdev, purb->pipe,
+          		//	USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,
+			//	USB_ENDPOINT_HALT, usb_pipeendpoint(purb->pipe),
+			//	NULL, 0, 10*HZ);
+		
+		        /* reset the endpoint toggle */
+        		//if (result >= 0)
+			//	usb_settoggle(pusbdev, usb_pipeendpoint(purb->pipe),
+			//		usb_pipeout(purb->pipe), 0);	
+
+			//msleep(10);
+		}
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0 \n", purb->status));
+		/*if(purb->status == (-ESHUTDOWN))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: ESHUTDOWN\n"));
+			
+			padapter->bDriverStopped=_TRUE;
+			
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped=TRUE\n"));
+			
+		}
+		else
+		{			
+			padapter->bSurpriseRemoved=_TRUE;
+			
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
+		}		
+
+		goto exit;*/
+	}	
+
+
+#if 0	
+	pxmitframe->fragcnt--;
+	if(pxmitframe->fragcnt == 0)// if((pxmitframe->fragcnt == 0) && (pxmitframe->irpcnt == 8)){
+	{
+		//RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port_complete:pxmitframe->fragcnt == 0\n"));
+		free_xmitframe(pxmitpriv,pxmitframe);	          
+      	}
+#else	
+
+	//not to consider tx fragment
+	free_xmitframe_ex(pxmitpriv, pxmitframe);		
+
+#endif	
+
+#ifdef CONFIG_XMIT_BH
+	free_xmitbuf(pxmitpriv, pxmitbuf);
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+#else
+	xmitframe_complete(padapter, pxmitpriv, pxmitbuf);
+#endif
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port_complete\n"));
+
+exit:
+
+_func_exit_;	
+
+}
+
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{    
+	_irqL irqL;
+	int i, pipe, status;
+	u32 ret, bwritezero;
+	PURB	purb = NULL;
+	_adapter *padapter = (_adapter *)pintfhdl->adapter;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;	
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	
+_func_enter_;	
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
+	
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+	
+	for(i=0; i<8; i++)
+       {
+		if(pxmitframe->bpending[i] == _FALSE)
+		{
+			_enter_critical(&pxmitpriv->lock, &irqL);
+
+			pxmitpriv->txirp_cnt++;
+			pxmitframe->bpending[i]  = _TRUE;
+
+			switch(pattrib->priority) 
+			{
+				case 1:				
+				case 2:				
+					pxmitpriv->bkq_cnt++;
+					break;
+				case 4:
+				case 5:
+					pxmitpriv->viq_cnt++;
+					break;
+				case 6:
+				case 7:
+					pxmitpriv->voq_cnt++;
+					break;
+				case 0:
+				case 3:			
+				default:
+					pxmitpriv->beq_cnt++;
+					break;		
+			}
+
+			_exit_critical(&pxmitpriv->lock, &irqL);
+			
+			pxmitframe->sz[i] = (u16)cnt;
+			purb	= pxmitframe->pxmit_urb[i];		
+			
+			break;	 
+		}
+		
+       }	
+
+	bwritezero = _FALSE;
+	if(pdvobj->ishighspeed)
+	{
+		if(cnt> 0 && cnt%512 == 0)
+		{
+			//printk("ishighspeed, cnt=%d\n", cnt);
+			bwritezero = _TRUE;
+		}	
+	}
+	else
+	{
+		if(cnt > 0 && cnt%64 == 0)
+		{
+			//printk("cnt=%d\n", cnt);
+			bwritezero = _TRUE;
+		}	
+	}
+	
+	//translate DMA FIFO addr to pipehandle
+	pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+#ifdef CONFIG_REDUCE_USB_TX_INT
+	//if ( (pxmitpriv->free_xmitbuf_cnt%2  == 0))
+	if ( pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0 )
+	{
+		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
+	} else {
+		purb->transfer_flags  |=  URB_NO_INTERRUPT;
+		//printk("URB_NO_INTERRUPT ");
+	}
+#endif
+
+	if ( bwritezero )
+	{
+		cnt += 8;
+	}
+	   
+	usb_fill_bulk_urb(purb, pusbd, pipe, 
+       				pxmitframe->mem_addr,
+              			cnt,
+              			usb_write_port_complete,
+              			pxmitframe);//context is xmit_frame
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+
+	if (!status)
+	{		
+		ret= _SUCCESS;
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port(): usb_submit_urb, status=%x\n", status));
+		ret= _FAIL;
+	}
+//   Commented by Albert 2009/10/13
+//   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
+/*	
+	if(bwritezero == _TRUE)
+	{
+		usb_bulkout_zero(pintfhdl, addr);
+	}
+*/
+
+_func_exit_;
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port\n"));
+	
+	return ret;
+
+}
+
+void usb_write_port_cancel(_adapter *padapter)
+{
+	int i,j;
+	struct xmit_buf	*pxmitbuf = (struct xmit_buf *)padapter->xmitpriv.pxmitbuf;
+
+	for(i=0; i<NR_XMITBUFF; i++)
+	{
+		for(j=0; j<8; j++)
+		{
+		        if(pxmitbuf->pxmit_urb[j])
+		        {
+		                usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+		        }
+		}
+		
+		pxmitbuf++;
+	}
+}
+
+int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	unsigned int pipe;
+	int status, intretry;
+	u8 reqtype;
+	struct dvobj_priv *pdvobjpriv = ( struct dvobj_priv *) pintfpriv->intf_dev;
+	struct usb_device *udev=pdvobjpriv->pusbdev;
+		
+	// Added by Albert 2010/02/09
+	// For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
+	// Trying to fix it here.
+
+	u8 *palloc_buf, *pIo_buf;
+
+	palloc_buf = _malloc( (u32) len + 16);
+	
+	if ( palloc_buf== NULL)
+	{
+		printk( "[%s] Can't alloc memory for vendor request\n", __FUNCTION__ );
+		return(-1);
+	}
+	
+	pIo_buf = palloc_buf + 16 -((uint)(palloc_buf) & 0x0f );
+	
+	if (requesttype == 0x01)
+	{
+		pipe = usb_rcvctrlpipe(udev, 0);//read_in
+		reqtype =  RTL871X_VENQT_READ;		
+	} 
+	else 
+	{
+		pipe = usb_sndctrlpipe(udev, 0);//write_out
+		reqtype =  RTL871X_VENQT_WRITE;		
+		_memcpy( pIo_buf, pdata, len);
+	}
+
+	intretry = 0;
+retry:
+	status = usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, RTW_USB_CONTROL_MSG_TIMEOUT );
+	
+	if (status < 0)
+       {
+		printk("retry = %d, reg 0x%x, usb read/write TimeOut! status:%d value=0x%x\n", intretry, value, status, *(u32*)pdata);
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("reg 0x%x, usb_read8 TimeOut! status:0x%x value=0x%x\n", value, status, *(u32*)pdata));
+		intretry++;
+		if ( intretry < RTW_USB_CONTROL_RETRY_CNT )
+		{
+			goto retry;
+		}
+       }
+	else if ( status > 0 )   // Success this control transfer.
+	{
+               if ( requesttype == 0x01 )
+               {   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
+                       _memcpy( pdata, pIo_buf,  status );
+               }
+	}
+
+	_mfree( palloc_buf, (u32) len + 16 );
+
+	return status;
+
+}
+
+
diff --git a/drivers/net/wireless/8712u/ifcfg-wlan0 b/drivers/net/wireless/8712u/ifcfg-wlan0
new file mode 100755
index 0000000..20dcbec
--- /dev/null
+++ b/drivers/net/wireless/8712u/ifcfg-wlan0
@@ -0,0 +1,4 @@
+#DHCP client
+DEVICE=wlan0
+BOOTPROTO=dhcp
+ONBOOT=yes
\ No newline at end of file
diff --git a/drivers/net/wireless/8712u/include/autoconf.h b/drivers/net/wireless/8712u/include/autoconf.h
new file mode 100755
index 0000000..6589e10
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/autoconf.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*
+ * Automatically generated C config: don't edit
+ */
+#define AUTOCONF_INCLUDED
+#define RTL871X_MODULE_NAME "RTL8712U-BGN"
+
+//#define CONFIG_DEBUG_RTL871X 1
+
+#define CONFIG_USB_HCI	1
+#undef  CONFIG_SDIO_HCI
+
+#undef CONFIG_RTL8711
+#define  CONFIG_RTL8712 1
+#undef  CONFIG_RTL8716
+
+
+#define CONFIG_IOCTL_CFG80211	1
+
+#ifdef CONFIG_IOCTL_CFG80211
+#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
+#endif //CONFIG_IOCTL_CFG80211
+
+//#define CONFIG_LITTLE_ENDIAN 1
+//#undef CONFIG_BIG_ENDIAN
+
+#undef PLATFORM_WINDOWS
+#undef PLATFORM_OS_XP 
+#undef PLATFORM_OS_CE
+
+
+#define PLATFORM_LINUX 1
+
+#define CONFIG_PWRCTRL	1
+//#define CONFIG_H2CLBK 1
+
+#define CONFIG_MP_INCLUDED
+
+//#undef CONFIG_EMBEDDED_FWIMG
+#define CONFIG_EMBEDDED_FWIMG 1
+
+#define CONFIG_R871X_TEST 1
+
+
+//#define CONFIG_DRVEXT_MODULE 1
+
+
+#ifdef CONFIG_RTL8712
+
+	#define CONFIG_DEBUG_RTL8712 1	
+
+	#define CONFIG_XMIT_ENQUEUE
+
+	//#define CONFIG_XMIT_DIRECT
+
+	#define CONFIG_80211N_HT 1
+
+	#define CONFIG_RECV_REORDERING_CTRL 1
+
+	#ifdef PLATFORM_LINUX
+
+		#define CONFIG_XMIT_BH 1
+		#define CONFIG_SKB_COPY 1
+
+		#define CONFIG_RECV_TASKLET 1		
+
+		#ifndef CONFIG_RECV_TASKLET
+			#define CONFIG_RECV_BH 1
+		#else			
+			#define CONFIG_PREALLOC_RECV_SKB 1
+		#endif
+	
+	#endif
+
+	#ifdef CONFIG_R871X_TEST
+
+		#define CONFIG_R8712_TEST 1
+
+		//#define CONFIG_MLME_EXT 1
+		//#define CONFIG_AP_MODE 1
+		//#define CONFIG_HOSTAPD_MODE 1	
+
+		#ifdef CONFIG_MLME_EXT
+			#define CONFIG_EVENT_THREAD_MODE 1
+		#endif  
+
+		//#define CONFIG_R8712_TEST_ASTA 1
+
+		#define CONFIG_R8712_TEST_BSTA 1			  
+
+	#endif
+
+	#define CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	#define CONFIG_REDUCE_USB_TX_INT
+
+#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+	//#define CONFIG_USB_TX_AGGREGATION	1
+	#define CONFIG_USB_RX_AGGREGATION	1
+#endif
+
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+
+	#define INTERNAL_MD5
+	#define INTERNAL_MD4
+	#define INTERNAL_DES
+	#define INTERNAL_SHA1
+	#define CONFIG_CRYPTO_INTERNAL
+	
+
+	#define CONFIG_INTERNAL_AES
+	#define CONFIG_INTERNAL_SHA1
+	#define CONFIG_INTERNAL_MD5
+	#define CONFIG_INTERNAL_SHA256
+
+	#define CONFIG_INTERNAL_LIBTOMMATH
+		
+	#define OPENSSL_NO_FP_API
+	#define OPENSSL_NO_ENGINE
+
+
+
+	#define CONFIG_NO_STDOUT_DEBUG 1
+
+	#define CONFIG_ETH_INTF	1
+
+	//#define CONFIG_WSC_CRYPTO_TEST	1
+	#ifdef CONFIG_WSC_CRYPTO_TEST
+	//#define CONFIG_WSC_CRYPTO_DH_TEST 1
+	//#define CONFIG_WSC_CRYPTO_SHA256_TEST 1
+	//#define CONFIG_WSC_CRYPTO_AES128_TEST 1
+	#endif
+
+
+	//#define CONFIG_DRVEXT_MODULE_WSC 1
+	
+	#ifdef CONFIG_DRVEXT_MODULE_WSC
+		//#define CONFIG_WSCCRYPTO_PREALLOC  1
+	#endif
+
+	//#define CONFIG_WSC_DEBUG 1  //for temmprarily setting debug
+	#ifdef CONFIG_WSC_DEBUG
+		#define allowed_ssid "802.11g-SSID"
+	#endif
+
+
+	#ifdef CONFIG_DEBUG_RTL871X
+
+		#define CONFIG_DEBUG_WSC 1
+		//#define CONFIG_DUMP_WSC_KEY	1
+
+		
+		#define CONFIG_DEBUG_WPA 1
+		//#define CONFIG_DUMP_WPA_KEY 1
+
+	#endif	
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/basic_types.h b/drivers/net/wireless/8712u/include/basic_types.h
new file mode 100755
index 0000000..e54b8bf
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/basic_types.h
@@ -0,0 +1,110 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+#include <drv_conf.h>
+
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+#ifndef TRUE
+	#define _TRUE	1
+#else
+	#define _TRUE	TRUE	
+#endif
+		
+#ifndef FALSE		
+	#define _FALSE	0
+#else
+	#define _FALSE	FALSE	
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+	typedef signed char s8;
+	typedef unsigned char u8;
+
+	typedef signed short s16;
+	typedef unsigned short u16;
+
+	typedef signed long s32;
+	typedef unsigned long u32;
+	
+	typedef unsigned int	uint;
+	typedef	signed int		sint;
+
+
+	typedef signed long long s64;
+	typedef unsigned long long u64;
+
+	#ifdef NDIS50_MINIPORT
+	
+		#define NDIS_MAJOR_VERSION       5
+		#define NDIS_MINOR_VERSION       0
+
+	#endif
+
+	#ifdef NDIS51_MINIPORT
+
+		#define NDIS_MAJOR_VERSION       5
+		#define NDIS_MINOR_VERSION       1
+
+	#endif
+
+
+#endif
+
+
+#ifdef PLATFORM_LINUX
+
+	#include <linux/types.h>
+	#define IN
+	#define OUT
+	#define VOID void
+	#define NDIS_OID uint
+	#define NDIS_STATUS uint
+	
+	
+	typedef	signed int sint;
+
+
+	#ifndef	PVOID
+	typedef void * PVOID;
+	//#define PVOID	(void *)
+	#endif
+
+        #define UCHAR u8
+	#define USHORT u16
+	#define UINT u32
+	#define ULONG u32	
+
+	typedef 	__kernel_size_t	SIZE_T;	
+	#define FIELD_OFFSET(s,field)	((int)&((s*)(0))->field)
+	
+#endif
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+
+#endif //__BASIC_TYPES_H__
+
diff --git a/drivers/net/wireless/8712u/include/byteorder/big_endian.h b/drivers/net/wireless/8712u/include/byteorder/big_endian.h
new file mode 100755
index 0000000..69d8fe7
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/byteorder/big_endian.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include <byteorder/swab.h>
+
+#define __constant_htonl(x) ((__u32)(x))
+#define __constant_ntohl(x) ((__u32)(x))
+#define __constant_htons(x) ((__u16)(x))
+#define __constant_ntohs(x) ((__u16)(x))
+#define __constant_cpu_to_le64(x) ___constant_swab64((x))
+#define __constant_le64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_le32(x) ___constant_swab32((x))
+#define __constant_le32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_le16(x) ___constant_swab16((x))
+#define __constant_le16_to_cpu(x) ___constant_swab16((x))
+#define __constant_cpu_to_be64(x) ((__u64)(x))
+#define __constant_be64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_be32(x) ((__u32)(x))
+#define __constant_be32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_be16(x) ((__u16)(x))
+#define __constant_be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64(x) __swab64((x))
+#define __le64_to_cpu(x) __swab64((x))
+#define __cpu_to_le32(x) __swab32((x))
+#define __le32_to_cpu(x) __swab32((x))
+#define __cpu_to_le16(x) __swab16((x))
+#define __le16_to_cpu(x) __swab16((x))
+#define __cpu_to_be64(x) ((__u64)(x))
+#define __be64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_be32(x) ((__u32)(x))
+#define __be32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_be16(x) ((__u16)(x))
+#define __be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64p(x) __swab64p((x))
+#define __le64_to_cpup(x) __swab64p((x))
+#define __cpu_to_le32p(x) __swab32p((x))
+#define __le32_to_cpup(x) __swab32p((x))
+#define __cpu_to_le16p(x) __swab16p((x))
+#define __le16_to_cpup(x) __swab16p((x))
+#define __cpu_to_be64p(x) (*(__u64*)(x))
+#define __be64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_be32p(x) (*(__u32*)(x))
+#define __be32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_be16p(x) (*(__u16*)(x))
+#define __be16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do {} while (0)
+#define __be64_to_cpus(x) do {} while (0)
+#define __cpu_to_be32s(x) do {} while (0)
+#define __be32_to_cpus(x) do {} while (0)
+#define __cpu_to_be16s(x) do {} while (0)
+#define __be16_to_cpus(x) do {} while (0)
+
+#include <byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
diff --git a/drivers/net/wireless/8712u/include/byteorder/generic.h b/drivers/net/wireless/8712u/include/byteorder/generic.h
new file mode 100755
index 0000000..2aa2839
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/byteorder/generic.h
@@ -0,0 +1,209 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/*
+ * linux/byteorder_generic.h
+ * Generic Byte-reordering support
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19970707
+ *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
+ *    cleaned them up.
+ *    I hope it is compliant with non-GCC compilers.
+ *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
+ *    because I wasn't sure it would be ok to put it in types.h
+ *    Upgraded it to 2.1.43
+ * Francois-Rene Rideau <fare@tunes.org> 19971012
+ *    Upgraded it to 2.1.57
+ *    to please Linus T., replaced huge #ifdef's between little/big endian
+ *    by nestedly #include'd files.
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    Made it to 2.1.71; now a facelift:
+ *    Put files under include/linux/byteorder/
+ *    Split swab from generic support.
+ *
+ * TODO:
+ *   = Regular kernel maintainers could also replace all these manual
+ *    byteswap macros that remain, disseminated among drivers,
+ *    after some grep or the sources...
+ *   = Linus might want to rename all these macros and files to fit his taste,
+ *    to fit his personal naming scheme.
+ *   = it seems that a few drivers would also appreciate
+ *    nybble swapping support...
+ *   = every architecture could add their byteswap macro in asm/byteorder.h
+ *    see how some architectures already do (i386, alpha, ppc, etc)
+ *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
+ *    distinguished throughout the kernel. This is not the case currently,
+ *    since little endian, big endian, and pdp endian machines needn't it.
+ *    But this might be the case for, say, a port of Linux to 20/21 bit
+ *    architectures (and F21 Linux addict around?).
+ */
+
+/*
+ * The following macros are to be defined by <asm/byteorder.h>:
+ *
+ * Conversion of long and short int between network and host format
+ *	ntohl(__u32 x)
+ *	ntohs(__u16 x)
+ *	htonl(__u32 x)
+ *	htons(__u16 x)
+ * It seems that some programs (which? where? or perhaps a standard? POSIX?)
+ * might like the above to be functions, not macros (why?).
+ * if that's true, then detect them, and take measures.
+ * Anyway, the measure is: define only ___ntohl as a macro instead,
+ * and in a separate file, have
+ * unsigned long inline ntohl(x){return ___ntohl(x);}
+ *
+ * The same for constant arguments
+ *	__constant_ntohl(__u32 x)
+ *	__constant_ntohs(__u16 x)
+ *	__constant_htonl(__u32 x)
+ *	__constant_htons(__u16 x)
+ *
+ * Conversion of XX-bit integers (16- 32- or 64-)
+ * between native CPU format and little/big endian format
+ * 64-bit stuff only defined for proper architectures
+ *	cpu_to_[bl]eXX(__uXX x)
+ *	[bl]eXX_to_cpu(__uXX x)
+ *
+ * The same, but takes a pointer to the value to convert
+ *	cpu_to_[bl]eXXp(__uXX x)
+ *	[bl]eXX_to_cpup(__uXX x)
+ *
+ * The same, but change in situ
+ *	cpu_to_[bl]eXXs(__uXX x)
+ *	[bl]eXX_to_cpus(__uXX x)
+ *
+ * See asm-foo/byteorder.h for examples of how to provide
+ * architecture-optimized versions
+ *
+ */
+
+
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL)
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+#endif
+
+
+/*
+ * Handle ntohl and suches. These have various compatibility
+ * issues - like we want to give the prototype even though we
+ * also have a macro for them in case some strange program
+ * wants to take the address of the thing or something..
+ *
+ * Note that these used to return a "long" in libc5, even though
+ * long is often 64-bit these days.. Thus the casts.
+ *
+ * They have to be macros in order to do the constant folding
+ * correctly - if the argument passed into a inline function
+ * it is no longer constant according to gcc..
+ */
+
+#undef ntohl
+#undef ntohs
+#undef htonl
+#undef htons
+
+/*
+ * Do the prototypes. Somebody might want to take the
+ * address or some such sick thing..
+ */
+#if defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+extern __u32			ntohl(__u32);
+extern __u32			htonl(__u32);
+#else
+extern unsigned long int	ntohl(unsigned long int);
+extern unsigned long int	htonl(unsigned long int);
+#endif
+extern unsigned short int	ntohs(unsigned short int);
+extern unsigned short int	htons(unsigned short int);
+
+
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) ||  defined(PLATFORM_MPIXEL)
+
+#define ___htonl(x) __cpu_to_be32(x)
+#define ___htons(x) __cpu_to_be16(x)
+#define ___ntohl(x) __be32_to_cpu(x)
+#define ___ntohs(x) __be16_to_cpu(x)
+
+#if defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+#define htonl(x) ___htonl(x)
+#define ntohl(x) ___ntohl(x)
+#else
+#define htonl(x) ((unsigned long)___htonl(x))
+#define ntohl(x) ((unsigned long)___ntohl(x))
+#endif
+#define htons(x) ___htons(x)
+#define ntohs(x) ___ntohs(x)
+
+#endif /* OPTIMIZE */
+
+
+#if defined (PLATFORM_WINDOWS)
+
+#define htonl(x) __cpu_to_be32(x)
+#define ntohl(x) __be32_to_cpu(x)
+#define htons(x) __cpu_to_be16(x)
+#define ntohs(x) __be16_to_cpu(x)
+
+
+#endif
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
diff --git a/drivers/net/wireless/8712u/include/byteorder/little_endian.h b/drivers/net/wireless/8712u/include/byteorder/little_endian.h
new file mode 100755
index 0000000..72d2f51
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/byteorder/little_endian.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#include <byteorder/swab.h>
+
+#define __constant_htonl(x) ___constant_swab32((x))
+#define __constant_ntohl(x) ___constant_swab32((x))
+#define __constant_htons(x) ___constant_swab16((x))
+#define __constant_ntohs(x) ___constant_swab16((x))
+#define __constant_cpu_to_le64(x) ((__u64)(x))
+#define __constant_le64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_le32(x) ((__u32)(x))
+#define __constant_le32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_le16(x) ((__u16)(x))
+#define __constant_le16_to_cpu(x) ((__u16)(x))
+#define __constant_cpu_to_be64(x) ___constant_swab64((x))
+#define __constant_be64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_be32(x) ___constant_swab32((x))
+#define __constant_be32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_be16(x) ___constant_swab16((x))
+#define __constant_be16_to_cpu(x) ___constant_swab16((x))
+#define __cpu_to_le64(x) ((__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_le32(x) ((__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_le16(x) ((__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_be64(x) __swab64((x))
+#define __be64_to_cpu(x) __swab64((x))
+#define __cpu_to_be32(x) __swab32((x))
+#define __be32_to_cpu(x) __swab32((x))
+#define __cpu_to_be16(x) __swab16((x))
+#define __be16_to_cpu(x) __swab16((x))
+#define __cpu_to_le64p(x) (*(__u64*)(x))
+#define __le64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_le32p(x) (*(__u32*)(x))
+#define __le32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_le16p(x) (*(__u16*)(x))
+#define __le16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_be64p(x) __swab64p((x))
+#define __be64_to_cpup(x) __swab64p((x))
+#define __cpu_to_be32p(x) __swab32p((x))
+#define __be32_to_cpup(x) __swab32p((x))
+#define __cpu_to_be16p(x) __swab16p((x))
+#define __be16_to_cpup(x) __swab16p((x))
+#define __cpu_to_le64s(x) do {} while (0)
+#define __le64_to_cpus(x) do {} while (0)
+#define __cpu_to_le32s(x) do {} while (0)
+#define __le32_to_cpus(x) do {} while (0)
+#define __cpu_to_le16s(x) do {} while (0)
+#define __le16_to_cpus(x) do {} while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+
+#include <byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
diff --git a/drivers/net/wireless/8712u/include/byteorder/swab.h b/drivers/net/wireless/8712u/include/byteorder/swab.h
new file mode 100755
index 0000000..585d550
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/byteorder/swab.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _LINUX_BYTEORDER_SWAB_H
+#define _LINUX_BYTEORDER_SWAB_H
+
+#ifndef __u16
+typedef unsigned short __u16;
+#endif
+
+#ifndef __u32
+typedef unsigned int	__u32;
+#endif
+
+#ifndef __u8
+typedef unsigned char __u8;
+#endif
+
+#ifndef __u64
+typedef unsigned long long	__u64;	
+#endif
+
+
+static __inline __u16  ___swab16(__u16 x)
+{
+	__u16 __x = x; 
+	return 
+	((__u16)( 
+		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
+		(((__u16)(__x) & (__u16)0xff00U) >> 8) ));
+
+}
+
+static __inline __u32  ___swab32(__u32 x)
+{
+	__u32 __x = (x);
+	return ((__u32)(
+		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
+		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
+		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24) ));
+}
+
+static __inline __u64  ___swab64(__u64 x)
+{
+	__u64 __x = (x);
+	
+	return 
+	((__u64)( \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
+}
+
+#ifndef __arch__swab16
+static __inline __u16 __arch__swab16(__u16 x)
+{
+	return ___swab16(x);
+}
+
+#endif
+
+#ifndef __arch__swab32
+static __inline __u32 __arch__swab32(__u32 x)
+{
+	__u32 __tmp = (x) ; 
+	return ___swab32(__tmp);
+}
+#endif
+
+#ifndef __arch__swab64
+
+static __inline __u64 __arch__swab64(__u64 x)
+{
+	__u64 __tmp = (x) ; 
+	return ___swab64(__tmp);
+}
+
+
+#endif
+
+#define __swab16(x) __fswab16(x)
+#define __swab32(x) __fswab32(x)
+#define __swab64(x) __fswab64(x)
+
+static __inline const __u16 __fswab16(__u16 x)
+{
+	return __arch__swab16(x);
+}
+static __inline const __u32 __fswab32(__u32 x)
+{
+	return __arch__swab32(x);
+}
+
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS)
+#define swab16 __swab16
+#define swab32 __swab32
+#define swab64 __swab64
+#define swab16p __swab16p
+#define swab32p __swab32p
+#define swab64p __swab64p
+#define swab16s __swab16s
+#define swab32s __swab32s
+#define swab64s __swab64s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWAB_H */
diff --git a/drivers/net/wireless/8712u/include/byteorder/swabb.h b/drivers/net/wireless/8712u/include/byteorder/swabb.h
new file mode 100755
index 0000000..8c84bce
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/byteorder/swabb.h
@@ -0,0 +1,156 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _LINUX_BYTEORDER_SWABB_H
+#define _LINUX_BYTEORDER_SWABB_H
+
+/*
+ * linux/byteorder/swabb.h
+ * SWAp Bytes Bizarrely
+ *	swaHHXX[ps]?(foo)
+ *
+ * Support for obNUXIous pdp-endian and other bizarre architectures.
+ * Will Linux ever run on such ancient beasts? if not, this file
+ * will be but a programming pearl. Still, it's a reminder that we
+ * shouldn't be making too many assumptions when trying to be portable.
+ *
+ */
+
+/*
+ * Meaning of the names I chose (vaxlinux people feel free to correct them):
+ * swahw32	swap 16-bit half-words in a 32-bit word
+ * swahb32	swap 8-bit halves of each 16-bit half-word in a 32-bit word
+ *
+ * No 64-bit support yet. I don't know NUXI conventions for long longs.
+ * I guarantee it will be a mess when it's there, though :->
+ * It will be even worse if there are conflicting 64-bit conventions.
+ * Hopefully, no one ever used 64-bit objects on NUXI machines.
+ *
+ */
+
+#define ___swahw32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x0000ffffUL) << 16) | \
+		(((__u32)(__x) & (__u32)0xffff0000UL) >> 16) )); \
+})
+#define ___swahb32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x00ff00ffUL) << 8) | \
+		(((__u32)(__x) & (__u32)0xff00ff00UL) >> 8) )); \
+})
+
+#define ___constant_swahw32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x0000ffffUL) << 16) | \
+		(((__u32)(x) & (__u32)0xffff0000UL) >> 16) ))
+#define ___constant_swahb32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | \
+		(((__u32)(x) & (__u32)0xff00ff00UL) >> 8) ))
+
+/*
+ * provide defaults when no architecture-specific optimization is detected
+ */
+#ifndef __arch__swahw32
+#  define __arch__swahw32(x) ___swahw32(x)
+#endif
+#ifndef __arch__swahb32
+#  define __arch__swahb32(x) ___swahb32(x)
+#endif
+
+#ifndef __arch__swahw32p
+#  define __arch__swahw32p(x) __swahw32(*(x))
+#endif
+#ifndef __arch__swahb32p
+#  define __arch__swahb32p(x) __swahb32(*(x))
+#endif
+
+#ifndef __arch__swahw32s
+#  define __arch__swahw32s(x) do { *(x) = __swahw32p((x)); } while (0)
+#endif
+#ifndef __arch__swahb32s
+#  define __arch__swahb32s(x) do { *(x) = __swahb32p((x)); } while (0)
+#endif
+
+
+/*
+ * Allow constant folding
+ */
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
+#  define __swahw32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swahw32((x)) : \
+ __fswahw32((x)))
+#  define __swahb32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swahb32((x)) : \
+ __fswahb32((x)))
+#else
+#  define __swahw32(x) __fswahw32(x)
+#  define __swahb32(x) __fswahb32(x)
+#endif /* OPTIMIZE */
+
+
+static __inline__ __const__ __u32 __fswahw32(__u32 x)
+{
+	return __arch__swahw32(x);
+}
+static __inline__ __u32 __swahw32p(__u32 *x)
+{
+	return __arch__swahw32p(x);
+}
+static __inline__ void __swahw32s(__u32 *addr)
+{
+	__arch__swahw32s(addr);
+}
+
+
+static __inline__ __const__ __u32 __fswahb32(__u32 x)
+{
+	return __arch__swahb32(x);
+}
+static __inline__ __u32 __swahb32p(__u32 *x)
+{
+	return __arch__swahb32p(x);
+}
+static __inline__ void __swahb32s(__u32 *addr)
+{
+	__arch__swahb32s(addr);
+}
+
+#ifdef __BYTEORDER_HAS_U64__
+/*
+ * Not supported yet
+ */
+#endif /* __BYTEORDER_HAS_U64__ */
+
+#if defined(PLATFORM_LINUX)
+#define swahw32 __swahw32
+#define swahb32 __swahb32
+#define swahw32p __swahw32p
+#define swahb32p __swahb32p
+#define swahw32s __swahw32s
+#define swahb32s __swahb32s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWABB_H */
diff --git a/drivers/net/wireless/8712u/include/circ_buf.h b/drivers/net/wireless/8712u/include/circ_buf.h
new file mode 100755
index 0000000..0c9ca2a
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/circ_buf.h
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __CIRC_BUF_H_
+#define __CIRC_BUF_H_ 1
+
+#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))
+
+#define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))
+
+#endif //_CIRC_BUF_H_
diff --git a/drivers/net/wireless/8712u/include/cmd_osdep.h b/drivers/net/wireless/8712u/include/cmd_osdep.h
new file mode 100755
index 0000000..d321f09
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/cmd_osdep.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __CMD_OSDEP_H_
+#define __CMD_OSDEP_H_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+extern sint _init_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern sint _init_evt_priv(struct evt_priv *pevtpriv);
+extern void _free_evt_priv (struct	evt_priv *pevtpriv);
+extern void _free_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern sint _enqueue_cmd(_queue *queue, struct cmd_obj *obj);
+extern struct	cmd_obj	*_dequeue_cmd(_queue *queue);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/drv_conf.h b/drivers/net/wireless/8712u/include/drv_conf.h
new file mode 100755
index 0000000..a3520c2
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/drv_conf.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __DRV_CONF_H__
+#define __DRV_CONF_H__
+#include "autoconf.h"
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+//Older Android kernel doesn't has CONFIG_ANDROID defined,
+//add this to force CONFIG_ANDROID defined
+#ifdef CONFIG_PLATFORM_ANDROID
+#define CONFIG_ANDROID
+#endif
+
+#ifdef CONFIG_ANDROID
+//Some Android build will restart the UI while non-printable ascii is passed
+//between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID
+//for Android here. If you are sure there is no risk on your system about this,
+//mask this macro define to support non-printable ascii ssid.
+#define CONFIG_VALIDATE_SSID
+#endif
+
+//#include <rtl871x_byteorder.h>
+
+#endif // __DRV_CONF_H__
+
diff --git a/drivers/net/wireless/8712u/include/drv_types.h b/drivers/net/wireless/8712u/include/drv_types.h
new file mode 100755
index 0000000..dee03ea
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/drv_types.h
@@ -0,0 +1,361 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*-------------------------------------------------------------------------------
+	
+	For type defines and data structure defines
+
+--------------------------------------------------------------------------------*/
+
+
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+
+
+#ifdef CONFIG_RTL8711
+#include <rtl8711_spec.h>
+#endif
+#ifdef CONFIG_RTL8712
+#include <rtl8712_spec.h>
+#endif
+
+#ifdef PLATFORM_OS_XP
+#include <drv_types_xp.h>
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <drv_types_ce.h>
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <drv_types_linux.h>
+#endif
+
+enum _NIC_VERSION {
+	
+	RTL8711_NIC,
+	RTL8712_NIC,
+	RTL8713_NIC,
+	RTL8716_NIC
+		
+};
+
+
+typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
+
+#ifdef CONFIG_80211N_HT
+#include <rtl871x_ht.h>
+#endif
+
+#include <rtl871x_cmd.h>
+#include <wlan_bssdef.h>
+#include <rtl871x_xmit.h>
+#include <rtl871x_recv.h>
+#include <rtl871x_qos.h>
+#include <rtl871x_security.h>
+#include <rtl871x_pwrctrl.h>
+#include <rtl871x_io.h>
+#include <rtl871x_eeprom.h>
+#include <sta_info.h>
+#include <rtl871x_mlme.h>
+#include <rtl871x_mp.h>
+#include <rtl871x_debug.h>
+#include <rtl871x_rf.h>
+#include <rtl871x_event.h>
+#include <hal_init.h>
+#include <rtl871x_led.h>
+
+#ifdef CONFIG_DRVEXT_MODULE
+#include <rtl871x_drvext.h>
+#include <wsc_api.h>
+#endif
+
+#ifdef CONFIG_MLME_EXT
+#include <rtl871x_mlme_ext.h>
+#include <rtl871x_wlan_mlme.h>
+#include <rtl871x_wlan_sme.h>
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+	#include "ioctl_cfg80211.h"	
+#endif //CONFIG_IOCTL_CFG80211
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
+#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
+
+struct specific_device_id{
+	
+	u32		flags;
+	
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv
+{    
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	u8	network_mode;	//infra, ad-hoc, auto	  
+	NDIS_802_11_SSID	ssid;
+	u8	channel;//ad-hoc support requirement 
+	u8	wireless_mode;//A, B, G, auto
+	u8	vrtl_carrier_sense;//Enable, Disable, Auto
+	u8	vcs_type;//RTS/CTS, CTS-to-self
+	u16	rts_thresh;
+	u16  frag_thresh;	
+	u8	preamble;//long, short, auto
+	u8  scan_mode;//active, passive
+	u8  adhoc_tx_pwr;
+	u8      	     soft_ap;
+	u8      	     smart_ps;  
+	 u8                  power_mgnt;
+	 u8                  radio_enable;
+	 u8                  long_retry_lmt;
+	 u8                  short_retry_lmt;
+  	 u16                 busy_thresh;
+    	 u8                  ack_policy;
+	 u8		     mp_mode;	
+	 u8 		     software_encrypt;
+	 u8 		     software_decrypt;	  
+
+	  //UAPSD
+	  u8		     wmm_enable;
+	  u8		     uapsd_enable;	  
+	  u8		     uapsd_max_sp;
+	  u8		     uapsd_acbk_en;
+	  u8		     uapsd_acbe_en;
+	  u8		     uapsd_acvi_en;
+	  u8		     uapsd_acvo_en;	  
+
+	  WLAN_BSSID_EX    dev_network;
+
+#ifdef CONFIG_80211N_HT
+
+	u8		ht_enable;
+	u8		cbw40_enable;
+	u8		ampdu_enable;//for tx
+	
+
+#endif
+	u8		rf_config ;
+	u8		low_power ;
+	u8		wifi_test;
+	  
+	  
+};
+
+
+//For registry parameters
+#define RGTRY_OFT(field) ((ULONG)FIELD_OFFSET(struct registry_priv,field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv*) 0)->field)
+#define BSSID_OFT(field) ((ULONG)FIELD_OFFSET(NDIS_WLAN_BSSID_EX,field))
+#define BSSID_SZ(field)   sizeof(((PNDIS_WLAN_BSSID_EX) 0)->field)
+
+
+struct dvobj_priv {
+
+	_adapter * padapter;
+
+/*-------- below is for SDIO INTERFACE --------*/
+
+#ifdef CONFIG_SDIO_HCI
+
+#ifdef PLATFORM_OS_XP
+	PDEVICE_OBJECT	pphysdevobj;//pPhysDevObj;
+	PDEVICE_OBJECT	pfuncdevobj;//pFuncDevObj;
+	PDEVICE_OBJECT	pnextdevobj;//pNextDevObj;
+	SDBUS_INTERFACE_STANDARD	sdbusinft;//SdBusInterface;
+	u8	nextdevstacksz;//unsigned char			 NextDeviceStackSize;
+#endif//PLATFORM_OS_XP
+
+#ifdef PLATFORM_OS_CE
+	SD_DEVICE_HANDLE hDevice;     
+	SD_CARD_RCA                 sd_rca;
+	SD_CARD_INTERFACE           card_intf;
+	BOOLEAN                     enableIsarWithStatus;
+	WCHAR	active_path[MAX_ACTIVE_REG_PATH];
+	SD_HOST_BLOCK_CAPABILITY    sd_host_blk_cap;
+#endif//PLATFORM_OS_CE
+
+#ifdef PLATFORM_LINUX
+	struct sdio_func	*func;	
+#endif//PLATFORM_LINUX
+
+	u8	func_number;//unsigned char			FunctionNumber;
+	u32	block_transfer_len;//unsigned long			BLOCK_TRANSFER_LEN;
+	u32	blk_shiftbits;
+	u16	driver_version;
+	u16	rxblknum;
+	u16	rxblknum_rd;
+	u16	c2hblknum; 
+	u8  tx_block_mode;
+	u8  rx_block_mode;
+	u8 cmdfifo_cnt;
+	u8 rxfifo_cnt;
+	u16	sdio_hisr;
+	u16	sdio_himr;	
+#endif//	CONFIG_SDIO_HCI
+
+/*-------- below is for USB INTERFACE --------*/
+ 
+#ifdef CONFIG_USB_HCI
+
+	u32 nr_endpoint;
+	u8   ishighspeed;
+
+	NDIS_STATUS  (*inirp_init)(_adapter * adapter);
+	NDIS_STATUS  (*inirp_deinit)(_adapter * adapter);
+	
+	_sema	usb_suspend_sema;
+	
+#ifdef PLATFORM_WINDOWS
+	//related device objects
+	PDEVICE_OBJECT	pphysdevobj;//pPhysDevObj;
+	PDEVICE_OBJECT	pfuncdevobj;//pFuncDevObj;
+	PDEVICE_OBJECT	pnextdevobj;//pNextDevObj;
+
+	u8	nextdevstacksz;//unsigned char NextDeviceStackSize;	//= (CHAR)CEdevice->pUsbDevObj->StackSize + 1; 
+
+	//urb for control diescriptor request
+
+#ifdef PLATFORM_OS_XP
+	struct _URB_CONTROL_DESCRIPTOR_REQUEST descriptor_urb;
+	PUSB_CONFIGURATION_DESCRIPTOR	pconfig_descriptor;//UsbConfigurationDescriptor;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	WCHAR			active_path[MAX_ACTIVE_REG_PATH];	// adapter regpath
+	USB_EXTENSION	usb_extension;
+#endif
+
+	u32	config_descriptor_len;//ULONG UsbConfigurationDescriptorLength;	
+#endif//PLATFORM_WINDOWS
+
+#ifdef PLATFORM_LINUX
+	struct usb_device *pusbdev;
+#endif//PLATFORM_LINUX
+
+#endif//CONFIG_USB_HCI
+	
+};
+
+
+struct _ADAPTER{	
+ 	
+	struct 	dvobj_priv dvobjpriv;
+	struct	mlme_priv mlmepriv;
+#ifdef CONFIG_MLME_EXT
+	struct	mlme_ext_priv mlmeextpriv;	
+#endif
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	struct	io_queue	*pio_queue;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	struct	registry_priv	registrypriv;
+	struct	wlan_acl_pool	acl_list;
+	struct	pwrctrl_priv	pwrctrlpriv;
+	struct 	eeprom_priv eeprompriv;
+	struct	hal_priv	halpriv;			
+	struct	led_priv	ledpriv;
+	
+#ifdef CONFIG_DRVEXT_MODULE
+	struct	drvext_priv	drvextpriv;
+#endif
+	
+#ifdef CONFIG_MP_INCLUDED
+       struct mp_priv  mppriv;
+#endif
+	
+#ifdef CONFIG_HOSTAPD_MODE
+	struct	hostapd_priv	*phostapdpriv;		
+#endif
+	
+	s32	bDriverStopped; 
+	s32	bSurpriseRemoved;
+
+	u32	IsrContent;
+	u32	ImrContent;	
+	
+	u8	EepromAddressSize;		
+	u8	hw_init_completed;	
+	
+	_thread_hdl_	cmdThread;
+	_thread_hdl_	evtThread;
+	_thread_hdl_	xmitThread;
+	_thread_hdl_	recvThread;
+
+
+	NDIS_STATUS (*dvobj_init)(_adapter * adapter);
+	void  (*dvobj_deinit)(_adapter * adapter);
+
+	
+
+#ifdef PLATFORM_WINDOWS
+	_nic_hdl		hndis_adapter;//hNdisAdapter(NDISMiniportAdapterHandle);
+	_nic_hdl		hndis_config;//hNdisConfiguration;
+	NDIS_STRING fw_img;
+
+	u32	NdisPacketFilter;	
+	u8	MCList[MAX_MCAST_LIST_NUM][6];
+	u32	MCAddrCount;	
+#endif //end of PLATFORM_WINDOWS
+
+
+#ifdef PLATFORM_LINUX	
+	_nic_hdl pnetdev;
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+
+#ifdef CONFIG_IOCTL_CFG80211
+	struct wireless_dev *rtw_wdev;
+#endif //CONFIG_IOCTL_CFG80211
+	
+#endif //end of PLATFORM_LINUX
+
+	int pid;//process id from UI
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+	_workitem wkFilterRxFF0;	
+	u8	blnEnableRxFF0Filter;
+	_lock	lockRxFF0Filter;
+#endif
+
+};	
+  
+static __inline u8 *myid(struct eeprom_priv *peepriv)
+{
+	return (peepriv->mac_addr);
+}
+
+
+#endif //__DRV_TYPES_H__
+
diff --git a/drivers/net/wireless/8712u/include/drv_types_ce.h b/drivers/net/wireless/8712u/include/drv_types_ce.h
new file mode 100755
index 0000000..b9286f1
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/drv_types_ce.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __DRV_TYPES_CE_H__
+#define __DRV_TYPES_CE_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#include <Sdcardddk.h>
+
+#define MAX_ACTIVE_REG_PATH 256
+
+#define MAX_MCAST_LIST_NUM					32
+
+
+
+//for ioctl
+#define MAKE_DRIVER_VERSION(_MainVer,_MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)
+
+#define NIC_HEADER_SIZE				14			//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+#define NIC_MAX_SEND_PACKETS			10		// max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h
+#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0,001)	//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+
+typedef struct _MP_REG_ENTRY
+{
+
+	NDIS_STRING		RegName;	// variable name text
+	BOOLEAN			bRequired;	// 1 -> required, 0 -> optional
+
+	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
+	uint			FieldOffset;	// offset to MP_ADAPTER field
+	uint			FieldSize;	// size (in bytes) of the field
+	
+#ifdef UNDER_AMD64
+	u64			Default;
+#else
+	u32			Default;		// default value to use
+#endif
+
+	u32			Min;			// minimum value allowed
+	u32			Max;		// maximum value allowed
+} MP_REG_ENTRY, *PMP_REG_ENTRY;
+
+#ifdef CONFIG_USB_HCI
+typedef struct _USB_EXTENSION {
+    LPCUSB_FUNCS    _lpUsbFuncs;
+	USB_HANDLE	    _hDevice;
+    PVOID 		    pAdapter;
+
+#if 0
+	USB_ENDPOINT_DESCRIPTOR		_endpACLIn;
+    USB_ENDPOINT_DESCRIPTOR		_endpACLOutHigh;
+	USB_ENDPOINT_DESCRIPTOR		_endpACLOutNormal;
+
+	USB_PIPE        pPipeIn;
+    USB_PIPE        pPipeOutNormal;
+    USB_PIPE        pPipeOutHigh;
+#endif
+
+} USB_EXTENSION, *PUSB_EXTENSION;
+#endif
+
+
+typedef struct _OCTET_STRING{
+	u8      *Octet;
+	u16      Length;
+} OCTET_STRING, *POCTET_STRING;
+
+
+
+
+
+#endif
diff --git a/drivers/net/wireless/8712u/include/drv_types_linux.h b/drivers/net/wireless/8712u/include/drv_types_linux.h
new file mode 100755
index 0000000..0e4fb32
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/drv_types_linux.h
@@ -0,0 +1,25 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __DRV_TYPES_LINUX_H__
+#define __DRV_TYPES_LINUX_H__
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/drv_types_xp.h b/drivers/net/wireless/8712u/include/drv_types_xp.h
new file mode 100755
index 0000000..4891e97
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/drv_types_xp.h
@@ -0,0 +1,95 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __DRV_TYPES_XP_H__
+#define __DRV_TYPES_XP_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+
+#define MAX_MCAST_LIST_NUM					32
+
+
+
+//for ioctl
+#define MAKE_DRIVER_VERSION(_MainVer,_MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)
+
+#define NIC_HEADER_SIZE				14			//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+#define NIC_MAX_SEND_PACKETS			10		// max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h
+#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0,001)	//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+
+
+#undef ON_VISTA
+//added by Jackson
+#ifndef ON_VISTA
+//
+// Bus driver versions
+//
+
+#define SDBUS_DRIVER_VERSION_1          0x100
+#define SDBUS_DRIVER_VERSION_2          0x200
+
+#define    SDP_FUNCTION_TYPE	4
+#define    SDP_BUS_DRIVER_VERSION 5
+#define    SDP_BUS_WIDTH 6
+#define    SDP_BUS_CLOCK 7
+#define    SDP_BUS_INTERFACE_CONTROL 8
+#define    SDP_HOST_BLOCK_LENGTH 9
+#define    SDP_FUNCTION_BLOCK_LENGTH 10
+#define    SDP_FN0_BLOCK_LENGTH 11
+#define    SDP_FUNCTION_INT_ENABLE 12
+#endif
+
+
+typedef struct _MP_REG_ENTRY
+{
+
+	NDIS_STRING		RegName;	// variable name text
+	BOOLEAN			bRequired;	// 1 -> required, 0 -> optional
+
+	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
+	uint			FieldOffset;	// offset to MP_ADAPTER field
+	uint			FieldSize;	// size (in bytes) of the field
+	
+#ifdef UNDER_AMD64
+	u64			Default;
+#else
+	u32			Default;		// default value to use
+#endif
+
+	u32			Min;			// minimum value allowed
+	u32			Max;		// maximum value allowed
+} MP_REG_ENTRY, *PMP_REG_ENTRY;
+
+
+typedef struct _OCTET_STRING{
+	u8      *Octet;
+	u16      Length;
+} OCTET_STRING, *POCTET_STRING;
+
+
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/ethernet.h b/drivers/net/wireless/8712u/include/ethernet.h
new file mode 100755
index 0000000..9f9fddb
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/ethernet.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*! \file */ 
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH				6		//!< Ethernet Address Length
+#define ETHERNET_HEADER_SIZE				14		//!< Ethernet Header Length
+#define LLC_HEADER_SIZE						6		//!< LLC Header Length
+#define TYPE_LENGTH_FIELD_SIZE				2		//!< Type/Length Size
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((UCHAR *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
+#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
+											((UCHAR *)(_pAddr))[0]==0xff	&& 		\
+											((UCHAR *)(_pAddr))[1]==0xff	&&		\
+											((UCHAR *)(_pAddr))[2]==0xff	&&		\
+											((UCHAR *)(_pAddr))[3]==0xff	&&		\
+											((UCHAR *)(_pAddr))[4]==0xff	&&		\
+											((UCHAR *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
+
+
+#endif // #ifndef __INC_ETHERNET_H
diff --git a/drivers/net/wireless/8712u/include/farray.h b/drivers/net/wireless/8712u/include/farray.h
new file mode 100755
index 0000000..5bb3ea9
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/farray.h
@@ -0,0 +1,32312 @@
+unsigned char f_array[129240] = {
+0x12,0x87,0xEC,0x11,
+0x30,0x00,0x00,0x00,
+0x08,0xFC,0x00,0x00,
+0x50,0xFC,0x00,0x00,
+0x30,0x00,0x00,0x00,
+0xA8,0xFA,0x00,0x00,
+0x97,0x02,0x00,0x00,
+0x04,0x02,0x19,0x55,
+0x87,0x12,0x12,0x01,
+0x00,0x00,0x12,0x06,
+0x00,0x00,0x00,0x00,
+0x00,0x07,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x01,0x01,0x00,0x01,
+0x01,0x01,0x00,0x00,
+0x01,0x00,0x01,0x00,
+0x00,0x00,0x01,0x01,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x7F,0x00,0x00,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x00,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x1A,0x3C,
+0x80,0x03,0x5A,0x37,
+0x00,0x80,0x1B,0x3C,
+0x80,0x00,0x7B,0x37,
+0x00,0x00,0x5B,0xAF,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x37,
+0x00,0x80,0x1B,0x3C,
+0x80,0x00,0x7B,0x37,
+0x00,0x00,0x5B,0xAF,
+0x01,0x80,0x1A,0x3C,
+0x04,0xF5,0x5A,0x27,
+0x08,0x00,0x40,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xA1,0xAF,
+0x08,0x00,0xA2,0xAF,
+0x0C,0x00,0xA3,0xAF,
+0x10,0x00,0xA4,0xAF,
+0x14,0x00,0xA5,0xAF,
+0x18,0x00,0xA6,0xAF,
+0x1C,0x00,0xA7,0xAF,
+0x20,0x00,0xA8,0xAF,
+0x24,0x00,0xA9,0xAF,
+0x28,0x00,0xAA,0xAF,
+0x2C,0x00,0xAB,0xAF,
+0x30,0x00,0xAC,0xAF,
+0x34,0x00,0xAD,0xAF,
+0x38,0x00,0xAE,0xAF,
+0x3C,0x00,0xAF,0xAF,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x70,0x0A,0x40,
+0x40,0x00,0xB0,0xAF,
+0x44,0x00,0xB1,0xAF,
+0x48,0x00,0xB2,0xAF,
+0x4C,0x00,0xB3,0xAF,
+0x50,0x00,0xB4,0xAF,
+0x54,0x00,0xB5,0xAF,
+0x58,0x00,0xB6,0xAF,
+0x5C,0x00,0xB7,0xAF,
+0x60,0x00,0xB8,0xAF,
+0x64,0x00,0xB9,0xAF,
+0x68,0x00,0xBC,0xAF,
+0x6C,0x00,0xBD,0xAF,
+0x70,0x00,0xBE,0xAF,
+0x74,0x00,0xBF,0xAF,
+0x78,0x00,0xA8,0xAF,
+0x7C,0x00,0xA9,0xAF,
+0x80,0x00,0xAA,0xAF,
+0x2D,0x3D,0x00,0x08,
+0x21,0x20,0xA0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x00,0x03,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0xE0,0xFF,0xBD,0x27,
+0x00,0x00,0x43,0xAC,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x46,0x34,
+0x00,0x00,0xC3,0x90,
+0x02,0x80,0x09,0x3C,
+0x02,0x80,0x08,0x3C,
+0xFF,0x00,0x70,0x30,
+0x00,0x3E,0x10,0x00,
+0x10,0x00,0x02,0x32,
+0x03,0x3E,0x07,0x00,
+0x11,0x00,0x40,0x10,
+0x02,0x80,0x11,0x3C,
+0x60,0x1B,0x25,0x26,
+0x94,0x5F,0x23,0x8D,
+0x64,0x37,0xA4,0x94,
+0x10,0x00,0x02,0x24,
+0x00,0x00,0xC2,0xA0,
+0x44,0x64,0x02,0x8D,
+0x04,0x00,0x80,0x10,
+0x01,0x00,0x66,0x24,
+0x64,0x37,0xA0,0xA4,
+0x68,0x37,0xA0,0xA4,
+0x00,0x00,0x04,0x24,
+0x01,0x00,0x83,0x24,
+0x01,0x00,0x42,0x24,
+0x44,0x64,0x02,0xAD,
+0x94,0x5F,0x26,0xAD,
+0x64,0x37,0xA3,0xA4,
+0x27,0x00,0xE0,0x04,
+0x42,0xB0,0x02,0x3C,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x02,0x32,
+0x0E,0x00,0x40,0x14,
+0x60,0x1B,0x24,0x26,
+0xE0,0x1B,0x83,0x94,
+0xDC,0x1B,0x85,0x94,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x80,0x00,0x63,0x30,
+0x41,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0x08,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA4,
+0x08,0x00,0xE0,0x03,
+0xDC,0x1B,0x83,0xA4,
+0x42,0xB0,0x02,0x3C,
+0x40,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x93,0x61,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x24,0x26,
+0xE0,0x1B,0x83,0x94,
+0xDC,0x1B,0x85,0x94,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x80,0x00,0x63,0x30,
+0x41,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0x08,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA4,
+0x08,0x00,0xE0,0x03,
+0xDC,0x1B,0x83,0xA4,
+0x80,0xFF,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xE5,0x28,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0xE8,0x00,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x84,0x30,
+0x0B,0x00,0x82,0x2C,
+0xFF,0xFF,0xE7,0x30,
+0x10,0x00,0xA8,0x93,
+0x19,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0xB8,0xED,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x43,0xB0,0x02,0x3C,
+0x78,0x00,0x44,0x34,
+0x07,0x00,0xE2,0x30,
+0x00,0x00,0x85,0xAC,
+0x04,0x00,0x86,0xAC,
+0x04,0x00,0x40,0x18,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0xE2,0x30,
+0x08,0x00,0x42,0x24,
+0xFF,0xFF,0x47,0x30,
+0x21,0x10,0xE8,0x00,
+0x00,0x80,0x03,0x3C,
+0x08,0x00,0x82,0xAC,
+0x25,0x10,0x43,0x00,
+0x08,0x00,0x82,0xAC,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x6C,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x60,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x54,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x48,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x3C,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x30,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x24,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x18,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x25,0x01,0x00,0x08,
+0x0C,0x00,0x44,0x34,
+0x25,0x01,0x00,0x08,
+0x43,0xB0,0x04,0x3C,
+0x01,0x00,0x02,0x24,
+0x43,0xB0,0x03,0x3C,
+0x04,0x20,0x82,0x00,
+0x88,0x00,0x65,0x34,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0x05,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x30,
+0x24,0x10,0x44,0x00,
+0xF5,0xFF,0x40,0x1C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0x90,0x05,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x2C,0x00,0xB5,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x08,0x00,0xF4,0x8C,
+0xFF,0x00,0xC6,0x30,
+0x00,0x01,0x02,0x24,
+0x0C,0x00,0xF1,0x84,
+0x23,0x10,0x46,0x00,
+0xFF,0xFF,0x50,0x30,
+0xFF,0x00,0x95,0x30,
+0x21,0x90,0xA0,0x00,
+0x21,0x30,0xC5,0x00,
+0x21,0x20,0xA0,0x02,
+0x21,0x28,0x80,0x02,
+0x21,0x38,0x00,0x02,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x23,0x18,0x30,0x02,
+0xFF,0xFF,0x42,0x32,
+0x00,0x8C,0x03,0x00,
+0x03,0x8C,0x11,0x00,
+0x9D,0x01,0x00,0x08,
+0x02,0x9A,0x02,0x00,
+0x28,0xB0,0x03,0x3C,
+0xC0,0x10,0x13,0x00,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0xFF,0xFF,0x23,0x32,
+0x01,0x01,0x25,0x2A,
+0xFF,0x00,0x93,0x30,
+0x20,0x10,0x02,0x3C,
+0x21,0xA0,0x90,0x02,
+0x00,0x22,0x13,0x00,
+0x00,0x01,0x10,0x24,
+0x0B,0x80,0x65,0x00,
+0x21,0x90,0x82,0x00,
+0x52,0x01,0x00,0x0C,
+0x21,0x20,0xA0,0x02,
+0x21,0x30,0x40,0x02,
+0x21,0x20,0xA0,0x02,
+0x21,0x28,0x80,0x02,
+0x21,0x38,0x00,0x02,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x23,0x18,0x30,0x02,
+0x00,0x8C,0x03,0x00,
+0x03,0x8C,0x11,0x00,
+0xE7,0xFF,0x20,0x1E,
+0x00,0x00,0x00,0x00,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x21,0x50,0x80,0x00,
+0x04,0x00,0x8D,0x8C,
+0x0C,0x00,0x4B,0x8D,
+0x08,0x00,0x84,0x8C,
+0xFF,0xE0,0x02,0x3C,
+0x10,0x00,0x47,0x8D,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0xA9,0x31,
+0x24,0x20,0x82,0x00,
+0x00,0x1E,0x09,0x00,
+0x02,0x14,0x0B,0x00,
+0x25,0x40,0x83,0x00,
+0x21,0x78,0xA0,0x00,
+0xB7,0x00,0xE0,0x04,
+0x07,0x00,0x44,0x30,
+0x00,0x00,0x42,0x95,
+0x00,0x00,0x00,0x00,
+0xFD,0x0F,0x42,0x28,
+0xB9,0x00,0x40,0x10,
+0xFF,0xDF,0x02,0x3C,
+0x02,0x80,0x0E,0x3C,
+0x08,0x00,0x48,0xAD,
+0x60,0x1B,0xC3,0x25,
+0xE2,0x3D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0B,0x00,0x40,0x14,
+0xC0,0x30,0x09,0x00,
+0x3A,0x43,0x62,0x90,
+0xFF,0xDF,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0x24,0x18,0x03,0x01,
+0x40,0x17,0x02,0x00,
+0x25,0x40,0x62,0x00,
+0x08,0x00,0x48,0xAD,
+0xC0,0x30,0x09,0x00,
+0x21,0x10,0xC9,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x49,0x00,
+0x80,0x10,0x02,0x00,
+0x60,0x1B,0xC9,0x25,
+0x21,0x28,0x49,0x00,
+0x08,0x25,0xA3,0x8C,
+0x01,0x00,0x0C,0x24,
+0x02,0x13,0x03,0x00,
+0x01,0x00,0x42,0x30,
+0xB5,0x00,0x4C,0x10,
+0x42,0x18,0x03,0x00,
+0x82,0x11,0x08,0x00,
+0x01,0x00,0x42,0x30,
+0x06,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xC0,0xFF,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x04,0x00,0x48,0x34,
+0x08,0x00,0x48,0xAD,
+0x02,0x80,0x02,0x3C,
+0x69,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x6A,0x00,0x60,0x14,
+0x21,0x20,0xC9,0x00,
+0xD4,0x23,0x83,0x8C,
+0xBF,0xFF,0x02,0x24,
+0x24,0x10,0xE2,0x00,
+0x40,0x00,0x63,0x30,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xD4,0x23,0x83,0x8C,
+0x7F,0xF8,0x02,0x24,
+0x24,0x10,0xE2,0x00,
+0x80,0x07,0x63,0x30,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xE2,0x3D,0x22,0x91,
+0x00,0x00,0x00,0x00,
+0x12,0x00,0x40,0x14,
+0x42,0x17,0x08,0x00,
+0x01,0x00,0x44,0x30,
+0xB1,0x00,0x8C,0x10,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0xC4,0x25,
+0x21,0x20,0xC4,0x00,
+0xD4,0x23,0x83,0x8C,
+0xFF,0xF7,0x02,0x24,
+0x24,0x10,0xE2,0x00,
+0x00,0x08,0x63,0x30,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xD4,0x23,0x83,0x8C,
+0xFF,0xEF,0x02,0x24,
+0x24,0x10,0xE2,0x00,
+0x00,0x10,0x63,0x30,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0x60,0x1B,0xC5,0x25,
+0x21,0x30,0xC5,0x00,
+0xD4,0x23,0xC4,0x8C,
+0xFD,0xFF,0x02,0x3C,
+0x02,0x00,0x03,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x83,0x00,
+0x24,0x10,0xE2,0x00,
+0x25,0x38,0x44,0x00,
+0x10,0x00,0x47,0xAD,
+0xB0,0x1B,0xA3,0x94,
+0xFB,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x10,0xE2,0x00,
+0x80,0x1C,0x03,0x00,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xD8,0x43,0xA3,0x90,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x03,0x00,0x63,0x30,
+0x24,0x10,0xE2,0x00,
+0xC0,0x1C,0x03,0x00,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xD4,0x23,0xC4,0x8C,
+0xFF,0xFD,0x02,0x3C,
+0x00,0x02,0x03,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x83,0x00,
+0x24,0x10,0xE2,0x00,
+0x25,0x38,0x44,0x00,
+0x10,0x00,0x47,0xAD,
+0xB0,0x1B,0xA3,0x94,
+0xFF,0xFB,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x10,0xE2,0x00,
+0x80,0x1E,0x03,0x00,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xD8,0x43,0xA3,0x90,
+0xFF,0xE7,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x03,0x00,0x63,0x30,
+0x24,0x10,0xE2,0x00,
+0xC0,0x1E,0x03,0x00,
+0x25,0x38,0x43,0x00,
+0x10,0x00,0x47,0xAD,
+0xD4,0x23,0xC3,0x8C,
+0xC0,0xFF,0x02,0x24,
+0x24,0x10,0xE2,0x00,
+0x3F,0x00,0x63,0x30,
+0x25,0x10,0x43,0x00,
+0x10,0x00,0x42,0xAD,
+0xD8,0x23,0xC4,0x8C,
+0x14,0x00,0x43,0x8D,
+0xFF,0xFF,0x02,0x3C,
+0xFF,0x7F,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x80,0x84,0x30,
+0x25,0x18,0x64,0x00,
+0x14,0x00,0x43,0xAD,
+0xDA,0x23,0xC4,0x94,
+0xE0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0x84,0x30,
+0x24,0x18,0x62,0x00,
+0x00,0x24,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x14,0x00,0x43,0xAD,
+0x02,0x00,0x43,0x91,
+0x02,0x14,0x0D,0x00,
+0x01,0x00,0x42,0x30,
+0x27,0x00,0x40,0x10,
+0x21,0x30,0x6F,0x00,
+0x60,0x1B,0xC4,0x25,
+0xE4,0x1D,0x85,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xA2,0x24,
+0xE4,0x1D,0x82,0xA4,
+0x0C,0x00,0x43,0x8D,
+0x00,0xF0,0x02,0x3C,
+0xFF,0x0F,0xA5,0x30,
+0xFF,0xFF,0x42,0x34,
+0x00,0x24,0x05,0x00,
+0x24,0x18,0x62,0x00,
+0x25,0x58,0x83,0x00,
+0x0C,0x00,0x4B,0xAD,
+0x16,0x00,0xC2,0x94,
+0x00,0x19,0x05,0x00,
+0x60,0x1B,0xC4,0x25,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x16,0x00,0xC2,0xA4,
+0x00,0x00,0x43,0x95,
+0xDC,0x43,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x43,0x00,
+0x08,0x00,0xE0,0x03,
+0xDC,0x43,0x82,0xAC,
+0x14,0x00,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x42,0x12,0x02,0x00,
+0x3F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0x44,0xFF,0x40,0x10,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x40,0x02,0x01,
+0x00,0x40,0x03,0x3C,
+0x25,0x40,0x03,0x01,
+0xCB,0x01,0x00,0x08,
+0x02,0x80,0x0E,0x3C,
+0x60,0x1B,0xC3,0x25,
+0xE2,0x3D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x1D,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xC2,0x13,0x0B,0x00,
+0x0E,0x00,0x42,0x30,
+0x21,0x10,0x43,0x00,
+0xD4,0x1D,0x45,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xA3,0x24,
+0xD4,0x1D,0x43,0xA4,
+0x0C,0x00,0x44,0x8D,
+0x00,0xF0,0x02,0x3C,
+0xFF,0x0F,0xA5,0x30,
+0xFF,0xFF,0x42,0x34,
+0x00,0x1C,0x05,0x00,
+0x5F,0x02,0x00,0x08,
+0x24,0x20,0x82,0x00,
+0x7F,0xFF,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x80,0x00,0x63,0x30,
+0x25,0x40,0x43,0x00,
+0x08,0x00,0x48,0xAD,
+0x08,0x25,0xA3,0x8C,
+0xFF,0xFF,0x02,0x3C,
+0xFF,0x1F,0x42,0x34,
+0x07,0x00,0x63,0x30,
+0x24,0x10,0xE2,0x00,
+0x40,0x1B,0x03,0x00,
+0x25,0x38,0x43,0x00,
+0xD9,0x01,0x00,0x08,
+0x10,0x00,0x47,0xAD,
+0x02,0x14,0x0B,0x00,
+0xFF,0x0F,0x45,0x30,
+0x16,0x00,0xC2,0x94,
+0x00,0x19,0x05,0x00,
+0x60,0x1B,0xC4,0x25,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x16,0x00,0xC2,0xA4,
+0x00,0x00,0x43,0x95,
+0xDC,0x43,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x43,0x00,
+0x08,0x00,0xE0,0x03,
+0xDC,0x43,0x82,0xAC,
+0x66,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x4E,0xFF,0x64,0x14,
+0x60,0x1B,0xC4,0x25,
+0xD9,0x43,0x22,0x91,
+0xFF,0xF7,0x03,0x24,
+0x24,0x18,0xE3,0x00,
+0x01,0x00,0x42,0x30,
+0xC0,0x12,0x02,0x00,
+0x25,0x38,0x62,0x00,
+0x10,0x00,0x47,0xAD,
+0xDA,0x43,0x22,0x91,
+0xFF,0xEF,0x03,0x24,
+0x24,0x18,0xE3,0x00,
+0x01,0x00,0x42,0x30,
+0x00,0x13,0x02,0x00,
+0x25,0x38,0x43,0x00,
+0x07,0x02,0x00,0x08,
+0x10,0x00,0x47,0xAD,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x04,0x00,0x8B,0x8C,
+0x21,0x80,0x80,0x00,
+0x08,0x00,0x84,0x8C,
+0x0E,0x00,0x07,0x96,
+0xFF,0xE0,0x02,0x3C,
+0x10,0x00,0x08,0x8E,
+0x1F,0x00,0x6A,0x31,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x00,0x1E,0x0A,0x00,
+0x25,0x48,0x83,0x00,
+0x21,0x68,0xA0,0x00,
+0x21,0x60,0xC0,0x00,
+0xCB,0x00,0x00,0x05,
+0x07,0x00,0xE7,0x30,
+0x00,0x00,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xFD,0x0F,0x42,0x28,
+0xCD,0x00,0x40,0x10,
+0xFF,0xDF,0x02,0x3C,
+0x02,0x80,0x11,0x3C,
+0x08,0x00,0x09,0xAE,
+0x60,0x1B,0x23,0x26,
+0xE2,0x3D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x3A,0x43,0x62,0x90,
+0xFF,0xDF,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x07,0x10,0xE2,0x00,
+0x01,0x00,0x42,0x30,
+0x24,0x18,0x23,0x01,
+0x40,0x17,0x02,0x00,
+0x25,0x48,0x62,0x00,
+0x08,0x00,0x09,0xAE,
+0x1C,0x00,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0xFB,0x00,0x40,0x04,
+0x04,0x00,0x03,0x24,
+0xC0,0x30,0x0A,0x00,
+0x21,0x10,0xCA,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x4A,0x00,
+0x80,0x10,0x02,0x00,
+0x60,0x1B,0x27,0x26,
+0x21,0x28,0x47,0x00,
+0x08,0x25,0xA3,0x8C,
+0x01,0x00,0x0A,0x24,
+0x02,0x13,0x03,0x00,
+0x01,0x00,0x42,0x30,
+0xDF,0x00,0x4A,0x10,
+0x42,0x18,0x03,0x00,
+0x82,0x11,0x09,0x00,
+0x01,0x00,0x42,0x30,
+0x06,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xC0,0xFF,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x04,0x00,0x49,0x34,
+0x08,0x00,0x09,0xAE,
+0x02,0x80,0x02,0x3C,
+0x69,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x6C,0x00,0x60,0x14,
+0x21,0x28,0xC7,0x00,
+0xD4,0x23,0xA4,0x8C,
+0x10,0x00,0x02,0x8E,
+0xBF,0xFF,0x03,0x24,
+0x40,0x00,0x84,0x30,
+0x24,0x10,0x43,0x00,
+0x25,0x40,0x44,0x00,
+0x10,0x00,0x08,0xAE,
+0xD4,0x23,0xA3,0x8C,
+0x7F,0xF8,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x80,0x07,0x63,0x30,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xE2,0x3D,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0x40,0x14,
+0x60,0x1B,0x25,0x26,
+0x42,0x17,0x09,0x00,
+0x01,0x00,0x44,0x30,
+0xFC,0x00,0x8A,0x10,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x24,0x26,
+0x21,0x20,0xC4,0x00,
+0xD4,0x23,0x83,0x8C,
+0xFF,0xF7,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x00,0x08,0x63,0x30,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xD4,0x23,0x83,0x8C,
+0xFF,0xEF,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x00,0x10,0x63,0x30,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0x60,0x1B,0x25,0x26,
+0x21,0x30,0xC5,0x00,
+0xD4,0x23,0xC4,0x8C,
+0xFD,0xFF,0x02,0x3C,
+0x02,0x00,0x03,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x83,0x00,
+0x24,0x10,0x02,0x01,
+0x25,0x40,0x44,0x00,
+0x10,0x00,0x08,0xAE,
+0xB0,0x1B,0xA3,0x94,
+0xFB,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x10,0x02,0x01,
+0x80,0x1C,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xD8,0x43,0xA3,0x90,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x03,0x00,0x63,0x30,
+0x24,0x10,0x02,0x01,
+0xC0,0x1C,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xD4,0x23,0xC4,0x8C,
+0xFF,0xFD,0x02,0x3C,
+0x00,0x02,0x03,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x83,0x00,
+0x24,0x10,0x02,0x01,
+0x25,0x40,0x44,0x00,
+0x10,0x00,0x08,0xAE,
+0xB0,0x1B,0xA3,0x94,
+0xFF,0xFB,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x10,0x02,0x01,
+0x80,0x1E,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xD8,0x43,0xA3,0x90,
+0xFF,0xE7,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x03,0x00,0x63,0x30,
+0x24,0x10,0x02,0x01,
+0xC0,0x1E,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xD4,0x23,0xC3,0x8C,
+0xC0,0xFF,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x3F,0x00,0x63,0x30,
+0x25,0x10,0x43,0x00,
+0x10,0x00,0x02,0xAE,
+0xD8,0x23,0xC4,0x8C,
+0x14,0x00,0x03,0x8E,
+0xFF,0xFF,0x02,0x3C,
+0xFF,0x7F,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x80,0x84,0x30,
+0x25,0x18,0x64,0x00,
+0x14,0x00,0x03,0xAE,
+0xDA,0x23,0xC4,0x94,
+0xE0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0x84,0x30,
+0x24,0x18,0x62,0x00,
+0x00,0x24,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x14,0x00,0x03,0xAE,
+0x02,0x00,0x02,0x92,
+0x02,0x24,0x0B,0x00,
+0x02,0x80,0x03,0x3C,
+0x21,0x10,0x4C,0x00,
+0xFF,0xFF,0x42,0x30,
+0x01,0x00,0x84,0x30,
+0x32,0x00,0x80,0x10,
+0x25,0x30,0x43,0x00,
+0x60,0x1B,0x24,0x26,
+0xE4,0x1D,0x85,0x94,
+0x80,0x00,0x07,0x24,
+0x01,0x00,0xA2,0x24,
+0xE4,0x1D,0x82,0xA4,
+0x0C,0x00,0x03,0x8E,
+0x00,0xF0,0x02,0x3C,
+0xFF,0x0F,0xA5,0x30,
+0xFF,0xFF,0x42,0x34,
+0x00,0x24,0x05,0x00,
+0x24,0x18,0x62,0x00,
+0x25,0x18,0x64,0x00,
+0x0C,0x00,0x03,0xAE,
+0x16,0x00,0xC2,0x94,
+0x00,0x19,0x05,0x00,
+0x02,0x00,0x04,0x24,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x16,0x00,0xC2,0xA4,
+0x21,0x28,0x80,0x01,
+0x21,0x30,0xA0,0x01,
+0x01,0x00,0x02,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x52,0x01,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x60,0x1B,0x24,0x26,
+0x00,0x00,0x03,0x96,
+0xDC,0x43,0x82,0x8C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x43,0x00,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0xDC,0x43,0x82,0xAC,
+0x14,0x00,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x42,0x12,0x02,0x00,
+0x3F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0x30,0xFF,0x40,0x10,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x48,0x22,0x01,
+0x00,0x40,0x03,0x3C,
+0x25,0x48,0x23,0x01,
+0xE3,0x02,0x00,0x08,
+0x02,0x80,0x11,0x3C,
+0x60,0x1B,0x23,0x26,
+0xE2,0x3D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x4F,0x00,0x40,0x14,
+0x80,0x00,0x07,0x24,
+0x0E,0x00,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x42,0x30,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0xD4,0x1D,0x45,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xA3,0x24,
+0xD4,0x1D,0x43,0xA4,
+0x0C,0x00,0x04,0x8E,
+0x00,0xF0,0x02,0x3C,
+0xFF,0x0F,0xA5,0x30,
+0xFF,0xFF,0x42,0x34,
+0x00,0x1C,0x05,0x00,
+0x24,0x20,0x82,0x00,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x04,0xAE,
+0x16,0x00,0xC2,0x94,
+0x00,0x19,0x05,0x00,
+0x02,0x00,0x04,0x24,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x16,0x00,0xC2,0xA4,
+0x21,0x28,0x80,0x01,
+0x21,0x30,0xA0,0x01,
+0x01,0x00,0x02,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x52,0x01,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x60,0x1B,0x24,0x26,
+0x00,0x00,0x03,0x96,
+0xDC,0x43,0x82,0x8C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x43,0x00,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0xDC,0x43,0x82,0xAC,
+0x7F,0xFF,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x80,0x00,0x63,0x30,
+0x25,0x48,0x43,0x00,
+0x08,0x00,0x09,0xAE,
+0x08,0x25,0xA3,0x8C,
+0x10,0x00,0x04,0x8E,
+0xFF,0xFF,0x02,0x3C,
+0x07,0x00,0x63,0x30,
+0xFF,0x1F,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x40,0x1B,0x03,0x00,
+0x25,0x40,0x83,0x00,
+0xF5,0x02,0x00,0x08,
+0x10,0x00,0x08,0xAE,
+0x1E,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x30,0x50,0x00,
+0x00,0x00,0xC4,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x82,0x30,
+0x02,0x29,0x02,0x00,
+0x3B,0x00,0xA3,0x10,
+0x06,0x00,0x02,0x24,
+0xFC,0xFE,0xA2,0x14,
+0x00,0x00,0x00,0x00,
+0x1A,0x00,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x39,0x00,0xC2,0xA0,
+0x1E,0x00,0x03,0x92,
+0x1A,0x00,0x02,0x96,
+0x21,0x18,0x70,0x00,
+0x03,0x12,0x02,0x00,
+0x38,0x00,0x62,0xA0,
+0x04,0x00,0x0B,0x8E,
+0x08,0x00,0x09,0x8E,
+0xE9,0x02,0x00,0x08,
+0xC0,0x30,0x0A,0x00,
+0x0E,0x00,0x02,0x96,
+0x02,0x00,0x04,0x24,
+0xFF,0x0F,0x45,0x30,
+0x16,0x00,0xC2,0x94,
+0x00,0x19,0x05,0x00,
+0x21,0x28,0x80,0x01,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x16,0x00,0xC2,0xA4,
+0x21,0x30,0xA0,0x01,
+0x01,0x00,0x02,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x52,0x01,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x60,0x1B,0x24,0x26,
+0x00,0x00,0x03,0x96,
+0xDC,0x43,0x82,0x8C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x43,0x00,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0xDC,0x43,0x82,0xAC,
+0x66,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0xFF,0x64,0x14,
+0x60,0x1B,0x24,0x26,
+0xD9,0x43,0xE2,0x90,
+0xFF,0xF7,0x03,0x24,
+0x24,0x18,0x03,0x01,
+0x01,0x00,0x42,0x30,
+0xC0,0x12,0x02,0x00,
+0x25,0x40,0x62,0x00,
+0x10,0x00,0x08,0xAE,
+0xDA,0x43,0xE2,0x90,
+0xFF,0xEF,0x03,0x24,
+0x24,0x18,0x03,0x01,
+0x01,0x00,0x42,0x30,
+0x00,0x13,0x02,0x00,
+0x25,0x40,0x43,0x00,
+0x25,0x03,0x00,0x08,
+0x10,0x00,0x08,0xAE,
+0x1A,0x00,0x05,0x96,
+0x0F,0x00,0x84,0x30,
+0x80,0x20,0x04,0x00,
+0x21,0x18,0xC4,0x00,
+0x11,0x00,0x65,0xA0,
+0x1E,0x00,0x02,0x92,
+0x1A,0x00,0x03,0x96,
+0x21,0x10,0x50,0x00,
+0x21,0x10,0x44,0x00,
+0x03,0x1A,0x03,0x00,
+0x10,0x00,0x43,0xA0,
+0x04,0x00,0x0B,0x8E,
+0x08,0x00,0x09,0x8E,
+0xE9,0x02,0x00,0x08,
+0xC0,0x30,0x0A,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xD0,0x10,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC0,0xFF,0xBD,0x27,
+0xEC,0x10,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x34,0x00,0xB7,0xAF,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x17,0x3C,
+0x28,0x00,0xB4,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xA6,0x40,0x00,0x0C,
+0x60,0x1B,0xF4,0x26,
+0x66,0x04,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x16,0x24,
+0x08,0x00,0x04,0xAE,
+0x60,0x1B,0xF1,0x26,
+0x10,0x00,0xB6,0xAF,
+0x08,0x38,0x26,0x8E,
+0x21,0x28,0x60,0x02,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x28,0x1C,0x22,0x8E,
+0x0F,0x00,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x4E,0x00,0x40,0x10,
+0x2A,0xB0,0x02,0x3C,
+0x09,0x00,0x42,0x34,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x56,0xA0,
+0x00,0x00,0x43,0xA0,
+0x66,0x00,0x5E,0x12,
+0x00,0x00,0x00,0x00,
+0x04,0x38,0x82,0x8E,
+0x01,0x00,0x04,0x24,
+0x70,0x38,0x93,0x8E,
+0x52,0x01,0x00,0x0C,
+0x08,0x38,0x82,0xAE,
+0x70,0x38,0x84,0x8E,
+0x74,0x38,0x83,0x8E,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x70,0x38,0x83,0xAE,
+0x02,0x80,0x15,0x3C,
+0xFF,0xFF,0x62,0x32,
+0x25,0x80,0x55,0x00,
+0x02,0x00,0x04,0x92,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x1E,0x24,
+0x21,0x20,0x93,0x00,
+0xFF,0xFF,0x84,0x30,
+0x4F,0x61,0x00,0x0C,
+0x25,0x20,0x95,0x00,
+0x0C,0x00,0x12,0x92,
+0x20,0x10,0x02,0x3C,
+0x60,0x1B,0xE8,0x26,
+0x00,0x1A,0x12,0x00,
+0x21,0x18,0x62,0x00,
+0x01,0x00,0x04,0x24,
+0x21,0x30,0x60,0x00,
+0x06,0x00,0x5E,0x12,
+0x80,0x00,0x07,0x24,
+0x70,0x38,0x05,0x8D,
+0x04,0x38,0x03,0xAD,
+0xA8,0x37,0x12,0xA1,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x04,0x00,0x04,0x8E,
+0x08,0x00,0x03,0x8E,
+0xFF,0xE0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0x84,0x30,
+0x24,0x18,0x62,0x00,
+0x00,0x26,0x04,0x00,
+0xFF,0xDF,0x02,0x3C,
+0x25,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x40,0x04,0x3C,
+0x25,0x18,0x64,0x00,
+0xC0,0xFF,0x05,0x24,
+0x82,0x11,0x03,0x00,
+0x24,0x20,0x65,0x00,
+0x01,0x00,0x42,0x30,
+0xB4,0xFF,0x40,0x10,
+0x04,0x00,0x84,0x34,
+0x01,0x00,0x16,0x24,
+0x08,0x00,0x03,0xAE,
+0x60,0x1B,0xF1,0x26,
+0x10,0x00,0xB6,0xAF,
+0x08,0x38,0x26,0x8E,
+0x21,0x28,0x60,0x02,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x28,0x1C,0x22,0x8E,
+0x0F,0x00,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0xB4,0xFF,0x40,0x14,
+0x2A,0xB0,0x02,0x3C,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x28,0x1C,0x23,0x8E,
+0xF0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x01,0x00,0x04,0x3C,
+0x25,0x18,0x64,0x00,
+0x28,0x1C,0x23,0xAE,
+0x02,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x53,0x00,
+0xFF,0xFF,0x42,0x30,
+0x25,0x10,0x55,0x00,
+0x02,0x00,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x64,0x30,
+0x00,0xC0,0x84,0x24,
+0x2B,0x1C,0x23,0xA2,
+0x57,0x37,0x00,0x0C,
+0xFF,0xFF,0x84,0x30,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x02,0x3C,
+0x09,0x00,0x42,0x34,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x56,0xA0,
+0x00,0x00,0x43,0xA0,
+0x9C,0xFF,0x5E,0x16,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xD0,0x1B,0x22,0x8E,
+0x41,0xB0,0x03,0x3C,
+0x3C,0x00,0xBF,0x8F,
+0x00,0x18,0x42,0x34,
+0x00,0x00,0x62,0xAC,
+0x38,0x00,0xBE,0x8F,
+0xD0,0x1B,0x22,0xAE,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x78,0x13,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x38,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x58,0x60,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x94,0x13,0x63,0x24,
+0x40,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0x7F,0x00,0xA2,0x30,
+0xBF,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0x02,0x80,0x16,0x3C,
+0x58,0x60,0xC2,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x02,0x80,0x15,0x3C,
+0x21,0x05,0x00,0x08,
+0x60,0x1B,0xD3,0x26,
+0x84,0x37,0x91,0xA0,
+0x60,0x1B,0xC2,0x26,
+0xBC,0x37,0x46,0x8C,
+0x28,0x38,0x45,0x8C,
+0x03,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x60,0x1B,0xD4,0x26,
+0xC0,0x37,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0xBC,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x06,0x3C,
+0x0D,0x00,0xC3,0x34,
+0x04,0x00,0x62,0x24,
+0x0B,0x18,0x57,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x05,0x24,
+0x00,0x00,0x64,0xA0,
+0x00,0x00,0x65,0xA0,
+0xA4,0x5F,0xA2,0x96,
+0xFF,0x00,0x03,0x24,
+0x01,0x00,0x42,0x24,
+0xA4,0x5F,0xA2,0xA6,
+0xA4,0x5F,0xA4,0x96,
+0x25,0xB0,0x02,0x3C,
+0x66,0x03,0x42,0x34,
+0x00,0x00,0x44,0xA4,
+0x21,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xBC,0x37,0x62,0x8E,
+0x03,0x00,0x04,0x24,
+0x28,0x38,0x72,0x8E,
+0x52,0x01,0x00,0x0C,
+0xC0,0x37,0x62,0xAE,
+0x28,0x38,0x64,0x8E,
+0x2C,0x38,0x63,0x8E,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x28,0x38,0x63,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x02,0x00,0x04,0x92,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0x4F,0x61,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x11,0x00,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x02,0x24,
+0xCE,0xFF,0x22,0x12,
+0x60,0x1B,0xC4,0x26,
+0xC4,0xFF,0xE0,0x16,
+0xBC,0x37,0x83,0xAC,
+0x03,0x05,0x00,0x08,
+0x80,0x37,0x91,0xA0,
+0x1B,0x00,0xE0,0x12,
+0x40,0x00,0xC2,0x34,
+0x84,0x37,0x83,0x92,
+0x41,0x00,0xC2,0x34,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA4,0x8C,
+0x01,0x00,0x02,0x3C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x00,0x80,0x42,0x34,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0x80,0x37,0x83,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA4,0x8C,
+0x01,0x00,0x02,0x3C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x00,0x80,0x42,0x34,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x38,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x58,0x60,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0xDC,0x15,0x63,0x24,
+0x10,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0xDF,0x00,0xA2,0x30,
+0xEF,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0x02,0x80,0x16,0x3C,
+0x58,0x60,0xC2,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x02,0x80,0x15,0x3C,
+0xB3,0x05,0x00,0x08,
+0x60,0x1B,0xD3,0x26,
+0x8C,0x37,0x91,0xA0,
+0x60,0x1B,0xC2,0x26,
+0xC8,0x37,0x46,0x8C,
+0x34,0x38,0x45,0x8C,
+0x04,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x60,0x1B,0xD4,0x26,
+0xCC,0x37,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0xBC,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x06,0x3C,
+0x15,0x00,0xC3,0x34,
+0x04,0x00,0x62,0x24,
+0x0B,0x18,0x57,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x05,0x24,
+0x00,0x00,0x64,0xA0,
+0x00,0x00,0x65,0xA0,
+0xA4,0x5F,0xA2,0x96,
+0xFF,0x00,0x03,0x24,
+0x01,0x00,0x42,0x24,
+0xA4,0x5F,0xA2,0xA6,
+0xA4,0x5F,0xA4,0x96,
+0x25,0xB0,0x02,0x3C,
+0x66,0x03,0x42,0x34,
+0x00,0x00,0x44,0xA4,
+0x21,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xC8,0x37,0x62,0x8E,
+0x04,0x00,0x04,0x24,
+0x34,0x38,0x72,0x8E,
+0x52,0x01,0x00,0x0C,
+0xCC,0x37,0x62,0xAE,
+0x34,0x38,0x64,0x8E,
+0x38,0x38,0x63,0x8E,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x34,0x38,0x63,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x02,0x00,0x04,0x92,
+0x02,0x00,0x05,0x24,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0x4F,0x61,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x11,0x00,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x02,0x24,
+0xCE,0xFF,0x22,0x12,
+0x60,0x1B,0xC4,0x26,
+0xC4,0xFF,0xE0,0x16,
+0xC8,0x37,0x83,0xAC,
+0x95,0x05,0x00,0x08,
+0x88,0x37,0x91,0xA0,
+0x1A,0x00,0xE0,0x12,
+0x42,0x00,0xC2,0x34,
+0x8C,0x37,0x83,0x92,
+0x43,0x00,0xC2,0x34,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x06,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x88,0x37,0x83,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x06,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x38,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x58,0x60,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x1C,0x18,0x63,0x24,
+0x01,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0xF7,0x00,0xA2,0x30,
+0xFE,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0x02,0x80,0x16,0x3C,
+0x58,0x60,0xC2,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x02,0x80,0x15,0x3C,
+0x43,0x06,0x00,0x08,
+0x60,0x1B,0xD3,0x26,
+0x9C,0x37,0x91,0xA0,
+0x60,0x1B,0xC2,0x26,
+0xD4,0x37,0x46,0x8C,
+0x40,0x38,0x45,0x8C,
+0x05,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x60,0x1B,0xD4,0x26,
+0xD8,0x37,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0xBC,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x06,0x3C,
+0x1D,0x00,0xC3,0x34,
+0x04,0x00,0x62,0x24,
+0x0B,0x18,0x57,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x05,0x24,
+0x00,0x00,0x64,0xA0,
+0x00,0x00,0x65,0xA0,
+0xA4,0x5F,0xA2,0x96,
+0xFF,0x00,0x03,0x24,
+0x01,0x00,0x42,0x24,
+0xA4,0x5F,0xA2,0xA6,
+0xA4,0x5F,0xA4,0x96,
+0x25,0xB0,0x02,0x3C,
+0x66,0x03,0x42,0x34,
+0x00,0x00,0x44,0xA4,
+0x21,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xD4,0x37,0x62,0x8E,
+0x05,0x00,0x04,0x24,
+0x40,0x38,0x72,0x8E,
+0x52,0x01,0x00,0x0C,
+0xD8,0x37,0x62,0xAE,
+0x40,0x38,0x64,0x8E,
+0x44,0x38,0x63,0x8E,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x40,0x38,0x63,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x02,0x00,0x04,0x92,
+0x08,0x00,0x05,0x24,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0x4F,0x61,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x11,0x00,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x02,0x24,
+0xCE,0xFF,0x22,0x12,
+0x60,0x1B,0xC4,0x26,
+0xC4,0xFF,0xE0,0x16,
+0xD4,0x37,0x83,0xAC,
+0x25,0x06,0x00,0x08,
+0x90,0x37,0x91,0xA0,
+0x1A,0x00,0xE0,0x12,
+0x44,0x00,0xC2,0x34,
+0x9C,0x37,0x83,0x92,
+0x45,0x00,0xC2,0x34,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x18,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x90,0x37,0x83,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x18,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x38,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x58,0x60,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x5C,0x1A,0x63,0x24,
+0x02,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0xFB,0x00,0xA2,0x30,
+0xFD,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0x02,0x80,0x16,0x3C,
+0x58,0x60,0xC2,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x02,0x80,0x15,0x3C,
+0xD3,0x06,0x00,0x08,
+0x60,0x1B,0xD3,0x26,
+0x98,0x37,0x91,0xA0,
+0x60,0x1B,0xC2,0x26,
+0xE0,0x37,0x46,0x8C,
+0x4C,0x38,0x45,0x8C,
+0x06,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x60,0x1B,0xD4,0x26,
+0xE4,0x37,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0xBC,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x06,0x3C,
+0x25,0x00,0xC3,0x34,
+0x04,0x00,0x62,0x24,
+0x0B,0x18,0x57,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x05,0x24,
+0x00,0x00,0x64,0xA0,
+0x00,0x00,0x65,0xA0,
+0xA4,0x5F,0xA2,0x96,
+0xFF,0x00,0x03,0x24,
+0x01,0x00,0x42,0x24,
+0xA4,0x5F,0xA2,0xA6,
+0xA4,0x5F,0xA4,0x96,
+0x25,0xB0,0x02,0x3C,
+0x66,0x03,0x42,0x34,
+0x00,0x00,0x44,0xA4,
+0x21,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xE0,0x37,0x62,0x8E,
+0x06,0x00,0x04,0x24,
+0x4C,0x38,0x72,0x8E,
+0x52,0x01,0x00,0x0C,
+0xE4,0x37,0x62,0xAE,
+0x4C,0x38,0x64,0x8E,
+0x50,0x38,0x63,0x8E,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x4C,0x38,0x63,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x02,0x00,0x04,0x92,
+0x04,0x00,0x05,0x24,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0x4F,0x61,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x11,0x00,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x02,0x24,
+0xCE,0xFF,0x22,0x12,
+0x60,0x1B,0xC4,0x26,
+0xC4,0xFF,0xE0,0x16,
+0xE0,0x37,0x83,0xAC,
+0xB5,0x06,0x00,0x08,
+0x94,0x37,0x91,0xA0,
+0x1A,0x00,0xE0,0x12,
+0x46,0x00,0xC2,0x34,
+0x98,0x37,0x83,0x92,
+0x47,0x00,0xC2,0x34,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x60,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x94,0x37,0x83,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xA0,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC5,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x60,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x9C,0x1C,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0xE8,0xFF,0xBD,0x27,
+0x00,0x00,0x43,0xAC,
+0x10,0x00,0xBF,0xAF,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x60,0x1B,0xA5,0x24,
+0xD8,0x1B,0xA2,0x8C,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x08,0x03,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x20,0x00,0xB0,0xAF,
+0x00,0x80,0x02,0x3C,
+0x25,0xB0,0x10,0x3C,
+0x18,0x03,0x03,0x36,
+0xFC,0x1C,0x42,0x24,
+0x34,0x00,0xB5,0xAF,
+0x02,0x80,0x15,0x3C,
+0x00,0x00,0x62,0xAC,
+0x2C,0x00,0xB3,0xAF,
+0xFC,0x00,0x10,0x36,
+0x60,0x1B,0xB3,0x26,
+0x38,0x00,0xBF,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x24,0x00,0xB1,0xAF,
+0xA6,0x40,0x00,0x0C,
+0x30,0x00,0xB4,0xAF,
+0x00,0x00,0x05,0x8E,
+0xAC,0x1B,0x64,0x96,
+0xCC,0x38,0x63,0x96,
+0xC4,0x38,0x66,0x8E,
+0x23,0x28,0xA4,0x00,
+0x21,0x10,0xA3,0x00,
+0x23,0x88,0x46,0x00,
+0x23,0x20,0x23,0x02,
+0x2B,0x18,0x71,0x00,
+0x0B,0x88,0x83,0x00,
+0x21,0x20,0x20,0x02,
+0xF3,0x27,0x00,0x0C,
+0xC8,0x38,0x65,0xAE,
+0x21,0x90,0x40,0x00,
+0x4A,0x00,0x40,0x10,
+0x18,0x00,0xA4,0x27,
+0x0C,0x00,0x51,0xAC,
+0xC4,0x38,0x63,0x8E,
+0xC8,0x38,0x62,0x8E,
+0x40,0x10,0x14,0x3C,
+0x21,0x20,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x2B,0x00,0x40,0x14,
+0xFF,0xFF,0x27,0x32,
+0x08,0x00,0x42,0x96,
+0xAC,0x1B,0x66,0x96,
+0x40,0x10,0x05,0x3C,
+0x21,0x20,0x00,0x00,
+0x21,0x30,0x66,0x00,
+0x10,0x00,0xA0,0xAF,
+0x25,0x28,0x45,0x00,
+0x15,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x88,0x54,0x42,0x24,
+0x04,0x00,0x43,0x8C,
+0x00,0x00,0x42,0xAE,
+0x04,0x00,0x52,0xAC,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x72,0xAC,
+0x52,0x01,0x00,0x0C,
+0x04,0x00,0x43,0xAE,
+0x60,0x1B,0xA5,0x26,
+0xC8,0x38,0xA6,0x8C,
+0xAC,0x1B,0xA3,0x94,
+0x25,0xB0,0x02,0x3C,
+0xF8,0x00,0x42,0x34,
+0x21,0x18,0xC3,0x00,
+0x00,0x00,0x43,0xAC,
+0x18,0x00,0xA4,0x27,
+0xC4,0x38,0xA6,0xAC,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0xCC,0x38,0x70,0x8E,
+0x08,0x00,0x45,0x96,
+0xAC,0x1B,0x66,0x96,
+0x23,0x80,0x03,0x02,
+0xFF,0xFF,0x10,0x32,
+0x21,0x30,0x66,0x00,
+0x21,0x38,0x00,0x02,
+0x25,0x28,0xB4,0x00,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x52,0x01,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x08,0x00,0x45,0x96,
+0xAC,0x1B,0x62,0x96,
+0x23,0x38,0x30,0x02,
+0x25,0x28,0xB4,0x00,
+0x21,0x10,0x06,0x3C,
+0x21,0x28,0xB0,0x00,
+0x21,0x30,0x46,0x00,
+0xFF,0xFF,0xE7,0x30,
+0x21,0x20,0x00,0x00,
+0x6F,0x07,0x00,0x08,
+0x10,0x00,0xA0,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x5C,0x60,0x62,0x8C,
+0x18,0x00,0xA4,0x27,
+0x08,0x00,0x42,0x34,
+0x85,0x07,0x00,0x08,
+0x5C,0x60,0x62,0xAC,
+0x06,0x00,0x80,0x10,
+0xFF,0x00,0xA5,0x30,
+0x01,0x00,0x02,0x24,
+0x10,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xC9,0x40,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0xA2,0x24,
+0x00,0x2E,0x02,0x00,
+0x03,0x2E,0x05,0x00,
+0x20,0x00,0xA3,0x28,
+0x00,0x00,0x80,0xA0,
+0xFA,0xFF,0x60,0x14,
+0x08,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x6D,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0xF5,0xFF,0xA2,0x24,
+0x02,0x00,0x42,0x2C,
+0x29,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x46,0x24,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x07,0x24,
+0xDE,0x07,0x00,0x08,
+0x21,0x20,0xC0,0x00,
+0x58,0x3E,0x42,0x8C,
+0x00,0x00,0x00,0x00,
+0x11,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xC9,0x40,0x80,0xA0,
+0x01,0x00,0xA3,0x24,
+0x00,0x2E,0x03,0x00,
+0x03,0x2E,0x05,0x00,
+0x20,0x00,0xA2,0x28,
+0xD9,0xFF,0x40,0x10,
+0x08,0x00,0x84,0x24,
+0xC8,0x40,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x62,0x30,
+0xF4,0xFF,0x63,0x24,
+0xFF,0x00,0x63,0x30,
+0xC0,0x10,0x02,0x00,
+0x03,0x00,0x63,0x2C,
+0xED,0xFF,0x60,0x14,
+0x21,0x10,0x46,0x00,
+0xD8,0x07,0x00,0x08,
+0xC9,0x40,0x87,0xA0,
+0x60,0x1B,0x42,0x24,
+0xC9,0x40,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x06,0x24,
+0x01,0x00,0xA2,0x24,
+0x00,0x2E,0x02,0x00,
+0x03,0x2E,0x05,0x00,
+0x20,0x00,0xA3,0x28,
+0x00,0x00,0x86,0xA0,
+0xFA,0xFF,0x60,0x14,
+0x08,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x42,0x24,
+0xC9,0x40,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x06,0x24,
+0x01,0x00,0xA2,0x24,
+0x00,0x2E,0x02,0x00,
+0x03,0x2E,0x05,0x00,
+0x20,0x00,0xA3,0x28,
+0x00,0x00,0x86,0xA0,
+0xFA,0xFF,0x60,0x14,
+0x08,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0x18,0x03,0x63,0x34,
+0x0C,0x20,0x42,0x24,
+0xB8,0xFF,0xBD,0x27,
+0x00,0x00,0x62,0xAC,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x24,0x00,0xB1,0xAF,
+0xB1,0x40,0x00,0x0C,
+0x20,0x00,0xB0,0xAF,
+0x01,0x00,0x03,0x24,
+0x26,0x00,0x43,0x10,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0x85,0x24,
+0x85,0x38,0xA3,0x90,
+0x01,0x00,0x02,0x24,
+0x0D,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xD8,0x1B,0xA2,0x8C,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x04,0x03,0x3C,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x24,0x10,0x43,0x00,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x48,0x00,0xBD,0x27,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0xA6,0x40,0x00,0x0C,
+0x02,0x00,0x17,0x24,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x55,0x24,
+0x2A,0xB0,0x02,0x3C,
+0x2D,0x00,0x5E,0x34,
+0x7C,0x38,0xB0,0x8E,
+0x52,0x01,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0xFF,0xFF,0x16,0x32,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x02,0x3C,
+0x25,0xA0,0xC2,0x02,
+0x5A,0x5F,0x83,0x90,
+0x02,0x00,0x84,0x92,
+0x0F,0x00,0x63,0x30,
+0x69,0x00,0x77,0x10,
+0x21,0x28,0x84,0x02,
+0x20,0x00,0x02,0x24,
+0x6B,0x00,0x82,0x10,
+0x21,0x30,0x00,0x00,
+0x6C,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x58,0xFC,0x45,0xAC,
+0x02,0x80,0x12,0x3C,
+0x02,0x00,0xA3,0x90,
+0x03,0x00,0xA4,0x90,
+0xBC,0xDB,0x42,0x92,
+0xFF,0x00,0x71,0x30,
+0x7F,0x00,0x93,0x30,
+0xFF,0x00,0x42,0x30,
+0x08,0x00,0xB0,0x24,
+0x1C,0x00,0xA0,0xAF,
+0x0B,0x00,0x53,0x10,
+0x41,0x00,0x23,0x2E,
+0x8C,0x57,0x00,0x0C,
+0x10,0x00,0x04,0x24,
+0xBC,0xDB,0x42,0x92,
+0xBC,0xDB,0x46,0x92,
+0x02,0x80,0x04,0x3C,
+0xE4,0xED,0x84,0x24,
+0x21,0x28,0x60,0x02,
+0x13,0x57,0x00,0x0C,
+0xFF,0x00,0xC6,0x30,
+0x21,0x18,0x00,0x00,
+0x74,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x0E,0x00,0x02,0x24,
+0x6B,0x00,0x22,0x12,
+0x37,0x00,0x02,0x24,
+0x69,0x00,0x22,0x12,
+0x10,0x00,0x02,0x24,
+0x67,0x00,0x22,0x12,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x13,0x24,
+0x68,0x00,0x73,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0xC0,0xDB,0x84,0x24,
+0xC0,0x18,0x11,0x00,
+0x21,0x18,0x64,0x00,
+0x04,0x00,0x62,0x8C,
+0x02,0x80,0x03,0x3C,
+0x21,0x20,0x00,0x02,
+0x09,0xF8,0x40,0x00,
+0x50,0xFC,0x62,0xAC,
+0x21,0x80,0x40,0x00,
+0x9A,0x40,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x03,0x00,0x00,0x12,
+0x39,0x00,0x02,0x24,
+0x65,0x00,0x22,0x12,
+0x00,0x00,0x00,0x00,
+0xBC,0xDB,0x43,0x92,
+0x85,0x38,0xB3,0xA2,
+0x01,0x00,0x63,0x24,
+0xBC,0xDB,0x43,0xA2,
+0xBC,0xDB,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x7F,0x00,0x42,0x30,
+0xBC,0xDB,0x42,0xA2,
+0xA0,0x40,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x39,0x00,0x02,0x24,
+0x41,0x00,0x22,0x12,
+0x01,0x00,0x02,0x24,
+0x00,0x00,0xC2,0xA3,
+0x00,0x00,0xD7,0xA3,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0x84,0x24,
+0x85,0x38,0x83,0x90,
+0x01,0x00,0x02,0x24,
+0x30,0x00,0x62,0x10,
+0xFF,0x00,0x02,0x24,
+0x21,0x10,0x00,0x00,
+0xFF,0x00,0x43,0x30,
+0x01,0x00,0x02,0x24,
+0x4D,0x00,0x62,0x14,
+0x20,0x10,0x03,0x3C,
+0xAC,0x37,0xA2,0x92,
+0x7C,0x38,0xA5,0x8E,
+0x00,0x12,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x10,0x38,0xA2,0xAE,
+0x21,0x30,0x40,0x00,
+0x0A,0x00,0x04,0x24,
+0x00,0x01,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x7C,0x38,0xB0,0x8E,
+0x52,0x01,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0xFF,0xFF,0x16,0x32,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x02,0x3C,
+0x25,0xA0,0xC2,0x02,
+0x5A,0x5F,0x83,0x90,
+0x02,0x00,0x84,0x92,
+0x0F,0x00,0x63,0x30,
+0x99,0xFF,0x77,0x14,
+0x21,0x28,0x84,0x02,
+0x00,0x00,0x82,0x8E,
+0x00,0x0C,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x97,0xFF,0x43,0x14,
+0x21,0x30,0x00,0x00,
+0x01,0x00,0x06,0x24,
+0x96,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x8C,0x57,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x78,0x37,0xA2,0x96,
+0x01,0x00,0x04,0x24,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0xC4,0xA3,
+0x78,0x37,0xA2,0xA6,
+0x85,0x38,0xA4,0xA2,
+0x00,0x00,0xD7,0xA3,
+0x9E,0x08,0x00,0x08,
+0x01,0x00,0x02,0x24,
+0x0C,0x00,0x84,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x83,0x30,
+0xCD,0xFF,0x62,0x10,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x63,0x24,
+0x01,0x00,0x02,0x24,
+0x9C,0x08,0x00,0x08,
+0xAC,0x37,0x64,0xA0,
+0x1C,0x00,0xA4,0x8F,
+0x01,0x00,0x02,0x24,
+0xC0,0xFF,0x82,0x14,
+0x02,0x80,0x04,0x3C,
+0x93,0x08,0x00,0x08,
+0x01,0x00,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x01,0x00,0x13,0x24,
+0x9A,0xFF,0x73,0x14,
+0x02,0x80,0x02,0x3C,
+0x76,0x08,0x00,0x08,
+0x25,0x80,0xC2,0x02,
+0xBC,0xDB,0x43,0x92,
+0x01,0x00,0x02,0x24,
+0x1C,0x00,0xA2,0xAF,
+0x01,0x00,0x63,0x24,
+0xBC,0xDB,0x43,0xA2,
+0xBC,0xDB,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x7F,0x00,0x42,0x30,
+0xBC,0xDB,0x42,0xA2,
+0x91,0x08,0x00,0x08,
+0x39,0x00,0x02,0x24,
+0x8E,0x08,0x00,0x08,
+0x85,0x38,0xA0,0xA2,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x08,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x02,0x80,0x02,0x3C,
+0x21,0xB8,0xA0,0x00,
+0xFF,0xFF,0xA5,0x30,
+0x25,0x40,0xA2,0x00,
+0x20,0x00,0xB2,0xAF,
+0x38,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x03,0x8D,
+0xFF,0xFF,0xD2,0x30,
+0x08,0x00,0x45,0x26,
+0x00,0xC0,0x02,0x24,
+0x04,0x00,0x06,0x8D,
+0x24,0x18,0x62,0x00,
+0xFF,0x3F,0xA5,0x30,
+0xF0,0xFF,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x80,0x05,0x3C,
+0x25,0x18,0x65,0x00,
+0xFF,0x01,0xC6,0x34,
+0x00,0x00,0x03,0xAD,
+0x04,0x00,0x06,0xAD,
+0x21,0x48,0x80,0x00,
+0xFF,0xFF,0xE7,0x30,
+0x18,0x00,0x06,0x25,
+0x18,0x00,0x12,0xA5,
+0x02,0x00,0xC7,0xA0,
+0x18,0x00,0x03,0x8D,
+0xFF,0x7F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x02,0x80,0x16,0x3C,
+0x18,0x00,0x03,0xAD,
+0x60,0x1B,0xC5,0x26,
+0x66,0x37,0xA4,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x82,0x24,
+0x66,0x37,0xA2,0xA0,
+0x18,0x00,0x03,0x8D,
+0xFF,0x80,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x7F,0x00,0x84,0x30,
+0x00,0x26,0x04,0x00,
+0x24,0x18,0x62,0x00,
+0x25,0x18,0x64,0x00,
+0x18,0x00,0x03,0xAD,
+0x02,0x80,0x02,0x3C,
+0x5A,0x5F,0x44,0x90,
+0x20,0x00,0x43,0x26,
+0xFF,0xFF,0x72,0x30,
+0x02,0x00,0x84,0x30,
+0x04,0x00,0x80,0x10,
+0x21,0x18,0x40,0x02,
+0x1F,0x00,0x42,0x32,
+0x71,0x00,0x40,0x10,
+0x08,0x00,0x42,0x26,
+0xFF,0xFF,0x63,0x30,
+0x72,0x00,0x43,0x12,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xC2,0x8C,
+0x21,0x90,0x60,0x00,
+0x00,0xC0,0x04,0x24,
+0x01,0x00,0x42,0x34,
+0x04,0x00,0xC2,0xAC,
+0x00,0x00,0x03,0x8D,
+0x00,0x00,0x00,0x00,
+0xFF,0x3F,0x62,0x30,
+0x08,0x00,0x42,0x24,
+0x24,0x18,0x64,0x00,
+0xFF,0x3F,0x42,0x30,
+0x25,0x18,0x62,0x00,
+0x00,0x00,0x03,0xAD,
+0x25,0xB0,0x02,0x3C,
+0xC0,0x00,0x42,0x34,
+0x07,0x00,0x43,0x32,
+0x00,0x00,0x52,0xA4,
+0x03,0x00,0x60,0x10,
+0xF8,0xFF,0x53,0x32,
+0x08,0x00,0x42,0x26,
+0xF8,0xFF,0x53,0x30,
+0x60,0x1B,0xD5,0x26,
+0xEC,0x38,0xA6,0x8E,
+0xF0,0x38,0xB0,0x8E,
+0x21,0x10,0xD3,0x00,
+0x2B,0x10,0x02,0x02,
+0x2F,0x00,0x40,0x10,
+0xFF,0x00,0x34,0x31,
+0x23,0x80,0x06,0x02,
+0x21,0x28,0xE0,0x02,
+0xFF,0xFF,0x07,0x32,
+0x01,0x00,0x11,0x24,
+0x21,0x20,0x80,0x02,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xB1,0xAF,
+0x23,0x18,0x70,0x02,
+0xFF,0xFF,0x72,0x30,
+0x22,0x10,0x02,0x3C,
+0x21,0x10,0x42,0x02,
+0x21,0x20,0x80,0x02,
+0x52,0x01,0x00,0x0C,
+0xEC,0x38,0xA2,0xAE,
+0x21,0x28,0xF0,0x02,
+0x21,0x38,0x40,0x02,
+0x21,0x20,0x80,0x02,
+0x22,0x10,0x06,0x3C,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xB1,0xAF,
+0x52,0x01,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0x60,0x1B,0xC2,0x26,
+0xEC,0x38,0x46,0x8C,
+0x25,0xB0,0x04,0x3C,
+0xEC,0x00,0x82,0x34,
+0x00,0x00,0x46,0xAC,
+0xBD,0x00,0x85,0x34,
+0x00,0x00,0xA3,0x90,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0xC2,0x00,0x84,0x34,
+0x01,0x00,0x02,0x24,
+0x10,0x00,0x63,0x34,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0xA3,0xA0,
+0x00,0x00,0x86,0xA4,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0xE0,0x02,
+0x21,0x20,0x80,0x02,
+0x21,0x38,0x60,0x02,
+0x01,0x00,0x02,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0xEC,0x38,0xA3,0x8E,
+0x21,0x20,0x80,0x02,
+0x21,0x18,0x73,0x00,
+0x52,0x01,0x00,0x0C,
+0xEC,0x38,0xA3,0xAE,
+0x60,0x1B,0xC2,0x26,
+0xEC,0x38,0x46,0x8C,
+0x25,0xB0,0x04,0x3C,
+0xEC,0x00,0x82,0x34,
+0x00,0x00,0x46,0xAC,
+0xBD,0x00,0x85,0x34,
+0x00,0x00,0xA3,0x90,
+0x38,0x00,0xBF,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0xC2,0x00,0x84,0x34,
+0x01,0x00,0x02,0x24,
+0x10,0x00,0x63,0x34,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0xA3,0xA0,
+0x00,0x00,0x86,0xA4,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x43,0x30,
+0xFF,0xFF,0x63,0x30,
+0x90,0xFF,0x43,0x16,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xC2,0x8C,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x40,0x09,0x00,0x08,
+0x04,0x00,0xC2,0xAC,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x14,0x00,0x03,0x8E,
+0x16,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0x0A,0x00,0x62,0x10,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x02,0x96,
+0x02,0x80,0x04,0x3C,
+0xC6,0x53,0x00,0x0C,
+0x25,0x20,0x44,0x00,
+0x08,0x00,0x05,0x8E,
+0x0C,0x00,0x06,0x96,
+0x14,0x00,0x07,0x96,
+0xF0,0x08,0x00,0x0C,
+0x09,0x00,0x04,0x24,
+0x04,0x00,0x03,0x8E,
+0x00,0x00,0x02,0x8E,
+0x21,0x20,0x00,0x02,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0x10,0xAE,
+0x14,0x28,0x00,0x0C,
+0x04,0x00,0x10,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x25,0xB0,0x02,0x3C,
+0xBF,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x63,0x2C,
+0x05,0x00,0x60,0x10,
+0x02,0x80,0x05,0x3C,
+0x90,0x54,0xA3,0x8C,
+0x90,0x54,0xA2,0x24,
+0x0D,0x00,0x62,0x10,
+0x21,0x20,0x00,0x02,
+0x90,0x54,0xA2,0x24,
+0x04,0x00,0x43,0x8C,
+0x00,0x00,0x02,0xAE,
+0x04,0x00,0x50,0xAC,
+0x00,0x00,0x70,0xAC,
+0x04,0x00,0x03,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xA9,0x09,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x04,0xEE,0x84,0x24,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x13,0x57,0x00,0x0C,
+0x1C,0x00,0xB1,0xAF,
+0x00,0x00,0x04,0x96,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x83,0x24,
+0x07,0x00,0x62,0x30,
+0x03,0x00,0x40,0x10,
+0xC2,0x10,0x03,0x00,
+0x28,0x00,0x82,0x24,
+0xC2,0x10,0x02,0x00,
+0xF3,0x27,0x00,0x0C,
+0xC0,0x20,0x02,0x00,
+0x61,0x00,0x40,0x10,
+0x21,0x88,0x40,0x00,
+0x02,0x80,0x12,0x3C,
+0x02,0x00,0x06,0x92,
+0x60,0x1B,0x50,0x26,
+0x10,0x38,0x05,0x8E,
+0x08,0x00,0xC6,0x24,
+0x0A,0x00,0x04,0x24,
+0x64,0x01,0x00,0x0C,
+0x21,0x38,0x40,0x00,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x5B,0x00,0x40,0x14,
+0x01,0x00,0x62,0x30,
+0x02,0x80,0x02,0x3C,
+0x4C,0xFC,0x43,0x90,
+0x60,0x1B,0x50,0x26,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0xE8,0x39,0x00,0xAE,
+0x04,0x3A,0x00,0xAE,
+0x20,0x3A,0x00,0xAE,
+0x60,0x42,0x00,0xAE,
+0x64,0x42,0x00,0xAE,
+0x70,0x43,0x00,0xAE,
+0xD6,0x43,0x00,0xA2,
+0x30,0x43,0x00,0xAE,
+0x3A,0x43,0x00,0xA2,
+0x9A,0x40,0x00,0x0C,
+0x5E,0x5F,0x43,0xA0,
+0x4F,0x6B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x35,0x6C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x6A,0x5F,0x48,0x90,
+0x25,0xB0,0x04,0x3C,
+0x2F,0x00,0x02,0x3C,
+0xD0,0x01,0x85,0x34,
+0x17,0x32,0x42,0x34,
+0x00,0x00,0xA2,0xAC,
+0x5E,0x00,0x03,0x3C,
+0x10,0x00,0x02,0x3C,
+0xDC,0x01,0x87,0x34,
+0xD4,0x01,0x86,0x34,
+0x17,0x43,0x63,0x34,
+0x20,0x53,0x42,0x34,
+0xD8,0x01,0x84,0x34,
+0x00,0x00,0xC3,0xAC,
+0x00,0x00,0x82,0xAC,
+0x44,0xA4,0x03,0x34,
+0x01,0x00,0x02,0x24,
+0x00,0x00,0xE3,0xAC,
+0x46,0x00,0x02,0x11,
+0xFF,0xF7,0x03,0x24,
+0xFC,0x23,0x02,0x8E,
+0xFF,0xEF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0xFC,0x23,0x02,0xAE,
+0x60,0x1B,0x42,0x8E,
+0xDF,0xFF,0x03,0x24,
+0xFB,0xFF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x50,0x0C,0x04,0x24,
+0x60,0x1B,0x50,0x26,
+0x24,0x5B,0x00,0x0C,
+0x60,0x1B,0x42,0xAE,
+0xFC,0x3E,0x02,0xA2,
+0x24,0x5B,0x00,0x0C,
+0x58,0x0C,0x04,0x24,
+0xFD,0x3E,0x02,0xA2,
+0x50,0x0C,0x04,0x24,
+0x0E,0x5B,0x00,0x0C,
+0x17,0x00,0x05,0x24,
+0x17,0x00,0x05,0x24,
+0x0E,0x5B,0x00,0x0C,
+0x58,0x0C,0x04,0x24,
+0x52,0x01,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x08,0x00,0x22,0x96,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0x25,0x28,0x45,0x00,
+0xCC,0x55,0x84,0x24,
+0xCE,0x53,0x00,0x0C,
+0x74,0x03,0x06,0x24,
+0x14,0x28,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0xB4,0x3A,0x02,0x8E,
+0xE4,0x4B,0x00,0x0C,
+0xE0,0x3D,0x02,0xA2,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x1F,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x56,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xFF,0xFE,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x25,0xB0,0x04,0x3C,
+0x4C,0x00,0x82,0x34,
+0x00,0x00,0x40,0xA0,
+0x48,0x00,0x84,0x34,
+0x00,0x00,0x83,0x8C,
+0x7B,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x83,0xAC,
+0x13,0x0A,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x02,0x3C,
+0x6B,0x5F,0x44,0x90,
+0x02,0x00,0x03,0x24,
+0x0C,0x00,0x83,0x10,
+0xFF,0xF7,0x03,0x24,
+0xFC,0x23,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x43,0x00,
+0x41,0x0A,0x00,0x08,
+0x00,0x10,0x42,0x34,
+0x02,0x80,0x04,0x3C,
+0xD0,0x55,0x84,0x24,
+0xAF,0x4F,0x00,0x0C,
+0x03,0x00,0x05,0x24,
+0x6E,0x0A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFC,0x23,0x02,0x8E,
+0xFF,0xEF,0x03,0x24,
+0x00,0x08,0x42,0x34,
+0x41,0x0A,0x00,0x08,
+0x24,0x10,0x43,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x85,0x90,
+0x02,0x80,0x11,0x3C,
+0x01,0x00,0x02,0x24,
+0xFF,0x00,0xA3,0x30,
+0x10,0x00,0xA4,0x27,
+0x0F,0x00,0x62,0x10,
+0x60,0x1B,0x26,0x26,
+0x04,0x00,0x02,0x24,
+0x1B,0x00,0x62,0x10,
+0x60,0x1B,0x30,0x26,
+0x60,0x1B,0x22,0x26,
+0xE2,0x3D,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x14,0xEE,0x84,0x24,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x9A,0x40,0x00,0x0C,
+0xE2,0x3D,0xC5,0xA0,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x60,0x1B,0x22,0x26,
+0xE2,0x3D,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x14,0xEE,0x84,0x24,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x9A,0x40,0x00,0x0C,
+0xE2,0x3D,0x05,0xA2,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0x04,0x00,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0xB5,0x0A,0x00,0x08,
+0x60,0x1B,0x22,0x26,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x02,0x92,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x40,0x00,
+0x04,0x00,0x42,0x2C,
+0x06,0x00,0x40,0x14,
+0x24,0xEE,0x84,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x03,0x92,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x80,0x02,0x3C,
+0xF8,0x5D,0x43,0xAC,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xD0,0xFF,0xBD,0x27,
+0x18,0x03,0x42,0x34,
+0x84,0x2B,0x63,0x24,
+0x24,0x00,0xB3,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x04,0x3C,
+0x18,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x12,0x00,0x40,0x10,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x02,0x3C,
+0x38,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x5B,0x00,0x60,0x14,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x41,0x64,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x01,0x00,0x05,0x24,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x02,0x80,0x02,0x3C,
+0x98,0x54,0x43,0x8C,
+0x98,0x54,0x42,0x24,
+0x95,0x00,0x62,0x10,
+0x02,0x80,0x13,0x3C,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x02,0x3C,
+0x36,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x60,0x1B,0x66,0x26,
+0xF4,0x38,0xC5,0x8C,
+0xC0,0x18,0x03,0x00,
+0x23,0xB0,0x04,0x3C,
+0xF0,0x07,0x63,0x30,
+0xFF,0x1F,0x02,0x3C,
+0x21,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x62,0x00,
+0x23,0x88,0x85,0x00,
+0x00,0x04,0x22,0x26,
+0x2B,0x28,0x85,0x00,
+0x98,0x38,0xC3,0x8C,
+0x0B,0x88,0x45,0x00,
+0xE1,0x01,0x22,0x2E,
+0x94,0x38,0xC3,0xAC,
+0xF8,0x38,0xC4,0xAC,
+0x9E,0x38,0xC0,0xA4,
+0x14,0x00,0x40,0x14,
+0x9D,0x38,0xC0,0xA0,
+0x20,0xFE,0x82,0x24,
+0x20,0x02,0x83,0x24,
+0x0A,0x18,0x45,0x00,
+0x23,0x10,0x02,0x3C,
+0xFF,0x03,0x42,0x34,
+0x2B,0x10,0x43,0x00,
+0x21,0x28,0x60,0x00,
+0x2A,0x00,0x40,0x14,
+0xF4,0x38,0xC3,0xAC,
+0xF8,0x38,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x2B,0x18,0x45,0x00,
+0x23,0x88,0x45,0x00,
+0x03,0x00,0x60,0x10,
+0xE1,0x01,0x22,0x2E,
+0x00,0x04,0x31,0x26,
+0xE1,0x01,0x22,0x2E,
+0x0A,0x00,0x40,0x10,
+0x60,0x1B,0x70,0x26,
+0x60,0x1B,0x70,0x26,
+0xF8,0x38,0x03,0x8E,
+0xF4,0x38,0x04,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x83,0x00,
+0x24,0x00,0x40,0x14,
+0x2B,0x10,0x64,0x00,
+0x4A,0x00,0x40,0x14,
+0x21,0x30,0x80,0x00,
+0xF4,0x38,0x03,0x96,
+0x2A,0xB0,0x02,0x3C,
+0x35,0x00,0x42,0x34,
+0xC2,0x88,0x03,0x00,
+0x00,0x00,0x51,0xA0,
+0x14,0x2A,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xD0,0x1B,0x02,0x8E,
+0x80,0x00,0x03,0x3C,
+0x41,0xB0,0x04,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xAC,
+0x28,0x00,0xBF,0x8F,
+0xD0,0x1B,0x02,0xAE,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x00,0xFC,0xA5,0x24,
+0x24,0x0B,0x00,0x08,
+0xF4,0x38,0xC5,0xAC,
+0x8E,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAA,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x81,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFE,0x0A,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x94,0x38,0x05,0x8E,
+0x21,0x30,0x80,0x00,
+0xFF,0xFF,0x27,0x32,
+0x09,0x00,0x04,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x94,0x38,0x03,0x8E,
+0x9E,0x38,0x05,0x96,
+0xF4,0x38,0x02,0x8E,
+0x21,0x18,0x71,0x00,
+0x21,0x28,0x25,0x02,
+0x21,0x10,0x51,0x00,
+0x09,0x00,0x04,0x24,
+0xF4,0x38,0x02,0xAE,
+0x94,0x38,0x03,0xAE,
+0x52,0x01,0x00,0x0C,
+0x9E,0x38,0x05,0xA6,
+0x60,0x1B,0x70,0x26,
+0xF4,0x38,0x03,0x96,
+0x2A,0xB0,0x02,0x3C,
+0x35,0x00,0x42,0x34,
+0xC2,0x88,0x03,0x00,
+0x00,0x00,0x51,0xA0,
+0x14,0x2A,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xD0,0x1B,0x02,0x8E,
+0x80,0x00,0x03,0x3C,
+0x41,0xB0,0x04,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xAC,
+0x28,0x00,0xBF,0x8F,
+0xD0,0x1B,0x02,0xAE,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xFC,0x38,0x02,0x8E,
+0x94,0x38,0x05,0x8E,
+0x23,0x88,0x44,0x00,
+0xFF,0xFF,0x27,0x32,
+0x09,0x00,0x04,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x94,0x38,0x03,0x8E,
+0x9E,0x38,0x02,0x96,
+0xF8,0x38,0x12,0x96,
+0x21,0x18,0x71,0x00,
+0x21,0x10,0x22,0x02,
+0x23,0x10,0x11,0x3C,
+0x94,0x38,0x03,0xAE,
+0x9E,0x38,0x02,0xA6,
+0x18,0x00,0x40,0x16,
+0xF4,0x38,0x11,0xAE,
+0x09,0x00,0x04,0x24,
+0x52,0x01,0x00,0x0C,
+0x60,0x1B,0x70,0x26,
+0x6A,0x0B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x8E,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x69,0xFF,0x40,0x10,
+0x60,0x1B,0x65,0x26,
+0x28,0x1C,0xA3,0x8C,
+0x0F,0x00,0x02,0x3C,
+0x24,0x10,0x62,0x00,
+0x64,0xFF,0x40,0x10,
+0xF0,0xFF,0x02,0x3C,
+0x68,0x3A,0xA4,0x94,
+0xFF,0xFF,0x42,0x34,
+0x24,0x10,0x62,0x00,
+0x00,0xC0,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0x57,0x37,0x00,0x0C,
+0x28,0x1C,0xA2,0xAC,
+0x02,0x0B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x52,0x01,0x00,0x0C,
+0x09,0x00,0x04,0x24,
+0x94,0x38,0x05,0x8E,
+0x09,0x00,0x04,0x24,
+0x23,0x10,0x06,0x3C,
+0x21,0x38,0x40,0x02,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x94,0x38,0x03,0x8E,
+0x9E,0x38,0x02,0x96,
+0x21,0x20,0x51,0x02,
+0x21,0x18,0x72,0x00,
+0x21,0x10,0x42,0x02,
+0xF4,0x38,0x04,0xAE,
+0x09,0x00,0x04,0x24,
+0x94,0x38,0x03,0xAE,
+0x92,0x0B,0x00,0x08,
+0x9E,0x38,0x02,0xA6,
+0x02,0x80,0x02,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x58,0xE2,0x46,0x24,
+0x00,0x00,0x83,0x8C,
+0x04,0x00,0xC2,0x90,
+0x02,0x80,0x04,0x3C,
+0x84,0xEE,0x84,0x24,
+0x03,0x00,0x62,0x10,
+0xFF,0x00,0x65,0x30,
+0x13,0x57,0x00,0x0C,
+0x04,0x00,0xC3,0xA0,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x21,0x88,0x80,0x00,
+0x10,0x00,0xA4,0x27,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x54,0x61,0xC3,0x90,
+0xFF,0x00,0x02,0x24,
+0x4C,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x24,0x92,
+0x54,0x61,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x30,0x00,0x40,0x10,
+0x02,0x80,0x07,0x3C,
+0x54,0x61,0xC4,0xA0,
+0x01,0x00,0x23,0x92,
+0x54,0x61,0xC4,0x24,
+0x02,0x80,0x14,0x3C,
+0x01,0x00,0x83,0xA0,
+0x02,0x00,0x22,0x92,
+0x08,0x00,0x30,0x26,
+0x21,0x98,0x00,0x00,
+0x02,0x00,0x82,0xA0,
+0x06,0x00,0x25,0x92,
+0x00,0x00,0x00,0x00,
+0x64,0x60,0x85,0xA2,
+0x03,0x00,0x22,0x92,
+0x00,0x00,0x00,0x00,
+0x57,0x61,0xE2,0xA0,
+0x04,0x00,0x23,0x96,
+0x02,0x80,0x02,0x3C,
+0x12,0x00,0xA0,0x10,
+0x58,0x61,0x43,0xA4,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x38,0x61,0x52,0x24,
+0x68,0x60,0x71,0x24,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x00,0x02,
+0xCE,0x53,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x64,0x60,0x83,0x92,
+0x10,0x00,0x02,0x96,
+0x01,0x00,0x73,0x26,
+0x2A,0x18,0x63,0x02,
+0x00,0x00,0x42,0xA6,
+0x14,0x00,0x10,0x26,
+0x10,0x00,0x31,0x26,
+0xF4,0xFF,0x60,0x14,
+0x02,0x00,0x52,0x26,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x02,0x24,
+0xCE,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x57,0x61,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x40,0x14,
+0x25,0xB0,0x04,0x3C,
+0x25,0xB0,0x05,0x3C,
+0xEC,0x02,0xA5,0x34,
+0x00,0x00,0xA2,0x8C,
+0x20,0x20,0x03,0x3C,
+0xFF,0xDF,0x04,0x24,
+0x25,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x00,0x00,0xA2,0xAC,
+0x25,0xB0,0x02,0x3C,
+0xFF,0xFF,0x03,0x24,
+0x1A,0x01,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x00,0x00,0x24,0x92,
+0xDF,0x0B,0x00,0x08,
+0x54,0x61,0xC4,0xA0,
+0x00,0x00,0x24,0x92,
+0x00,0x00,0x00,0x00,
+0xB3,0xFF,0x80,0x14,
+0x25,0xB0,0x02,0x3C,
+0x00,0x10,0x03,0x24,
+0x1A,0x01,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x54,0x61,0xC4,0xA0,
+0x00,0x00,0x24,0x92,
+0xDE,0x0B,0x00,0x08,
+0x02,0x80,0x07,0x3C,
+0xEC,0x02,0x84,0x34,
+0x00,0x00,0x83,0x8C,
+0x20,0x20,0x02,0x3C,
+0x00,0x20,0x42,0x34,
+0x25,0x18,0x62,0x00,
+0x00,0x00,0x83,0xAC,
+0x1E,0x0C,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x2E,0x00,0x83,0x90,
+0x01,0x00,0x02,0x24,
+0x0C,0x00,0x62,0x10,
+0x21,0x88,0x80,0x00,
+0x02,0x00,0x62,0x28,
+0x32,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x15,0x00,0x62,0x10,
+0x02,0x80,0x10,0x3C,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x32,0x00,0x83,0x90,
+0x02,0x80,0x04,0x3C,
+0x34,0x00,0x25,0x26,
+0xC0,0x30,0x03,0x00,
+0x02,0x80,0x02,0x3C,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x28,0x5C,0x84,0x24,
+0xF8,0x00,0xC6,0x30,
+0x20,0x00,0xBD,0x27,
+0xCE,0x53,0x00,0x08,
+0xB8,0x5D,0x43,0xA0,
+0x58,0xE2,0x10,0x26,
+0x04,0x00,0x04,0x92,
+0x6F,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x72,0x24,
+0x04,0x00,0x05,0x92,
+0xCC,0x3E,0x44,0x8E,
+0xB1,0x07,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x58,0x42,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0xDF,0xFF,0x40,0x10,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x40,0x02,
+0x30,0x00,0x24,0x96,
+0xC0,0x10,0x05,0x00,
+0x21,0x10,0x46,0x00,
+0xCA,0x40,0x44,0xA4,
+0x58,0x42,0xC3,0x90,
+0x01,0x00,0xA2,0x24,
+0xFF,0x00,0x45,0x30,
+0x2B,0x18,0xA3,0x00,
+0xF7,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x45,0x0C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xD0,0xFF,0x60,0x14,
+0x02,0x80,0x10,0x3C,
+0x58,0xE2,0x10,0x26,
+0x04,0x00,0x04,0x92,
+0x6F,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x04,0x00,0x05,0x92,
+0x2C,0x5A,0x64,0x8C,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xB1,0x07,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x24,0x00,0xB3,0xAF,
+0x02,0x80,0x13,0x3C,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x60,0x1B,0x72,0x26,
+0xB0,0x1B,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x30,0x42,0x30,
+0x0B,0x00,0x40,0x10,
+0x21,0xA0,0x80,0x00,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x02,0x80,0x15,0x3C,
+0x1A,0x64,0xA2,0x92,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x75,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x60,0x1B,0x62,0x8E,
+0xDF,0xFF,0x03,0x24,
+0xFB,0xFF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x50,0x0C,0x04,0x24,
+0x24,0x5B,0x00,0x0C,
+0x60,0x1B,0x62,0xAE,
+0xFC,0x3E,0x42,0xA2,
+0x24,0x5B,0x00,0x0C,
+0x58,0x0C,0x04,0x24,
+0xFD,0x3E,0x42,0xA2,
+0x50,0x0C,0x04,0x24,
+0x0E,0x5B,0x00,0x0C,
+0x17,0x00,0x05,0x24,
+0x17,0x00,0x05,0x24,
+0x0E,0x5B,0x00,0x0C,
+0x58,0x0C,0x04,0x24,
+0xB0,0x1B,0x42,0x96,
+0x02,0x80,0x04,0x3C,
+0x90,0xEE,0x84,0x24,
+0x00,0x10,0x42,0x34,
+0x13,0x57,0x00,0x0C,
+0xB0,0x1B,0x42,0xA6,
+0x01,0x00,0x02,0x24,
+0x25,0xB0,0x03,0x3C,
+0xC8,0x3E,0x42,0xAE,
+0x4C,0x00,0x63,0x34,
+0xB0,0x1B,0x42,0x96,
+0x00,0x00,0x66,0x90,
+0x08,0x00,0x85,0x8E,
+0xE0,0x3D,0x47,0x92,
+0xE1,0x3D,0x48,0x92,
+0xD8,0x43,0x49,0x92,
+0x00,0x80,0x42,0x30,
+0xFB,0x3E,0x46,0xA2,
+0xD0,0x3E,0x45,0xAE,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x60,0xA0,
+0xF5,0x3E,0x47,0xA2,
+0xF6,0x3E,0x48,0xA2,
+0xF8,0x3E,0x42,0xA6,
+0xFA,0x3E,0x49,0xA2,
+0x00,0x3F,0x40,0xAE,
+0x04,0x3F,0x40,0xAE,
+0x9A,0x40,0x00,0x0C,
+0xF7,0x3E,0x40,0xA2,
+0x10,0x00,0xA4,0x27,
+0xA0,0x40,0x00,0x0C,
+0xEE,0x43,0x40,0xA2,
+0x08,0x00,0x86,0x8E,
+0x00,0x00,0x00,0x00,
+0x31,0x00,0xC0,0x14,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x83,0x8E,
+0x02,0x80,0x02,0x3C,
+0x68,0x5A,0x51,0x24,
+0xCC,0x3E,0x43,0xAE,
+0x3F,0x00,0x10,0x24,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x00,0x00,
+0x07,0x00,0x06,0x24,
+0xBD,0x53,0x00,0x0C,
+0xFF,0xFF,0x10,0x26,
+0xFA,0xFF,0x01,0x06,
+0x07,0x00,0x31,0x26,
+0x37,0x0C,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0x60,0x1B,0x62,0x26,
+0xB0,0x1B,0x42,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x43,0x30,
+0x08,0x00,0x60,0x10,
+0x01,0x00,0x42,0x30,
+0x07,0x00,0x40,0x10,
+0x25,0xB0,0x04,0x3C,
+0x1A,0x64,0xA2,0x92,
+0x0C,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x25,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x48,0x00,0x84,0x34,
+0x00,0x00,0x83,0x8C,
+0x7B,0xFF,0x02,0x3C,
+0x60,0x1B,0x65,0x26,
+0xFF,0xFF,0x42,0x34,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x24,0x18,0x62,0x00,
+0x1E,0x00,0x02,0x24,
+0x00,0x00,0x83,0xAC,
+0x38,0x00,0xBD,0x27,
+0x94,0x39,0xA2,0xAC,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x5C,0x42,0xA0,0xA0,
+0x0C,0x00,0x90,0x26,
+0x21,0x28,0x00,0x02,
+0xCE,0x53,0x00,0x0C,
+0x34,0x5A,0x84,0x24,
+0x02,0x80,0x04,0x3C,
+0xA0,0xEE,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0xDF,0x0C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x04,0x24,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0xA5,0x0C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x90,0x50,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xFB,0x0C,0x00,0x08,
+0x25,0xB0,0x04,0x3C,
+0x08,0x00,0xE0,0x03,
+0x09,0x00,0x02,0x24,
+0xFF,0x00,0x86,0x30,
+0x02,0x80,0x02,0x3C,
+0x40,0x00,0xC3,0x2C,
+0x4B,0xFC,0x47,0x90,
+0x00,0x00,0x63,0x38,
+0x3F,0x00,0x02,0x24,
+0x0A,0x30,0x43,0x00,
+0x01,0x00,0x02,0x24,
+0x08,0x0E,0x04,0x24,
+0x00,0x7F,0x05,0x24,
+0x03,0x00,0xE2,0x10,
+0x31,0x00,0xC3,0x2C,
+0x50,0x44,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x30,0x00,0x02,0x24,
+0x50,0x44,0x00,0x08,
+0x0A,0x30,0x43,0x00,
+0xB0,0xFF,0xBD,0x27,
+0x02,0x80,0x0B,0x3C,
+0x40,0x00,0xB6,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x4C,0x00,0xBF,0xAF,
+0x48,0x00,0xBE,0xAF,
+0x44,0x00,0xB7,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0x38,0x00,0xB4,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0xAC,0xEE,0x63,0x25,
+0x0A,0x00,0x69,0x94,
+0x02,0x00,0x67,0x94,
+0x06,0x00,0x68,0x94,
+0x02,0x80,0x02,0x3C,
+0x10,0x37,0x4A,0x84,
+0xAC,0xEE,0x6C,0x95,
+0x04,0x00,0x62,0x94,
+0x08,0x00,0x6B,0x94,
+0x00,0x3C,0x07,0x00,
+0xFF,0x00,0xC3,0x30,
+0x00,0x44,0x08,0x00,
+0x00,0x4C,0x09,0x00,
+0x25,0x40,0x02,0x01,
+0x25,0x38,0xEC,0x00,
+0x25,0x48,0x2B,0x01,
+0x00,0x00,0x4A,0x29,
+0x04,0x00,0x62,0x2C,
+0x10,0x00,0xA7,0xAF,
+0x14,0x00,0xA8,0xAF,
+0x18,0x00,0xA9,0xAF,
+0xFF,0x00,0x88,0x30,
+0xFF,0x00,0xA7,0x30,
+0x80,0x98,0x0A,0x00,
+0x05,0x00,0x40,0x14,
+0x21,0xB0,0x00,0x00,
+0x09,0x00,0x63,0x2C,
+0x01,0x00,0x16,0x24,
+0x02,0x00,0x02,0x24,
+0x0A,0xB0,0x43,0x00,
+0x00,0x24,0x07,0x00,
+0x00,0x16,0x07,0x00,
+0x00,0x2C,0x08,0x00,
+0x25,0x10,0x44,0x00,
+0x00,0x1E,0x08,0x00,
+0x00,0x22,0x07,0x00,
+0x25,0x18,0x65,0x00,
+0x25,0x10,0x44,0x00,
+0x00,0x2A,0x08,0x00,
+0x25,0x18,0x65,0x00,
+0x25,0xA0,0x47,0x00,
+0x02,0x80,0x02,0x3C,
+0x25,0x90,0x68,0x00,
+0x60,0x1B,0x5E,0x24,
+0x21,0x80,0x00,0x00,
+0x02,0x80,0x15,0x3C,
+0x10,0x00,0xB1,0x27,
+0x03,0x00,0x17,0x24,
+0x02,0x00,0x02,0x2E,
+0x3D,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x4E,0xFC,0xA2,0x92,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x32,0x00,0x57,0x10,
+0x21,0x40,0x80,0x02,
+0x21,0x38,0x00,0x00,
+0x7F,0x00,0x09,0x24,
+0xC0,0x20,0x07,0x00,
+0x04,0x10,0x89,0x00,
+0x24,0x10,0x48,0x00,
+0x06,0x10,0x82,0x00,
+0x01,0x00,0xE5,0x24,
+0xFF,0x00,0x43,0x30,
+0x21,0x30,0x27,0x02,
+0x40,0x00,0x63,0x2C,
+0xFF,0x00,0xA7,0x30,
+0x02,0x00,0x60,0x14,
+0x04,0x00,0xE4,0x2C,
+0x3F,0x00,0x02,0x24,
+0xF3,0xFF,0x80,0x14,
+0x10,0x00,0xC2,0xA0,
+0x23,0x00,0xA6,0x93,
+0x22,0x00,0xA2,0x93,
+0x21,0x00,0xA5,0x93,
+0x40,0x18,0x10,0x00,
+0x00,0x14,0x02,0x00,
+0x21,0x18,0x71,0x00,
+0x20,0x00,0xA7,0x93,
+0x00,0x36,0x06,0x00,
+0x25,0x30,0xC2,0x00,
+0x00,0x2A,0x05,0x00,
+0x00,0x00,0x64,0x94,
+0x25,0x30,0xC5,0x00,
+0x7F,0x7F,0x05,0x3C,
+0x25,0x30,0xC7,0x00,
+0x50,0x44,0x00,0x0C,
+0x7F,0x7F,0xA5,0x34,
+0x01,0x00,0x02,0x26,
+0xFF,0x00,0x50,0x30,
+0x06,0x00,0x03,0x2E,
+0xD3,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x4C,0x00,0xBF,0x8F,
+0x48,0x00,0xBE,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0x80,0x10,0x10,0x00,
+0x21,0x10,0x5E,0x00,
+0xF0,0x1C,0x43,0x8C,
+0x7A,0x0D,0x00,0x08,
+0x21,0x40,0x74,0x00,
+0x4E,0xFC,0xA2,0x92,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x80,0x10,0x10,0x00,
+0x21,0x10,0x5E,0x00,
+0xF0,0x1C,0x43,0x8C,
+0x7A,0x0D,0x00,0x08,
+0x21,0x40,0x72,0x00,
+0xC0,0xFF,0x57,0x14,
+0x21,0x40,0x40,0x02,
+0x80,0x10,0x16,0x00,
+0x21,0x10,0x50,0x00,
+0x02,0x80,0x03,0x3C,
+0x78,0xDE,0x63,0x24,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0xFB,0xFF,0x43,0x90,
+0xFA,0xFF,0x44,0x90,
+0xF9,0xFF,0x45,0x90,
+0x07,0x18,0x63,0x02,
+0x07,0x20,0x64,0x02,
+0xF8,0xFF,0x46,0x90,
+0x0F,0x00,0x63,0x30,
+0x0F,0x00,0x84,0x30,
+0x07,0x28,0x65,0x02,
+0x00,0x1E,0x03,0x00,
+0x00,0x24,0x04,0x00,
+0x0F,0x00,0xA5,0x30,
+0x25,0x18,0x64,0x00,
+0x00,0x2A,0x05,0x00,
+0x07,0x30,0x66,0x02,
+0x25,0x18,0x65,0x00,
+0x0F,0x00,0xC6,0x30,
+0x25,0x18,0x66,0x00,
+0x7A,0x0D,0x00,0x08,
+0x21,0x40,0x43,0x02,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x43,0x90,
+0x02,0x80,0x07,0x3C,
+0x60,0x1B,0xE2,0x24,
+0xFF,0x00,0x91,0x30,
+0x21,0x20,0x22,0x02,
+0x20,0x00,0x62,0x30,
+0x10,0x00,0x63,0x30,
+0x63,0x1D,0x93,0x90,
+0x29,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x8D,0x1D,0x82,0x90,
+0x7F,0x1D,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x23,0x10,0x43,0x00,
+0x00,0x36,0x02,0x00,
+0x03,0x36,0x06,0x00,
+0xFF,0x00,0x70,0x30,
+0x60,0x1B,0xE7,0x24,
+0x21,0x40,0x27,0x02,
+0xB7,0x1D,0x02,0x91,
+0xB0,0x1B,0xE3,0x84,
+0x0F,0x00,0x05,0x3C,
+0x0F,0x00,0x42,0x30,
+0x21,0x10,0x50,0x00,
+0x0C,0x08,0x04,0x24,
+0x0F,0x00,0xC6,0x30,
+0x00,0xFF,0xA5,0x34,
+0x08,0x00,0x60,0x04,
+0xFF,0x00,0x52,0x30,
+0xC5,0x1D,0x03,0x91,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x62,0x30,
+0x21,0x10,0x50,0x00,
+0x08,0x00,0x63,0x30,
+0x23,0x10,0x43,0x00,
+0xFF,0x00,0x50,0x30,
+0x50,0x44,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x24,0x0D,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x40,0x02,
+0x21,0x30,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x35,0x0D,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0xDE,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xA9,0x1D,0x82,0x90,
+0x9B,0x1D,0x83,0x90,
+0xEA,0x0D,0x00,0x08,
+0x23,0x10,0x43,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x02,0x3C,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x69,0x5F,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0x14,0x00,0x62,0x10,
+0xFF,0x00,0x91,0x30,
+0x02,0x80,0x10,0x3C,
+0x60,0x1B,0x02,0x26,
+0xB0,0x1B,0x45,0x94,
+0x21,0x20,0x20,0x02,
+0xD5,0x0D,0x00,0x0C,
+0x00,0x10,0xA5,0x30,
+0x21,0x30,0x20,0x02,
+0x18,0x00,0x04,0x24,
+0x12,0x46,0x00,0x0C,
+0xFF,0x03,0x05,0x24,
+0x60,0x1B,0x02,0x26,
+0xE0,0x3D,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xB8,0xEE,0x84,0x24,
+0x13,0x57,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x1B,0x00,0x23,0x12,
+0x0B,0x00,0x02,0x24,
+0x1E,0x00,0x22,0x12,
+0x0F,0x00,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x15,0x00,0x04,0x24,
+0xF4,0xF8,0x06,0x34,
+0x12,0x46,0x00,0x0C,
+0x02,0x80,0x10,0x3C,
+0x02,0x80,0x02,0x3C,
+0x49,0xFC,0x43,0x90,
+0xFE,0x00,0x02,0x24,
+0xE7,0xFF,0x62,0x14,
+0x21,0x30,0x20,0x02,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x3B,0x46,0x00,0x0C,
+0x15,0x00,0x04,0x24,
+0xFF,0x00,0x46,0x30,
+0x00,0xFF,0x03,0x36,
+0x24,0x10,0x43,0x00,
+0x01,0x00,0xC6,0x24,
+0xFF,0xFF,0x05,0x36,
+0x25,0x30,0x46,0x00,
+0x12,0x46,0x00,0x0C,
+0x15,0x00,0x04,0x24,
+0x23,0x0E,0x00,0x08,
+0x02,0x80,0x10,0x3C,
+0x0F,0x00,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x15,0x00,0x04,0x24,
+0x37,0x0E,0x00,0x08,
+0xF4,0xA8,0x06,0x34,
+0xFF,0xFF,0xA5,0x34,
+0x15,0x00,0x04,0x24,
+0x37,0x0E,0x00,0x08,
+0xF5,0xF8,0x06,0x34,
+0x02,0x80,0x02,0x3C,
+0x57,0x61,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0xEC,0x02,0x66,0x34,
+0x54,0x39,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x09,0x00,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0x8C,
+0x20,0x20,0x03,0x3C,
+0xFF,0xDF,0x04,0x24,
+0x25,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x00,0x00,0xC2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x00,0x00,0xC3,0x8C,
+0x20,0x20,0x02,0x3C,
+0x00,0x20,0x42,0x34,
+0x25,0x18,0x62,0x00,
+0x21,0x10,0x00,0x00,
+0x00,0x00,0xC3,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x84,0x30,
+0x40,0x19,0x04,0x00,
+0x02,0x80,0x02,0x3C,
+0x21,0x18,0x64,0x00,
+0x30,0xE4,0x42,0x24,
+0x21,0x18,0x62,0x00,
+0x20,0x00,0x64,0x90,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x58,0x42,0x44,0xA0,
+0x14,0x00,0x80,0x10,
+0x21,0x28,0x00,0x00,
+0x21,0x38,0x40,0x00,
+0x21,0x30,0x60,0x00,
+0x3C,0x00,0x0A,0x24,
+0x01,0x00,0x09,0x24,
+0x02,0x00,0x08,0x24,
+0x21,0x18,0xC5,0x00,
+0x00,0x00,0x64,0x90,
+0xC0,0x10,0x05,0x00,
+0x21,0x10,0x47,0x00,
+0xC8,0x40,0x44,0xA0,
+0xCC,0x40,0x48,0xA0,
+0xCA,0x40,0x4A,0xA4,
+0xC9,0x40,0x49,0xA0,
+0x58,0x42,0xE3,0x90,
+0x01,0x00,0xA2,0x24,
+0xFF,0x00,0x45,0x30,
+0x2B,0x18,0xA3,0x00,
+0xF4,0xFF,0x60,0x14,
+0x21,0x18,0xC5,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFC,0x00,0x84,0x30,
+0x80,0x00,0x02,0x24,
+0x11,0x00,0x82,0x10,
+0x06,0x00,0x03,0x24,
+0x81,0x00,0x82,0x28,
+0x10,0x00,0x40,0x10,
+0xB0,0x00,0x02,0x24,
+0x20,0x00,0x02,0x24,
+0x0B,0x00,0x82,0x10,
+0x02,0x00,0x03,0x24,
+0x21,0x00,0x82,0x28,
+0x15,0x00,0x40,0x10,
+0x40,0x00,0x02,0x24,
+0x06,0x00,0x80,0x10,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x10,0x00,0x02,0x24,
+0x02,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xFD,0xFF,0x82,0x10,
+0x09,0x00,0x03,0x24,
+0xB1,0x00,0x82,0x28,
+0x0F,0x00,0x40,0x10,
+0xC8,0x00,0x02,0x24,
+0x90,0x00,0x02,0x24,
+0xF7,0xFF,0x82,0x10,
+0x07,0x00,0x03,0x24,
+0x08,0x00,0x03,0x24,
+0xA1,0x0E,0x00,0x08,
+0xA0,0x00,0x02,0x24,
+0xF2,0xFF,0x82,0x10,
+0x04,0x00,0x03,0x24,
+0x41,0x00,0x82,0x28,
+0x0F,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x03,0x24,
+0xA1,0x0E,0x00,0x08,
+0x30,0x00,0x02,0x24,
+0xEA,0xFF,0x82,0x10,
+0x0C,0x00,0x03,0x24,
+0xC9,0x00,0x82,0x28,
+0x04,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x03,0x24,
+0xA1,0x0E,0x00,0x08,
+0xC0,0x00,0x02,0x24,
+0x0B,0x00,0x03,0x24,
+0xA1,0x0E,0x00,0x08,
+0xD0,0x00,0x02,0x24,
+0x05,0x00,0x03,0x24,
+0xA1,0x0E,0x00,0x08,
+0x50,0x00,0x02,0x24,
+0xD0,0xFF,0xBD,0x27,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x08,0x00,0x90,0x94,
+0x02,0x80,0x02,0x3C,
+0x21,0x98,0x80,0x00,
+0x25,0x80,0x02,0x02,
+0xFF,0x00,0xB4,0x30,
+0x21,0x20,0x00,0x02,
+0xFF,0x00,0xD1,0x30,
+0x21,0x28,0x00,0x00,
+0x08,0x00,0x06,0x24,
+0xC6,0x53,0x00,0x0C,
+0xFF,0x00,0xF2,0x30,
+0x04,0x00,0x06,0x8E,
+0x08,0x00,0x05,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xE0,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x24,0x30,0xC3,0x00,
+0x24,0x28,0xA2,0x00,
+0x3F,0xFF,0x02,0x3C,
+0x10,0x00,0x08,0x8E,
+0xFF,0xFF,0x42,0x34,
+0x00,0x12,0xC6,0x34,
+0x00,0x40,0x03,0x3C,
+0x24,0x30,0xC2,0x00,
+0x05,0x00,0x07,0x24,
+0x04,0x00,0x02,0x24,
+0x0B,0x38,0x54,0x00,
+0x25,0x28,0xA3,0x00,
+0x01,0x00,0x84,0x32,
+0x7F,0xFF,0x03,0x24,
+0x00,0x80,0x02,0x3C,
+0x14,0x00,0x09,0x8E,
+0x24,0x28,0xA3,0x00,
+0xC0,0x21,0x04,0x00,
+0x25,0x40,0x02,0x01,
+0x03,0x00,0x31,0x32,
+0xFF,0xE0,0x02,0x3C,
+0x80,0x8D,0x11,0x00,
+0x25,0x28,0xA4,0x00,
+0xFF,0xFF,0x42,0x34,
+0x0C,0x00,0x6A,0x8E,
+0x25,0x30,0xD1,0x00,
+0xFF,0x81,0x03,0x24,
+0xE0,0xFF,0x04,0x24,
+0x24,0x28,0xA2,0x00,
+0x3F,0x00,0x52,0x32,
+0xFB,0xFF,0x02,0x3C,
+0x24,0x48,0x23,0x01,
+0x24,0x30,0xC4,0x00,
+0x00,0x1E,0x07,0x00,
+0x40,0x92,0x12,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x40,0x02,0x01,
+0x25,0x48,0x32,0x01,
+0x25,0x28,0xA3,0x00,
+0x25,0x30,0xC7,0x00,
+0x20,0x00,0x02,0x24,
+0x08,0x00,0x05,0xAE,
+0x00,0x00,0x0A,0xA6,
+0x02,0x00,0x02,0xA2,
+0x10,0x00,0x08,0xAE,
+0x14,0x00,0x09,0xAE,
+0x04,0x00,0x06,0xAE,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x98,0x54,0x42,0x24,
+0x04,0x00,0x43,0x8C,
+0x00,0x00,0x62,0xAE,
+0x04,0x00,0x53,0xAC,
+0x00,0x00,0x73,0xAC,
+0x04,0x00,0x63,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0xFF,0x90,0x30,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0xFF,0x00,0xD2,0x30,
+0x24,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0xFF,0x00,0xB1,0x30,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x45,0x24,
+0x00,0x80,0x02,0x34,
+0x21,0x20,0x20,0x02,
+0x23,0x00,0x02,0x12,
+0xD8,0x43,0xB2,0xA0,
+0xB0,0x1B,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0x7F,0x42,0x30,
+0x14,0x0E,0x00,0x0C,
+0xB0,0x1B,0xA2,0xA4,
+0x25,0xB0,0x03,0x3C,
+0x03,0x02,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x00,0x08,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x04,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA0,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x09,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x84,0x08,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x58,0x00,0x06,0x24,
+0x18,0x00,0x04,0x24,
+0x00,0x0C,0x05,0x24,
+0x12,0x46,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xB0,0x1B,0xA2,0x94,
+0x00,0x80,0x03,0x24,
+0x02,0x00,0x24,0x26,
+0x25,0x10,0x43,0x00,
+0x01,0x00,0x03,0x24,
+0x02,0x00,0x43,0x12,
+0xB0,0x1B,0xA2,0xA4,
+0xFE,0xFF,0x24,0x26,
+0x14,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x07,0x3C,
+0x03,0x02,0xE7,0x34,
+0x00,0x00,0xE3,0x90,
+0xFB,0xFF,0x02,0x24,
+0x00,0x08,0x04,0x24,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0xE3,0xA0,
+0x01,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x03,0x00,0x50,0x32,
+0x00,0x09,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x42,0x30,0x10,0x00,
+0x00,0x0A,0x04,0x24,
+0x50,0x44,0x00,0x0C,
+0x10,0x00,0x05,0x24,
+0x21,0x30,0x00,0x02,
+0x00,0x0D,0x04,0x24,
+0x50,0x44,0x00,0x0C,
+0x00,0x0C,0x05,0x24,
+0x84,0x08,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x18,0x00,0x06,0x24,
+0x18,0x00,0x04,0x24,
+0x00,0x0C,0x05,0x24,
+0x12,0x46,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0xFF,0xFF,0x91,0x30,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x9A,0x40,0x00,0x0C,
+0xFF,0x00,0xB0,0x30,
+0x02,0x80,0x02,0x3C,
+0x40,0x59,0x45,0x90,
+0x21,0x20,0x20,0x02,
+0x20,0x0F,0x00,0x0C,
+0x21,0x30,0x00,0x02,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x06,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xD0,0x55,0xC2,0x24,
+0x01,0x00,0x44,0x90,
+0xD0,0x55,0xC3,0x90,
+0x02,0x00,0x45,0x90,
+0x03,0x00,0x46,0x90,
+0x05,0x00,0x47,0x90,
+0x04,0x00,0x48,0x90,
+0x00,0x22,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x00,0x2C,0x05,0x00,
+0x25,0xB0,0x10,0x3C,
+0x25,0x18,0x65,0x00,
+0x00,0x36,0x06,0x00,
+0x00,0x3A,0x07,0x00,
+0x25,0x18,0x66,0x00,
+0x58,0x00,0x02,0x36,
+0x5C,0x00,0x05,0x36,
+0x25,0x40,0x07,0x01,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x43,0xAC,
+0xCC,0x55,0x84,0x24,
+0x00,0x00,0xA8,0xAC,
+0xFD,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x94,0x00,0x03,0x36,
+0x00,0x00,0x62,0xA4,
+0x48,0x00,0x10,0x36,
+0x00,0x00,0x02,0x8E,
+0x84,0x00,0x03,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x02,0xAE,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0x21,0x28,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x50,0x24,
+0x13,0x00,0xA0,0x10,
+0x21,0x20,0xA0,0x00,
+0x04,0x00,0x02,0x24,
+0x09,0x00,0x03,0x24,
+0x0C,0x00,0xA2,0xAC,
+0x14,0x00,0xA3,0xAC,
+0x08,0x00,0xA5,0x94,
+0x00,0x3F,0x03,0x8E,
+0x02,0x80,0x02,0x3C,
+0x25,0x28,0xA2,0x00,
+0xCB,0x09,0x00,0x0C,
+0x20,0x00,0xA3,0xAC,
+0x04,0x3F,0x06,0x8E,
+0x00,0x3F,0x05,0x8E,
+0x02,0x80,0x04,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xB4,0xEF,0x84,0x24,
+0x13,0x57,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x60,0x1B,0x46,0x24,
+0x10,0x00,0xBF,0xAF,
+0x58,0x42,0xC3,0x90,
+0xFF,0x00,0x84,0x30,
+0xC0,0x10,0x04,0x00,
+0x2B,0x20,0x83,0x00,
+0x21,0x10,0x46,0x00,
+0x0C,0x00,0x80,0x10,
+0x01,0x00,0x03,0x24,
+0xC8,0x40,0x43,0x90,
+0x02,0x80,0x04,0x3C,
+0xFF,0x00,0x62,0x30,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x42,0x2C,
+0x09,0x00,0x40,0x10,
+0xCC,0xEF,0x84,0x24,
+0x50,0x3E,0xC2,0x90,
+0xE0,0x3D,0xC3,0xA0,
+0x21,0x18,0x00,0x00,
+0xE1,0x3D,0xC2,0xA0,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x01,0x00,0x03,0x24,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x60,0x1B,0x50,0x24,
+0x5C,0x42,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x60,0x10,
+0x14,0x00,0xBF,0xAF,
+0xF7,0x3E,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x43,0x30,
+0xC0,0x18,0x03,0x00,
+0x21,0x18,0x70,0x00,
+0xCC,0x40,0x65,0x90,
+0x01,0x00,0x42,0x24,
+0x07,0x00,0xA0,0x10,
+0xFF,0x00,0x44,0x30,
+0x01,0x00,0x03,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xDE,0x0F,0x00,0x0C,
+0xF7,0x3E,0x02,0xA2,
+0xF8,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0xE0,0x3D,0x04,0x92,
+0x14,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x11,0x10,0x00,0x08,
+0x01,0x00,0x03,0x24,
+0xF7,0x3E,0x04,0x92,
+0xDE,0x0F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0xEC,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x83,0x0F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x5C,0x42,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x10,0x10,0x00,0x08,
+0x5C,0x42,0x02,0xA2,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x28,0x00,0x04,0x24,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0xF3,0x27,0x00,0x0C,
+0xFF,0xFF,0xB2,0x30,
+0x21,0x88,0x40,0x00,
+0x21,0x28,0x00,0x02,
+0x06,0x00,0x06,0x24,
+0x12,0x00,0x20,0x12,
+0xFF,0xFF,0x02,0x24,
+0x08,0x00,0x30,0x96,
+0x08,0x00,0x02,0x24,
+0x0C,0x00,0x22,0xAE,
+0x02,0x80,0x02,0x3C,
+0x25,0x80,0x02,0x02,
+0x0C,0x00,0x03,0x24,
+0x20,0x00,0x10,0x26,
+0x14,0x00,0x23,0xAE,
+0xCE,0x53,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x21,0x20,0x20,0x02,
+0xCB,0x09,0x00,0x0C,
+0x06,0x00,0x12,0xA6,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x00,0xF0,0x84,0x24,
+0x21,0x10,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x21,0x90,0x80,0x00,
+0x2C,0x00,0x04,0x24,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x21,0x98,0xA0,0x00,
+0x20,0x00,0xBF,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x0C,0xF0,0x84,0x24,
+0x19,0x00,0x40,0x10,
+0x21,0x30,0x60,0x02,
+0x05,0x00,0x45,0x92,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x0B,0x00,0x03,0x24,
+0x25,0x80,0x02,0x02,
+0x20,0x00,0x10,0x26,
+0x0C,0x00,0x02,0x24,
+0x21,0x20,0x00,0x02,
+0x0C,0x00,0x22,0xAE,
+0x14,0x00,0x23,0xAE,
+0x21,0x28,0x40,0x02,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x08,0x00,0x13,0xAE,
+0x21,0x20,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xCB,0x09,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x74,0x00,0x04,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0x40,0x10,
+0x21,0x20,0x40,0x00,
+0x54,0x00,0x02,0x24,
+0x1A,0x00,0x03,0x24,
+0x0C,0x00,0xA2,0xAC,
+0x14,0x00,0xA3,0xAC,
+0x02,0x80,0x02,0x3C,
+0xC0,0x5D,0x43,0x8C,
+0x08,0x00,0xA5,0x94,
+0x02,0x80,0x02,0x3C,
+0x80,0x18,0x03,0x00,
+0x25,0x28,0xA2,0x00,
+0xFF,0xFF,0x63,0x30,
+0x10,0x00,0xBF,0x8F,
+0x20,0x00,0xA3,0xAC,
+0xCB,0x09,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0xF4,0xFF,0xB1,0x24,
+0x24,0x00,0xB3,0xAF,
+0x3D,0x00,0x05,0x24,
+0x21,0x98,0x80,0x00,
+0x14,0x00,0xA6,0x27,
+0x24,0x00,0x84,0x24,
+0x21,0x38,0x20,0x02,
+0x20,0x00,0xB2,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x6B,0x21,0x00,0x0C,
+0x18,0x00,0xB0,0xAF,
+0x0F,0x00,0x40,0x10,
+0x02,0x80,0x12,0x3C,
+0x14,0x00,0xA6,0x8F,
+0x02,0x80,0x04,0x3C,
+0xF8,0x5E,0x84,0x24,
+0x02,0x00,0x45,0x24,
+0xCE,0x53,0x00,0x0C,
+0x60,0x1B,0x50,0x26,
+0xD8,0x43,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x11,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x40,0x04,
+0x03,0x00,0x42,0x28,
+0x3D,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x52,0x26,
+0xD6,0x43,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x40,0x14,
+0x24,0x00,0x70,0x26,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x99,0x43,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x83,0x30,
+0x04,0x00,0x62,0x30,
+0xEF,0xFF,0x40,0x10,
+0x03,0x00,0x63,0x30,
+0x01,0x00,0x02,0x24,
+0x31,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x83,0x30,
+0x03,0x00,0x02,0x24,
+0xE8,0xFF,0x62,0x14,
+0x00,0x80,0x04,0x34,
+0x83,0x0F,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0xB8,0x10,0x00,0x08,
+0x60,0x1B,0x52,0x26,
+0x21,0x20,0x00,0x02,
+0x4A,0x00,0x05,0x24,
+0x14,0x00,0xA6,0x27,
+0x6B,0x21,0x00,0x0C,
+0x21,0x38,0x20,0x02,
+0x05,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x32,0x5F,0x84,0x24,
+0x06,0x00,0x45,0x24,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x21,0x20,0x00,0x02,
+0x21,0x38,0x20,0x02,
+0x48,0x00,0x05,0x24,
+0x6B,0x21,0x00,0x0C,
+0x14,0x00,0xA6,0x27,
+0xD7,0xFF,0x40,0x10,
+0x02,0x00,0x45,0x24,
+0x10,0x00,0xA4,0x27,
+0xCE,0x53,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x10,0x00,0xA3,0x93,
+0x00,0x00,0x00,0x00,
+0x02,0x19,0x03,0x00,
+0x01,0x00,0x63,0x30,
+0xCE,0xFF,0x60,0x10,
+0x21,0x20,0x00,0x00,
+0x88,0x48,0x00,0x0C,
+0xD4,0x43,0x40,0xA2,
+0xBC,0x10,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x99,0x43,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0xC0,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x83,0x0F,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0xB8,0x10,0x00,0x08,
+0x60,0x1B,0x52,0x26,
+0x00,0x80,0x04,0x34,
+0x83,0x0F,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x99,0x43,0x04,0x92,
+0xCD,0x10,0x00,0x08,
+0x03,0x00,0x83,0x30,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xF4,0xFF,0xB1,0x24,
+0x24,0x00,0x90,0x24,
+0x21,0x20,0x00,0x02,
+0x2D,0x00,0x05,0x24,
+0x14,0x00,0xA6,0x27,
+0x20,0x00,0xBF,0xAF,
+0x6B,0x21,0x00,0x0C,
+0x21,0x38,0x20,0x02,
+0x11,0x00,0x40,0x10,
+0x02,0x00,0x45,0x24,
+0x10,0x00,0xA4,0x27,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA3,0x97,
+0x00,0x00,0x00,0x00,
+0x82,0x1B,0x03,0x00,
+0x01,0x00,0x63,0x30,
+0x03,0x00,0x60,0x10,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x31,0x5F,0x43,0xA0,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x21,0x20,0x00,0x02,
+0x21,0x38,0x20,0x02,
+0x03,0x00,0x05,0x24,
+0x6B,0x21,0x00,0x0C,
+0x14,0x00,0xA6,0x27,
+0x1E,0x00,0x40,0x10,
+0x02,0x80,0x0A,0x3C,
+0x60,0x1B,0x43,0x25,
+0xCF,0x43,0x64,0x90,
+0x02,0x00,0x45,0x90,
+0x01,0x00,0x02,0x24,
+0xD0,0x43,0x62,0xA0,
+0x0D,0x00,0x80,0x10,
+0x21,0x30,0x00,0x00,
+0x21,0x48,0x60,0x00,
+0x21,0x40,0x80,0x00,
+0xFF,0x00,0xA7,0x30,
+0x21,0x10,0xC9,0x00,
+0xAF,0x43,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x67,0x10,
+0x01,0x00,0xC4,0x24,
+0xFF,0x00,0x86,0x30,
+0x2B,0x10,0xC8,0x00,
+0xF9,0xFF,0x40,0x14,
+0x21,0x10,0xC9,0x00,
+0x60,0x1B,0x44,0x25,
+0xCF,0x43,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x62,0x30,
+0xDC,0xFF,0x46,0x14,
+0x21,0x10,0x44,0x00,
+0x01,0x00,0x63,0x24,
+0xAF,0x43,0x45,0xA0,
+0x1A,0x11,0x00,0x08,
+0xCF,0x43,0x83,0xA0,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xCF,0x43,0x43,0x90,
+0xE0,0x3D,0x44,0x90,
+0x21,0x18,0x62,0x00,
+0x1A,0x11,0x00,0x08,
+0xAF,0x43,0x64,0xA0,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x57,0x61,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0xEC,0x02,0x65,0x34,
+0x00,0x00,0xA3,0x8C,
+0x0F,0x00,0x80,0x14,
+0x20,0x20,0x02,0x3C,
+0x00,0x20,0x42,0x34,
+0x25,0x10,0x62,0x00,
+0x00,0x00,0xA2,0xAC,
+0x02,0x80,0x02,0x3C,
+0x58,0x61,0x43,0x94,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x40,0x18,0x03,0x00,
+0xA0,0x40,0x00,0x0C,
+0xC8,0x61,0x43,0xAC,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x25,0x10,0x62,0x00,
+0xFF,0xDF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0xA2,0xAC,
+0x02,0x80,0x02,0x3C,
+0x58,0x61,0x43,0x94,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x40,0x18,0x03,0x00,
+0xA0,0x40,0x00,0x0C,
+0xC8,0x61,0x43,0xAC,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x10,0x00,0xBF,0xAF,
+0x10,0x37,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x43,0x30,
+0x00,0x01,0x42,0x30,
+0x03,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x80,0x10,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x7F,0x49,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x1A,0x64,0x43,0x90,
+0x02,0x80,0x11,0x3C,
+0x04,0x00,0x04,0x24,
+0x0F,0x00,0x63,0x30,
+0x04,0x00,0x63,0x28,
+0x3A,0x00,0x60,0x14,
+0x01,0x00,0x05,0x24,
+0x40,0xE6,0x23,0x8E,
+0x0F,0x00,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x00,0x04,0x24,
+0x60,0x00,0x06,0x24,
+0x12,0x00,0x60,0x14,
+0x60,0x1B,0x50,0x24,
+0x12,0x46,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE4,0x43,0x05,0x92,
+0xD0,0x07,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x0A,0x10,0x05,0x00,
+0x58,0x3A,0x02,0xAE,
+0x02,0x80,0x02,0x3C,
+0x19,0x64,0x44,0x90,
+0x40,0xE6,0x23,0xAE,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x0F,0x00,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x3B,0x46,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0xE5,0x43,0x04,0x92,
+0xFF,0x00,0x43,0x30,
+0x00,0x2C,0x03,0x00,
+0x0A,0x00,0x64,0x10,
+0xE6,0x43,0x02,0xA2,
+0x02,0x80,0x02,0x3C,
+0x4A,0xFC,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x22,0x04,0x00,
+0xB3,0x2D,0x00,0x74,
+0x25,0x20,0xA4,0x00,
+0xE6,0x43,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0xE5,0x43,0x03,0xA2,
+0xE4,0x43,0x03,0x92,
+0x10,0x27,0x02,0x24,
+0x40,0xE6,0x20,0xAE,
+0x0A,0x10,0x03,0x00,
+0x58,0x3A,0x02,0xAE,
+0x02,0x80,0x02,0x3C,
+0x19,0x64,0x44,0x90,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xAD,0x34,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x95,0x11,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB8,0xFF,0xBD,0x27,
+0x40,0x00,0xB4,0xAF,
+0x21,0xA0,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x3C,0x00,0xB3,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x44,0x00,0xBF,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x30,0x00,0xB0,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x02,0x80,0x13,0x3C,
+0x21,0x88,0x40,0x00,
+0x80,0xE3,0x65,0x26,
+0x49,0x00,0x40,0x10,
+0x06,0x00,0x06,0x24,
+0x08,0x00,0x50,0x94,
+0x0C,0x00,0x52,0x24,
+0x02,0x80,0x02,0x3C,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x00,0xA6,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x48,0x37,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x30,0x00,0x04,0x26,
+0x80,0xE3,0x65,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x07,0x3C,
+0x03,0xFF,0x63,0x30,
+0x40,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x02,0x80,0x03,0x3C,
+0x0C,0x00,0x22,0xAE,
+0x60,0x1B,0x69,0x24,
+0xE4,0x1D,0x24,0x95,
+0x20,0x00,0x03,0x26,
+0x38,0x00,0x10,0x26,
+0xFF,0x0F,0x82,0x30,
+0x00,0x11,0x02,0x00,
+0x01,0x00,0x84,0x24,
+0x02,0x42,0x02,0x00,
+0xE4,0x1D,0x24,0xA5,
+0x34,0x5A,0xE7,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x17,0x00,0x68,0xA0,
+0x16,0x00,0x62,0xA0,
+0x29,0x00,0x80,0x16,
+0x21,0x20,0x00,0x02,
+0x21,0x20,0x00,0x02,
+0x21,0x38,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x0C,0x00,0x32,0x26,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB2,0xAF,
+0x18,0x00,0xA4,0x27,
+0x28,0x00,0xA5,0x27,
+0x05,0x52,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA3,0x8F,
+0x18,0x00,0xA7,0x27,
+0x01,0x00,0x05,0x24,
+0x09,0x00,0x62,0x28,
+0x08,0x00,0x06,0x24,
+0x26,0x00,0x40,0x14,
+0x21,0x20,0x00,0x02,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB2,0xAF,
+0x28,0x00,0xA6,0x8F,
+0x21,0x20,0x40,0x00,
+0x32,0x00,0x05,0x24,
+0x20,0x00,0xA7,0x27,
+0x10,0x00,0xB2,0xAF,
+0xF8,0xFF,0xC6,0x24,
+0x25,0x51,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x01,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0xC7,0x0E,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xD0,0x3E,0x26,0x8D,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB2,0xAF,
+0x18,0x00,0xA4,0x27,
+0x28,0x00,0xA5,0x27,
+0x05,0x52,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA3,0x8F,
+0x18,0x00,0xA7,0x27,
+0x01,0x00,0x05,0x24,
+0x09,0x00,0x62,0x28,
+0x08,0x00,0x06,0x24,
+0xDC,0xFF,0x40,0x10,
+0x21,0x20,0x00,0x02,
+0x21,0x20,0x00,0x02,
+0x21,0x30,0x60,0x00,
+0x01,0x00,0x05,0x24,
+0x18,0x00,0xA7,0x27,
+0x22,0x12,0x00,0x08,
+0x10,0x00,0xB2,0xAF,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x21,0x80,0x80,0x00,
+0x45,0x00,0xA0,0x14,
+0x21,0x90,0x00,0x00,
+0x08,0x00,0x82,0x90,
+0x02,0x80,0x13,0x3C,
+0x60,0x1B,0x63,0x26,
+0x0F,0x00,0x42,0x30,
+0x34,0x43,0x62,0xAC,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x10,0x26,
+0xD0,0x01,0x57,0x34,
+0x02,0x80,0x14,0x3C,
+0xD8,0x01,0x5E,0x34,
+0xDC,0x01,0x55,0x34,
+0xD4,0x01,0x56,0x34,
+0x03,0x00,0x11,0x24,
+0x00,0x00,0x06,0x92,
+0x60,0x1B,0x62,0x26,
+0x2C,0x43,0x47,0x90,
+0x0F,0x00,0xC3,0x30,
+0x01,0x00,0x05,0x92,
+0x18,0x00,0x67,0x00,
+0x03,0x00,0x04,0x92,
+0x02,0x00,0x02,0x92,
+0x0F,0x00,0xA7,0x30,
+0x00,0x3A,0x07,0x00,
+0x02,0x29,0x05,0x00,
+0x00,0x22,0x04,0x00,
+0x25,0x20,0x82,0x00,
+0x00,0x2B,0x05,0x00,
+0x42,0x11,0x06,0x00,
+0x00,0x24,0x04,0x00,
+0x03,0x00,0x49,0x30,
+0x02,0x31,0x06,0x00,
+0x01,0x00,0x02,0x24,
+0x01,0x00,0xC6,0x30,
+0x12,0x18,0x00,0x00,
+0x0A,0x00,0x63,0x24,
+0xFF,0x00,0x63,0x30,
+0x25,0x18,0x67,0x00,
+0x25,0x18,0x65,0x00,
+0x30,0x00,0x22,0x11,
+0x25,0x38,0x64,0x00,
+0x02,0x00,0x22,0x29,
+0x3E,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x38,0x00,0x22,0x11,
+0x03,0x00,0x02,0x24,
+0x40,0x00,0x22,0x11,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x20,0x01,
+0x2C,0xF0,0x84,0x26,
+0x13,0x57,0x00,0x0C,
+0xFF,0xFF,0x31,0x26,
+0xD9,0xFF,0x21,0x06,
+0x04,0x00,0x10,0x26,
+0x25,0xB0,0x02,0x3C,
+0xE7,0x01,0x42,0x34,
+0x00,0x00,0x52,0xA0,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x13,0x3C,
+0x08,0x00,0x83,0x90,
+0x60,0x1B,0x62,0x26,
+0x34,0x43,0x44,0x8C,
+0x0F,0x00,0x63,0x30,
+0xBB,0xFF,0x83,0x14,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x00,0x00,0xA7,0xAE,
+0x21,0x20,0x00,0x00,
+0x25,0xB0,0x08,0x3C,
+0x07,0x10,0x92,0x00,
+0x01,0x00,0x42,0x30,
+0x01,0x00,0x84,0x24,
+0x02,0x00,0x40,0x10,
+0x03,0x00,0x85,0x2C,
+0xD0,0x01,0x07,0xAD,
+0xF9,0xFF,0xA0,0x14,
+0x04,0x00,0x08,0x25,
+0x83,0x12,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0x0D,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x82,0x12,0x00,0x08,
+0x02,0x00,0x52,0x36,
+0xC7,0xFF,0x20,0x15,
+0x21,0x28,0x20,0x01,
+0x0D,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x83,0x12,0x00,0x08,
+0x04,0x00,0x52,0x36,
+0x06,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x82,0x12,0x00,0x08,
+0x01,0x00,0x52,0x36,
+0x00,0x00,0xC7,0xAE,
+0x83,0x12,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0x00,0x00,0xE7,0xAE,
+0x83,0x12,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0x00,0x00,0xC7,0xAF,
+0x83,0x12,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0xB8,0xFF,0xBD,0x27,
+0x24,0x00,0xB1,0xAF,
+0x21,0x88,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x2C,0x00,0xB3,0xAF,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x28,0x00,0xB2,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x20,0x00,0xB0,0xAF,
+0xAC,0x00,0x40,0x10,
+0x21,0x98,0x40,0x00,
+0x08,0x00,0x50,0x94,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x20,0x02,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x20,0x00,0x00,0xA6,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x48,0x37,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x30,0x00,0x04,0x26,
+0x20,0x00,0x03,0x96,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x54,0x24,
+0x03,0xFF,0x63,0x30,
+0x50,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0xE4,0x1D,0x82,0x96,
+0x02,0x80,0x03,0x3C,
+0xCC,0x55,0x63,0x24,
+0x74,0x00,0x72,0x24,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0x02,0x22,0x03,0x00,
+0xE4,0x1D,0x82,0xA6,
+0x20,0x00,0x11,0x26,
+0x20,0x00,0x02,0x24,
+0x16,0x00,0x23,0xA2,
+0x17,0x00,0x24,0xA2,
+0x21,0x20,0x40,0x02,
+0xFB,0x50,0x00,0x0C,
+0x0C,0x00,0x62,0xAE,
+0x40,0x00,0x11,0x26,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x40,0x00,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x0C,0x00,0x63,0x8E,
+0x21,0x20,0x40,0x02,
+0x42,0x00,0x11,0x26,
+0x02,0x00,0x63,0x24,
+0x16,0x51,0x00,0x0C,
+0x0C,0x00,0x63,0xAE,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0x20,0x02,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x0C,0x00,0x63,0x8E,
+0x02,0x80,0x02,0x3C,
+0xCC,0x55,0x42,0x24,
+0x02,0x00,0x63,0x24,
+0x0C,0x00,0x63,0xAE,
+0x0C,0x00,0x46,0x8C,
+0x44,0x00,0x04,0x26,
+0x0C,0x00,0x76,0x26,
+0x60,0x00,0x50,0x24,
+0x21,0x28,0x00,0x00,
+0x10,0x00,0x47,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0x21,0x20,0x00,0x02,
+0x1B,0x52,0x00,0x0C,
+0x21,0x88,0x40,0x00,
+0x09,0x00,0x43,0x2C,
+0x08,0x00,0x06,0x24,
+0x21,0x20,0x20,0x02,
+0x0B,0x30,0x43,0x00,
+0x21,0x38,0x00,0x02,
+0x01,0x00,0x05,0x24,
+0x18,0x00,0xA3,0xAF,
+0x21,0xB8,0x40,0x00,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0x21,0x20,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0xCC,0x55,0x42,0x24,
+0x03,0x00,0x05,0x24,
+0x01,0x00,0x06,0x24,
+0x48,0x00,0x47,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0x21,0x88,0x40,0x00,
+0xDC,0x3A,0x82,0x8E,
+0x0C,0x00,0x10,0x24,
+0x2B,0x10,0x02,0x02,
+0x3A,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x42,0x56,0x5E,0x24,
+0x48,0x13,0x00,0x08,
+0x21,0xA8,0x80,0x02,
+0x21,0x10,0x12,0x02,
+0x01,0x00,0x43,0x90,
+0xDC,0x3A,0xA4,0x8E,
+0x21,0x18,0x70,0x00,
+0x02,0x00,0x70,0x24,
+0x2B,0x20,0x04,0x02,
+0x2F,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x12,0x02,
+0x00,0x00,0x47,0x90,
+0x02,0x80,0x14,0x3C,
+0x2D,0x00,0x03,0x24,
+0x21,0x28,0x1E,0x02,
+0xD8,0x5E,0x84,0x26,
+0xF1,0xFF,0xE3,0x14,
+0x20,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x78,0x43,0xA3,0x96,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x47,0x90,
+0xBD,0xFF,0x63,0x30,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x0C,0x00,0x63,0x34,
+0x01,0x00,0xE7,0x30,
+0x4C,0xE6,0xA5,0x24,
+0xDB,0x5E,0x44,0x24,
+0x10,0x00,0x06,0x24,
+0x06,0x00,0xE0,0x14,
+0x78,0x43,0xA3,0xA6,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x03,0x3C,
+0x5C,0xE6,0xA5,0x24,
+0xDB,0x5E,0x64,0x24,
+0x10,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x12,0x02,
+0x01,0x00,0x46,0x90,
+0x21,0x20,0x20,0x02,
+0xD8,0x5E,0x87,0x26,
+0x2D,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0x21,0x88,0x40,0x00,
+0x21,0x10,0x12,0x02,
+0x01,0x00,0x43,0x90,
+0xDC,0x3A,0xA4,0x8E,
+0x21,0x18,0x70,0x00,
+0x02,0x00,0x70,0x24,
+0x2B,0x20,0x04,0x02,
+0xD4,0xFF,0x80,0x14,
+0x21,0x10,0x12,0x02,
+0x18,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0x40,0x10,
+0x21,0x20,0x60,0x02,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0x21,0x38,0x00,0x00,
+0xC7,0x0E,0x00,0x08,
+0x48,0x00,0xBD,0x27,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0xCC,0x55,0x63,0x24,
+0x21,0x20,0x20,0x02,
+0xF8,0xFF,0xE6,0x26,
+0x68,0x00,0x67,0x24,
+0x32,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0x21,0x20,0x60,0x02,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0x21,0x38,0x00,0x00,
+0xC7,0x0E,0x00,0x08,
+0x48,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x03,0x3C,
+0x10,0x37,0x65,0x94,
+0x0F,0x00,0x42,0x30,
+0x00,0x00,0x83,0x8C,
+0xC0,0x10,0x02,0x00,
+0x21,0x20,0x44,0x00,
+0x00,0x10,0xA8,0x30,
+0x02,0x80,0x02,0x3C,
+0x00,0x08,0xA5,0x30,
+0xCC,0x55,0x51,0x24,
+0xFF,0x3F,0x63,0x30,
+0x06,0x00,0xA0,0x10,
+0x18,0x00,0x90,0x24,
+0xE8,0xFF,0x67,0x24,
+0x30,0x00,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x07,0x00,0x00,0x11,
+0x10,0x00,0xA6,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x6B,0x21,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF7,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x44,0x24,
+0x10,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x10,
+0x10,0x00,0x25,0x26,
+0x0C,0x00,0x26,0x8E,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xED,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x26,0x52,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0xCE,0x12,0x00,0x0C,
+0x21,0x20,0x40,0x00,
+0xC4,0x13,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xC8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xF0,0x80,0x00,
+0x21,0xB0,0xA0,0x00,
+0x21,0xB8,0xC0,0x00,
+0x60,0x1B,0x53,0x24,
+0x69,0x5A,0x74,0x24,
+0x21,0x90,0x00,0x00,
+0x01,0x00,0x15,0x24,
+0x21,0x80,0x00,0x00,
+0x34,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0xFD,0x13,0x00,0x08,
+0x44,0x00,0xA7,0xAF,
+0xF7,0x53,0x00,0x0C,
+0x07,0x00,0x10,0x26,
+0x24,0x00,0x40,0x10,
+0x21,0x20,0xC0,0x03,
+0x01,0x00,0x52,0x26,
+0x40,0x00,0x42,0x2E,
+0x13,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x88,0x13,0x02,
+0x08,0x3F,0x22,0x92,
+0x21,0x20,0x14,0x02,
+0x21,0x28,0xC0,0x02,
+0xF3,0xFF,0x55,0x10,
+0x06,0x00,0x06,0x24,
+0x21,0x20,0x14,0x02,
+0x21,0x28,0xC0,0x02,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x08,0x3F,0x35,0xA2,
+0xE0,0x3D,0x62,0x92,
+0x44,0x00,0xA4,0x8F,
+0x01,0x00,0x03,0x24,
+0x0A,0x00,0x82,0xA0,
+0x48,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x52,0xAC,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x44,0x00,0xA3,0x8F,
+0xE0,0x3D,0x62,0x92,
+0x21,0x28,0xE0,0x02,
+0x90,0x4B,0x00,0x0C,
+0x0A,0x00,0x62,0xA0,
+0xED,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x48,0x00,0xA4,0x8F,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x00,0x00,0x92,0xAC,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x03,0x24,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xA0,0xFF,0xBD,0x27,
+0x38,0x00,0xB0,0xAF,
+0x5C,0x00,0xBF,0xAF,
+0x58,0x00,0xBE,0xAF,
+0x54,0x00,0xB7,0xAF,
+0x50,0x00,0xB6,0xAF,
+0x4C,0x00,0xB5,0xAF,
+0x48,0x00,0xB4,0xAF,
+0x44,0x00,0xB3,0xAF,
+0x40,0x00,0xB2,0xAF,
+0x3C,0x00,0xB1,0xAF,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0xFF,0x3F,0x46,0x30,
+0xE8,0xFF,0xC5,0x24,
+0x01,0x03,0xA2,0x2C,
+0x15,0x00,0x40,0x14,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x63,0x24,
+0x04,0x3F,0x62,0x8C,
+0x02,0x80,0x04,0x3C,
+0x8C,0xF0,0x84,0x24,
+0x01,0x00,0x42,0x24,
+0x13,0x57,0x00,0x0C,
+0x04,0x3F,0x62,0xAC,
+0x5C,0x00,0xBF,0x8F,
+0x58,0x00,0xBE,0x8F,
+0x54,0x00,0xB7,0x8F,
+0x50,0x00,0xB6,0x8F,
+0x4C,0x00,0xB5,0x8F,
+0x48,0x00,0xB4,0x8F,
+0x44,0x00,0xB3,0x8F,
+0x40,0x00,0xB2,0x8F,
+0x3C,0x00,0xB1,0x8F,
+0x38,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x60,0x00,0xBD,0x27,
+0x7C,0x00,0xC4,0x24,
+0xF3,0x27,0x00,0x0C,
+0x5C,0x00,0xD7,0x24,
+0xF0,0xFF,0x40,0x10,
+0x21,0xA8,0x40,0x00,
+0x08,0x00,0x42,0x94,
+0x02,0x80,0x03,0x3C,
+0x21,0x28,0x00,0x00,
+0x25,0x10,0x43,0x00,
+0x20,0x00,0x51,0x24,
+0x21,0x20,0x20,0x02,
+0xBD,0x53,0x00,0x0C,
+0x21,0x30,0xE0,0x02,
+0x02,0x80,0x03,0x3C,
+0xA4,0xF0,0x62,0x24,
+0xA4,0xF0,0x67,0x90,
+0x01,0x00,0x44,0x90,
+0x02,0x00,0x03,0x92,
+0x02,0x00,0x45,0x90,
+0x03,0x00,0x46,0x90,
+0x02,0x80,0x02,0x3C,
+0x00,0x22,0x04,0x00,
+0x60,0x1B,0x53,0x24,
+0x0F,0x00,0x63,0x30,
+0x25,0x20,0x87,0x00,
+0x00,0x2C,0x05,0x00,
+0x00,0x00,0x07,0x8E,
+0xC0,0x18,0x03,0x00,
+0xE7,0x43,0x62,0x92,
+0x21,0x18,0x70,0x00,
+0x25,0x28,0xA4,0x00,
+0x00,0x36,0x06,0x00,
+0x25,0x30,0xC5,0x00,
+0x22,0x00,0x64,0x24,
+0x20,0x00,0xA6,0xAF,
+0x30,0x00,0xA4,0xAF,
+0xFF,0x3F,0xF2,0x30,
+0x18,0x00,0x74,0x24,
+0x4A,0x00,0x40,0x14,
+0x28,0x00,0x76,0x24,
+0x02,0x14,0x07,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x41,0x00,0x40,0x10,
+0x21,0x20,0x00,0x02,
+0x34,0x00,0x20,0xAE,
+0x18,0x00,0xA2,0x27,
+0x21,0x20,0x80,0x02,
+0x21,0x28,0xC0,0x02,
+0x21,0x30,0x40,0x02,
+0x21,0x38,0x20,0x02,
+0x10,0x00,0xA2,0xAF,
+0xDE,0x13,0x00,0x0C,
+0x18,0x00,0xA0,0xA7,
+0x28,0x00,0x40,0x10,
+0x5C,0x00,0x43,0x26,
+0xE8,0xFF,0x42,0x26,
+0x2C,0x00,0xA2,0xAF,
+0x00,0x00,0x23,0xAE,
+0x2C,0x00,0xA2,0x8F,
+0x74,0x00,0x3E,0x26,
+0x18,0x00,0x85,0x26,
+0x21,0x30,0x40,0x00,
+0x21,0x20,0xC0,0x03,
+0xCE,0x53,0x00,0x0C,
+0x70,0x00,0x22,0xAE,
+0x70,0x00,0x27,0x8E,
+0x80,0x00,0x34,0x26,
+0x21,0x20,0x80,0x02,
+0xF4,0xFF,0xE7,0x24,
+0x21,0x28,0x00,0x00,
+0x6B,0x21,0x00,0x0C,
+0x2C,0x00,0xA6,0x27,
+0x15,0x00,0x40,0x10,
+0x21,0x80,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x52,0x24,
+0xD0,0x3E,0x46,0x8E,
+0x00,0x00,0x00,0x00,
+0x3A,0x00,0xC0,0x18,
+0x02,0x80,0x02,0x3C,
+0x6E,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x36,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x2C,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x2D,0x00,0xC2,0x10,
+0x02,0x80,0x04,0x3C,
+0x18,0x00,0xA3,0x97,
+0x00,0x00,0x00,0x00,
+0xC0,0x10,0x03,0x00,
+0x23,0x10,0x43,0x00,
+0x21,0x10,0x52,0x00,
+0x08,0x3F,0x40,0xA0,
+0x14,0x28,0x00,0x0C,
+0x21,0x20,0xA0,0x02,
+0x5C,0x00,0xBF,0x8F,
+0x58,0x00,0xBE,0x8F,
+0x54,0x00,0xB7,0x8F,
+0x50,0x00,0xB6,0x8F,
+0x4C,0x00,0xB5,0x8F,
+0x48,0x00,0xB4,0x8F,
+0x44,0x00,0xB3,0x8F,
+0x40,0x00,0xB2,0x8F,
+0x3C,0x00,0xB1,0x8F,
+0x38,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x60,0x00,0xBD,0x27,
+0x9C,0x1E,0x00,0x0C,
+0x18,0x00,0x05,0x26,
+0x87,0x14,0x00,0x08,
+0x34,0x00,0x22,0xAE,
+0x02,0x80,0x04,0x3C,
+0x48,0x5F,0x84,0x24,
+0x21,0x28,0xC0,0x02,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x04,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x07,0x8E,
+0x82,0x14,0x00,0x08,
+0x02,0x14,0x07,0x00,
+0x9A,0x40,0x00,0x0C,
+0x28,0x00,0xA4,0x27,
+0xEE,0x43,0x62,0x92,
+0x28,0x00,0xA4,0x27,
+0x01,0x00,0x42,0x24,
+0xA0,0x40,0x00,0x0C,
+0xEE,0x43,0x62,0xA2,
+0x00,0x00,0x07,0x8E,
+0x82,0x14,0x00,0x08,
+0x02,0x14,0x07,0x00,
+0x34,0x5A,0x84,0x24,
+0xF7,0x53,0x00,0x0C,
+0x02,0x00,0x05,0x26,
+0xD0,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x06,0x92,
+0x00,0x00,0x00,0x00,
+0x5A,0x00,0xC0,0x14,
+0x10,0x00,0x24,0x26,
+0x0C,0x00,0x20,0xAE,
+0x60,0x00,0x32,0x26,
+0x21,0x20,0x40,0x02,
+0x21,0x28,0x00,0x00,
+0xBD,0x53,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x70,0x00,0x27,0x8E,
+0x21,0x20,0x80,0x02,
+0x01,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x2C,0x00,0xA6,0x27,
+0x06,0x00,0x40,0x10,
+0x21,0x98,0x00,0x00,
+0x2C,0x00,0xA6,0x8F,
+0x02,0x00,0x45,0x24,
+0xCE,0x53,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x2C,0x00,0xB3,0x8F,
+0x70,0x00,0x27,0x8E,
+0x21,0x20,0x80,0x02,
+0x32,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x2C,0x00,0xA6,0x27,
+0x05,0x00,0x40,0x10,
+0x21,0x20,0x33,0x02,
+0x2C,0x00,0xA6,0x8F,
+0x60,0x00,0x84,0x24,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x2C,0x00,0xA5,0x8F,
+0x21,0x20,0x40,0x02,
+0xB3,0x21,0x00,0x0C,
+0x21,0x28,0xB3,0x00,
+0x21,0x18,0x40,0x00,
+0x01,0x00,0x02,0x24,
+0x38,0x00,0x62,0x10,
+0x03,0x00,0x02,0x24,
+0x38,0x00,0x22,0xAE,
+0x70,0x00,0x27,0x8E,
+0x21,0x20,0x80,0x02,
+0x03,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x2C,0x00,0xA6,0x27,
+0x21,0x80,0x40,0x00,
+0x48,0x00,0x20,0xAE,
+0x1B,0x00,0x40,0x10,
+0x3C,0x00,0x20,0xAE,
+0x02,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x48,0x00,0x22,0xAE,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0x83,0x24,
+0x48,0x00,0x25,0x8E,
+0x58,0x42,0x62,0x90,
+0x21,0x30,0x00,0x00,
+0x0A,0x00,0x40,0x10,
+0xFF,0x00,0xA8,0x30,
+0x21,0x38,0x40,0x00,
+0xC8,0x40,0x64,0x24,
+0x00,0x00,0x82,0x90,
+0x01,0x00,0xC6,0x24,
+0x2B,0x18,0xC7,0x00,
+0x1E,0x00,0x48,0x10,
+0x08,0x00,0x84,0x24,
+0xFA,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0xA8,0xF0,0x84,0x24,
+0x14,0x28,0x00,0x0C,
+0x21,0x20,0xA0,0x02,
+0xBA,0x14,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x70,0x00,0x27,0x8E,
+0x21,0x20,0x80,0x02,
+0x3D,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x2C,0x00,0xA6,0x27,
+0xDF,0xFF,0x40,0x14,
+0x21,0x80,0x40,0x00,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x62,0x24,
+0xE0,0x3D,0x43,0x90,
+0x1C,0x15,0x00,0x08,
+0x48,0x00,0x23,0xAE,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x05,0x26,
+0x01,0x00,0x03,0x92,
+0xE8,0x14,0x00,0x08,
+0x0C,0x00,0x23,0xAE,
+0x0F,0x15,0x00,0x08,
+0x38,0x00,0x23,0xAE,
+0xFB,0x50,0x00,0x0C,
+0x21,0x20,0xC0,0x03,
+0x21,0x28,0x40,0x00,
+0x40,0x00,0x24,0x26,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x18,0x51,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0xFF,0xFF,0x50,0x30,
+0x01,0x00,0x02,0x32,
+0x18,0x00,0x40,0x10,
+0x21,0x28,0xC0,0x02,
+0x01,0x00,0x02,0x24,
+0x5C,0x00,0x22,0xAE,
+0x30,0x00,0xA5,0x8F,
+0x04,0x00,0x24,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x10,0x00,0x02,0x32,
+0x11,0x00,0x40,0x10,
+0x01,0x00,0x02,0x24,
+0x30,0x00,0x22,0xAE,
+0x02,0x80,0x03,0x3C,
+0x44,0x00,0x20,0xAE,
+0x60,0x1B,0x62,0x24,
+0x00,0x3F,0x43,0x8C,
+0x21,0x20,0xA0,0x02,
+0x01,0x00,0x63,0x24,
+0x00,0x3F,0x43,0xAC,
+0x08,0x00,0x02,0x24,
+0x0C,0x00,0xB7,0xAE,
+0xCB,0x09,0x00,0x0C,
+0x14,0x00,0xA2,0xAE,
+0x4D,0x14,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x56,0x15,0x00,0x08,
+0x5C,0x00,0x20,0xAE,
+0x5D,0x15,0x00,0x08,
+0x30,0x00,0x20,0xAE,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0x70,0x43,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x60,0x10,
+0x01,0x00,0x05,0x24,
+0x2A,0x43,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x2C,
+0x07,0x00,0x40,0x10,
+0x21,0x28,0x00,0x00,
+0xE3,0x3D,0x83,0x90,
+0x01,0x00,0x02,0x24,
+0x03,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0x82,0x24,
+0xE0,0x43,0x45,0x8C,
+0xDC,0x43,0x46,0x8C,
+0x21,0x20,0x40,0x00,
+0x40,0x18,0x05,0x00,
+0x40,0x10,0x06,0x00,
+0x2B,0x18,0x66,0x00,
+0x2B,0x38,0x45,0x00,
+0x04,0x00,0x60,0x14,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x05,0x24,
+0x02,0x00,0x02,0x24,
+0x0A,0x28,0x47,0x00,
+0x21,0x10,0xA0,0x00,
+0xDC,0x43,0x80,0xAC,
+0x08,0x00,0xE0,0x03,
+0xE0,0x43,0x80,0xAC,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x82,0x15,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x66,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x12,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x6E,0x15,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x0D,0x00,0x43,0x10,
+0x02,0x80,0x02,0x3C,
+0x8A,0x5E,0x44,0x90,
+0x02,0x80,0x02,0x3C,
+0xC4,0xE2,0x42,0x24,
+0x40,0x18,0x04,0x00,
+0x21,0x18,0x64,0x00,
+0x21,0x18,0x70,0x00,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x64,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xD8,0x01,0x42,0x34,
+0x00,0x00,0x44,0xAC,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x00,0x84,0x90,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x0F,0x00,0x84,0x30,
+0xC0,0x20,0x04,0x00,
+0x21,0x20,0x90,0x00,
+0x1C,0x00,0x84,0x24,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x06,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x10,0x37,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x63,0x30,
+0x06,0x00,0x60,0x14,
+0x21,0x20,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x33,0x14,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x50,0x57,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x18,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x00,0x00,0x43,0xAC,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x28,0x00,0x44,0x24,
+0x06,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x18,0x00,0x50,0x24,
+0x06,0x00,0x40,0x10,
+0x21,0x20,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x48,0x37,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xF3,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x42,0x30,
+0xEE,0xFF,0x40,0x10,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x18,0x64,0x43,0x90,
+0x05,0x00,0x02,0x24,
+0xFF,0x00,0x63,0x30,
+0x05,0x00,0x62,0x10,
+0x02,0x80,0x02,0x3C,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xE8,0x15,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x10,0x37,0x43,0x94,
+0x02,0x80,0x06,0x3C,
+0x00,0x01,0x63,0x30,
+0xF8,0xFF,0x60,0x10,
+0x01,0x00,0x05,0x24,
+0x39,0x64,0xC4,0x90,
+0xFB,0xFF,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0x39,0x64,0xC4,0xA0,
+0x08,0x64,0x40,0xAC,
+0x02,0x80,0x02,0x3C,
+0x19,0x64,0x44,0x90,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xE8,0x15,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x38,0x80,0x00,
+0x21,0x18,0x00,0x00,
+0x0F,0x00,0xA0,0x10,
+0xFF,0xFF,0xA6,0x24,
+0x02,0x80,0x02,0x3C,
+0xD8,0x61,0x48,0x24,
+0xFF,0xFF,0x05,0x24,
+0x00,0x00,0xE2,0x90,
+0x02,0x22,0x03,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x26,0x10,0x62,0x00,
+0xFF,0x00,0x42,0x30,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x48,0x00,
+0x00,0x00,0x43,0x94,
+0x01,0x00,0xE7,0x24,
+0xF6,0xFF,0xC5,0x14,
+0x26,0x18,0x83,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xC8,0xFF,0xBD,0x27,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0xA2,0x8C,
+0x02,0x80,0x15,0x3C,
+0x21,0x30,0xA0,0x00,
+0x42,0x1B,0x02,0x00,
+0x78,0x00,0x63,0x30,
+0x02,0x16,0x02,0x00,
+0x64,0x60,0xA5,0x92,
+0x21,0x18,0x66,0x00,
+0x03,0x00,0x42,0x30,
+0x21,0x18,0x62,0x00,
+0x21,0xA0,0x00,0x00,
+0x21,0x88,0x80,0x00,
+0x18,0x00,0x72,0x24,
+0x21,0x38,0x00,0x00,
+0x2B,0x00,0xA0,0x10,
+0x21,0x98,0x80,0x02,
+0x02,0x80,0x02,0x3C,
+0x68,0x60,0x57,0x24,
+0x02,0x80,0x16,0x3C,
+0x00,0x11,0x13,0x00,
+0x21,0x50,0x57,0x00,
+0x21,0x30,0x40,0x02,
+0x21,0x40,0x00,0x00,
+0x21,0x48,0x40,0x01,
+0x21,0x58,0x40,0x01,
+0x2C,0x00,0x00,0x15,
+0x01,0x00,0x02,0x24,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x22,0x91,
+0x21,0x28,0x27,0x02,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0x01,0x00,0x84,0x24,
+0x04,0x00,0x40,0x10,
+0x08,0x00,0x83,0x28,
+0x04,0x00,0xC2,0x90,
+0x01,0x00,0xE7,0x24,
+0x00,0x00,0xA2,0xA0,
+0xF5,0xFF,0x60,0x14,
+0x01,0x00,0xC6,0x24,
+0x01,0x00,0x08,0x25,
+0x10,0x00,0x02,0x29,
+0xEE,0xFF,0x40,0x14,
+0x38,0x61,0xC2,0x26,
+0x40,0x80,0x13,0x00,
+0x21,0x80,0x02,0x02,
+0x21,0x28,0xE0,0x00,
+0x1A,0x16,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x00,0x00,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x5F,0x00,0x62,0x10,
+0x01,0x00,0x73,0x26,
+0x64,0x60,0xA2,0x92,
+0x00,0x00,0x00,0x00,
+0x2A,0x10,0x62,0x02,
+0xDA,0xFF,0x40,0x14,
+0x21,0x38,0x00,0x00,
+0x21,0x10,0x80,0x02,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x21,0x00,0x02,0x11,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x80,0x00,0x42,0x30,
+0x13,0x00,0x40,0x10,
+0x21,0x28,0x68,0x01,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0x04,0x00,0x40,0x10,
+0x21,0x18,0x27,0x02,
+0x14,0x00,0xC2,0x90,
+0x01,0x00,0xE7,0x24,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0x82,0x28,
+0xCF,0xFF,0x40,0x10,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x80,0x00,0x42,0x30,
+0xEF,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0xF2,0xFF,0x40,0x10,
+0x21,0x18,0x27,0x02,
+0x12,0x00,0xC2,0x90,
+0x8D,0x16,0x00,0x08,
+0x01,0x00,0xE7,0x24,
+0x04,0x00,0x82,0x28,
+0x12,0x00,0x40,0x10,
+0x01,0x00,0x45,0x25,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0x05,0x00,0x40,0x10,
+0x21,0x10,0x27,0x02,
+0x04,0x00,0xC3,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xA0,
+0x01,0x00,0xE7,0x24,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0x82,0x28,
+0xB0,0xFF,0x40,0x10,
+0x01,0x00,0xC6,0x24,
+0x04,0x00,0x82,0x28,
+0xF0,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x80,0x00,0x42,0x30,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0xEF,0xFF,0x40,0x10,
+0x21,0x10,0x27,0x02,
+0x14,0x00,0xC3,0x90,
+0xAC,0x16,0x00,0x08,
+0x00,0x00,0x43,0xA0,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0xE6,0xFF,0x40,0x10,
+0x21,0x10,0x27,0x02,
+0x12,0x00,0xC3,0x90,
+0xAC,0x16,0x00,0x08,
+0x00,0x00,0x43,0xA0,
+0x01,0x00,0x14,0x24,
+0x21,0x10,0x80,0x02,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x82,0x8C,
+0x21,0x18,0x80,0x00,
+0x02,0x80,0x06,0x3C,
+0x42,0x23,0x02,0x00,
+0x78,0x00,0x84,0x30,
+0x02,0x16,0x02,0x00,
+0x21,0x20,0x83,0x00,
+0x03,0x00,0x42,0x30,
+0x21,0x20,0x82,0x00,
+0x80,0xE3,0xC6,0x24,
+0x36,0x00,0x84,0x24,
+0x80,0x00,0x05,0x24,
+0xA5,0x55,0x00,0x0C,
+0x06,0x00,0x07,0x24,
+0x02,0x80,0x06,0x3C,
+0x06,0x00,0x44,0x24,
+0x5C,0x61,0xC6,0x24,
+0x7A,0x00,0x05,0x24,
+0x04,0x00,0x40,0x10,
+0x60,0x00,0x07,0x24,
+0xA5,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x40,0x00,
+0x2B,0x10,0x10,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x60,0xFF,0xBD,0x27,
+0xDC,0x5B,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x98,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x9C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x90,0x00,0xA4,0x27,
+0x02,0x80,0x03,0x3C,
+0x54,0x61,0x66,0x90,
+0xFF,0x00,0x02,0x24,
+0x08,0x00,0xC2,0x10,
+0x54,0x61,0x65,0x24,
+0xA0,0x40,0x00,0x0C,
+0x90,0x00,0xA4,0x27,
+0x9C,0x00,0xBF,0x8F,
+0x98,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0xA0,0x00,0xBD,0x27,
+0x01,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x46,0x10,
+0x21,0x20,0x00,0x02,
+0x02,0x00,0xA2,0x90,
+0x10,0x00,0xA4,0x27,
+0xF2,0xFF,0x46,0x14,
+0x21,0x28,0x00,0x02,
+0x2E,0x16,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEE,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x4A,0x11,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x07,0x17,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xD8,0x16,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x18,0x17,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x18,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x60,0x1B,0x50,0x24,
+0x90,0x42,0x03,0x8E,
+0x10,0x00,0xA4,0x27,
+0x01,0x00,0x63,0x24,
+0x03,0x00,0x62,0x2C,
+0x12,0x00,0x40,0x10,
+0x90,0x42,0x03,0xAE,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x05,0x4D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x32,0x00,0x03,0x24,
+0xCC,0x39,0x03,0xAE,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x9A,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xFF,0xDF,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0xA1,0x48,0x00,0x0C,
+0xFE,0xFF,0x04,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x38,0x00,0xA4,0xA3,
+0x00,0x01,0x04,0x24,
+0x28,0x00,0xB2,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x3C,0x00,0xA5,0xA3,
+0xF3,0x27,0x00,0x0C,
+0x40,0x00,0xA6,0xA7,
+0x46,0x00,0x40,0x10,
+0x21,0x90,0x40,0x00,
+0x40,0x00,0xA7,0x97,
+0x38,0x00,0xA5,0x93,
+0x3C,0x00,0xA6,0x93,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x84,0xF1,0x84,0x24,
+0x08,0x00,0x50,0x96,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x11,0x3C,
+0x25,0x80,0x02,0x02,
+0xD0,0x55,0x31,0x26,
+0x21,0x28,0x20,0x02,
+0x24,0x00,0x04,0x26,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x00,0xA6,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x2A,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x21,0x28,0x20,0x02,
+0x30,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x14,0x3C,
+0x03,0xFF,0x63,0x30,
+0xD0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x60,0x1B,0x93,0x26,
+0x0C,0x00,0x42,0xAE,
+0xE4,0x1D,0x62,0x96,
+0x20,0x00,0x05,0x26,
+0x0C,0x00,0x51,0x26,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x22,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xE4,0x1D,0x62,0xA6,
+0x38,0x00,0xA6,0x27,
+0x16,0x00,0xA3,0xA0,
+0x17,0x00,0xA4,0xA0,
+0x21,0x38,0x20,0x02,
+0x38,0x00,0x04,0x26,
+0x4C,0x51,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x40,0x00,
+0x01,0x00,0x05,0x24,
+0x3C,0x00,0xA6,0x27,
+0x4C,0x51,0x00,0x0C,
+0x21,0x38,0x20,0x02,
+0x38,0x00,0xA3,0x93,
+0x21,0x20,0x40,0x00,
+0x03,0x00,0x02,0x24,
+0x14,0x00,0x62,0x10,
+0x04,0x00,0x02,0x24,
+0x36,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x82,0x26,
+0x2A,0x43,0x43,0x90,
+0x04,0x00,0x07,0x24,
+0x21,0x20,0x40,0x02,
+0x01,0x00,0x63,0x38,
+0x0B,0x38,0x03,0x00,
+0x21,0x28,0x00,0x00,
+0xC7,0x0E,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x3C,0x00,0xA3,0x93,
+0x00,0x00,0x00,0x00,
+0x36,0x00,0x60,0x10,
+0x21,0x80,0x60,0x02,
+0x01,0x00,0x02,0x24,
+0xE9,0xFF,0x62,0x14,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x98,0x5E,0xC6,0x24,
+0x4C,0x51,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x40,0x00,
+0x40,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x4C,0x51,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x3C,0x43,0x68,0x8E,
+0xFF,0xFF,0x03,0x3C,
+0x3F,0x00,0x63,0x34,
+0x24,0x40,0x03,0x01,
+0x02,0x80,0x06,0x3C,
+0x00,0x08,0x08,0x35,
+0x21,0x38,0x20,0x02,
+0x9C,0x5E,0xC6,0x24,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x4C,0x51,0x00,0x0C,
+0x3C,0x43,0x68,0xAE,
+0x02,0x80,0x06,0x3C,
+0x21,0x20,0x40,0x00,
+0x9E,0x5E,0xC6,0x24,
+0x21,0x38,0x20,0x02,
+0x4C,0x51,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x96,0x17,0x00,0x08,
+0x60,0x1B,0x82,0x26,
+0x3C,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0xC9,0xFF,0x40,0x14,
+0x60,0x1B,0x82,0x26,
+0xD1,0x43,0x62,0x92,
+0x01,0x00,0x10,0x24,
+0x43,0x00,0x50,0x10,
+0x48,0x00,0x05,0x24,
+0xD0,0x43,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xC0,0xFF,0x50,0x14,
+0x02,0x80,0x07,0x3C,
+0xCF,0x43,0x66,0x92,
+0x0E,0x5F,0xE7,0x24,
+0x01,0x00,0xC6,0x24,
+0x49,0x00,0x05,0x24,
+0x10,0x00,0xB1,0xAF,
+0x25,0x51,0x00,0x0C,
+0xAE,0x43,0x60,0xA2,
+0x96,0x17,0x00,0x08,
+0x60,0x1B,0x82,0x26,
+0x39,0x43,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x68,0x24,
+0xFF,0x00,0x02,0x31,
+0xFD,0xFF,0x40,0x10,
+0x21,0x18,0x00,0x01,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x39,0x43,0x08,0xA2,
+0x99,0x5E,0xC6,0x24,
+0x4C,0x51,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x3C,0x43,0x08,0x8E,
+0x40,0x00,0xA4,0x97,
+0xC3,0xFF,0x03,0x24,
+0x02,0x00,0x08,0x35,
+0x0F,0x00,0x84,0x30,
+0x24,0x40,0x03,0x01,
+0x80,0x20,0x04,0x00,
+0xFF,0xFF,0x03,0x3C,
+0x3F,0x00,0x63,0x34,
+0x25,0x40,0x04,0x01,
+0x24,0x40,0x03,0x01,
+0x00,0x08,0x08,0x35,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x3C,0x43,0x08,0xAE,
+0x9C,0x5E,0xC6,0x24,
+0x21,0x20,0x40,0x00,
+0x4C,0x51,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x9E,0x5E,0xC6,0x24,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x4C,0x51,0x00,0x0C,
+0x3E,0x43,0x00,0xA6,
+0x40,0x00,0xA3,0x97,
+0x21,0x20,0x40,0x00,
+0x02,0x80,0x06,0x3C,
+0x07,0x00,0x63,0x30,
+0x40,0x18,0x03,0x00,
+0x21,0x18,0x70,0x00,
+0xD4,0x1D,0x62,0x94,
+0xA0,0x5E,0xC6,0x24,
+0x21,0x38,0x20,0x02,
+0x00,0x11,0x02,0x00,
+0x02,0x00,0x05,0x24,
+0x4C,0x51,0x00,0x0C,
+0x40,0x43,0x02,0xA6,
+0x96,0x17,0x00,0x08,
+0x60,0x1B,0x82,0x26,
+0x01,0x00,0x06,0x24,
+0x18,0x00,0xA7,0x27,
+0x18,0x00,0xA3,0xA3,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB1,0xAF,
+0xD2,0x17,0x00,0x08,
+0x21,0x20,0x40,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x82,0x90,
+0x02,0x80,0x11,0x3C,
+0x21,0x80,0x80,0x00,
+0x60,0x1B,0x31,0x26,
+0x02,0x80,0x04,0x3C,
+0x02,0x00,0x06,0x24,
+0x01,0x00,0x05,0x26,
+0x9C,0x5E,0x84,0x24,
+0xCE,0x53,0x00,0x0C,
+0x38,0x43,0x22,0xA2,
+0x04,0x00,0x03,0x92,
+0x03,0x00,0x02,0x92,
+0x00,0x1A,0x03,0x00,
+0x25,0x18,0x62,0x00,
+0x3E,0x43,0x23,0xA6,
+0x06,0x00,0x02,0x92,
+0x05,0x00,0x03,0x92,
+0x00,0x12,0x02,0x00,
+0x25,0x10,0x43,0x00,
+0x40,0x43,0x22,0xA6,
+0x01,0x00,0x05,0x92,
+0x06,0x00,0x04,0x92,
+0x05,0x00,0x02,0x92,
+0x82,0x28,0x05,0x00,
+0x00,0x22,0x04,0x00,
+0x25,0x20,0x82,0x00,
+0xDF,0x48,0x00,0x0C,
+0x0F,0x00,0xA5,0x30,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x03,0x00,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0x4B,0x17,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x03,0x42,0x34,
+0x0C,0x61,0x63,0x24,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x00,0x00,0x43,0xAC,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x88,0x44,0x00,
+0x28,0x00,0x24,0x26,
+0x06,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x18,0x00,0x30,0x26,
+0x08,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x39,0x52,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x02,0x80,0x04,0x3C,
+0x48,0x37,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xF1,0xFF,0x40,0x14,
+0x03,0x00,0x02,0x24,
+0x30,0x00,0x23,0x92,
+0x00,0x00,0x00,0x00,
+0xED,0xFF,0x62,0x14,
+0x30,0x00,0x24,0x26,
+0x02,0x80,0x07,0x3C,
+0x60,0x1B,0xE5,0x24,
+0x70,0x43,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0xE7,0xFF,0x40,0x10,
+0x01,0x00,0x06,0x24,
+0x01,0x00,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x1A,0x00,0x66,0x10,
+0x02,0x00,0x62,0x28,
+0x2E,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0xDF,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x62,0x30,
+0x0A,0x00,0x40,0x14,
+0x02,0x11,0x03,0x00,
+0x3A,0x43,0xA3,0x90,
+0x04,0x10,0x46,0x00,
+0x27,0x10,0x02,0x00,
+0x24,0x10,0x43,0x00,
+0x3A,0x43,0xA2,0xA0,
+0x05,0x00,0x83,0x90,
+0x04,0x00,0x82,0x90,
+0x00,0x1A,0x03,0x00,
+0x25,0x90,0x62,0x00,
+0x3A,0x43,0xA5,0x90,
+0x02,0x80,0x04,0x3C,
+0xA0,0xF1,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x59,0x18,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x82,0x90,
+0x05,0x00,0x83,0x90,
+0x03,0x00,0x84,0x90,
+0x00,0x12,0x02,0x00,
+0x82,0x18,0x03,0x00,
+0x25,0x10,0x44,0x00,
+0x15,0x00,0x40,0x14,
+0x07,0x00,0x64,0x30,
+0x3A,0x43,0xA3,0x90,
+0x04,0x10,0x86,0x00,
+0x25,0x10,0x43,0x00,
+0x3A,0x43,0xA2,0xA0,
+0x60,0x1B,0xE2,0x24,
+0x6C,0x43,0x43,0x90,
+0x3A,0x43,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x21,0x18,0x62,0x00,
+0xB0,0xF1,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x64,0x43,0x60,0xA0,
+0x59,0x18,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB2,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x1B,0x18,0x00,0x0C,
+0x32,0x00,0x24,0x26,
+0x59,0x18,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x3A,0x43,0xA3,0x90,
+0x04,0x10,0x86,0x00,
+0x27,0x10,0x02,0x00,
+0x9B,0x18,0x00,0x08,
+0x24,0x10,0x43,0x00,
+0xB8,0xFF,0xBD,0x27,
+0x38,0x00,0xB6,0xAF,
+0xFF,0xFF,0x96,0x30,
+0x00,0x01,0x04,0x24,
+0x3C,0x00,0xB7,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x40,0x00,0xBF,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x24,0x00,0xB1,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x20,0x00,0xB0,0xAF,
+0x21,0x90,0x40,0x00,
+0x52,0x00,0x40,0x10,
+0x21,0xB8,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0xC0,0xF1,0x84,0x24,
+0x08,0x00,0x50,0x96,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x11,0x3C,
+0x25,0x80,0x02,0x02,
+0xD0,0x55,0x31,0x26,
+0x24,0x00,0x04,0x26,
+0x21,0x28,0x20,0x02,
+0x20,0x00,0x00,0xA6,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x48,0x37,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x30,0x00,0x04,0x26,
+0x21,0x28,0x20,0x02,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x15,0x3C,
+0x03,0xFF,0x63,0x30,
+0xB0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x60,0x1B,0xA9,0x26,
+0x0C,0x00,0x42,0xAE,
+0xE4,0x1D,0x22,0x95,
+0x20,0x00,0x14,0x26,
+0x0C,0x00,0x51,0x26,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x22,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xE4,0x1D,0x22,0xA5,
+0x17,0x00,0x84,0xA2,
+0x16,0x00,0x83,0xA2,
+0x94,0x42,0x24,0x8D,
+0x03,0x00,0x02,0x24,
+0x31,0x00,0x82,0x10,
+0x38,0x00,0x10,0x26,
+0x60,0x1B,0xB3,0x26,
+0x98,0x42,0x62,0x8E,
+0x21,0x20,0x00,0x02,
+0x02,0x00,0x05,0x24,
+0x01,0x00,0x42,0x38,
+0x01,0x00,0x42,0x2C,
+0x18,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x4C,0x51,0x00,0x0C,
+0x18,0x00,0xA2,0xA7,
+0x94,0x42,0x63,0x8E,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x18,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x4C,0x51,0x00,0x0C,
+0x18,0x00,0xA3,0xA7,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x18,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x4C,0x51,0x00,0x0C,
+0x18,0x00,0xB6,0xA7,
+0x94,0x42,0x63,0x8E,
+0x21,0x80,0x40,0x00,
+0x03,0x00,0x02,0x24,
+0x2B,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xA2,0x26,
+0x2A,0x43,0x43,0x90,
+0x04,0x00,0x07,0x24,
+0x21,0x20,0x40,0x02,
+0x01,0x00,0x63,0x38,
+0x0B,0x38,0x03,0x00,
+0x21,0x30,0xE0,0x02,
+0xC7,0x0E,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xB0,0x1B,0x22,0x95,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0xCD,0xFF,0x40,0x10,
+0x60,0x1B,0xB3,0x26,
+0xA4,0x42,0x28,0x8D,
+0xA0,0x42,0x23,0x8D,
+0xFF,0x00,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x10,0x02,0x01,
+0x80,0x1F,0x03,0x00,
+0x25,0x10,0x43,0x00,
+0x01,0x00,0x08,0x25,
+0x21,0x20,0x00,0x02,
+0x04,0x00,0x05,0x24,
+0x1C,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0xA4,0x42,0x28,0xAD,
+0x4C,0x51,0x00,0x0C,
+0x1C,0x00,0xA2,0xAF,
+0xED,0x18,0x00,0x08,
+0x21,0x80,0x40,0x00,
+0xB0,0x1B,0x62,0x96,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0xD3,0xFF,0x40,0x10,
+0x60,0x1B,0xA2,0x26,
+0x02,0x80,0x07,0x3C,
+0x21,0x20,0x00,0x02,
+0x08,0x5E,0xE7,0x24,
+0x10,0x00,0x05,0x24,
+0x80,0x00,0x06,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB1,0xAF,
+0x00,0x00,0x83,0x96,
+0x01,0x00,0x17,0x24,
+0x00,0x40,0x63,0x34,
+0x09,0x19,0x00,0x08,
+0x00,0x00,0x83,0xA6,
+0xB0,0xFF,0xBD,0x27,
+0x38,0x00,0xB4,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0x48,0x00,0xBF,0xAF,
+0x44,0x00,0xB7,0xAF,
+0x40,0x00,0xB6,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x14,0x3C,
+0x21,0x90,0x80,0x00,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x28,0x00,0x11,0x26,
+0xD0,0x55,0x85,0x26,
+0x21,0x20,0x20,0x02,
+0x06,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x18,0x00,0x13,0x26,
+0x7E,0x00,0x40,0x10,
+0x21,0x20,0x60,0x02,
+0x02,0x80,0x02,0x3C,
+0x6D,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x65,0x00,0x60,0x14,
+0x02,0x80,0x16,0x3C,
+0x60,0x1B,0xC2,0x26,
+0xE7,0x43,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x60,0x10,
+0x3C,0x00,0x04,0x26,
+0x60,0x1B,0xD0,0x26,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x62,0x30,
+0x2A,0x00,0x40,0x10,
+0x10,0x00,0x62,0x30,
+0xD6,0x43,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x6E,0x00,0x40,0x14,
+0x21,0x20,0x60,0x02,
+0x33,0x14,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x48,0x00,0xBF,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0x00,0x00,0x47,0x8E,
+0x07,0x00,0x05,0x24,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0xE1,0xFF,0x40,0x10,
+0x21,0x18,0x40,0x00,
+0x20,0x00,0xA5,0x8F,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0xA2,0x28,
+0xDC,0xFF,0x40,0x14,
+0xFD,0xFF,0xA5,0x24,
+0x05,0x00,0x64,0x24,
+0x95,0x4C,0x00,0x0C,
+0xFF,0x00,0xA5,0x30,
+0x02,0x80,0x04,0x3C,
+0x48,0x5F,0x84,0x24,
+0x21,0x28,0x20,0x02,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x67,0x19,0x00,0x08,
+0x60,0x1B,0xD0,0x26,
+0x4E,0x00,0x40,0x14,
+0x10,0x00,0x75,0x26,
+0x60,0x1B,0xD0,0x26,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xD6,0xFF,0x40,0x10,
+0xD0,0x55,0x85,0x26,
+0x10,0x00,0x64,0x26,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xD1,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x40,0x02,
+0x9C,0x1E,0x00,0x0C,
+0x18,0x00,0x45,0x26,
+0x21,0x20,0x40,0x00,
+0x16,0x1E,0x00,0x0C,
+0x05,0x00,0x05,0x24,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0xBC,0x00,0x40,0x10,
+0x04,0x00,0x62,0x30,
+0x70,0x43,0x03,0x8E,
+0x01,0x00,0x02,0x24,
+0xF4,0x00,0x62,0x10,
+0x21,0x20,0x60,0x02,
+0x9A,0x40,0x00,0x0C,
+0x24,0x00,0xA4,0x27,
+0xE8,0x1E,0x03,0x8E,
+0xEC,0x1E,0x02,0x8E,
+0x24,0x00,0xA4,0x27,
+0x01,0x00,0x63,0x24,
+0x01,0x00,0x42,0x24,
+0xEC,0x1E,0x02,0xAE,
+0xA0,0x40,0x00,0x0C,
+0xE8,0x1E,0x03,0xAE,
+0x60,0x1B,0xD0,0x26,
+0x2B,0x43,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x44,0x24,
+0xFF,0x00,0x83,0x30,
+0x15,0x00,0x02,0x24,
+0xC1,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x72,0x19,0x00,0x08,
+0x2B,0x43,0x04,0xA2,
+0x00,0x00,0x47,0x8E,
+0x3C,0x00,0x04,0x26,
+0x03,0x00,0x05,0x24,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0x99,0xFF,0x40,0x10,
+0x02,0x80,0x16,0x3C,
+0x02,0x00,0x42,0x90,
+0x60,0x1B,0xC3,0x26,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x58,0x3E,0x44,0x8C,
+0x5C,0x3E,0x43,0x8C,
+0x01,0x00,0x84,0x24,
+0x01,0x00,0x63,0x24,
+0x5C,0x3E,0x43,0xAC,
+0x66,0x19,0x00,0x08,
+0x58,0x3E,0x44,0xAC,
+0x3D,0x32,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x5D,0x19,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x45,0x8E,
+0x00,0x00,0x00,0x00,
+0xFF,0x3F,0xA5,0x30,
+0x02,0x11,0x00,0x0C,
+0xE8,0xFF,0xA5,0x24,
+0x70,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0xA0,0x02,
+0xD0,0x55,0x85,0x26,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xAE,0xFF,0x40,0x14,
+0x07,0x00,0x02,0x24,
+0x2A,0x43,0x02,0xA2,
+0xE8,0x39,0x00,0xAE,
+0x00,0x00,0x44,0x8E,
+0x0C,0x00,0x14,0x24,
+0xFF,0x3F,0x82,0x30,
+0xE8,0xFF,0x42,0x24,
+0x2A,0x10,0x82,0x02,
+0x4A,0x00,0x40,0x10,
+0x21,0xB8,0x00,0x02,
+0xFE,0x19,0x00,0x08,
+0x21,0x80,0x74,0x02,
+0x19,0x00,0x03,0x92,
+0xFF,0x3F,0x82,0x30,
+0xE8,0xFF,0x42,0x24,
+0x21,0x18,0x74,0x00,
+0x02,0x00,0x74,0x24,
+0x2A,0x10,0x82,0x02,
+0x41,0x00,0x40,0x10,
+0x60,0x1B,0xD0,0x26,
+0x21,0x80,0x74,0x02,
+0x18,0x00,0x03,0x92,
+0xDD,0x00,0x02,0x24,
+0xF4,0xFF,0x62,0x14,
+0x1A,0x00,0x11,0x26,
+0x02,0x80,0x05,0x3C,
+0x54,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x00,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x50,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xFA,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x44,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xEF,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x40,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xE9,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x3C,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xE3,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x34,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xEC,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x30,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xE0,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x38,0xE3,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xF8,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x21,0x20,0x20,0x02,
+0x24,0xE3,0xA5,0x24,
+0xF7,0x53,0x00,0x0C,
+0x04,0x00,0x06,0x24,
+0xE0,0x00,0x40,0x10,
+0x02,0x00,0x02,0x24,
+0x00,0x00,0x44,0x8E,
+0xF5,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xD0,0x26,
+0x2A,0x43,0x03,0x92,
+0x07,0x00,0x02,0x24,
+0x18,0x00,0x62,0x10,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0x24,0xF2,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x66,0x5F,0x46,0x90,
+0x01,0x00,0x03,0x24,
+0x05,0x00,0xC3,0x10,
+0x03,0x00,0x02,0x24,
+0x95,0x4F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x72,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC4,0x26,
+0x2A,0x43,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x2C,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0xDA,0x43,0x86,0xA0,
+0x95,0x4F,0x00,0x0C,
+0xD9,0x43,0x80,0xA0,
+0x72,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x4C,0xE3,0xA5,0x24,
+0x21,0x20,0xA0,0x02,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x07,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x21,0x20,0xA0,0x02,
+0x48,0xE3,0xA5,0x24,
+0xF7,0x53,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xDE,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x38,0xF2,0x84,0x24,
+0x43,0x1A,0x00,0x08,
+0x2A,0x43,0x00,0xA2,
+0x53,0xFF,0x40,0x10,
+0x60,0x1B,0xD0,0x26,
+0x0A,0x00,0x77,0x26,
+0xEE,0x52,0x00,0x0C,
+0x21,0x20,0xE0,0x02,
+0x20,0x00,0x10,0x24,
+0x3C,0x00,0x50,0x10,
+0x21,0x88,0x40,0x00,
+0x9A,0x40,0x00,0x0C,
+0x24,0x00,0xA4,0x27,
+0x40,0x10,0x11,0x00,
+0x21,0x10,0x51,0x00,
+0x60,0x1B,0xC4,0x26,
+0x00,0x11,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0xF8,0x1D,0x43,0x8C,
+0x24,0x00,0xA4,0x27,
+0x01,0x00,0x63,0x24,
+0xA0,0x40,0x00,0x0C,
+0xF8,0x1D,0x43,0xAC,
+0x72,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xD9,0x43,0x86,0xA0,
+0x95,0x4F,0x00,0x0C,
+0xDA,0x43,0x80,0xA0,
+0x72,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x94,0x15,0x00,0x0C,
+0x2B,0x43,0x00,0xA2,
+0x02,0x80,0x02,0x3C,
+0x6A,0x5F,0x44,0x90,
+0x02,0x00,0x03,0x24,
+0xE9,0xFE,0x83,0x14,
+0x2A,0x00,0x05,0x24,
+0x00,0x00,0x47,0x8E,
+0x24,0x00,0x64,0x26,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x6B,0x21,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0xE1,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x82,0x30,
+0x9A,0x00,0x40,0x10,
+0x60,0x1B,0xC5,0x26,
+0x01,0x00,0x82,0x30,
+0x97,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x6B,0x5F,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0xA3,0x00,0x83,0x10,
+0xFF,0xEF,0x03,0x24,
+0xFC,0x23,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x42,0x34,
+0x24,0x10,0x43,0x00,
+0x72,0x19,0x00,0x08,
+0xFC,0x23,0x02,0xAE,
+0x00,0x00,0x45,0x8E,
+0x00,0x00,0x00,0x00,
+0xFF,0x3F,0xA5,0x30,
+0x9A,0x10,0x00,0x0C,
+0xE8,0xFF,0xA5,0x24,
+0xB1,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x04,0x24,
+0x96,0x52,0x00,0x0C,
+0x21,0x28,0xE0,0x02,
+0xC1,0xFF,0x50,0x10,
+0x21,0x88,0x40,0x00,
+0x00,0x00,0x47,0x8E,
+0x24,0x00,0x75,0x26,
+0x21,0x20,0xA0,0x02,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x01,0x00,0x05,0x24,
+0x6B,0x21,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0xB9,0xFE,0x40,0x10,
+0x02,0x00,0x45,0x24,
+0x20,0x00,0xA6,0x8F,
+0xCE,0x53,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x47,0x8E,
+0x21,0x20,0xA0,0x02,
+0x32,0x00,0x05,0x24,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x20,0x00,0xB0,0x8F,
+0x6B,0x21,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0x08,0x00,0x40,0x10,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xA6,0x8F,
+0x21,0x20,0x90,0x00,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x20,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x03,0x02,
+0x10,0x00,0xA4,0x27,
+0xB3,0x21,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x21,0x28,0x00,0x02,
+0x10,0x00,0xA4,0x27,
+0x75,0x52,0x00,0x0C,
+0x0F,0x00,0x54,0x30,
+0x00,0x00,0x47,0x8E,
+0x21,0x20,0xA0,0x02,
+0x2D,0x00,0x05,0x24,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x20,0x00,0xA6,0x27,
+0x6B,0x21,0x00,0x0C,
+0x21,0x98,0x40,0x00,
+0x11,0x00,0x40,0x10,
+0x00,0x81,0x11,0x00,
+0x06,0x00,0x44,0x90,
+0x05,0x00,0x43,0x90,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x45,0x90,
+0x00,0x1B,0x03,0x00,
+0x00,0x25,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x10,0x00,0xA5,0x30,
+0x25,0x98,0x63,0x02,
+0x02,0x00,0xA0,0x14,
+0x0F,0x00,0x02,0x3C,
+0xFF,0x0F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x98,0x62,0x02,
+0x08,0x00,0x94,0x36,
+0x00,0x81,0x11,0x00,
+0x25,0x80,0x14,0x02,
+0xFF,0xFF,0x10,0x32,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x20,0x02,
+0x21,0x30,0x00,0x02,
+0x21,0x38,0x60,0x02,
+0x13,0x57,0x00,0x0C,
+0x54,0xF2,0x84,0x24,
+0x21,0x20,0x00,0x02,
+0x57,0x5D,0x00,0x74,
+0x21,0x28,0x60,0x02,
+0x60,0x1B,0xC3,0x26,
+0xD7,0x43,0x62,0x90,
+0x21,0x20,0xE0,0x02,
+0x21,0x28,0x20,0x02,
+0x01,0x00,0x42,0x24,
+0x52,0x10,0x00,0x0C,
+0xD7,0x43,0x62,0xA0,
+0x70,0x1A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x01,0x00,0x02,0x24,
+0x68,0xF2,0x84,0x24,
+0x43,0x1A,0x00,0x08,
+0x2A,0x43,0xE2,0xA2,
+0x02,0x80,0x04,0x3C,
+0x80,0xF2,0x84,0x24,
+0x43,0x1A,0x00,0x08,
+0x2A,0x43,0xE0,0xA2,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0xC3,0x26,
+0x04,0x00,0x02,0x24,
+0x94,0xF2,0x84,0x24,
+0x43,0x1A,0x00,0x08,
+0x2A,0x43,0x62,0xA0,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0xC3,0x26,
+0x03,0x00,0x02,0x24,
+0xA8,0xF2,0x84,0x24,
+0x43,0x1A,0x00,0x08,
+0x2A,0x43,0x62,0xA0,
+0x1E,0x00,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x62,0x14,
+0x02,0x80,0x04,0x3C,
+0x20,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x05,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xD0,0xE6,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x13,0x00,0x60,0x14,
+0x11,0x00,0x03,0x24,
+0x13,0x57,0x00,0x0C,
+0xBC,0xF2,0x84,0x24,
+0x05,0x00,0x02,0x24,
+0x45,0x1A,0x00,0x08,
+0x2A,0x43,0xE2,0xA2,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0xC3,0x26,
+0x02,0x00,0x02,0x24,
+0xD4,0xF2,0x84,0x24,
+0x43,0x1A,0x00,0x08,
+0x2A,0x43,0x62,0xA0,
+0xFC,0x23,0xA2,0x8C,
+0xFF,0xEF,0x03,0x24,
+0xFF,0xF7,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x72,0x19,0x00,0x08,
+0xFC,0x23,0xA2,0xAC,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x02,0x3C,
+0xE8,0xF2,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x5E,0x5F,0x43,0xA0,
+0x60,0x1B,0xC3,0x26,
+0x06,0x00,0x02,0x24,
+0x45,0x1A,0x00,0x08,
+0x2A,0x43,0x62,0xA0,
+0xFC,0x23,0x02,0x8E,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x10,0x42,0x34,
+0x72,0x19,0x00,0x08,
+0xFC,0x23,0x02,0xAE,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x06,0x3C,
+0x18,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x60,0x1B,0xD0,0x24,
+0x8C,0x42,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x45,0x24,
+0x03,0x00,0xA3,0x2C,
+0x12,0x00,0x60,0x14,
+0x03,0x00,0x02,0x24,
+0x98,0x42,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x62,0x10,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x8C,0x42,0x05,0xAE,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xFF,0xDF,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0xA1,0x48,0x00,0x0C,
+0xFF,0xFF,0x04,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x8C,0x42,0x05,0xAE,
+0x60,0x1B,0xD0,0x24,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x80,0x00,0x42,0x30,
+0x0E,0x00,0x40,0x10,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x01,0x00,0x02,0x24,
+0x98,0x42,0x02,0xAE,
+0x8C,0x42,0x00,0xAE,
+0x60,0x1B,0xD0,0x24,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x80,0x00,0x42,0x30,
+0xF4,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x9A,0x40,0x00,0x0C,
+0x94,0x42,0x02,0xAE,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xBF,0xFF,0x42,0x30,
+0x20,0x00,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0xB1,0x18,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x32,0x00,0x03,0x24,
+0xB0,0x39,0x03,0xAE,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xB0,0xFF,0xBD,0x27,
+0x40,0x00,0xB6,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0xFF,0xFF,0xF6,0x30,
+0x25,0xB0,0x15,0x3C,
+0x00,0x80,0x02,0x3C,
+0x2C,0x00,0xB1,0xAF,
+0x18,0x03,0xA3,0x36,
+0x24,0x6E,0x42,0x24,
+0x20,0x00,0xD1,0x26,
+0x50,0x00,0xA4,0xAF,
+0x48,0x00,0xBE,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x64,0x00,0xBE,0x93,
+0x60,0x00,0xB3,0x93,
+0x21,0x20,0x20,0x02,
+0x00,0x00,0x62,0xAC,
+0x44,0x00,0xB7,0xAF,
+0x38,0x00,0xB4,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x4C,0x00,0xBF,0xAF,
+0x28,0x00,0xB0,0xAF,
+0xFF,0x00,0xB7,0x30,
+0xF3,0x27,0x00,0x0C,
+0xFF,0x00,0xD4,0x30,
+0x4E,0x00,0x40,0x10,
+0x21,0x90,0x40,0x00,
+0x08,0x00,0x44,0x94,
+0x02,0x80,0x10,0x3C,
+0x21,0x30,0x20,0x02,
+0x25,0x20,0x90,0x00,
+0xBD,0x53,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x08,0x00,0x43,0x96,
+0x00,0x00,0x00,0x00,
+0x25,0x80,0x70,0x00,
+0x4F,0x00,0x60,0x16,
+0x20,0x00,0x11,0x26,
+0x20,0x00,0x14,0xA6,
+0x48,0x00,0x02,0x24,
+0x8A,0x00,0x82,0x12,
+0xC8,0x00,0x02,0x24,
+0x89,0x00,0x82,0x12,
+0x50,0x00,0xA2,0x36,
+0x04,0x00,0x02,0x24,
+0x49,0x00,0xE2,0x16,
+0x04,0x00,0x24,0x26,
+0xA4,0x00,0x02,0x24,
+0xAF,0x00,0x82,0x12,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0x44,0x96,
+0x02,0x80,0x02,0x3C,
+0x12,0x00,0x03,0x24,
+0x25,0x80,0x82,0x00,
+0x14,0x00,0x43,0xAE,
+0x0C,0x00,0x56,0xAE,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x00,0x00,
+0xC6,0x53,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x04,0x00,0x03,0x8E,
+0xFF,0xE0,0x02,0x24,
+0x00,0x00,0x16,0xA6,
+0x24,0x38,0x62,0x00,
+0x20,0x00,0x02,0x24,
+0x02,0x00,0x02,0xA2,
+0xA4,0x00,0x02,0x24,
+0x64,0x00,0x82,0x12,
+0x00,0x12,0xE7,0x34,
+0x14,0x00,0x02,0x8E,
+0xFF,0x81,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x14,0x00,0x02,0xAE,
+0x08,0x00,0x04,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x00,0x40,0x02,0x3C,
+0x10,0x00,0x06,0x8E,
+0x25,0x20,0x82,0x00,
+0xFF,0xE0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xE0,0xFF,0x05,0x24,
+0x00,0x80,0x03,0x3C,
+0x24,0x28,0xE5,0x00,
+0x24,0x20,0x82,0x00,
+0x00,0x05,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x25,0x30,0xC3,0x00,
+0x05,0x00,0xA5,0x34,
+0x08,0x00,0x04,0xAE,
+0x10,0x00,0x06,0xAE,
+0x20,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x04,0x00,0x05,0xAE,
+0x02,0x80,0x02,0x3C,
+0x98,0x54,0x42,0x24,
+0x04,0x00,0x43,0x8C,
+0x00,0x00,0x42,0xAE,
+0x04,0x00,0x52,0xAC,
+0x00,0x00,0x72,0xAC,
+0x04,0x00,0x43,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x20,0x00,0xA4,0x27,
+0x4C,0x00,0xBF,0x8F,
+0x48,0x00,0xBE,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0x00,0x10,0x82,0x36,
+0xB0,0x1B,0x00,0x08,
+0x20,0x00,0x02,0xA6,
+0x50,0x00,0xA5,0x8F,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x0A,0x00,0x24,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x10,0x00,0x24,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x00,0x1E,0x14,0x00,
+0x03,0x1E,0x03,0x00,
+0x45,0x00,0x60,0x04,
+0x02,0x80,0x05,0x3C,
+0x60,0x1B,0xA5,0x24,
+0xE4,0x1D,0xA6,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xC2,0x24,
+0x00,0x21,0x06,0x00,
+0xFF,0xFF,0x46,0x30,
+0xFF,0xFF,0x84,0x30,
+0x00,0x10,0xC2,0x2C,
+0x0A,0x30,0x02,0x00,
+0x02,0x1A,0x04,0x00,
+0x17,0x00,0x23,0xA2,
+0x16,0x00,0x24,0xA2,
+0xE4,0x1D,0xA6,0xA4,
+0x08,0x00,0x44,0x96,
+0x02,0x80,0x02,0x3C,
+0x12,0x00,0x03,0x24,
+0x25,0x80,0x82,0x00,
+0x14,0x00,0x43,0xAE,
+0x0C,0x00,0x56,0xAE,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x00,0x00,
+0xC6,0x53,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x04,0x00,0x03,0x8E,
+0xFF,0xE0,0x02,0x24,
+0x00,0x00,0x16,0xA6,
+0x24,0x38,0x62,0x00,
+0x20,0x00,0x02,0x24,
+0x02,0x00,0x02,0xA2,
+0xA4,0x00,0x02,0x24,
+0x9E,0xFF,0x82,0x16,
+0x00,0x12,0xE7,0x34,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x07,0xAE,
+0x88,0x37,0x43,0x8C,
+0x14,0x00,0x04,0x8E,
+0xFF,0x81,0x02,0x24,
+0xC2,0x1A,0x03,0x00,
+0x24,0x20,0x82,0x00,
+0x00,0x1E,0x63,0x30,
+0x25,0x20,0x83,0x00,
+0xD2,0x1B,0x00,0x08,
+0x14,0x00,0x04,0xAE,
+0x50,0x00,0xA2,0x36,
+0x00,0x00,0x43,0x8C,
+0x54,0x00,0xA4,0x36,
+0x58,0x00,0xA5,0x36,
+0x10,0x00,0xA3,0xAF,
+0x00,0x00,0x82,0x8C,
+0x5C,0x00,0xA7,0x36,
+0x2A,0x00,0x04,0x26,
+0x14,0x00,0xA2,0xAF,
+0x00,0x00,0xA3,0x8C,
+0x06,0x00,0x06,0x24,
+0x10,0x00,0xA5,0x27,
+0x18,0x00,0xA3,0xAF,
+0x00,0x00,0xE2,0x8C,
+0xCE,0x53,0x00,0x0C,
+0x1C,0x00,0xA2,0xAF,
+0x30,0x00,0x04,0x26,
+0x18,0x00,0xA5,0x27,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x63,0x34,
+0xB5,0x1B,0x00,0x08,
+0x20,0x00,0x03,0xA6,
+0x02,0x80,0x02,0x3C,
+0xFF,0xFF,0xC3,0x33,
+0x60,0x1B,0x42,0x24,
+0x40,0x28,0x1E,0x00,
+0x18,0x00,0x23,0xA2,
+0x21,0x28,0xA2,0x00,
+0x19,0x00,0x20,0xA2,
+0xD4,0x1D,0xA6,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xC2,0x24,
+0x00,0x21,0x06,0x00,
+0xFF,0xFF,0x46,0x30,
+0xFF,0xFF,0x84,0x30,
+0x00,0x10,0xC2,0x2C,
+0x0A,0x30,0x02,0x00,
+0x02,0x1A,0x04,0x00,
+0x17,0x00,0x23,0xA2,
+0x16,0x00,0x24,0xA2,
+0xBB,0x1B,0x00,0x08,
+0xD4,0x1D,0xA6,0xA4,
+0xC8,0x55,0x43,0x94,
+0x02,0x80,0x05,0x3C,
+0x04,0x00,0x24,0x26,
+0x00,0xC0,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x02,0x12,0x03,0x00,
+0xD0,0x55,0xA5,0x24,
+0x03,0x00,0x22,0xA2,
+0x02,0x00,0x23,0xA2,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x0A,0x00,0x24,0x26,
+0x48,0x37,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xBB,0x1B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xD0,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x02,0x80,0x13,0x3C,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x21,0x80,0x00,0x00,
+0x60,0x1B,0x72,0x26,
+0x02,0x80,0x15,0x3C,
+0x0C,0x00,0x14,0x24,
+0x02,0x80,0x11,0x3C,
+0xB0,0x1B,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x43,0x30,
+0x00,0x10,0x44,0x30,
+0x16,0x00,0x60,0x10,
+0x01,0x00,0x42,0x30,
+0x14,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0xA2,0x92,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x02,0x00,0x54,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x04,0x24,
+0x90,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x13,0x57,0x00,0x0C,
+0x30,0xF3,0x24,0x26,
+0x01,0x00,0x02,0x26,
+0xFF,0x00,0x50,0x30,
+0x02,0x00,0x03,0x2E,
+0xE8,0xFF,0x60,0x14,
+0x60,0x1B,0x63,0x26,
+0xB8,0x88,0x02,0x34,
+0x04,0x3A,0x62,0xAC,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x2C,0x00,0xB5,0xAF,
+0x02,0x80,0x15,0x3C,
+0x1C,0x00,0xB1,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x60,0x1B,0xB1,0x26,
+0xB0,0x1B,0x23,0x96,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x62,0x30,
+0x4C,0x00,0x40,0x14,
+0x00,0x01,0x62,0x30,
+0x3F,0x00,0x40,0x10,
+0x00,0x10,0x62,0x30,
+0x82,0x00,0x40,0x14,
+0x01,0x00,0x62,0x30,
+0x5E,0x00,0x40,0x10,
+0x04,0x00,0x62,0x30,
+0x78,0x42,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x60,0x14,
+0x02,0x80,0x02,0x3C,
+0x44,0xE6,0x40,0xAC,
+0xE8,0x1E,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x71,0x00,0x40,0x14,
+0x01,0x00,0x02,0x24,
+0x8A,0x00,0x62,0x14,
+0x02,0x80,0x10,0x3C,
+0x7C,0x42,0x24,0x92,
+0x7D,0x42,0x25,0x92,
+0x44,0xE6,0x03,0x8E,
+0x01,0x00,0x84,0x38,
+0x03,0x00,0x02,0x24,
+0x0B,0x28,0x44,0x00,
+0x2B,0x18,0x65,0x00,
+0x8B,0x00,0x60,0x14,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x4C,0xF3,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x54,0x61,0x44,0x90,
+0xFF,0x00,0x03,0x24,
+0x8E,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x10,0x3C,
+0x03,0x00,0x05,0x24,
+0xD0,0x55,0x04,0x26,
+0xAF,0x4F,0x00,0x0C,
+0x78,0x42,0x20,0xAE,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x22,0x96,
+0x10,0x00,0xA4,0x27,
+0xFE,0xFE,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x22,0xA6,
+0x25,0xB0,0x06,0x3C,
+0x4C,0x00,0xC2,0x34,
+0x00,0x00,0x40,0xA0,
+0x48,0x00,0xC6,0x34,
+0x00,0x00,0xC3,0x8C,
+0x7B,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0xC3,0xAC,
+0x21,0x20,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0xFB,0x3E,0x20,0xA2,
+0x83,0x0F,0x00,0x0C,
+0xD6,0x1E,0x20,0xA2,
+0xD0,0x55,0x04,0x26,
+0x2D,0x10,0x00,0x0C,
+0xFF,0xFF,0x05,0x34,
+0xFD,0x61,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x68,0xF3,0x84,0x24,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0xE8,0x39,0x20,0xAE,
+0xB0,0x1B,0x22,0x96,
+0x10,0x00,0xA4,0x27,
+0xEF,0xDF,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x22,0xA6,
+0xA1,0x48,0x00,0x0C,
+0xFD,0xFF,0x04,0x24,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x21,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x98,0x20,0x02,
+0x47,0x39,0x56,0x24,
+0x01,0x00,0x14,0x24,
+0x20,0x01,0x11,0x24,
+0x2C,0x1D,0x00,0x08,
+0x19,0x00,0x12,0x24,
+0xFF,0xFF,0x52,0x26,
+0x18,0x00,0x40,0x06,
+0x30,0x00,0x31,0x26,
+0x21,0x80,0x33,0x02,
+0xE6,0x1D,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0xF9,0xFF,0x54,0x14,
+0x10,0x00,0xA4,0x27,
+0xF8,0x1D,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x1D,0x00,0x40,0x14,
+0xFF,0xFF,0x05,0x34,
+0xD7,0x43,0x62,0x92,
+0x21,0x20,0x36,0x02,
+0xFF,0xFF,0x42,0x24,
+0xD7,0x43,0x62,0xA2,
+0x2D,0x10,0x00,0x0C,
+0xE6,0x1D,0x00,0xA2,
+0x2A,0x1D,0x00,0x08,
+0xFF,0xFF,0x52,0x26,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x10,0x00,0xA4,0x27,
+0x78,0x42,0x20,0xAE,
+0xA0,0x40,0x00,0x0C,
+0xE8,0x1E,0x20,0xAE,
+0x71,0x23,0x00,0x0C,
+0x60,0x1B,0xB0,0x26,
+0xE8,0x39,0x02,0xAE,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x9A,0x40,0x00,0x0C,
+0xFF,0xFF,0x52,0x26,
+0x10,0x00,0xA4,0x27,
+0xA0,0x40,0x00,0x0C,
+0xF8,0x1D,0x00,0xAE,
+0x2A,0x1D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x9F,0x50,0x00,0x0C,
+0x78,0x42,0x22,0xAE,
+0x02,0x80,0x03,0x3C,
+0x44,0xE6,0x62,0x8C,
+0x60,0x1B,0xB0,0x26,
+0x01,0x00,0x42,0x24,
+0x71,0x23,0x00,0x0C,
+0x44,0xE6,0x62,0xAC,
+0x46,0x1D,0x00,0x08,
+0xE8,0x39,0x02,0xAE,
+0x9F,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x44,0xE6,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x44,0xE6,0x02,0xAE,
+0x71,0x23,0x00,0x0C,
+0x60,0x1B,0xB0,0x26,
+0x46,0x1D,0x00,0x08,
+0xE8,0x39,0x02,0xAE,
+0x4A,0x11,0x00,0x0C,
+0x02,0x80,0x10,0x3C,
+0xE1,0x1C,0x00,0x08,
+0x03,0x00,0x05,0x24,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0xFF,0x0F,0x00,0x0C,
+0x18,0x00,0xB0,0xAF,
+0x30,0x00,0x40,0x10,
+0x02,0x80,0x11,0x3C,
+0x60,0x1B,0x24,0x26,
+0xF7,0x3E,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0xC9,0x40,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x60,0x10,
+0x60,0x1B,0x25,0x26,
+0x02,0x80,0x02,0x3C,
+0x6E,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0xD0,0x3E,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xD2,0x11,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x60,0x1B,0x25,0x26,
+0xF7,0x3E,0xA4,0x90,
+0x00,0x00,0x00,0x00,
+0xC0,0x20,0x04,0x00,
+0x21,0x20,0x85,0x00,
+0xCC,0x40,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x24,
+0xCC,0x40,0x82,0xA0,
+0xF7,0x3E,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0xC0,0x18,0x03,0x00,
+0x21,0x18,0x65,0x00,
+0xCA,0x40,0x64,0x94,
+0x00,0x00,0x00,0x00,
+0x94,0x39,0xA4,0xAC,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD2,0x11,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xD2,0x11,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x8C,0x1D,0x00,0x08,
+0x60,0x1B,0x25,0x26,
+0x60,0x1B,0x30,0x26,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xFF,0xEF,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x09,0x00,0x40,0x10,
+0x25,0xB0,0x05,0x3C,
+0x48,0x00,0xA5,0x34,
+0x00,0x00,0xA3,0x8C,
+0x60,0x1B,0x24,0x8E,
+0x84,0x00,0x02,0x3C,
+0x25,0x18,0x62,0x00,
+0x25,0x00,0x84,0x34,
+0x00,0x00,0xA3,0xAC,
+0x60,0x1B,0x24,0xAE,
+0xFB,0x3E,0x03,0x92,
+0xF5,0x3E,0x06,0x92,
+0xF6,0x3E,0x07,0x92,
+0xF8,0x3E,0x04,0x96,
+0xFA,0x3E,0x05,0x92,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xE0,0x3D,0x06,0xA2,
+0x83,0x0F,0x00,0x0C,
+0xE1,0x3D,0x07,0xA2,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x10,0x00,0x40,0x10,
+0x01,0x00,0x62,0x30,
+0x0E,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x1A,0x64,0x43,0x90,
+0x0C,0x00,0x02,0x24,
+0x0F,0x00,0x63,0x30,
+0x09,0x00,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x90,0x50,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0xD6,0x43,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x4F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xBE,0x0F,0x00,0x0C,
+0x60,0x1B,0x30,0x26,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0xC8,0x3E,0x00,0xAE,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x2A,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x18,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x27,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x1B,0x00,0x40,0x14,
+0x04,0x00,0x04,0x24,
+0x02,0x80,0x03,0x3C,
+0x40,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x14,
+0x60,0x1B,0x30,0x26,
+0x40,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x40,0x64,0x62,0xA0,
+0x60,0x1B,0x30,0x26,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xEE,0x43,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x9D,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x5C,0xE2,0x44,0x90,
+0x6F,0x0E,0x00,0x0C,
+0xE7,0x43,0x00,0xA2,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x9B,0x1D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0xF0,0x1D,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x40,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x01,0x00,0x05,0x24,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0xF9,0x1D,0x00,0x08,
+0x60,0x1B,0x30,0x26,
+0x02,0x80,0x09,0x3C,
+0x60,0x1B,0x28,0x25,
+0x6C,0x37,0x06,0x8D,
+0xFF,0xFF,0x02,0x34,
+0x74,0x00,0xC2,0x10,
+0x21,0x38,0x80,0x00,
+0x2B,0x10,0xC7,0x00,
+0x31,0x00,0x40,0x10,
+0x02,0x19,0x06,0x00,
+0x21,0x10,0xC7,0x00,
+0x23,0x10,0x43,0x00,
+0x10,0x00,0x46,0x24,
+0x6C,0x37,0x06,0xAD,
+0x70,0x37,0x02,0xAD,
+0x60,0x1B,0x26,0x25,
+0x05,0x00,0xC4,0x90,
+0xFF,0xFF,0x02,0x34,
+0xFF,0x00,0x83,0x30,
+0x31,0x00,0x62,0x10,
+0x00,0x11,0x07,0x00,
+0xFF,0x00,0x84,0x30,
+0x2B,0x10,0x87,0x00,
+0x34,0x00,0x40,0x10,
+0x03,0x19,0x04,0x00,
+0x03,0x11,0x04,0x00,
+0x21,0x18,0x87,0x00,
+0x23,0x18,0x62,0x00,
+0xC0,0x10,0x05,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x45,0x00,
+0x10,0x00,0x64,0x24,
+0x70,0x37,0xC3,0xAC,
+0x80,0x10,0x02,0x00,
+0x60,0x1B,0x23,0x25,
+0x21,0x28,0x43,0x00,
+0x05,0x00,0xC4,0xA0,
+0xF8,0x24,0xA6,0x8C,
+0x00,0x21,0x07,0x00,
+0xFF,0xFF,0xC2,0x38,
+0x0A,0x30,0x82,0x00,
+0x2B,0x18,0xC7,0x00,
+0x32,0x00,0x60,0x10,
+0x02,0x19,0x06,0x00,
+0x21,0x10,0xC7,0x00,
+0x23,0x10,0x43,0x00,
+0x10,0x00,0x46,0x24,
+0xF8,0x24,0xA6,0xAC,
+0xFC,0x24,0xA2,0xAC,
+0x60,0x1B,0x26,0x25,
+0x60,0x42,0xC5,0x8C,
+0x00,0x00,0x00,0x00,
+0x32,0x00,0xA0,0x14,
+0xFA,0xFF,0xE2,0x24,
+0x80,0x10,0x07,0x00,
+0x08,0x00,0xE0,0x03,
+0x60,0x42,0xC2,0xAC,
+0x21,0x10,0xC7,0x00,
+0x23,0x10,0x43,0x00,
+0x6C,0x37,0x02,0xAD,
+0x70,0x37,0x02,0xAD,
+0x60,0x1B,0x26,0x25,
+0x05,0x00,0xC4,0x90,
+0xFF,0xFF,0x02,0x34,
+0xFF,0x00,0x83,0x30,
+0xD3,0xFF,0x62,0x14,
+0xFF,0x00,0x84,0x30,
+0x00,0x11,0x07,0x00,
+0x21,0x20,0x40,0x00,
+0xFF,0x00,0x84,0x30,
+0x05,0x00,0xC2,0xA0,
+0x2B,0x10,0x87,0x00,
+0xD0,0xFF,0x40,0x14,
+0x03,0x11,0x04,0x00,
+0x03,0x19,0x04,0x00,
+0x21,0x10,0x87,0x00,
+0x23,0x10,0x43,0x00,
+0x05,0x00,0xC2,0xA0,
+0x70,0x37,0xC2,0xAC,
+0xC0,0x10,0x05,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x10,0x02,0x00,
+0x60,0x1B,0x23,0x25,
+0x21,0x28,0x43,0x00,
+0xF8,0x24,0xA6,0x8C,
+0x00,0x21,0x07,0x00,
+0xFF,0xFF,0xC2,0x38,
+0x0A,0x30,0x82,0x00,
+0x2B,0x18,0xC7,0x00,
+0xD0,0xFF,0x60,0x14,
+0x02,0x19,0x06,0x00,
+0x21,0x10,0xC7,0x00,
+0x23,0x10,0x43,0x00,
+0xF8,0x24,0xA2,0xAC,
+0xFC,0x24,0xA2,0xAC,
+0x60,0x1B,0x26,0x25,
+0x60,0x42,0xC5,0x8C,
+0x00,0x00,0x00,0x00,
+0xD2,0xFF,0xA0,0x10,
+0x80,0x10,0x07,0x00,
+0xFA,0xFF,0xE2,0x24,
+0x0E,0x00,0x42,0x2C,
+0x0B,0x00,0x40,0x10,
+0x21,0x10,0xA7,0x00,
+0x82,0x10,0x05,0x00,
+0x40,0x18,0x07,0x00,
+0x21,0x18,0x67,0x00,
+0x40,0x20,0x02,0x00,
+0x21,0x20,0x82,0x00,
+0x21,0x18,0x65,0x00,
+0x23,0x18,0x64,0x00,
+0x60,0x42,0xC3,0xAC,
+0x08,0x00,0xE0,0x03,
+0x64,0x42,0xC3,0xAC,
+0x82,0x18,0x05,0x00,
+0x23,0x10,0x43,0x00,
+0x60,0x42,0xC2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x64,0x42,0xC2,0xAC,
+0x00,0x31,0x04,0x00,
+0x1C,0x1E,0x00,0x08,
+0x6C,0x37,0x06,0xAD,
+0x63,0x00,0x82,0x24,
+0x77,0x00,0x42,0x2C,
+0x00,0x00,0x85,0x28,
+0x04,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x64,0x00,0x82,0x24,
+0x64,0x00,0x03,0x24,
+0x0B,0x18,0x45,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x0C,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x3F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x08,0x00,0x40,0x14,
+0x25,0xB0,0x02,0x3C,
+0x00,0x00,0xA4,0x8C,
+0x10,0x00,0xBF,0x8F,
+0x18,0x00,0xBD,0x27,
+0x3F,0x00,0x84,0x30,
+0x40,0x20,0x04,0x00,
+0x92,0x1E,0x00,0x08,
+0x96,0xFF,0x84,0x24,
+0x24,0x08,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x02,0x63,0x30,
+0x1B,0x00,0x60,0x14,
+0x01,0x00,0x02,0x24,
+0x05,0x00,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x82,0x31,0x03,0x00,
+0x3C,0x00,0xC2,0x10,
+0x02,0x00,0xC2,0x28,
+0x57,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x46,0x00,0xC2,0x10,
+0x03,0x00,0x02,0x24,
+0x2E,0x00,0xC2,0x10,
+0x3E,0x00,0x63,0x30,
+0x92,0x1E,0x00,0x0C,
+0x21,0x20,0xE0,0x00,
+0x06,0x00,0x45,0x24,
+0x65,0x00,0xA4,0x2C,
+0x64,0x00,0x03,0x24,
+0x0A,0x28,0x64,0x00,
+0xDD,0xFF,0xA2,0x24,
+0x08,0x00,0x42,0x2C,
+0x1F,0x00,0x40,0x10,
+0xE5,0xFF,0xA2,0x24,
+0xFE,0xFF,0xA5,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x05,0x00,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x60,0x00,0x66,0x30,
+0x42,0x31,0x06,0x00,
+0x25,0x00,0xC2,0x10,
+0x02,0x00,0xC2,0x28,
+0x36,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x2F,0x00,0xC2,0x10,
+0x03,0x00,0x02,0x24,
+0xE6,0xFF,0xC2,0x14,
+0x1F,0x00,0x62,0x30,
+0x40,0x10,0x02,0x00,
+0xD8,0xFF,0x03,0x24,
+0x23,0x38,0x62,0x00,
+0x92,0x1E,0x00,0x0C,
+0x21,0x20,0xE0,0x00,
+0x06,0x00,0x45,0x24,
+0x65,0x00,0xA4,0x2C,
+0x64,0x00,0x03,0x24,
+0x0A,0x28,0x64,0x00,
+0xDD,0xFF,0xA2,0x24,
+0x08,0x00,0x42,0x2C,
+0xE3,0xFF,0x40,0x14,
+0xE5,0xFF,0xA2,0x24,
+0x08,0x00,0x42,0x2C,
+0x06,0x00,0x40,0x10,
+0xF1,0xFF,0xA2,0x24,
+0xC7,0x1E,0x00,0x08,
+0xFA,0xFF,0xA5,0x24,
+0xD8,0xFF,0x02,0x24,
+0xBC,0x1E,0x00,0x08,
+0x23,0x38,0x43,0x00,
+0x0C,0x00,0x42,0x2C,
+0x0C,0x00,0x40,0x10,
+0xFB,0xFF,0xA2,0x24,
+0xC7,0x1E,0x00,0x08,
+0xF8,0xFF,0xA5,0x24,
+0x3E,0x00,0x63,0x30,
+0xFE,0xFF,0x02,0x24,
+0xBC,0x1E,0x00,0x08,
+0x23,0x38,0x43,0x00,
+0x1F,0x00,0x62,0x30,
+0x40,0x10,0x02,0x00,
+0xFE,0xFF,0x03,0x24,
+0xDA,0x1E,0x00,0x08,
+0x23,0x38,0x62,0x00,
+0x0A,0x00,0x42,0x2C,
+0xCB,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xC7,0x1E,0x00,0x08,
+0xFC,0xFF,0xA5,0x24,
+0x3E,0x00,0x63,0x30,
+0xEC,0xFF,0x02,0x24,
+0xBC,0x1E,0x00,0x08,
+0x23,0x38,0x43,0x00,
+0x1F,0x00,0x62,0x30,
+0x40,0x10,0x02,0x00,
+0xEC,0xFF,0x03,0x24,
+0xDA,0x1E,0x00,0x08,
+0x23,0x38,0x62,0x00,
+0xB3,0xFF,0xC0,0x14,
+0x1F,0x00,0x62,0x30,
+0x40,0x10,0x02,0x00,
+0x0E,0x00,0x03,0x24,
+0xDA,0x1E,0x00,0x08,
+0x23,0x38,0x62,0x00,
+0xAD,0xFF,0xC0,0x14,
+0x3E,0x00,0x63,0x30,
+0x0E,0x00,0x02,0x24,
+0xBC,0x1E,0x00,0x08,
+0x23,0x38,0x43,0x00,
+0x98,0xFF,0xBD,0x27,
+0x60,0x00,0xBE,0xAF,
+0x64,0x00,0xBF,0xAF,
+0x5C,0x00,0xB7,0xAF,
+0x58,0x00,0xB6,0xAF,
+0x54,0x00,0xB5,0xAF,
+0x50,0x00,0xB4,0xAF,
+0x4C,0x00,0xB3,0xAF,
+0x48,0x00,0xB2,0xAF,
+0x44,0x00,0xB1,0xAF,
+0x40,0x00,0xB0,0xAF,
+0x02,0x80,0x1E,0x3C,
+0x02,0x80,0x02,0x3C,
+0x88,0x54,0x45,0x8C,
+0x00,0x80,0x04,0x3C,
+0x4C,0x7C,0x83,0x24,
+0x88,0x54,0x44,0x24,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x75,0x00,0xA4,0x10,
+0x02,0x80,0x02,0x3C,
+0x88,0xF3,0x42,0x24,
+0x00,0x00,0x57,0x8C,
+0x00,0x00,0x00,0x00,
+0x28,0x39,0xF5,0x8E,
+0x02,0x80,0x02,0x3C,
+0x21,0xB0,0x00,0x00,
+0x08,0x00,0xA3,0x96,
+0x53,0x1F,0x00,0x08,
+0x25,0xA0,0x62,0x00,
+0x17,0x00,0x25,0x92,
+0x16,0x00,0x26,0x92,
+0xE4,0x3D,0xE2,0x96,
+0xFF,0x00,0xA3,0x30,
+0x00,0x1A,0x03,0x00,
+0xFF,0x00,0xC4,0x30,
+0x25,0x18,0x64,0x00,
+0x14,0x00,0x43,0x10,
+0xFF,0x00,0xA2,0x30,
+0xFF,0x00,0xC3,0x30,
+0x00,0x12,0x02,0x00,
+0x25,0x10,0x43,0x00,
+0xE4,0x3D,0xE2,0xA6,
+0x01,0x00,0x24,0x92,
+0x18,0x00,0x42,0x92,
+0x00,0x22,0x04,0x00,
+0x90,0x0E,0x00,0x0C,
+0x25,0x20,0x82,0x00,
+0x40,0x18,0x02,0x00,
+0x21,0x18,0x62,0x00,
+0x02,0x80,0x04,0x3C,
+0x88,0xE3,0x82,0x24,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x08,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x40,0x00,
+0x21,0x20,0x60,0x02,
+0x0C,0x00,0xA2,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xC2,0x02,
+0x3A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x82,0x8E,
+0x02,0x80,0x03,0x3C,
+0x48,0x37,0x64,0x24,
+0x42,0x1B,0x02,0x00,
+0x78,0x00,0x63,0x30,
+0x02,0x2E,0x02,0x00,
+0xFF,0x3F,0x42,0x30,
+0x21,0x10,0x43,0x00,
+0x03,0x00,0xA5,0x30,
+0x21,0x10,0x45,0x00,
+0x18,0x00,0x42,0x24,
+0xFF,0xFF,0x51,0x30,
+0x7F,0x00,0x22,0x32,
+0x21,0x98,0x80,0x02,
+0x06,0x00,0x06,0x24,
+0x80,0x00,0x23,0x26,
+0x02,0x00,0x40,0x10,
+0x80,0xFF,0x25,0x32,
+0x80,0xFF,0x65,0x30,
+0x00,0x00,0x63,0x8E,
+0x21,0x88,0xA0,0x00,
+0x21,0x38,0xC5,0x02,
+0x42,0x13,0x03,0x00,
+0x78,0x00,0x42,0x30,
+0x02,0x1E,0x03,0x00,
+0x21,0x10,0x53,0x00,
+0x03,0x00,0x63,0x30,
+0x21,0x90,0x43,0x00,
+0x1C,0x00,0x50,0x26,
+0x21,0x28,0x00,0x02,
+0xF7,0x53,0x00,0x0C,
+0xFF,0xFF,0xF6,0x30,
+0x21,0xA0,0x91,0x02,
+0x21,0x28,0x00,0x02,
+0x18,0x00,0x51,0x26,
+0x06,0x00,0x06,0x24,
+0x0B,0x00,0x40,0x14,
+0x80,0xE3,0xC4,0x27,
+0x01,0x00,0x22,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x12,0x02,0x00,
+0x00,0x08,0x42,0x30,
+0xB4,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x16,0x00,0x26,0x92,
+0x17,0x00,0x25,0x92,
+0x3B,0x1F,0x00,0x08,
+0xFF,0x00,0xA2,0x30,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0xA2,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xC2,0x02,
+0xC8,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x38,0x00,0xA4,0x27,
+0x04,0x00,0xA3,0x8E,
+0x00,0x00,0xA2,0x8E,
+0x21,0x20,0xA0,0x02,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0xB5,0xAE,
+0x14,0x28,0x00,0x0C,
+0x04,0x00,0xB5,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x38,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x88,0x54,0x43,0x8C,
+0x88,0x54,0x42,0x24,
+0x90,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x88,0xF3,0x63,0x24,
+0x00,0x00,0x71,0x8C,
+0x25,0xB0,0x10,0x3C,
+0x04,0x01,0x02,0x36,
+0x00,0x00,0x43,0x8C,
+0xDC,0x38,0x27,0x8E,
+0x00,0x00,0x00,0x00,
+0x76,0x00,0xE3,0x10,
+0xE0,0x38,0x23,0xAE,
+0x2B,0x10,0x67,0x00,
+0x80,0x00,0x40,0x14,
+0x2B,0x10,0xE3,0x00,
+0xA8,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0xB0,0x38,0x83,0x94,
+0x02,0x80,0x02,0x3C,
+0x21,0x88,0x00,0x00,
+0x33,0x00,0xC0,0x1A,
+0x25,0x90,0x62,0x00,
+0x21,0x80,0x80,0x00,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x14,0x24,
+0xBB,0x1F,0x00,0x08,
+0x00,0xC0,0x17,0x3C,
+0x80,0x18,0x11,0x00,
+0x2A,0x10,0x76,0x00,
+0x2A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x98,0x72,0x00,
+0x00,0x00,0x62,0x8E,
+0xE0,0x43,0x03,0x8E,
+0x38,0x00,0xA4,0x27,
+0xFF,0x3F,0x42,0x30,
+0x21,0x18,0x62,0x00,
+0x9A,0x40,0x00,0x0C,
+0xE0,0x43,0x03,0xAE,
+0xE8,0x1E,0x02,0x8E,
+0xF0,0x1E,0x03,0x8E,
+0x38,0x00,0xA4,0x27,
+0x01,0x00,0x42,0x24,
+0x01,0x00,0x63,0x24,
+0xE8,0x1E,0x02,0xAE,
+0xA0,0x40,0x00,0x0C,
+0xF0,0x1E,0x03,0xAE,
+0xD6,0x60,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x00,0x00,0x63,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x60,0x14,
+0x06,0x00,0x22,0x26,
+0x01,0x00,0x22,0x26,
+0xFF,0xFF,0x51,0x30,
+0x82,0x16,0x03,0x00,
+0x01,0x00,0x42,0x30,
+0xE1,0xFF,0x54,0x14,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x42,0x11,0x02,0x00,
+0x01,0x00,0x42,0x30,
+0x0C,0x00,0x54,0x10,
+0xC2,0x13,0x03,0x00,
+0x1E,0x00,0x42,0x30,
+0x21,0x10,0x51,0x00,
+0xFF,0xFF,0x51,0x30,
+0x80,0x18,0x11,0x00,
+0x2A,0x10,0x76,0x00,
+0xD8,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x14,0x28,0x00,0x0C,
+0x21,0x20,0xA0,0x02,
+0x22,0x20,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x63,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x14,0x03,0x00,
+0x0F,0x00,0x42,0x30,
+0x11,0x00,0x40,0x14,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x44,0x30,
+0x07,0x00,0x80,0x10,
+0x24,0x10,0x77,0x00,
+0x0C,0x00,0x40,0x14,
+0x03,0x00,0x02,0x24,
+0x0A,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x80,0x28,0x11,0x00,
+0x21,0x28,0xB2,0x00,
+0x9C,0x1E,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x21,0x20,0x40,0x00,
+0x16,0x1E,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x7B,0x00,0x54,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x92,
+0x02,0x00,0x02,0x24,
+0x63,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x63,0x30,
+0x08,0x00,0x74,0x10,
+0xD0,0x02,0x02,0x24,
+0x00,0x00,0x63,0x8E,
+0x00,0x00,0x00,0x00,
+0xC2,0x13,0x03,0x00,
+0x1E,0x00,0x42,0x30,
+0x21,0x10,0x51,0x00,
+0xE0,0x1F,0x00,0x08,
+0xFF,0xFF,0x51,0x30,
+0x6C,0x37,0x02,0xAE,
+0x00,0x00,0x63,0x8E,
+0x14,0x20,0x00,0x08,
+0xC2,0x13,0x03,0x00,
+0x02,0x80,0x04,0x3C,
+0x00,0x01,0x02,0x36,
+0x60,0x1B,0x84,0x24,
+0x00,0x00,0x47,0xAC,
+0xDC,0x38,0x87,0xAC,
+0x02,0x80,0x02,0x3C,
+0x08,0x04,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x1B,0x3E,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x20,0x1F,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0xE4,0x38,0x22,0x8E,
+0xFF,0xFF,0x73,0x30,
+0x23,0x10,0x47,0x00,
+0xFF,0xFF,0x52,0x30,
+0x21,0x18,0x53,0x02,
+0xFF,0xFF,0x76,0x30,
+0xF3,0x27,0x00,0x0C,
+0x21,0x20,0xC0,0x02,
+0xEF,0xFF,0x40,0x10,
+0x21,0xA8,0x40,0x00,
+0x08,0x00,0x42,0x8C,
+0xDC,0x38,0x26,0x8E,
+0x21,0x38,0x40,0x02,
+0x21,0x18,0x56,0x00,
+0xAC,0x38,0x23,0xAE,
+0x21,0x28,0x40,0x00,
+0x08,0x00,0x04,0x24,
+0xB0,0x38,0x22,0xAE,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x52,0x01,0x00,0x0C,
+0x08,0x00,0x04,0x24,
+0xB0,0x38,0x25,0x8E,
+0x24,0x10,0x02,0x3C,
+0x00,0x01,0x10,0x36,
+0x00,0x00,0x02,0xAE,
+0x21,0x38,0x60,0x02,
+0x21,0x28,0xB2,0x00,
+0x08,0x00,0x04,0x24,
+0x24,0x10,0x06,0x3C,
+0xDC,0x38,0x22,0xAE,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xE0,0x38,0x23,0x8E,
+0x08,0x00,0x04,0x24,
+0x52,0x01,0x00,0x0C,
+0xDC,0x38,0x23,0xAE,
+0xDC,0x38,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x02,0xAE,
+0xAC,0x1F,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x23,0x10,0x67,0x00,
+0xFF,0xFF,0x56,0x30,
+0xF3,0x27,0x00,0x0C,
+0x21,0x20,0xC0,0x02,
+0x45,0x00,0x40,0x10,
+0x21,0xA8,0x40,0x00,
+0x08,0x00,0x42,0x8C,
+0xDC,0x38,0x26,0x8E,
+0x08,0x00,0x04,0x24,
+0x21,0x18,0x56,0x00,
+0xAC,0x38,0x23,0xAE,
+0x21,0x28,0x40,0x00,
+0x21,0x38,0xC0,0x02,
+0xB0,0x38,0x22,0xAE,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xE0,0x38,0x23,0x8E,
+0x08,0x00,0x04,0x24,
+0x52,0x01,0x00,0x0C,
+0xDC,0x38,0x23,0xAE,
+0xDC,0x38,0x23,0x8E,
+0x00,0x01,0x02,0x36,
+0x00,0x00,0x43,0xAC,
+0xAC,0x1F,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x63,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x14,0x03,0x00,
+0x0F,0x00,0x42,0x30,
+0x08,0x00,0x42,0x28,
+0x99,0xFF,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x42,0x30,
+0x94,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x80,0x28,0x11,0x00,
+0x21,0x28,0xB2,0x00,
+0x9C,0x1E,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x21,0x20,0x40,0x00,
+0x16,0x1E,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x0B,0x20,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x04,0x00,0x63,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x14,0x03,0x00,
+0x0F,0x00,0x42,0x30,
+0x08,0x00,0x42,0x28,
+0x06,0x00,0x40,0x10,
+0x24,0x10,0x77,0x00,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x42,0x30,
+0x0B,0x00,0x40,0x10,
+0x80,0x28,0x11,0x00,
+0x24,0x10,0x77,0x00,
+0x79,0xFF,0x40,0x14,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x42,0x30,
+0x03,0x00,0x03,0x24,
+0x75,0xFF,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x73,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x80,0x28,0x11,0x00,
+0x21,0x28,0xB2,0x00,
+0x9C,0x1E,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x21,0x20,0x40,0x00,
+0x16,0x1E,0x00,0x0C,
+0x05,0x00,0x05,0x24,
+0x06,0x20,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0x38,0x23,0x8E,
+0x00,0x01,0x02,0x36,
+0x00,0x00,0x43,0xAC,
+0x21,0x20,0x00,0x08,
+0xDC,0x38,0x23,0xAE,
+0xB8,0xFF,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x44,0x00,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x0E,0x00,0x40,0x04,
+0x1C,0x00,0xA0,0xAF,
+0x21,0x20,0x60,0x00,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0x64,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0xF6,0xFF,0x41,0x04,
+0x21,0x10,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x98,0x54,0x62,0x8C,
+0x01,0x80,0x05,0x3C,
+0x88,0x82,0xA4,0x24,
+0x25,0xB0,0x03,0x3C,
+0x02,0x80,0x05,0x3C,
+0x18,0x03,0x63,0x34,
+0x98,0x54,0xB3,0x24,
+0x00,0x00,0x64,0xAC,
+0x55,0x00,0x53,0x10,
+0x01,0x00,0x15,0x24,
+0x2A,0xB0,0x02,0x3C,
+0x05,0x00,0x52,0x34,
+0x02,0x80,0x02,0x3C,
+0xA0,0xF3,0x42,0x24,
+0x00,0x00,0x5E,0x8C,
+0x21,0xB8,0x60,0x00,
+0x01,0x00,0x14,0x24,
+0x02,0x00,0x16,0x24,
+0x11,0x11,0x03,0x3C,
+0x22,0x22,0x63,0x34,
+0x00,0x00,0xE3,0xAE,
+0x05,0x00,0xA0,0x12,
+0x02,0x80,0x04,0x3C,
+0x18,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x65,0x00,0x40,0x14,
+0x21,0xA8,0x00,0x00,
+0x00,0x00,0xC3,0x97,
+0x02,0x80,0x05,0x3C,
+0x60,0x1B,0xA2,0x24,
+0x38,0x39,0x50,0x8C,
+0xFF,0xFF,0x62,0x30,
+0xFF,0x00,0x51,0x30,
+0x02,0x12,0x02,0x00,
+0x2B,0x10,0x51,0x00,
+0x4D,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x0E,0x00,0x20,0x12,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xA4,0xF3,0x63,0x24,
+0xA8,0xF3,0x42,0x24,
+0x00,0x00,0x65,0x8C,
+0x00,0x00,0x44,0x8C,
+0x02,0x80,0x02,0x3C,
+0xA0,0xF3,0x42,0x24,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0xA4,0xAC,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x62,0x30,
+0x37,0x00,0x40,0x14,
+0x08,0x00,0x62,0x24,
+0xC2,0x10,0x03,0x00,
+0xC0,0x10,0x02,0x00,
+0x20,0x00,0x42,0x24,
+0x18,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0xFF,0xFF,0x51,0x30,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x08,0x00,0x05,0x8E,
+0x21,0x38,0x20,0x02,
+0x32,0x10,0x06,0x3C,
+0x01,0x00,0x04,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xB4,0xAF,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x18,0x00,0xA4,0x27,
+0x00,0x00,0x54,0xA2,
+0x00,0x00,0x56,0xA2,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x00,0x00,0x02,0x8E,
+0x04,0x00,0x03,0x8E,
+0x21,0x20,0x00,0x02,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0x10,0xAE,
+0x14,0x28,0x00,0x0C,
+0x04,0x00,0x10,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x00,0x00,0x62,0x8E,
+0x00,0x00,0x00,0x00,
+0xB6,0xFF,0x53,0x14,
+0x11,0x11,0x03,0x3C,
+0x1C,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x18,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x37,0x00,0x40,0x14,
+0x1C,0x00,0xA0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x08,0x08,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x1B,0x3E,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0xC3,0x20,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0xFD,0x20,0x00,0x08,
+0xC2,0x10,0x02,0x00,
+0x48,0xE6,0x43,0x94,
+0x01,0x00,0x02,0x24,
+0x00,0x00,0x42,0xA2,
+0x01,0x00,0x63,0x24,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x8C,0xF3,0xA4,0x24,
+0x48,0xE6,0x43,0xA4,
+0xFF,0xFF,0x65,0x30,
+0x00,0x00,0x56,0xA2,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE8,0x20,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x1A,0x64,0xA2,0x90,
+0x01,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x11,0x00,0x40,0x14,
+0x1C,0x00,0xA3,0xAF,
+0x02,0x80,0x04,0x3C,
+0x5E,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xDE,0x20,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x12,0x34,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xDE,0x20,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x04,0x24,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x4C,0x21,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x19,0x64,0xA4,0x90,
+0x01,0x00,0x05,0x24,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2B,0x21,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xE0,0x18,
+0x21,0x18,0x00,0x00,
+0x00,0x00,0xC0,0xAC,
+0x21,0x40,0x00,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x45,0x10,
+0x21,0x18,0x80,0x00,
+0x01,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x48,0x00,
+0x02,0x00,0x68,0x24,
+0x21,0x10,0x82,0x00,
+0x2B,0x18,0x07,0x01,
+0xF5,0xFF,0x60,0x14,
+0x02,0x00,0x44,0x24,
+0x21,0x18,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x01,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x13,0x00,0xA0,0x18,
+0x21,0x30,0x00,0x00,
+0x02,0x00,0x0A,0x24,
+0x04,0x00,0x09,0x24,
+0x0B,0x00,0x08,0x24,
+0x16,0x00,0x07,0x24,
+0x21,0x10,0x86,0x00,
+0x00,0x00,0x43,0x90,
+0x01,0x00,0xC6,0x24,
+0x7F,0x00,0x63,0x30,
+0x0B,0x00,0x6A,0x10,
+0x2A,0x10,0xC5,0x00,
+0x09,0x00,0x69,0x10,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x68,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x67,0x10,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x13,0x00,0xA0,0x18,
+0x21,0x30,0x00,0x00,
+0x02,0x00,0x07,0x24,
+0x04,0x00,0x08,0x24,
+0x0B,0x00,0x09,0x24,
+0x16,0x00,0x0A,0x24,
+0x21,0x10,0x86,0x00,
+0x00,0x00,0x43,0x90,
+0x01,0x00,0xC6,0x24,
+0x7F,0x00,0x63,0x30,
+0x07,0x00,0x67,0x10,
+0x2A,0x10,0xC5,0x00,
+0x05,0x00,0x68,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x69,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x6A,0x14,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x02,0x80,0x02,0x3C,
+0xD0,0x5E,0x43,0x8C,
+0x08,0x00,0x10,0x24,
+0x21,0x90,0xA0,0x00,
+0x0A,0x80,0x03,0x00,
+0x0D,0x00,0xA0,0x14,
+0x21,0x88,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0xA4,0xF5,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x90,0xF5,0xA5,0x24,
+0x21,0x10,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x9B,0x21,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x21,0x20,0x20,0x02,
+0x0F,0x00,0x43,0x10,
+0x21,0x28,0x40,0x02,
+0x83,0x21,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x03,0x36,
+0x01,0x00,0x42,0x38,
+0x02,0x00,0x04,0x36,
+0x21,0x80,0x60,0x00,
+0x0B,0x80,0x82,0x00,
+0x21,0x10,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x01,0x00,0x10,0x36,
+0x21,0x10,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x07,0x3C,
+0x60,0x1B,0xE5,0x24,
+0x42,0x43,0xA3,0x90,
+0xFF,0x00,0x84,0x30,
+0x80,0x10,0x04,0x00,
+0x0C,0x00,0x60,0x14,
+0x21,0x30,0x45,0x00,
+0xC8,0x00,0x02,0x24,
+0x3C,0x3A,0xA2,0xAC,
+0x01,0x00,0x03,0x24,
+0x60,0x1B,0xE2,0x24,
+0x04,0x18,0x83,0x00,
+0x6C,0x43,0xA4,0xA0,
+0x42,0x43,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x64,0x00,
+0x08,0x00,0xE0,0x03,
+0x42,0x43,0x43,0xA0,
+0x3C,0x3A,0xA3,0x8C,
+0xC8,0x00,0x02,0x24,
+0x23,0x10,0x43,0x00,
+0x44,0x43,0xC2,0xAC,
+0x01,0x00,0x03,0x24,
+0x60,0x1B,0xE2,0x24,
+0x04,0x18,0x83,0x00,
+0x42,0x43,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x64,0x00,
+0x08,0x00,0xE0,0x03,
+0x42,0x43,0x43,0xA0,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x60,0x1B,0x25,0x26,
+0x6C,0x43,0xA6,0x90,
+0x01,0x00,0x02,0x24,
+0x04,0x10,0xC2,0x00,
+0x06,0x00,0x40,0x14,
+0xC9,0x00,0x10,0x24,
+0x3A,0x43,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x23,0x00,0x40,0x14,
+0x21,0x20,0xC5,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x46,0x24,
+0x21,0x20,0x00,0x00,
+0x44,0x43,0xC5,0x24,
+0x00,0x00,0xA2,0x8C,
+0x04,0x00,0xA5,0x24,
+0x05,0x00,0x40,0x10,
+0x2B,0x18,0x50,0x00,
+0x03,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x40,0x00,
+0x6C,0x43,0xC4,0xA0,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0x82,0x2C,
+0xF5,0xFF,0x40,0x14,
+0xC9,0x00,0x02,0x24,
+0x21,0x00,0x02,0x12,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x45,0x24,
+0x07,0x00,0x04,0x24,
+0x44,0x43,0xA2,0x8C,
+0xFF,0xFF,0x84,0x24,
+0x02,0x00,0x40,0x10,
+0x23,0x18,0x50,0x00,
+0x44,0x43,0xA3,0xAC,
+0xFA,0xFF,0x81,0x04,
+0x04,0x00,0xA5,0x24,
+0x60,0x1B,0x22,0x26,
+0x3C,0x3A,0x50,0xAC,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x64,0x43,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x63,0x24,
+0xFF,0x00,0x62,0x30,
+0x03,0x00,0x42,0x2C,
+0xD8,0xFF,0x40,0x10,
+0x64,0x43,0x83,0xA0,
+0x80,0x18,0x06,0x00,
+0x21,0x18,0x65,0x00,
+0xC8,0x00,0x02,0x24,
+0x03,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x4B,0x17,0x00,0x0C,
+0x44,0x43,0x62,0xAC,
+0x16,0x22,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x22,0x26,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x20,0x00,0xBD,0x27,
+0x42,0x43,0x40,0xA0,
+0x08,0x00,0xE0,0x03,
+0x3C,0x3A,0x40,0xAC,
+0xA0,0xFF,0xBD,0x27,
+0x3C,0x00,0xB1,0xAF,
+0x38,0x00,0xB0,0xAF,
+0x02,0x80,0x0C,0x3C,
+0x02,0x80,0x0D,0x3C,
+0x02,0x80,0x0F,0x3C,
+0x02,0x80,0x10,0x3C,
+0x02,0x80,0x11,0x3C,
+0x58,0x00,0xBF,0xAF,
+0x54,0x00,0xB7,0xAF,
+0x50,0x00,0xB6,0xAF,
+0x4C,0x00,0xB5,0xAF,
+0x48,0x00,0xB4,0xAF,
+0x44,0x00,0xB3,0xAF,
+0x40,0x00,0xB2,0xAF,
+0xBC,0xF5,0x82,0x25,
+0xC0,0xF5,0xA3,0x25,
+0xC4,0xF5,0xE4,0x25,
+0xC8,0xF5,0x05,0x26,
+0xCC,0xF5,0x26,0x26,
+0x01,0x00,0x47,0x90,
+0x01,0x00,0x68,0x90,
+0x01,0x00,0x89,0x90,
+0x01,0x00,0xAA,0x90,
+0x01,0x00,0xCB,0x90,
+0xBC,0xF5,0x98,0x91,
+0x02,0x00,0x53,0x90,
+0xC0,0xF5,0xB7,0x91,
+0x02,0x00,0x72,0x90,
+0xC4,0xF5,0xF6,0x91,
+0x02,0x00,0x8E,0x90,
+0xC8,0xF5,0x15,0x92,
+0x02,0x00,0xAD,0x90,
+0xCC,0xF5,0x34,0x92,
+0x02,0x00,0xCC,0x90,
+0x03,0x00,0x4F,0x90,
+0x03,0x00,0x70,0x90,
+0x03,0x00,0x82,0x90,
+0x03,0x00,0xA3,0x90,
+0x03,0x00,0xD1,0x90,
+0x00,0x3A,0x07,0x00,
+0x00,0x42,0x08,0x00,
+0x00,0x4A,0x09,0x00,
+0x00,0x52,0x0A,0x00,
+0x00,0x5A,0x0B,0x00,
+0x25,0x38,0xF8,0x00,
+0x25,0x40,0x17,0x01,
+0x25,0x48,0x36,0x01,
+0x25,0x50,0x55,0x01,
+0x25,0x58,0x74,0x01,
+0x00,0x9C,0x13,0x00,
+0x00,0x94,0x12,0x00,
+0x00,0x74,0x0E,0x00,
+0x00,0x6C,0x0D,0x00,
+0x00,0x64,0x0C,0x00,
+0x25,0x98,0x67,0x02,
+0x25,0x90,0x48,0x02,
+0x25,0x70,0xC9,0x01,
+0x25,0x68,0xAA,0x01,
+0x25,0x60,0x8B,0x01,
+0x00,0x7E,0x0F,0x00,
+0x00,0x86,0x10,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x00,0x8E,0x11,0x00,
+0x02,0x80,0x04,0x3C,
+0x25,0x18,0x6D,0x00,
+0x25,0x78,0xF3,0x01,
+0x25,0x10,0x4E,0x00,
+0x25,0x88,0x2C,0x02,
+0x25,0x80,0x12,0x02,
+0xCC,0x55,0x84,0x24,
+0x28,0x00,0xA3,0xAF,
+0x10,0x00,0xAF,0xAF,
+0x20,0x00,0xA2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x18,0x51,0x00,0x0C,
+0x30,0x00,0xB1,0xAF,
+0x10,0x00,0x42,0x30,
+0x30,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x14,0x3C,
+0x60,0x1B,0x83,0x26,
+0xDC,0x3A,0x62,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x35,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x40,0x56,0x52,0x24,
+0x4A,0x56,0x73,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x42,0x56,0x55,0x24,
+0xBC,0x22,0x00,0x08,
+0x4E,0x56,0x76,0x24,
+0xDD,0x00,0x02,0x24,
+0x21,0x20,0x35,0x02,
+0x36,0x00,0x62,0x10,
+0x10,0x00,0xA5,0x27,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x43,0x90,
+0x60,0x1B,0x84,0x26,
+0xDC,0x3A,0x82,0x8C,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x71,0x24,
+0x2B,0x10,0x22,0x02,
+0x20,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x32,0x02,
+0x00,0x00,0x43,0x90,
+0x21,0x80,0x33,0x02,
+0x30,0x00,0x02,0x24,
+0x21,0x20,0x00,0x02,
+0x28,0x00,0xA5,0x27,
+0xEC,0xFF,0x62,0x14,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x02,
+0x30,0x00,0xA5,0x27,
+0x05,0x00,0x40,0x10,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE7,0xFF,0x40,0x14,
+0x21,0x10,0x32,0x02,
+0x21,0x18,0x00,0x00,
+0x58,0x00,0xBF,0x8F,
+0x54,0x00,0xB7,0x8F,
+0x50,0x00,0xB6,0x8F,
+0x4C,0x00,0xB5,0x8F,
+0x48,0x00,0xB4,0x8F,
+0x44,0x00,0xB3,0x8F,
+0x40,0x00,0xB2,0x8F,
+0x3C,0x00,0xB1,0x8F,
+0x38,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x60,0x00,0xBD,0x27,
+0x58,0x00,0xBF,0x8F,
+0x54,0x00,0xB7,0x8F,
+0x50,0x00,0xB6,0x8F,
+0x4C,0x00,0xB5,0x8F,
+0x48,0x00,0xB4,0x8F,
+0x44,0x00,0xB3,0x8F,
+0x40,0x00,0xB2,0x8F,
+0x3C,0x00,0xB1,0x8F,
+0x38,0x00,0xB0,0x8F,
+0x01,0x00,0x03,0x24,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x60,0x00,0xBD,0x27,
+0xF7,0x53,0x00,0x0C,
+0x21,0x80,0x36,0x02,
+0x21,0x20,0x00,0x02,
+0x18,0x00,0xA5,0x27,
+0xC6,0xFF,0x40,0x14,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x02,
+0xC8,0x22,0x00,0x08,
+0x20,0x00,0xA5,0x27,
+0xB8,0xFF,0xBD,0x27,
+0x02,0x80,0x08,0x3C,
+0x02,0x80,0x0B,0x3C,
+0x02,0x80,0x0C,0x3C,
+0x40,0x00,0xBF,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0x38,0x00,0xB4,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0xC0,0xF5,0x63,0x25,
+0xBC,0xF5,0x02,0x25,
+0xC8,0xF5,0x84,0x25,
+0x01,0x00,0x45,0x90,
+0x01,0x00,0x66,0x90,
+0x01,0x00,0x87,0x90,
+0xBC,0xF5,0x0F,0x91,
+0x02,0x00,0x4A,0x90,
+0xC0,0xF5,0x6E,0x91,
+0x02,0x00,0x69,0x90,
+0xC8,0xF5,0x8D,0x91,
+0x02,0x00,0x88,0x90,
+0x03,0x00,0x4B,0x90,
+0x03,0x00,0x6C,0x90,
+0x03,0x00,0x82,0x90,
+0x00,0x2A,0x05,0x00,
+0x00,0x32,0x06,0x00,
+0x00,0x3A,0x07,0x00,
+0x25,0x28,0xAF,0x00,
+0x25,0x30,0xCE,0x00,
+0x25,0x38,0xED,0x00,
+0x00,0x54,0x0A,0x00,
+0x00,0x4C,0x09,0x00,
+0x00,0x44,0x08,0x00,
+0x25,0x50,0x45,0x01,
+0x25,0x48,0x26,0x01,
+0x25,0x40,0x07,0x01,
+0x00,0x5E,0x0B,0x00,
+0x00,0x66,0x0C,0x00,
+0x00,0x16,0x02,0x00,
+0x02,0x80,0x04,0x3C,
+0x25,0x58,0x6A,0x01,
+0x25,0x60,0x89,0x01,
+0x25,0x10,0x48,0x00,
+0xCC,0x55,0x84,0x24,
+0x10,0x00,0xAB,0xAF,
+0x18,0x00,0xAC,0xAF,
+0x18,0x51,0x00,0x0C,
+0x20,0x00,0xA2,0xAF,
+0x10,0x00,0x42,0x30,
+0x29,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x13,0x3C,
+0x60,0x1B,0x63,0x26,
+0xDC,0x3A,0x62,0x8C,
+0x0C,0x00,0x10,0x24,
+0x2B,0x10,0x02,0x02,
+0x2C,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x40,0x56,0x51,0x24,
+0x4A,0x56,0x72,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x42,0x56,0x54,0x24,
+0x44,0x23,0x00,0x08,
+0x4E,0x56,0x75,0x24,
+0xDD,0x00,0x02,0x24,
+0x21,0x20,0x14,0x02,
+0x2B,0x00,0x62,0x10,
+0x10,0x00,0xA5,0x27,
+0x21,0x10,0x11,0x02,
+0x01,0x00,0x43,0x90,
+0x60,0x1B,0x64,0x26,
+0xDC,0x3A,0x82,0x8C,
+0x21,0x18,0x70,0x00,
+0x02,0x00,0x70,0x24,
+0x2B,0x10,0x02,0x02,
+0x17,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x11,0x02,
+0x00,0x00,0x43,0x90,
+0x30,0x00,0x02,0x24,
+0x21,0x20,0x12,0x02,
+0x20,0x00,0xA5,0x27,
+0xED,0xFF,0x62,0x14,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEE,0xFF,0x40,0x14,
+0x21,0x10,0x11,0x02,
+0x01,0x00,0x03,0x24,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x21,0x18,0x00,0x00,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x15,0x02,
+0x18,0x00,0xA5,0x27,
+0xD1,0xFF,0x40,0x14,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xCE,0xFF,0x40,0x14,
+0x21,0x10,0x11,0x02,
+0x50,0x23,0x00,0x08,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x60,0x1B,0x45,0x24,
+0x10,0x00,0xBF,0xAF,
+0xB0,0x1B,0xA6,0x94,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xC2,0x30,
+0x12,0x00,0x40,0x10,
+0x01,0x00,0xC2,0x30,
+0x7C,0x42,0xA3,0x90,
+0x01,0x00,0x02,0x24,
+0x32,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x28,0x43,0xA3,0x94,
+0x00,0x00,0x00,0x00,
+0x80,0x18,0x03,0x00,
+0x70,0x17,0x62,0x28,
+0x04,0x00,0x40,0x14,
+0x70,0x17,0x04,0x24,
+0x21,0x4E,0x62,0x28,
+0x20,0x4E,0x04,0x24,
+0x0B,0x20,0x62,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x1A,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x78,0x42,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x40,0x14,
+0x01,0x00,0x02,0x24,
+0x7C,0x42,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x62,0x10,
+0xE8,0x03,0x04,0x24,
+0x28,0x43,0xA2,0x94,
+0x10,0x00,0xBF,0x8F,
+0x80,0x10,0x02,0x00,
+0xE9,0x03,0x43,0x28,
+0x0B,0x20,0x43,0x00,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x7C,0x42,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0xE7,0xFF,0x62,0x14,
+0x64,0x00,0x04,0x24,
+0x7E,0x42,0xA4,0x90,
+0x10,0x00,0xBF,0x8F,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x02,0x80,0x05,0x3C,
+0xEC,0xF5,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0xD0,0xF5,0xA5,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x20,0x00,0x00,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x80,0x42,0xA4,0x8C,
+0x10,0x00,0xBF,0x8F,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x21,0x38,0x80,0x00,
+0x08,0x00,0xC0,0x10,
+0xFF,0xFF,0xC3,0x24,
+0xFF,0xFF,0x06,0x24,
+0x00,0x00,0xA2,0x8C,
+0xFF,0xFF,0x63,0x24,
+0x04,0x00,0xA5,0x24,
+0x00,0x00,0xE2,0xAC,
+0xFB,0xFF,0x66,0x14,
+0x04,0x00,0xE7,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x10,0xF0,
+0x01,0x6A,0x00,0xF4,
+0x40,0x32,0x10,0xF3,
+0x68,0x44,0x11,0xF7,
+0x01,0x4A,0xF5,0x63,
+0x40,0xDB,0x00,0x6A,
+0x06,0xD2,0xFF,0x6A,
+0x01,0x4A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x0A,0xD2,0x00,0xF3,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x0C,0xD2,0x01,0xF6,
+0x00,0x6A,0x4B,0xEA,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x40,0x32,0x63,0xF3,
+0x00,0x4B,0x40,0x32,
+0x14,0x62,0x13,0xD1,
+0x12,0xD0,0x09,0xD4,
+0x07,0xD3,0x0B,0xD4,
+0x0D,0xD2,0x09,0x93,
+0x10,0xF0,0x01,0x6A,
+0x00,0xF4,0x40,0x32,
+0x11,0xF7,0x01,0x4A,
+0x00,0xF3,0x18,0x4B,
+0x40,0xDB,0x07,0x94,
+0x66,0xF7,0x48,0xAC,
+0x01,0x4A,0x66,0xF7,
+0x48,0xCC,0x00,0x1C,
+0xAB,0x40,0x00,0x65,
+0x09,0x92,0xFF,0xF7,
+0x1F,0x6D,0x7F,0x4A,
+0x47,0x4A,0x40,0xAA,
+0xAC,0xEA,0x11,0x5A,
+0x16,0x61,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x4C,0xF0,
+0x48,0x9B,0x6C,0xF0,
+0x60,0x9C,0x10,0xF0,
+0x02,0x6D,0x00,0xF4,
+0xA0,0x35,0x6D,0xEA,
+0x4C,0xF0,0x48,0xDD,
+0x00,0x6A,0x6C,0xF0,
+0x40,0xDC,0x00,0x1C,
+0xA6,0x40,0x00,0x65,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x7E,0xF6,0x04,0x4B,
+0x40,0x9B,0x20,0x9A,
+0x06,0x21,0x06,0x94,
+0xFF,0xF7,0x1F,0x6D,
+0x01,0x4C,0xAC,0xEC,
+0x06,0xD4,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x7E,0xF6,
+0x08,0x4A,0xC0,0x9A,
+0xFF,0x6C,0x01,0x4C,
+0xC0,0x30,0x4F,0x40,
+0x23,0xEA,0x80,0xF0,
+0x0A,0x60,0xFF,0x6B,
+0x01,0x4B,0x6B,0xEB,
+0x60,0x33,0x0C,0x92,
+0x60,0x33,0xE0,0xF0,
+0x1F,0x4B,0x2C,0xEB,
+0x19,0x4A,0x4A,0xEB,
+0x60,0xF3,0x11,0x60,
+0x63,0xEA,0x80,0xF0,
+0x0F,0x61,0x0D,0x92,
+0x01,0x4A,0x4A,0xEB,
+0xC0,0xF0,0x0B,0x60,
+0x63,0xEA,0x00,0xF1,
+0x09,0x61,0x02,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0xA2,0x42,0xAA,0xEB,
+0x60,0xF1,0x09,0x60,
+0x63,0xED,0xA0,0xF1,
+0x14,0x61,0x4A,0xEB,
+0x20,0xF4,0x0C,0x60,
+0x63,0xEA,0x40,0xF4,
+0x08,0x61,0x04,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x6E,0xEA,0x60,0xF2,
+0x04,0x22,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x00,0x6B,0x60,0xF3,
+0x10,0x4A,0x60,0xDA,
+0x06,0xD3,0x09,0x93,
+0x10,0xF0,0x01,0x6A,
+0x00,0xF4,0x40,0x32,
+0x12,0xF0,0x01,0x4A,
+0x00,0xF3,0x18,0x4B,
+0x40,0xDB,0x00,0x1C,
+0xAB,0x40,0xFF,0x68,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0xB0,0xF0,
+0x2F,0x42,0x0A,0x10,
+0x40,0xA1,0x0C,0xEA,
+0x04,0x5A,0x10,0x60,
+0x07,0x93,0x27,0xF1,
+0x90,0x9B,0x00,0x1C,
+0xA9,0x09,0x00,0x65,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x8A,0xF4,0x10,0x4C,
+0x00,0x1C,0x61,0x57,
+0x00,0x65,0xEC,0x22,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x0C,0xF4,0x5A,0xA4,
+0x0F,0x6B,0xFF,0x6C,
+0x6C,0xEA,0x02,0x72,
+0x0B,0x61,0x10,0xF0,
+0x02,0x6D,0x00,0xF4,
+0xA0,0x35,0x0C,0xF4,
+0x59,0xA5,0x8C,0xEA,
+0x6C,0xEA,0x01,0x72,
+0xE0,0xF2,0x1C,0x60,
+0x00,0x1C,0xA6,0x40,
+0x00,0x65,0x00,0x6D,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x02,0xF0,0x08,0x4C,
+0xC5,0x67,0x00,0x1C,
+0x1B,0x3E,0xE5,0x67,
+0x24,0x17,0x06,0x94,
+0x0A,0xF0,0x00,0x5C,
+0xAE,0x61,0xC9,0xF7,
+0x1B,0x6D,0xAB,0xED,
+0xA0,0x35,0xA0,0x35,
+0x00,0x6A,0x60,0xF3,
+0x10,0x4D,0x40,0xDD,
+0x09,0x93,0x06,0xD2,
+0x01,0x6A,0x60,0xF3,
+0x14,0x4B,0x4B,0xEA,
+0x40,0xDB,0x9D,0x17,
+0x0C,0x92,0x7F,0x4A,
+0x2D,0x4A,0x4A,0xEB,
+0xE0,0xF2,0x06,0x60,
+0x63,0xEA,0x56,0x61,
+0x0C,0x92,0x7F,0x4A,
+0x23,0x4A,0x4A,0xEB,
+0x20,0xF3,0x02,0x60,
+0x63,0xEA,0xC0,0xF0,
+0x01,0x61,0x0C,0x92,
+0x7F,0x4A,0x21,0x4A,
+0x4A,0xEB,0x40,0xF1,
+0x1B,0x60,0x63,0xEA,
+0xA0,0xF3,0x07,0x61,
+0x0C,0x92,0x28,0x4A,
+0x6E,0xEA,0x7F,0xF7,
+0x14,0x2A,0x02,0xF0,
+0x00,0x68,0x00,0x30,
+0x60,0x6E,0xAF,0x40,
+0x00,0x1C,0x12,0x46,
+0x24,0x6C,0xE0,0xF3,
+0x08,0x6C,0x00,0x1C,
+0x43,0x26,0x00,0x65,
+0x00,0x1C,0xAB,0x40,
+0x00,0x65,0x24,0x6C,
+0x00,0x1C,0x3B,0x46,
+0xAF,0x40,0x1F,0x6E,
+0x4C,0xEE,0x00,0x1C,
+0xA6,0x40,0x10,0xD6,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x09,0x92,
+0x10,0x96,0x60,0xF3,
+0x14,0x4A,0xC0,0xC2,
+0x52,0x17,0x09,0x92,
+0x60,0xF3,0x14,0x4A,
+0x20,0x9A,0x02,0xF0,
+0x00,0x6A,0x40,0x32,
+0x40,0x32,0xFF,0x4A,
+0x4C,0xE9,0x23,0xEE,
+0x5F,0xF7,0x05,0x60,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x0A,0xF0,0x00,0x6A,
+0x80,0x34,0x4B,0xEA,
+0x60,0xF3,0x18,0x4C,
+0x40,0x32,0xC0,0x9C,
+0x40,0x32,0x4D,0xE9,
+0xC0,0xD9,0x35,0x17,
+0x00,0xF2,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x87,0x42,
+0x09,0x4C,0x8A,0xEB,
+0x80,0xF2,0x08,0x60,
+0x63,0xEC,0x80,0xF0,
+0x1D,0x61,0x0C,0x92,
+0x7F,0x4A,0x2F,0x4A,
+0x4A,0xEB,0xC0,0xF2,
+0x1E,0x60,0x43,0xEB,
+0x20,0xF3,0x1B,0x61,
+0x00,0xF3,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x7F,0x4A,
+0x30,0x4A,0x6E,0xEA,
+0x1F,0xF7,0x15,0x2A,
+0x00,0x18,0x69,0x5C,
+0x00,0x65,0x11,0x17,
+0x01,0xF0,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x15,0x4A,
+0x4A,0xEB,0xC0,0xF2,
+0x00,0x60,0x63,0xEA,
+0x80,0xF0,0x1B,0x61,
+0x01,0xF4,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x4A,0xEB,
+0xE0,0xF2,0x0C,0x60,
+0x63,0xEA,0x20,0xF1,
+0x1B,0x61,0x01,0xF5,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x6E,0xEA,0xFF,0xF6,
+0x12,0x2A,0x1F,0xF7,
+0x00,0x6A,0x2C,0xEA,
+0x42,0x33,0x0F,0x6A,
+0x40,0x32,0x40,0x32,
+0x2C,0xEA,0x42,0x30,
+0x10,0xF0,0x00,0x6C,
+0x02,0x30,0x08,0xD4,
+0x01,0x28,0x08,0xD0,
+0x08,0x94,0x1E,0xF0,
+0x00,0x6A,0x40,0x32,
+0xFF,0xF7,0x1F,0x6D,
+0x4C,0xE9,0xAC,0xEC,
+0xFF,0x6A,0xA3,0x67,
+0xD0,0x67,0x4C,0xED,
+0x4C,0xEE,0x00,0x1C,
+0x20,0x0F,0x0F,0xD3,
+0x08,0x92,0x00,0xF5,
+0x22,0x31,0x0F,0x93,
+0x10,0xF0,0x00,0x72,
+0x04,0x61,0x01,0x70,
+0xC0,0xF1,0x09,0x61,
+0x02,0x4B,0xFF,0x6A,
+0x83,0x67,0x4C,0xEC,
+0x00,0x1C,0xD5,0x0D,
+0xB1,0x67,0xC1,0x16,
+0x0C,0x92,0x7F,0x4A,
+0x25,0x4A,0x4A,0xEB,
+0xA0,0xF0,0x0C,0x60,
+0x43,0xEB,0xE0,0xF0,
+0x06,0x61,0x0C,0x92,
+0x7F,0x4A,0x26,0x4A,
+0x6E,0xEA,0xE0,0xF2,
+0x09,0x22,0x0C,0x92,
+0x7F,0x4A,0x27,0x4A,
+0x6E,0xEA,0xBF,0xF6,
+0x0C,0x2A,0x00,0x18,
+0x88,0x5D,0x00,0x65,
+0xA8,0x16,0x1F,0xF7,
+0x00,0x6B,0x22,0x32,
+0x6C,0xEA,0x42,0x32,
+0x2C,0xEB,0x62,0x31,
+0x82,0x67,0x04,0x22,
+0x01,0x72,0x01,0x6C,
+0x01,0x60,0x00,0x6C,
+0x02,0xF0,0x00,0x68,
+0x00,0x1C,0x7F,0x43,
+0x00,0x30,0xAF,0x40,
+0x00,0x1C,0x3B,0x46,
+0x91,0x67,0xFF,0x48,
+0x4C,0xE8,0x09,0x92,
+0x60,0xF3,0x14,0x4A,
+0x00,0xDA,0x8B,0x16,
+0x12,0x4A,0x4A,0xEB,
+0x40,0xF2,0x11,0x60,
+0x43,0xEB,0x40,0xF2,
+0x1F,0x61,0x0A,0x92,
+0x0F,0x4A,0x6E,0xEA,
+0x80,0xF0,0x1C,0x22,
+0xFF,0x6A,0x01,0x4A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x10,0x4A,
+0x6E,0xEA,0x7F,0xF6,
+0x16,0x2A,0x1F,0xF7,
+0x00,0x6A,0x4C,0xE9,
+0x4A,0xE9,0x60,0xF1,
+0x12,0x61,0x07,0x95,
+0xFF,0xF7,0x1F,0x6A,
+0x27,0xF1,0x44,0xDD,
+0x6A,0x16,0x0C,0x92,
+0x14,0x4A,0x4A,0xEB,
+0x5D,0x60,0x63,0xEA,
+0xA0,0xF0,0x13,0x61,
+0x0C,0x92,0x07,0x4A,
+0x6E,0xEA,0x5F,0xF6,
+0x1E,0x2A,0x00,0x18,
+0xD3,0x5F,0x91,0x67,
+0x5A,0x16,0x87,0x42,
+0x01,0x4C,0x8A,0xEB,
+0x80,0xF0,0x08,0x60,
+0x63,0xEC,0xE0,0xF0,
+0x0B,0x61,0x03,0x4A,
+0x6E,0xEA,0x5F,0xF6,
+0x0E,0x2A,0x1F,0xF7,
+0x00,0x6B,0x22,0x32,
+0x6C,0xEA,0x42,0x32,
+0x2C,0xEB,0x62,0x31,
+0x82,0x67,0x04,0x22,
+0x01,0x72,0x01,0x6C,
+0x01,0x60,0x00,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x00,0x65,0xC9,0xF7,
+0x1B,0x6D,0xAB,0xED,
+0xA0,0x35,0xA0,0x35,
+0x60,0xF3,0x14,0x4D,
+0xC0,0x9D,0x02,0xF0,
+0x00,0x68,0x00,0x30,
+0x91,0x67,0x00,0x1C,
+0x12,0x46,0xAF,0x40,
+0x91,0x67,0x00,0x1C,
+0x3B,0x46,0xAF,0x40,
+0xC2,0x67,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x60,0xF3,0x14,0x4A,
+0xC0,0xDA,0x21,0x16,
+0x01,0xF7,0x00,0x6A,
+0x4C,0xE9,0x22,0x32,
+0x01,0x72,0x01,0x6C,
+0x07,0x60,0x02,0x72,
+0x02,0x6C,0x04,0x60,
+0x03,0x72,0x03,0x6C,
+0x01,0x60,0x00,0x6C,
+0x00,0x18,0x86,0x5C,
+0x00,0x65,0x0F,0x16,
+0x07,0x94,0xFF,0xF7,
+0x1F,0x6D,0x27,0xF1,
+0xA4,0xDC,0x09,0x16,
+0x0F,0xF7,0x40,0x40,
+0x2C,0xEA,0x1F,0xF6,
+0x04,0x22,0x07,0x93,
+0xFF,0x6D,0x01,0x4D,
+0xAB,0xED,0x00,0xF3,
+0x44,0x9B,0xA0,0x35,
+0xA0,0x35,0xE0,0xF0,
+0x1F,0x4D,0xAC,0xEA,
+0x8D,0xEA,0x00,0xF3,
+0x44,0xDB,0x07,0x94,
+0x1F,0xF7,0x00,0x6B,
+0x22,0x32,0x6C,0xEA,
+0x42,0x32,0x00,0xF3,
+0x5C,0xC4,0x6C,0xE9,
+0xFB,0x4A,0x00,0xF3,
+0x5D,0xC4,0x22,0x32,
+0x00,0xF3,0x5E,0xC4,
+0xFB,0x4A,0x00,0xF3,
+0x5F,0xC4,0xE3,0x15,
+0xC9,0xF7,0x1B,0x6B,
+0x6B,0xEB,0x60,0x33,
+0x60,0x33,0xFF,0x6A,
+0x40,0xF1,0x16,0x4B,
+0x40,0xCB,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x01,0x6A,
+0x8B,0xF7,0x48,0xC4,
+0xD2,0x15,0x07,0x92,
+0x00,0x6B,0x27,0xF1,
+0x64,0xDA,0xCD,0x15,
+0x1F,0xF7,0x00,0x6A,
+0x2C,0xEA,0x42,0x31,
+0x91,0x67,0x04,0x21,
+0x01,0x71,0x01,0x6C,
+0x01,0x60,0x00,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x00,0x65,0xBF,0x15,
+0x01,0x4A,0x6E,0xEA,
+0xBF,0xF5,0x1B,0x2A,
+0x07,0x94,0x09,0x93,
+0xFF,0xF7,0x1F,0x6D,
+0xC4,0xF7,0x5C,0x9C,
+0x60,0xF3,0x14,0x4B,
+0xAC,0xEA,0x40,0xDB,
+0xB0,0x15,0x0C,0x92,
+0x17,0x4A,0x6E,0xEA,
+0x70,0x22,0x0C,0x92,
+0x18,0x4A,0x6E,0xEA,
+0xBF,0xF5,0x07,0x2A,
+0x07,0x94,0x0C,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x62,0x9C,0x40,0x32,
+0x40,0x32,0xFF,0x4A,
+0x4C,0xEB,0x62,0xDC,
+0x9C,0x15,0x1F,0xF7,
+0x00,0x6A,0x2C,0xEA,
+0x42,0x32,0xFF,0x72,
+0x7C,0x61,0xC9,0xF7,
+0x1B,0x6B,0x6B,0xEB,
+0x60,0x33,0x60,0x33,
+0x60,0xF3,0x04,0x4B,
+0x40,0xAB,0x4D,0xEC,
+0x80,0xCB,0x07,0x94,
+0x06,0xF0,0x00,0x6A,
+0x4B,0xEA,0xE0,0xF2,
+0x64,0x9C,0x40,0x32,
+0x40,0x32,0xFF,0x4A,
+0x4C,0xEB,0xE0,0xF2,
+0x64,0xDC,0x1F,0xF7,
+0x00,0x6A,0x4C,0xE9,
+0x19,0xF4,0x00,0x71,
+0x7F,0xF5,0x19,0x61,
+0x07,0x95,0x06,0xF0,
+0x00,0x6B,0x6B,0xEB,
+0xE0,0xF2,0x44,0x9D,
+0x60,0x33,0x60,0x33,
+0xFF,0x4B,0x6C,0xEA,
+0x02,0xF0,0x00,0x6B,
+0x60,0x33,0x60,0x33,
+0x6D,0xEA,0xE0,0xF2,
+0x44,0xDD,0x67,0x15,
+0x01,0xF7,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x6E,0xEA,
+0x67,0x22,0x0D,0x92,
+0x6E,0xEA,0x5F,0xF5,
+0x1C,0x2A,0x0B,0x92,
+0x60,0xF3,0x14,0x4A,
+0x20,0x9A,0x02,0xF0,
+0x00,0x6A,0x40,0x32,
+0x40,0x32,0xFF,0x4A,
+0x4C,0xE9,0xFF,0x6A,
+0x01,0x4A,0x40,0x32,
+0x23,0xEA,0x5F,0xF5,
+0x0C,0x60,0x0A,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0xC9,0xF7,0x1B,0x6B,
+0x4D,0xE9,0x6B,0xEB,
+0xC0,0x99,0x60,0x33,
+0x60,0x33,0x60,0xF3,
+0x18,0x4B,0xC0,0xDB,
+0x3C,0x15,0x09,0x94,
+0x1F,0xF7,0x00,0x6A,
+0xFF,0xF7,0x1F,0x6D,
+0x60,0xF3,0x08,0x4C,
+0x60,0x9C,0x4C,0xE9,
+0x20,0x32,0xAC,0xEB,
+0x6D,0xEA,0x40,0xDC,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x60,0xF3,
+0x04,0x4A,0x60,0xA2,
+0xFF,0x6A,0x6C,0xEA,
+0x40,0x6B,0x6D,0xEA,
+0xC9,0xF7,0x1B,0x6B,
+0x6B,0xEB,0x60,0x33,
+0x60,0x33,0x60,0xF3,
+0x04,0x4B,0x40,0xC3,
+0x1A,0x15,0x99,0x2A,
+0xC9,0xF7,0x1B,0x6D,
+0xAB,0xED,0xA0,0x35,
+0xA0,0x35,0x60,0xF3,
+0x04,0x4D,0x60,0xAD,
+0xFF,0x6A,0x02,0x4A,
+0x4B,0xEA,0x6C,0xEA,
+0x40,0xCD,0x07,0x92,
+0x07,0x94,0xE0,0xF2,
+0x64,0x9A,0x06,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0xFF,0x4A,0x4C,0xEB,
+0x7E,0x17,0xFE,0x4B,
+0x36,0x16,0x07,0x93,
+0x00,0x6C,0x27,0xF1,
+0x84,0xDB,0xF9,0x14,
+0x07,0x93,0x0F,0xF7,
+0x40,0x40,0x4C,0xE9,
+0x22,0x34,0xA3,0xF3,
+0x9A,0xCB,0x09,0x92,
+0x04,0x6D,0x7F,0x4A,
+0x15,0x4A,0x80,0xCA,
+0x09,0x93,0x00,0xF4,
+0x00,0x6A,0x7F,0x4B,
+0x1B,0x4B,0x40,0xCB,
+0x09,0x93,0xA0,0x6A,
+0x7F,0x4B,0x19,0x4B,
+0x40,0xCB,0x09,0x92,
+0xC9,0xF7,0x1A,0x6B,
+0x6B,0xEB,0x7F,0x4A,
+0x60,0x33,0x60,0x33,
+0x17,0x4A,0xA0,0xCA,
+0x47,0x43,0x73,0x4A,
+0xA0,0xC2,0xFF,0xF7,
+0x1F,0x6D,0xAC,0xEC,
+0x94,0x34,0xC8,0x44,
+0xC8,0x4E,0x60,0xF0,
+0xDC,0xCB,0x09,0x92,
+0x40,0xF0,0x64,0xAA,
+0x00,0xF2,0x01,0x6A,
+0x4B,0xEA,0x6C,0xEA,
+0x09,0x93,0x40,0xF0,
+0x44,0xCB,0x09,0x94,
+0x00,0xF2,0x00,0x6A,
+0x40,0xF0,0x64,0xAC,
+0x6D,0xEA,0x40,0xF0,
+0x44,0xCC,0xBB,0x14,
+0x0C,0xF4,0x59,0xA5,
+0x01,0x6D,0x00,0x1C,
+0xAD,0x34,0x4C,0xEC,
+0xFD,0x14,0xC9,0xF7,
+0x1B,0x6D,0xAB,0xED,
+0xA0,0x35,0xA0,0x35,
+0x60,0xF3,0x10,0x4D,
+0x00,0x6A,0x40,0xDD,
+0x00,0x18,0xB3,0x2D,
+0x91,0x67,0xA7,0x14,
+0x00,0x18,0x78,0x5B,
+0x91,0x67,0xA3,0x14,
+0x00,0x1C,0xAB,0x40,
+0x00,0x65,0x07,0x95,
+0x0F,0x6A,0x40,0x32,
+0x23,0xF4,0x68,0x9D,
+0x40,0x32,0x6C,0xEA,
+0x04,0x22,0x00,0x1C,
+0xA6,0x40,0x00,0x65,
+0x94,0x14,0x43,0x67,
+0x0F,0x6B,0x6B,0xEB,
+0x60,0x33,0x60,0x33,
+0x01,0x6C,0xFF,0x4B,
+0x80,0x34,0x6C,0xEA,
+0x80,0x34,0x8D,0xEA,
+0x23,0xF4,0x48,0xDD,
+0x0F,0xF7,0x40,0x40,
+0x07,0x93,0x4C,0xE9,
+0xFF,0xF7,0x1F,0x6D,
+0x22,0x32,0xAC,0xEA,
+0x23,0xF4,0x4B,0xC3,
+0x07,0x95,0x42,0x34,
+0x0F,0x6A,0x4C,0xEC,
+0xF0,0x6A,0x4B,0xEA,
+0x23,0xF4,0x68,0x9D,
+0x40,0x32,0x40,0x32,
+0xFF,0x4A,0x00,0xF5,
+0x80,0x34,0x4C,0xEB,
+0x8D,0xEB,0x23,0xF4,
+0x68,0xDD,0x23,0xF4,
+0x8B,0xA5,0x00,0x1C,
+0x57,0x37,0x00,0x65,
+0x00,0x1C,0xA6,0x40,
+0x00,0x65,0x63,0x14,
+0x0F,0xF7,0x40,0x40,
+0x09,0x90,0x4C,0xE9,
+0x22,0x32,0x60,0xF3,
+0x14,0x48,0xFF,0xF7,
+0x1F,0x6D,0xAC,0xEA,
+0xA0,0x98,0x82,0x67,
+0x00,0x18,0x57,0x5D,
+0x0E,0xD2,0x0E,0x92,
+0xC0,0x98,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x3E,0xF6,
+0x14,0x4C,0x00,0x1C,
+0x13,0x57,0xA2,0x67,
+0x48,0x14,0x00,0x1C,
+0xC5,0x26,0x00,0x65,
+0x44,0x14,0x1F,0xF7,
+0x00,0x6A,0x22,0x34,
+0x4C,0xEC,0x4C,0xE9,
+0x82,0x34,0x00,0x18,
+0x2F,0x5C,0x22,0x35,
+0x09,0x93,0x60,0xF3,
+0x14,0x4B,0x40,0xC3,
+0x36,0x14,0x00,0x1C,
+0xAB,0x40,0x00,0x65,
+0x0F,0xF7,0x40,0x40,
+0x4C,0xE9,0x07,0x93,
+0x22,0x32,0xFF,0xF7,
+0x1F,0x6D,0xAC,0xEA,
+0x23,0xF4,0x4B,0xC3,
+0x00,0x1C,0xA6,0x40,
+0x00,0x65,0x25,0x14,
+0x00,0x1C,0xAB,0x40,
+0x00,0x65,0x07,0x93,
+0x0F,0x6C,0x8B,0xEC,
+0x23,0xF4,0x48,0x9B,
+0x80,0x34,0x80,0x34,
+0xFF,0x4C,0x8C,0xEA,
+0x23,0xF4,0x48,0xDB,
+0x23,0xF4,0x8B,0xA3,
+0x00,0x1C,0x57,0x37,
+0x00,0x65,0xAA,0x17,
+0x0F,0xF7,0x40,0x40,
+0x4C,0xE9,0x22,0x32,
+0x01,0x6B,0xA2,0x67,
+0x6C,0xED,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x46,0x36,
+0x4A,0x37,0x4E,0x32,
+0x6C,0xEA,0x6C,0xEE,
+0x6C,0xEF,0xDC,0xF6,
+0xB0,0xDC,0x07,0x93,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x6B,0xF7,0xD1,0xC4,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0xDC,0xF6,0xEC,0xDC,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0xE7,0xF5,0x43,0xC3,
+0x5E,0xF6,0x10,0x4C,
+0x00,0x1C,0x13,0x57,
+0x04,0xD2,0xFF,0xF3,
+0x04,0x10,0x00,0x18,
+0x86,0x5B,0x91,0x67,
+0xDF,0xF3,0x1F,0x10,
+0x0F,0xF7,0x40,0x40,
+0x4C,0xE9,0x00,0x1C,
+0x1A,0x5B,0x22,0x34,
+0xC2,0x67,0x09,0x92,
+0x60,0xF3,0x14,0x4A,
+0xC0,0xDA,0xDF,0xF3,
+0x12,0x10,0x22,0x34,
+0x1F,0xF7,0x00,0x6A,
+0x4C,0xEC,0x00,0x18,
+0xB2,0x28,0x82,0x34,
+0xDF,0xF3,0x09,0x10,
+0x22,0x34,0x1F,0xF7,
+0x00,0x6A,0x4C,0xEC,
+0x00,0x18,0x83,0x5D,
+0x82,0x34,0xDF,0xF3,
+0x00,0x10,0x0F,0xF7,
+0x40,0x40,0x09,0x90,
+0x2C,0xEA,0x42,0x31,
+0x60,0xF3,0x14,0x48,
+0xC0,0x98,0x91,0x67,
+0x00,0x1C,0xF7,0x5A,
+0xA6,0x67,0x00,0x1C,
+0x1A,0x5B,0x91,0x67,
+0x40,0xD8,0xBF,0xF3,
+0x0E,0x10,0x00,0x65,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x0C,0x99,0x63,0x24,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x05,0x3C,
+0xD8,0x63,0xA5,0x8C,
+0x04,0x00,0x02,0x24,
+0x1E,0x00,0xA2,0x10,
+0x05,0x00,0xA2,0x2C,
+0x10,0x00,0x40,0x10,
+0x05,0x00,0x02,0x24,
+0x03,0x00,0x02,0x24,
+0x08,0x00,0xA2,0x10,
+0x00,0x19,0x04,0x00,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0xC0,0x10,0x02,0x00,
+0x23,0x10,0x44,0x00,
+0x00,0x11,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x40,0x19,0x02,0x00,
+0xFF,0xFF,0x63,0x24,
+0xFE,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0xA2,0x10,
+0x06,0x00,0x02,0x24,
+0xF2,0xFF,0xA2,0x14,
+0x80,0x10,0x04,0x00,
+0x40,0x11,0x04,0x00,
+0x23,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x00,0x19,0x02,0x00,
+0x23,0x18,0x62,0x00,
+0x59,0x26,0x00,0x08,
+0x00,0x19,0x03,0x00,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0xC0,0x10,0x02,0x00,
+0x23,0x10,0x44,0x00,
+0x00,0x11,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x59,0x26,0x00,0x08,
+0x00,0x19,0x02,0x00,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC8,0x99,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x05,0x3C,
+0xD8,0x63,0xA3,0x8C,
+0x05,0x00,0x02,0x24,
+0x06,0x00,0x62,0x10,
+0x06,0x00,0x62,0x2C,
+0x0C,0x00,0x40,0x10,
+0x06,0x00,0x02,0x24,
+0x04,0x00,0x02,0x24,
+0x0E,0x00,0x62,0x10,
+0x80,0x10,0x04,0x00,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0xFF,0xFF,0x42,0x24,
+0xFE,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xF7,0xFF,0x62,0x14,
+0x00,0x11,0x04,0x00,
+0x23,0x10,0x44,0x00,
+0x84,0x26,0x00,0x08,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x84,0x26,0x00,0x08,
+0x40,0x10,0x02,0x00,
+0xFF,0xFF,0x85,0x30,
+0x21,0x30,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x2A,0xB0,0x04,0x3C,
+0xB4,0x00,0x63,0x34,
+0x01,0x00,0xA2,0x24,
+0x31,0x00,0x84,0x34,
+0x00,0x00,0x65,0xA0,
+0x00,0x00,0x85,0xA0,
+0xFF,0xFF,0x45,0x30,
+0x12,0x00,0xA0,0x10,
+0x01,0x00,0x03,0x24,
+0x28,0xB0,0x07,0x3C,
+0xA6,0x26,0x00,0x08,
+0xFF,0xFF,0x08,0x24,
+0x00,0x00,0x83,0xA0,
+0x01,0x00,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x2B,0x10,0xA3,0x00,
+0x09,0x00,0x40,0x14,
+0x08,0x00,0xC6,0x24,
+0xF9,0xFF,0x65,0x14,
+0x21,0x20,0xC7,0x00,
+0x01,0x00,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x2B,0x10,0xA3,0x00,
+0x00,0x00,0x88,0xA0,
+0xF9,0xFF,0x40,0x10,
+0x08,0x00,0xC6,0x24,
+0x00,0x01,0xA2,0x2C,
+0x13,0x00,0x40,0x10,
+0x21,0x18,0xA0,0x00,
+0xFF,0x00,0x08,0x24,
+0x28,0xB0,0x07,0x3C,
+0xBA,0x26,0x00,0x08,
+0xFF,0xFF,0x09,0x24,
+0xFF,0xFF,0x43,0x30,
+0x00,0x00,0xA2,0xA0,
+0x00,0x01,0x62,0x2C,
+0x0A,0x00,0x40,0x10,
+0x08,0x00,0xC6,0x24,
+0x01,0x00,0x62,0x24,
+0xF9,0xFF,0x68,0x14,
+0x21,0x28,0xC7,0x00,
+0x00,0x01,0x02,0x24,
+0xFF,0xFF,0x43,0x30,
+0x00,0x01,0x62,0x2C,
+0x00,0x00,0xA9,0xA0,
+0xF8,0xFF,0x40,0x14,
+0x08,0x00,0xC6,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x25,0xB0,0x12,0x3C,
+0xFF,0xFF,0x02,0x24,
+0x28,0x00,0xB6,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x42,0x00,0x56,0x36,
+0x14,0x00,0xB1,0xAF,
+0xFC,0x77,0x13,0x24,
+0x40,0x00,0x51,0x36,
+0x00,0x00,0xC2,0xA2,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x33,0xA6,
+0xFC,0x57,0x10,0x24,
+0x32,0x00,0x04,0x24,
+0x2C,0x00,0xBF,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x72,0x26,0x00,0x0C,
+0x20,0x00,0xB4,0xAF,
+0x00,0x00,0x30,0xA6,
+0x72,0x26,0x00,0x0C,
+0x32,0x00,0x04,0x24,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0x22,0xA6,
+0x72,0x26,0x00,0x0C,
+0x32,0x00,0x04,0x24,
+0x00,0x00,0x33,0xA6,
+0x72,0x26,0x00,0x0C,
+0x32,0x00,0x04,0x24,
+0x00,0x00,0x30,0xA6,
+0x72,0x26,0x00,0x0C,
+0x32,0x00,0x04,0x24,
+0x00,0x10,0x02,0x24,
+0x00,0x00,0x22,0xA6,
+0xD8,0x00,0x45,0x36,
+0x00,0x00,0xA2,0x90,
+0xA0,0x00,0x54,0x36,
+0xA4,0x00,0x55,0x36,
+0x7F,0x00,0x42,0x30,
+0x00,0x00,0xA2,0xA0,
+0xA8,0x00,0x53,0x36,
+0x00,0x80,0x02,0x3C,
+0xFC,0x17,0x03,0x24,
+0x00,0x00,0x80,0xAE,
+0x00,0x00,0xA0,0xAE,
+0x00,0x00,0x62,0xAE,
+0x00,0x00,0x23,0xA6,
+0x00,0x00,0xA3,0x90,
+0x02,0x80,0x10,0x3C,
+0x60,0x1B,0x10,0x26,
+0xAA,0x1B,0x04,0x92,
+0x80,0xFF,0x02,0x24,
+0x25,0x18,0x62,0x00,
+0x56,0x01,0x52,0x36,
+0xFF,0x0F,0x02,0x24,
+0x00,0x00,0xA3,0xA0,
+0x00,0x00,0x42,0xA6,
+0x91,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1C,0x1C,0x04,0x8E,
+0x14,0x1C,0x02,0x8E,
+0x18,0x1C,0x03,0x8E,
+0x2C,0x00,0xBF,0x8F,
+0x00,0x00,0x82,0xAE,
+0x18,0x00,0xB2,0x8F,
+0x00,0x00,0xA3,0xAE,
+0x20,0x00,0xB4,0x8F,
+0x00,0x00,0x64,0xAE,
+0x24,0x00,0xB5,0x8F,
+0x00,0x00,0xC0,0xA2,
+0x1C,0x00,0xB3,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0xFF,0x00,0x82,0x30,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x21,0x88,0xC0,0x00,
+0x21,0x80,0xE0,0x00,
+0xC0,0x90,0x02,0x00,
+0x28,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0xFF,0xFF,0xB3,0x30,
+0x25,0xB0,0x02,0x3C,
+0x40,0x02,0x49,0x34,
+0x0C,0x00,0x10,0x26,
+0x05,0x00,0x06,0x24,
+0x01,0x00,0x0A,0x24,
+0x44,0x02,0x48,0x34,
+0x3A,0x27,0x00,0x08,
+0x01,0x80,0x07,0x3C,
+0x2C,0x00,0xCA,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x92,
+0x00,0x00,0x04,0x92,
+0x02,0x00,0x03,0x92,
+0x03,0x00,0x05,0x92,
+0x00,0x12,0x02,0x00,
+0x25,0x20,0x82,0x00,
+0x00,0x1C,0x03,0x00,
+0x21,0x10,0x46,0x02,
+0x25,0x20,0x83,0x00,
+0x00,0x2E,0x05,0x00,
+0x25,0x20,0x85,0x00,
+0x25,0x10,0x47,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x00,0x00,0x04,0xAD,
+0xFC,0xFF,0x10,0x26,
+0x00,0x00,0x22,0xAD,
+0x11,0x00,0xC0,0x04,
+0x00,0x00,0x00,0x00,
+0xEB,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x22,0x92,
+0x01,0x00,0x23,0x92,
+0xFC,0xFF,0x10,0x26,
+0x00,0x14,0x02,0x00,
+0x25,0x10,0x62,0x02,
+0x00,0x1E,0x03,0x00,
+0x25,0x20,0x43,0x00,
+0x21,0x10,0x46,0x02,
+0x25,0x10,0x47,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x00,0x00,0x04,0xAD,
+0x00,0x00,0x22,0xAD,
+0xF1,0xFF,0xC1,0x04,
+0x00,0x00,0x00,0x00,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x03,0x00,0x22,0x92,
+0x02,0x00,0x24,0x92,
+0x04,0x00,0x23,0x92,
+0x05,0x00,0x25,0x92,
+0x2D,0x27,0x00,0x08,
+0x00,0x12,0x02,0x00,
+0xFF,0xFF,0x84,0x30,
+0x42,0xB0,0x08,0x3C,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x48,0x00,
+0x04,0x00,0x46,0xAC,
+0x00,0x00,0x07,0x91,
+0x40,0x18,0x04,0x00,
+0x03,0x00,0x06,0x24,
+0xFF,0x00,0xE7,0x30,
+0x04,0x30,0x66,0x00,
+0x01,0x00,0x02,0x24,
+0x04,0x10,0x62,0x00,
+0x25,0x30,0xC7,0x00,
+0xFF,0xFF,0xA5,0x30,
+0x25,0x10,0x47,0x00,
+0x02,0x00,0xA0,0x14,
+0xFF,0x00,0xC7,0x30,
+0xFF,0x00,0x47,0x30,
+0x42,0xB0,0x02,0x3C,
+0x00,0x00,0x47,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0x83,0x90,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x86,0xAC,
+0x18,0x00,0x85,0xAC,
+0x00,0x00,0x84,0xAC,
+0x03,0x00,0x62,0x10,
+0x04,0x00,0x84,0xAC,
+0x53,0x5B,0x00,0x08,
+0x0C,0x00,0x80,0xAC,
+0x0C,0x00,0x82,0x8C,
+0x53,0x5B,0x00,0x08,
+0x10,0x00,0x82,0xAC,
+0xC8,0xFF,0xBD,0x27,
+0x28,0x00,0xB6,0xAF,
+0x25,0xB0,0x02,0x3C,
+0x02,0x80,0x16,0x3C,
+0x2C,0x00,0xB7,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x18,0x03,0x55,0x34,
+0x01,0x80,0x17,0x3C,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x14,0x3C,
+0xD8,0xE6,0xD2,0x26,
+0xEC,0x9D,0xE2,0x26,
+0x00,0x00,0xA2,0xAE,
+0xD8,0xE6,0xD0,0x8E,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x94,0x5F,0x71,0x8E,
+0x00,0x00,0x00,0x00,
+0x23,0x00,0x20,0x12,
+0x00,0x00,0x00,0x00,
+0xA6,0x40,0x00,0x0C,
+0x94,0x5F,0x60,0xAE,
+0x22,0x00,0x12,0x12,
+0x08,0x0C,0x84,0x26,
+0x14,0x00,0x03,0x92,
+0x01,0x00,0x02,0x24,
+0x2A,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x60,0x14,
+0x02,0x00,0x02,0x24,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x23,0x02,
+0x1D,0x00,0x40,0x10,
+0x23,0x10,0x71,0x00,
+0x0C,0x00,0x02,0xAE,
+0x00,0x00,0x10,0x8E,
+0x97,0x27,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x60,0x10,
+0x2B,0x10,0x23,0x02,
+0xF5,0xFF,0x40,0x14,
+0x23,0x10,0x71,0x00,
+0x08,0x00,0x02,0x8E,
+0x18,0x00,0x04,0x8E,
+0x09,0xF8,0x40,0x00,
+0x0C,0x00,0x00,0xAE,
+0x00,0x00,0x10,0x8E,
+0x97,0x27,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xA6,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x0C,0x84,0x26,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x1B,0x3E,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x8D,0x27,0x00,0x08,
+0xEC,0x9D,0xE2,0x26,
+0x08,0x00,0x02,0x8E,
+0x18,0x00,0x04,0x8E,
+0x09,0xF8,0x40,0x00,
+0x00,0x00,0x00,0x00,
+0xA5,0x27,0x00,0x08,
+0x0C,0x00,0x02,0xAE,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x23,0x02,
+0xDA,0xFF,0x40,0x14,
+0x23,0x10,0x71,0x00,
+0x08,0x00,0x02,0x8E,
+0x18,0x00,0x04,0x8E,
+0x09,0xF8,0x40,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x03,0xAE,
+0x00,0x00,0x10,0x8E,
+0x97,0x27,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0xC0,0x54,0x42,0x24,
+0x18,0x00,0xB0,0xAF,
+0xC0,0x80,0x04,0x00,
+0x21,0x80,0x02,0x02,
+0x1C,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x02,0x8E,
+0x10,0x00,0xA4,0x27,
+0x09,0x00,0x50,0x10,
+0x21,0x88,0x00,0x00,
+0x04,0x00,0x43,0x8C,
+0x21,0x88,0x40,0x00,
+0x00,0x00,0x42,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0x31,0xAE,
+0x04,0x00,0x31,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x01,0x01,0x82,0x2C,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x21,0x18,0x00,0x00,
+0x10,0x00,0x40,0x14,
+0x01,0x00,0x04,0x24,
+0x01,0x02,0x02,0x2E,
+0x0D,0x00,0x40,0x14,
+0x02,0x00,0x04,0x24,
+0x01,0x08,0x02,0x2E,
+0x0A,0x00,0x40,0x14,
+0x03,0x00,0x04,0x24,
+0x01,0x10,0x02,0x2E,
+0x06,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x04,0x00,0x04,0x24,
+0xD5,0x27,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF7,0xFF,0x40,0x10,
+0x21,0x18,0x40,0x00,
+0x0C,0x00,0x50,0xAC,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x10,0x00,0x03,0x8E,
+0x02,0x80,0x02,0x3C,
+0xC0,0x54,0x42,0x24,
+0xC0,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x64,0x8C,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x00,0x00,0x04,0xAE,
+0x04,0x00,0x90,0xAC,
+0x04,0x00,0x03,0xAE,
+0x5C,0x60,0xC5,0x8C,
+0x10,0x00,0xA4,0x27,
+0x05,0x00,0xA0,0x10,
+0x00,0x00,0x70,0xAC,
+0x48,0x60,0xE2,0x8C,
+0x5C,0x60,0xC0,0xAC,
+0x25,0x10,0x45,0x00,
+0x48,0x60,0xE2,0xAC,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC9,0xF7,0x1B,0x6B,
+0x6B,0xEB,0x60,0x33,
+0xFF,0x6A,0x60,0x33,
+0x4C,0xEC,0x60,0xF1,
+0x00,0x4B,0xAC,0xEA,
+0x69,0xE2,0x80,0xC2,
+0x20,0xE8,0x00,0x65,
+0xFF,0x6A,0x8C,0xEA,
+0x15,0x5A,0x0E,0x60,
+0x01,0x6B,0x83,0x67,
+0x84,0xEA,0x02,0xF0,
+0x00,0x6A,0x40,0x32,
+0xEE,0xF0,0x10,0x4A,
+0x8C,0xEA,0x05,0x2A,
+0x0F,0x6A,0x8C,0xEA,
+0x02,0x6B,0x01,0x2A,
+0x00,0x6B,0x20,0xE8,
+0x43,0x67,0x00,0x00,
+0xFF,0x63,0x01,0xD1,
+0x8C,0x31,0x8D,0xE1,
+0x68,0x33,0x8D,0xE3,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x68,0x33,0x4D,0xE3,
+0x00,0xD0,0x04,0x67,
+0x83,0x67,0x04,0xF5,
+0xC4,0x9C,0x00,0x6A,
+0x04,0xF5,0x4A,0xC3,
+0x04,0xF5,0x4B,0xC3,
+0x1D,0x6D,0x01,0x6B,
+0xFF,0x6F,0xFF,0x4D,
+0x43,0x67,0x44,0xED,
+0xCC,0xEA,0x1E,0x2A,
+0xEC,0xED,0xF9,0x2D,
+0x09,0xE1,0x48,0x32,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x09,0xE2,0x63,0xF3,
+0x00,0x4B,0x48,0x32,
+0x71,0xE2,0x04,0xF5,
+0xC4,0x9C,0x00,0x6D,
+0x01,0x6B,0xFF,0x6F,
+0x43,0x67,0x44,0xED,
+0xCC,0xEA,0x0B,0x2A,
+0x01,0x4D,0xEC,0xED,
+0x1D,0x5D,0xF8,0x61,
+0x01,0x91,0x00,0x90,
+0x20,0xE8,0x01,0x63,
+0x04,0xF5,0xAA,0xC4,
+0xE1,0x17,0x01,0x91,
+0x00,0x90,0x04,0xF5,
+0xAB,0xC4,0x20,0xE8,
+0x01,0x63,0x00,0x00,
+0xFB,0x63,0x07,0xD1,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x00,0x6A,0x63,0xF3,
+0x00,0x49,0x08,0x62,
+0x06,0xD0,0x04,0xD2,
+0x34,0x10,0x03,0x54,
+0x62,0x60,0x01,0x74,
+0x6E,0x60,0x04,0xF5,
+0x88,0x99,0x07,0x6A,
+0xFF,0x6B,0x82,0x34,
+0x86,0x34,0x4C,0xEC,
+0x04,0x58,0x6C,0xEC,
+0x12,0x60,0x00,0x18,
+0x95,0x5B,0xB0,0x67,
+0xC9,0xF7,0x1B,0x6C,
+0x04,0xF5,0x60,0x99,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x4C,0xEB,
+0x80,0xF1,0x04,0x4C,
+0x08,0x32,0x89,0xE2,
+0x04,0xF5,0x64,0xD9,
+0x60,0xDA,0x00,0x18,
+0x45,0x28,0x04,0x94,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x04,0x93,
+0x80,0x34,0x80,0x34,
+0x60,0xF1,0x00,0x4C,
+0x89,0xE3,0x40,0xA2,
+0x04,0x92,0x7F,0x49,
+0x15,0x49,0x01,0x4A,
+0x20,0x5A,0x04,0xD2,
+0x48,0x60,0x04,0xF5,
+0xA8,0x99,0x01,0x6B,
+0xA2,0x34,0x92,0x32,
+0x6C,0xEA,0xFF,0x6B,
+0x6C,0xEA,0xF0,0x22,
+0xE4,0xF4,0x78,0x99,
+0xFF,0x6A,0x86,0x34,
+0x72,0x33,0x4C,0xEB,
+0x7F,0x6A,0x4C,0xEB,
+0x07,0x6A,0x4C,0xEC,
+0xFF,0x6A,0x4C,0xEC,
+0x07,0x68,0xAC,0xE8,
+0x02,0x74,0x4C,0xE8,
+0xB2,0x61,0x38,0x5B,
+0x0A,0x61,0x01,0xF6,
+0x01,0x6A,0x4B,0xEA,
+0xAC,0xEA,0x00,0xF2,
+0x00,0x6B,0x6D,0xEA,
+0x04,0xF5,0x48,0xD9,
+0xAA,0x17,0x14,0x5B,
+0xA8,0x60,0x01,0xF6,
+0x01,0x6A,0x4B,0xEA,
+0xAC,0xEA,0x00,0xF6,
+0x00,0x6B,0x6D,0xEA,
+0xF3,0x17,0x03,0x74,
+0x9E,0x61,0x1A,0x5B,
+0x9C,0x61,0x01,0xF6,
+0x01,0x6A,0x4B,0xEA,
+0xAC,0xEA,0x00,0xF4,
+0x00,0x6C,0x8D,0xEA,
+0x04,0xF5,0x48,0xD9,
+0x92,0x17,0x32,0x5B,
+0x90,0x60,0x01,0xF6,
+0x01,0x6A,0x4B,0xEA,
+0xAC,0xEA,0x00,0xF4,
+0x00,0x6B,0x6D,0xEA,
+0xDB,0x17,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0x6A,0x00,0xEF,
+0x05,0x63,0x00,0x00,
+0x20,0xE8,0x00,0x65,
+0xA4,0x67,0xC9,0xF7,
+0x1B,0x6C,0xFC,0x63,
+0x8B,0xEC,0x06,0xD0,
+0x80,0x34,0xAC,0x30,
+0xA1,0xE0,0x80,0x34,
+0x07,0x62,0x80,0xF1,
+0x40,0x44,0x08,0x30,
+0x40,0xA2,0xA1,0xE0,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x08,0x30,0x41,0xE0,
+0x04,0xF5,0x48,0x98,
+0x07,0x6B,0x80,0xF1,
+0x04,0x4C,0x6C,0xEA,
+0x48,0x32,0x89,0xE2,
+0x04,0xF5,0x60,0x98,
+0x40,0x9A,0x85,0x67,
+0x6C,0xEA,0x04,0xF5,
+0x44,0xD8,0x00,0x18,
+0x45,0x28,0x04,0xD5,
+0x04,0x95,0x04,0xF5,
+0x8A,0xA0,0xFF,0x6A,
+0x00,0x18,0x33,0x28,
+0x4C,0xED,0x07,0x97,
+0x06,0x90,0x00,0xEF,
+0x04,0x63,0x00,0x00,
+0xFF,0xF7,0x1F,0x6B,
+0x8C,0xEB,0x00,0xF2,
+0x00,0x6A,0x0B,0x6C,
+0x6C,0xEA,0x6C,0xEC,
+0x07,0x6B,0x0E,0x2A,
+0x0C,0x5C,0x0B,0x60,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x88,0x32,0x7E,0xF6,
+0x14,0x4B,0x69,0xE2,
+0x40,0x9A,0x00,0xEA,
+0x00,0x65,0x07,0x6B,
+0x20,0xE8,0x43,0x67,
+0x06,0x6B,0x20,0xE8,
+0x43,0x67,0x05,0x6B,
+0x20,0xE8,0x43,0x67,
+0x04,0x6B,0x20,0xE8,
+0x43,0x67,0x03,0x6B,
+0x20,0xE8,0x43,0x67,
+0x02,0x6B,0x20,0xE8,
+0x43,0x67,0x01,0x6B,
+0x20,0xE8,0x43,0x67,
+0x00,0x6B,0x20,0xE8,
+0x43,0x67,0x00,0x00,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0xF7,0x63,0x63,0xF3,
+0x00,0x4B,0x00,0x6A,
+0x0F,0xD1,0x23,0x67,
+0x10,0x62,0x0E,0xD0,
+0x04,0xD2,0x05,0xD3,
+0x06,0xD3,0x07,0xD3,
+0x08,0xD2,0x09,0xD2,
+0x0A,0xD2,0x0B,0xD2,
+0x0C,0xD2,0xE4,0xF4,
+0x08,0x49,0x48,0x99,
+0x01,0x6B,0xFF,0x6C,
+0x42,0x32,0x52,0x32,
+0x6C,0xEA,0x8C,0xEA,
+0x80,0xF0,0x11,0x22,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x04,0x96,0x40,0x32,
+0x60,0xF1,0x00,0x4A,
+0x49,0xE6,0x40,0xA2,
+0xFF,0x6B,0x4C,0xEC,
+0x05,0x92,0x0C,0x65,
+0x51,0xE4,0xC0,0xF4,
+0x4A,0xA4,0x6C,0xEA,
+0x61,0x99,0x58,0xEB,
+0xE0,0xF4,0x47,0xA4,
+0xFF,0x6B,0x6C,0xEA,
+0x62,0x99,0x12,0xED,
+0x00,0x65,0x00,0x65,
+0x58,0xEB,0x12,0xEA,
+0x55,0xE5,0xFF,0xF7,
+0x4C,0x99,0xA3,0xEA,
+0x40,0xF1,0x0F,0x61,
+0xAB,0xE2,0xFF,0xF7,
+0x4C,0xD9,0x61,0x99,
+0x42,0x99,0xC8,0x67,
+0xFF,0xF7,0xEC,0x99,
+0x55,0xE3,0xFF,0xF7,
+0x70,0x99,0xFF,0xF7,
+0x54,0x99,0x51,0xE3,
+0xFF,0xF7,0x7C,0x99,
+0x40,0x99,0x41,0xE3,
+0x05,0x93,0x69,0xE6,
+0x20,0xF5,0x5E,0xA2,
+0xFF,0x6E,0xCC,0xEA,
+0xC5,0x67,0x0F,0x25,
+0xA3,0xEA,0xD8,0x67,
+0x0D,0x2E,0x48,0x67,
+0x07,0x5A,0x04,0x61,
+0x0C,0x72,0x02,0x60,
+0x0D,0x72,0x05,0x61,
+0xAC,0x32,0xAB,0xE2,
+0x4E,0x32,0x83,0xEA,
+0x10,0x61,0x79,0x26,
+0x05,0x92,0x68,0x67,
+0x68,0x34,0x51,0xE4,
+0x06,0x92,0x69,0xE2,
+0x44,0xF5,0x66,0xA2,
+0xFF,0x6A,0x4C,0xEB,
+0x60,0xF5,0x40,0x9C,
+0x44,0xEB,0xE3,0xEA,
+0x6A,0x60,0x01,0x68,
+0x5F,0x99,0x70,0x67,
+0x88,0x67,0x64,0xEC,
+0x6C,0xEA,0x00,0xF1,
+0x1C,0x22,0x06,0x96,
+0x95,0xE6,0x44,0xF5,
+0x66,0xA5,0x04,0xF5,
+0xEC,0xA5,0xFF,0x6E,
+0x46,0x67,0xCC,0xEB,
+0x0A,0x6C,0xEC,0xEA,
+0x84,0xEB,0x82,0xEA,
+0x00,0xF1,0x0D,0x60,
+0x41,0x47,0x04,0xF5,
+0x4C,0xC5,0xCC,0xEA,
+0x8E,0xEA,0x02,0x2A,
+0x24,0xF5,0x09,0xC5,
+0x05,0x94,0x68,0x67,
+0x68,0x32,0x89,0xE2,
+0xC0,0xF5,0x94,0x9A,
+0x60,0xF5,0x40,0x9A,
+0x84,0x33,0x8D,0xE3,
+0x69,0xE2,0x4A,0x37,
+0xFF,0xF7,0xEC,0xD9,
+0x05,0x96,0x27,0xF1,
+0x44,0x9E,0xFF,0xF7,
+0x1F,0x72,0xC0,0xF0,
+0x1B,0x61,0x00,0x6B,
+0x61,0xD9,0x62,0xD9,
+0xFF,0xF7,0x70,0xD9,
+0xFF,0xF7,0x74,0xD9,
+0xFF,0xF7,0x78,0xD9,
+0xFF,0xF7,0x7C,0xD9,
+0x60,0xD9,0x04,0x94,
+0x0C,0x96,0x0B,0x92,
+0x01,0x4C,0x0A,0x93,
+0x04,0xD4,0x09,0x94,
+0x7F,0x4E,0x7F,0x4A,
+0x7F,0x4B,0x15,0x4E,
+0x15,0x4A,0x15,0x4B,
+0x7F,0x4C,0x15,0x4C,
+0x0C,0xD6,0x0B,0xD2,
+0x08,0x96,0x07,0x92,
+0x0A,0xD3,0x06,0x93,
+0x09,0xD4,0x04,0x94,
+0x7F,0x4E,0x7F,0x4A,
+0x7F,0x4B,0x15,0x4E,
+0x15,0x4A,0x15,0x4B,
+0x7F,0x49,0x20,0x54,
+0x08,0xD6,0x07,0xD2,
+0x06,0xD3,0x15,0x49,
+0x3F,0xF7,0x15,0x61,
+0x10,0x97,0x0F,0x91,
+0x0E,0x90,0x00,0xEF,
+0x09,0x63,0xA0,0xF0,
+0x0E,0x25,0xA0,0xF0,
+0x0E,0x2E,0xA4,0x32,
+0xA9,0xE2,0x4A,0x32,
+0x03,0xEA,0xC1,0x60,
+0x06,0x96,0x48,0x67,
+0x00,0x6B,0x51,0xE6,
+0x04,0xF5,0x6C,0xC4,
+0x01,0x6B,0x64,0xEA,
+0x5F,0x99,0x6F,0xEB,
+0x6C,0xEA,0x5F,0xD9,
+0x24,0xF5,0x49,0xA4,
+0xFF,0x6C,0x8C,0xEA,
+0x01,0x72,0x10,0x60,
+0x09,0x96,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x00,0x6D,
+0x63,0xF3,0x00,0x4A,
+0x4D,0xE6,0x85,0x67,
+0xA9,0xE3,0x01,0x4D,
+0x1D,0x55,0x44,0xF5,
+0x86,0xC2,0xFA,0x61,
+0x06,0x93,0x88,0x67,
+0x00,0x6E,0x89,0xE3,
+0x24,0xF5,0xC9,0xC2,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0xBE,0xF6,0x04,0x4A,
+0x00,0x9A,0x10,0xF0,
+0x02,0x6F,0x00,0xF4,
+0xE0,0x37,0x10,0xF0,
+0x02,0x6E,0x00,0xF4,
+0xC0,0x36,0x00,0x6D,
+0x5D,0xF3,0x08,0x4F,
+0xDD,0xF2,0x14,0x4E,
+0xA8,0x32,0xED,0xE2,
+0x60,0x9B,0x11,0xE2,
+0xC9,0xE2,0xC0,0xF5,
+0x74,0xDC,0x40,0x9A,
+0x01,0x4D,0x1D,0x55,
+0x60,0xF5,0x40,0xDC,
+0xF3,0x61,0x68,0x67,
+0x20,0x23,0x07,0x94,
+0xA8,0x67,0xFF,0x4D,
+0x04,0xF5,0x4B,0xA4,
+0xFF,0x68,0x42,0xED,
+0x18,0x61,0x08,0x96,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x69,0xE6,0x04,0xF5,
+0x8B,0xA2,0x04,0xF5,
+0xC4,0x9A,0x01,0x6F,
+0x0C,0xEC,0x67,0x67,
+0x64,0xED,0x46,0x67,
+0x6C,0xEA,0x6E,0xEA,
+0x00,0xF1,0x03,0x22,
+0xFF,0x4D,0x82,0xED,
+0xF6,0x60,0x88,0x67,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x88,0x32,0x63,0xF3,
+0x00,0x4E,0xC9,0xE2,
+0xC0,0xF5,0x94,0x9A,
+0x60,0xF5,0x40,0x9A,
+0x84,0x33,0x8D,0xE3,
+0x69,0xE2,0x4A,0x37,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x4B,0xF7,0x5E,0xA2,
+0xFF,0x6B,0x6C,0xEA,
+0x22,0x72,0xC0,0xF0,
+0x17,0x61,0x88,0x67,
+0x13,0x74,0x3F,0xF7,
+0x0D,0x60,0x07,0x96,
+0x01,0x6B,0x64,0xEC,
+0x64,0xF5,0x44,0x9E,
+0xFF,0xF7,0xEC,0xD9,
+0x6D,0xEA,0x64,0xF5,
+0x44,0xDE,0x05,0x96,
+0x27,0xF1,0x44,0x9E,
+0xFF,0xF7,0x1F,0x72,
+0x3F,0xF7,0x05,0x60,
+0x04,0x95,0xFF,0x6A,
+0x88,0x67,0x00,0x18,
+0x33,0x28,0x4C,0xED,
+0x1E,0x17,0x00,0x6B,
+0xFF,0xF7,0x6C,0xD9,
+0xB0,0x16,0x1F,0xF7,
+0x18,0x26,0x05,0x94,
+0x68,0x67,0x68,0x32,
+0x89,0xE2,0xC0,0xF5,
+0x54,0x9A,0x43,0xEF,
+0x4E,0x17,0x48,0x67,
+0x1C,0x5A,0xFF,0xF6,
+0x17,0x60,0x06,0x94,
+0x4D,0xE4,0x24,0xF5,
+0x49,0xA3,0xFF,0x6C,
+0x01,0x72,0x53,0x60,
+0x0C,0x96,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x00,0x6D,
+0x63,0xF3,0x00,0x4A,
+0x4D,0xE6,0x85,0x67,
+0xA9,0xE3,0x01,0x4D,
+0x1D,0x55,0x44,0xF5,
+0x86,0xC2,0xFA,0x61,
+0x06,0x93,0x88,0x67,
+0x00,0x6E,0x89,0xE3,
+0x01,0x6C,0x04,0xF5,
+0xCC,0xC2,0x24,0xF5,
+0xC9,0xC2,0x64,0x67,
+0x48,0x67,0x64,0xEA,
+0x5F,0x99,0x6F,0xEB,
+0x6C,0xEA,0x68,0x67,
+0x5F,0xD9,0x4E,0x23,
+0x20,0xF0,0x42,0xA1,
+0xA8,0x67,0x01,0x4D,
+0xA2,0xEA,0xFF,0x68,
+0x17,0x61,0x0A,0x93,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x89,0xE3,0x04,0xF5,
+0x8A,0xA2,0x04,0xF5,
+0xC4,0x9A,0x01,0x6F,
+0x0C,0xEC,0x67,0x67,
+0x64,0xED,0x46,0x67,
+0x6C,0xEA,0x6E,0xEA,
+0x6F,0x22,0x01,0x4D,
+0xA2,0xEC,0xF7,0x60,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x4B,0xF7,0x5E,0xA2,
+0x22,0x72,0xBF,0xF6,
+0x07,0x61,0x48,0x67,
+0xEE,0x4A,0xFF,0x6B,
+0x6C,0xEA,0x02,0x5A,
+0xBF,0xF6,0x00,0x60,
+0x18,0x6E,0x0E,0x65,
+0x9D,0x16,0xC8,0x67,
+0x18,0x5E,0x3F,0x61,
+0x44,0xF5,0x46,0xA3,
+0x4C,0xEC,0x05,0x5C,
+0x03,0x60,0x01,0x4A,
+0x44,0xF5,0x46,0xC3,
+0x06,0x93,0x88,0x67,
+0x00,0x6E,0x89,0xE3,
+0x01,0x6C,0x04,0xF5,
+0xCC,0xC2,0x24,0xF5,
+0xC9,0xC2,0x64,0x67,
+0x48,0x67,0x64,0xEA,
+0x5F,0x99,0x6F,0xEB,
+0x6C,0xEA,0x68,0x67,
+0x5F,0xD9,0xB2,0x2B,
+0x20,0xF0,0x42,0xA1,
+0xA4,0x67,0xFF,0x68,
+0xAD,0x22,0x0B,0x94,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x63,0xF3,0x00,0x4E,
+0xC9,0xE4,0x04,0xF5,
+0x8A,0xA2,0xE5,0x67,
+0x04,0xF5,0xC4,0x9A,
+0x0C,0xEC,0x67,0x67,
+0x64,0xED,0x46,0x67,
+0x6C,0xEA,0x6E,0xEA,
+0x09,0x22,0x01,0x4D,
+0xA2,0xEC,0x96,0x61,
+0x67,0x67,0x64,0xED,
+0x46,0x67,0x6C,0xEA,
+0x6E,0xEA,0xF7,0x2A,
+0x0C,0xED,0x0D,0x65,
+0x8D,0x17,0x48,0x67,
+0x05,0x5A,0x05,0x60,
+0x44,0xF5,0x46,0xA3,
+0x4C,0xEC,0x03,0x5C,
+0xBD,0x17,0x44,0xF5,
+0x46,0xA3,0x4C,0xEC,
+0x04,0x5C,0xB8,0x17,
+0x07,0x94,0x48,0x67,
+0x01,0x6B,0x64,0xEA,
+0x64,0xF5,0x44,0x9C,
+0x6D,0xEA,0x64,0xF5,
+0x44,0xDC,0x50,0x16,
+0x0C,0xED,0x0D,0x65,
+0x91,0x17,0x0C,0xED,
+0x0D,0x65,0xFD,0x16,
+0xFB,0x63,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x08,0x62,
+0x07,0xD1,0x06,0xD0,
+0x63,0xF3,0x00,0x4C,
+0x87,0xF0,0x7D,0xA4,
+0x87,0xF0,0x58,0x9C,
+0x69,0xE2,0x05,0xD2,
+0x05,0x93,0x87,0xF0,
+0x54,0x9C,0x43,0xEB,
+0xE0,0xF0,0x03,0x60,
+0x24,0x67,0x0E,0x10,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x05,0x94,0x63,0xF3,
+0x00,0x49,0x87,0xF0,
+0x54,0x99,0x10,0x4C,
+0x05,0xD4,0x43,0xEC,
+0xC0,0xF0,0x13,0x60,
+0x87,0xF0,0x5D,0xA1,
+0x05,0x94,0xFF,0xF7,
+0x1F,0x6D,0x10,0x4A,
+0x87,0xF0,0x5D,0xC1,
+0xEF,0xF7,0x1E,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x8C,0xED,0x40,0x32,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0xAA,0xF2,0x14,0x4C,
+0x4D,0xED,0x00,0x1C,
+0xCE,0x53,0x10,0x6E,
+0x46,0xF7,0x98,0x99,
+0x1F,0x6B,0x40,0xF4,
+0x82,0x30,0x6C,0xE8,
+0x0C,0x32,0x09,0xE2,
+0x48,0x32,0x09,0xE2,
+0x48,0x32,0x35,0xE2,
+0x04,0xF5,0x48,0x9D,
+0x01,0x6B,0x42,0x32,
+0x52,0x32,0x6C,0xEA,
+0xFF,0x6B,0x6C,0xEA,
+0xC5,0x22,0xC9,0xF7,
+0x1B,0x6B,0x6B,0xEB,
+0x60,0x33,0x60,0x33,
+0x60,0xF1,0x00,0x4B,
+0x69,0xE0,0x40,0xA2,
+0x46,0xF7,0x74,0x99,
+0xFF,0x6F,0x4C,0xEF,
+0x3F,0x69,0x80,0xF5,
+0x62,0x32,0x2C,0xEA,
+0xFF,0x6E,0x05,0x52,
+0x4C,0xEE,0x01,0x61,
+0x04,0x6E,0xC0,0xF7,
+0x62,0x32,0x0E,0x2A,
+0xE4,0xF4,0x54,0x9D,
+0x04,0x6E,0x01,0x4A,
+0xE4,0xF4,0x54,0xDD,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x46,0xF7,0x98,0x9A,
+0x82,0x32,0x52,0x32,
+0x1F,0x6B,0x6C,0xEA,
+0x08,0x52,0x4F,0x60,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x46,0xF7,0x54,0x9C,
+0x2C,0xEA,0xEE,0xEA,
+0x44,0x2A,0x72,0x26,
+0x01,0x76,0x05,0x61,
+0xC4,0xF4,0x5C,0x9D,
+0x01,0x4A,0xC4,0xF4,
+0x5C,0xDD,0x02,0x76,
+0x05,0x61,0xE4,0xF4,
+0x40,0x9D,0x01,0x4A,
+0xE4,0xF4,0x40,0xDD,
+0x03,0x76,0x05,0x61,
+0xE4,0xF4,0x44,0x9D,
+0x01,0x4A,0xE4,0xF4,
+0x44,0xDD,0x04,0x76,
+0x05,0x61,0xE4,0xF4,
+0x48,0x9D,0x01,0x4A,
+0xE4,0xF4,0x48,0xDD,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x89,0xE7,0xE4,0xF4,
+0x78,0x9D,0x00,0xF5,
+0x44,0xA2,0xFF,0x6C,
+0x72,0x33,0x8C,0xEA,
+0x43,0xEB,0x4C,0x61,
+0xE4,0xF4,0x4C,0x9D,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x01,0x4A,0xE4,0xF4,
+0x4C,0xDD,0xE8,0x32,
+0xE9,0xE2,0x69,0xE2,
+0xC9,0xE2,0xA0,0xF3,
+0x68,0xA2,0x8C,0xEB,
+0xC4,0xF4,0x54,0x9D,
+0x69,0xE2,0xC4,0xF4,
+0x54,0xDD,0x9D,0x67,
+0x00,0x1C,0x9A,0x40,
+0x10,0x4C,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x68,0xF2,
+0x58,0x9B,0x01,0x72,
+0x0A,0x61,0x05,0x70,
+0x08,0x61,0x46,0xF7,
+0x54,0x9B,0xC0,0xF7,
+0x42,0x32,0x03,0x22,
+0x00,0x6A,0x68,0xF2,
+0x58,0xDB,0x9D,0x67,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x00,0x1C,0xA0,0x40,
+0x10,0x4C,0x63,0xF3,
+0x00,0x49,0x05,0x94,
+0x87,0xF0,0x54,0x99,
+0x10,0x4C,0x43,0xEC,
+0x05,0xD4,0x3F,0xF7,
+0x0D,0x61,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0xEF,0x05,0x63,
+0xC4,0xF4,0x58,0x9D,
+0x01,0x4A,0xC4,0xF4,
+0x58,0xDD,0x88,0x17,
+0xE4,0xF4,0x50,0x9D,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x01,0x4A,0xE4,0xF4,
+0x50,0xDD,0xE8,0x32,
+0xE9,0xE2,0x89,0xE2,
+0xC9,0xE2,0x20,0xF4,
+0x79,0xA2,0xFF,0x6A,
+0x4C,0xEB,0xB2,0x17,
+0xE0,0x63,0x00,0x6A,
+0x3E,0x62,0x3D,0xD1,
+0x3C,0xD0,0xFC,0x63,
+0x1D,0xD2,0x62,0x67,
+0x1D,0x94,0x04,0x05,
+0x07,0x68,0x94,0x32,
+0xA9,0xE2,0x1E,0xD0,
+0x60,0xDA,0x1E,0x94,
+0x04,0x4A,0xFF,0x4C,
+0x00,0x54,0x1E,0xD4,
+0xF9,0x60,0x1D,0x95,
+0x01,0x4D,0x03,0x5D,
+0x1D,0xD5,0xEE,0x61,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x31,
+0x20,0x31,0xC0,0xF2,
+0x44,0x41,0x1D,0xD3,
+0x60,0xDA,0x41,0x99,
+0x01,0xF7,0x00,0x6B,
+0x01,0xF4,0x84,0x41,
+0x42,0x32,0x6C,0xEA,
+0x42,0x32,0x00,0x1C,
+0xEE,0x5A,0x33,0xD2,
+0x01,0xF4,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x31,0xD2,0x9D,0x67,
+0x70,0x4C,0x00,0x1C,
+0x9A,0x40,0x32,0xD2,
+0x1D,0x94,0x10,0x6D,
+0xA4,0xED,0x00,0x1C,
+0x3B,0x46,0xFF,0x4D,
+0x9D,0x67,0x70,0x4C,
+0x00,0x1C,0xA0,0x40,
+0x1F,0xD2,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x01,0x6C,0x9D,0x67,
+0x00,0x1C,0x9A,0x40,
+0x70,0x4C,0x1D,0x94,
+0x10,0x6D,0xA4,0xED,
+0x00,0x1C,0x3B,0x46,
+0xFF,0x4D,0x9D,0x67,
+0x70,0x4C,0x00,0x1C,
+0xA0,0x40,0x20,0xD2,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x00,0x1C,
+0x7F,0x43,0x1D,0x94,
+0xE1,0xF6,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0xD1,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x21,0xD2,
+0x71,0xF6,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x22,0xD2,0x71,0xF6,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x23,0xD2,
+0x71,0xF6,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x24,0xD2,0x71,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x25,0xD2,
+0x81,0xF6,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x26,0xD2,0x81,0xF6,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x27,0xD2,
+0x81,0xF6,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x28,0xD2,0x81,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x29,0xD2,
+0xD1,0xF6,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x2A,0xD2,0xD1,0xF6,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x2B,0xD2,
+0xD1,0xF6,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x2C,0xD2,0x2D,0xD2,
+0xE7,0xF7,0x0E,0x6A,
+0x40,0x32,0x40,0x32,
+0xA2,0x67,0xE1,0xF6,
+0x80,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x36,0xD2,
+0x36,0x95,0xD1,0xF6,
+0x8C,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x71,0xF6,
+0x80,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x71,0xF6,
+0x84,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x71,0xF6,
+0x88,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x71,0xF6,
+0x8C,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x81,0xF6,
+0x80,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x81,0xF6,
+0x84,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x81,0xF6,
+0x88,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0x81,0xF6,
+0x8C,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0xD1,0xF6,
+0x80,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0xD1,0xF6,
+0x84,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x36,0x95,0xD1,0xF6,
+0x88,0x41,0xF2,0xF2,
+0x1B,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x33,0x93,0x01,0x6A,
+0x1D,0x90,0x4E,0xEB,
+0x43,0xEB,0x58,0x67,
+0x39,0xD2,0x0F,0xF7,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x10,0xF0,
+0x00,0x4A,0x43,0xD2,
+0x00,0xF5,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x1E,0xD0,
+0x37,0xD2,0x11,0x67,
+0x01,0xF0,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x00,0x6B,0x40,0x32,
+0x1D,0xD3,0x38,0xD2,
+0x33,0x94,0x60,0xF1,
+0x13,0x24,0x39,0x95,
+0xE0,0xF1,0x0C,0x2D,
+0xA1,0xF6,0x8C,0x40,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x05,0xF0,
+0x00,0x6B,0x6B,0xEB,
+0x60,0x33,0x60,0x33,
+0x4C,0xEB,0x01,0x5B,
+0x58,0x67,0x91,0xF6,
+0x84,0x40,0x00,0x1C,
+0xEE,0x5A,0x35,0xD2,
+0xE0,0xF3,0x1F,0x6B,
+0x60,0x33,0x60,0x33,
+0x6C,0xEA,0x42,0x32,
+0x42,0x32,0xB1,0xF6,
+0x84,0x40,0x3D,0xD3,
+0x00,0x1C,0xEE,0x5A,
+0x2E,0xD2,0x3D,0x94,
+0x8C,0xEA,0x42,0x32,
+0x42,0x32,0x91,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xEE,0x5A,0x2F,0xD2,
+0x3D,0x95,0xB1,0xF6,
+0x8C,0x40,0xAC,0xEA,
+0x42,0x32,0x42,0x32,
+0x00,0x1C,0xEE,0x5A,
+0x30,0xD2,0x3D,0x93,
+0x2E,0x94,0x4C,0xEB,
+0x62,0x32,0x20,0xF1,
+0x00,0x74,0x42,0x32,
+0xA0,0xF2,0x15,0x60,
+0x2F,0x95,0x20,0xF1,
+0x00,0x75,0xA0,0xF2,
+0x10,0x60,0x30,0x93,
+0x20,0x73,0xA0,0xF2,
+0x0C,0x60,0x20,0x72,
+0x01,0x6B,0xA0,0xF2,
+0x08,0x60,0x2E,0x94,
+0x80,0x74,0xA0,0xF2,
+0x02,0x60,0x2F,0x95,
+0x80,0x75,0x80,0xF2,
+0x1E,0x60,0x30,0x94,
+0xE0,0xF3,0x00,0x74,
+0x80,0xF2,0x19,0x60,
+0xE0,0xF3,0x00,0x72,
+0x01,0x6A,0x80,0xF2,
+0x14,0x60,0x35,0x95,
+0x03,0x25,0x02,0x23,
+0x20,0xF4,0x19,0x2A,
+0x1D,0x95,0x01,0x4D,
+0x0A,0x5D,0x1D,0xD5,
+0x97,0x61,0x1E,0x92,
+0x01,0x4A,0x03,0x5A,
+0x1E,0xD2,0x8A,0x61,
+0x04,0x90,0x20,0xF4,
+0x09,0x28,0x0C,0x91,
+0x03,0x29,0x14,0x92,
+0xFF,0x6C,0x2B,0x22,
+0x90,0x67,0x00,0x18,
+0x95,0x5D,0xB1,0x67,
+0x03,0x5A,0x07,0x60,
+0x05,0x94,0x00,0x18,
+0x95,0x5D,0x0D,0x95,
+0x03,0x5A,0x00,0x6C,
+0x1E,0x61,0x14,0x93,
+0x90,0x67,0xA3,0x67,
+0x00,0x18,0x95,0x5D,
+0x40,0xD3,0x03,0x5A,
+0x07,0x60,0x05,0x94,
+0x00,0x18,0x95,0x5D,
+0x15,0x95,0x03,0x5A,
+0x00,0x6C,0x0F,0x61,
+0x40,0x95,0x00,0x18,
+0x95,0x5D,0x91,0x67,
+0x03,0x5A,0x40,0xF2,
+0x1E,0x60,0x0D,0x94,
+0x00,0x18,0x95,0x5D,
+0x15,0x95,0x03,0x5A,
+0x01,0x6C,0x40,0xF2,
+0x16,0x60,0xFF,0x74,
+0x40,0xF2,0x17,0x60,
+0x04,0x05,0x94,0x34,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0xB1,0xE4,0x63,0xF3,
+0x00,0x49,0x60,0x9C,
+0x43,0x99,0x00,0xF4,
+0x00,0x68,0xE0,0xF3,
+0x1F,0x6F,0x0B,0xE8,
+0xEC,0xEB,0x0C,0xEA,
+0x6D,0xEA,0x61,0x9C,
+0x02,0xF0,0x00,0x6E,
+0xCB,0xEE,0xEC,0xEB,
+0xC0,0x36,0xE0,0xF3,
+0x1F,0x4E,0x60,0x33,
+0x68,0x33,0xCC,0xEA,
+0xE7,0xF7,0x10,0x6D,
+0x6D,0xEA,0xAB,0xED,
+0x62,0x9C,0xA0,0x35,
+0xA0,0x35,0xFF,0x4D,
+0xEC,0xEB,0x00,0xF5,
+0x60,0x33,0xAC,0xEA,
+0x6D,0xEA,0x43,0xD9,
+0x63,0x9C,0x44,0x99,
+0xEC,0xEB,0x0C,0xEA,
+0x6D,0xEA,0x64,0x9C,
+0xCC,0xEA,0xEC,0xEB,
+0x60,0x33,0x68,0x33,
+0x6D,0xEA,0x65,0x9C,
+0xAC,0xEA,0xEC,0xEB,
+0x00,0xF5,0x60,0x33,
+0x6D,0xEA,0x44,0xD9,
+0x46,0x9C,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x4A,0xC9,
+0x47,0x9C,0x4B,0xC9,
+0x44,0x9B,0x80,0xF7,
+0x42,0x32,0x01,0x72,
+0xC0,0xF2,0x1E,0x61,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x31,
+0x20,0x31,0xE1,0xF6,
+0x80,0x41,0x00,0x1C,
+0xD1,0x5A,0x21,0x95,
+0xD1,0xF6,0x8C,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x22,0x95,0x71,0xF6,
+0x80,0x41,0x00,0x1C,
+0xD1,0x5A,0x23,0x95,
+0x71,0xF6,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x24,0x95,0x71,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x25,0x95,
+0x71,0xF6,0x8C,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x26,0x95,0x81,0xF6,
+0x80,0x41,0x00,0x1C,
+0xD1,0x5A,0x27,0x95,
+0x81,0xF6,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x28,0x95,0x81,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x29,0x95,
+0x81,0xF6,0x8C,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x2A,0x95,0xD1,0xF6,
+0x80,0x41,0x00,0x1C,
+0xD1,0x5A,0x2B,0x95,
+0xD1,0xF6,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x2C,0x95,0x81,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x2D,0x95,
+0x1F,0x96,0x10,0x6D,
+0xA4,0xED,0xFF,0x4D,
+0x00,0x1C,0x12,0x46,
+0x00,0x6C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x01,0x6C,0x20,0x96,
+0x10,0x6D,0xA4,0xED,
+0xFF,0x4D,0x00,0x1C,
+0x12,0x46,0x00,0x6C,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x00,0x1C,
+0x7F,0x43,0x00,0x6C,
+0x10,0x6D,0xA4,0xED,
+0x1E,0x6C,0x00,0x1C,
+0x3B,0x46,0xFF,0x4D,
+0x01,0x6E,0x22,0x67,
+0x4D,0xEE,0x10,0x6D,
+0x03,0x6A,0x4B,0xEA,
+0xA4,0xED,0x4C,0xEE,
+0xFF,0x4D,0x00,0x1C,
+0x12,0x46,0x1E,0x6C,
+0x00,0x1C,0x43,0x26,
+0x03,0x6C,0x10,0x6D,
+0x03,0x6A,0xD1,0x67,
+0xA4,0xED,0x1E,0x6C,
+0xFF,0x4D,0x00,0x1C,
+0x12,0x46,0x4D,0xEE,
+0x04,0x63,0x3E,0x97,
+0x3D,0x91,0x3C,0x90,
+0x00,0xEF,0x20,0x63,
+0xA0,0x6D,0xA0,0x35,
+0xA0,0x35,0x01,0xF4,
+0x84,0x40,0x2A,0xF4,
+0x10,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x08,0x6D,0xA0,0x35,
+0xA0,0x35,0x7F,0x4D,
+0x01,0xF4,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x65,0x4D,0x8F,0xF7,
+0x00,0x6D,0xAB,0xED,
+0xA0,0x35,0x21,0xF6,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0xA0,0x35,
+0x00,0xF2,0x14,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x41,0xF6,0x80,0x40,
+0x40,0xF1,0x08,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x0D,0xF0,
+0x16,0x6D,0xA0,0x35,
+0xA0,0x35,0x41,0xF6,
+0x84,0x40,0xA0,0xF4,
+0x02,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x41,0xF6,0x8C,0x40,
+0xC5,0xF0,0x11,0x6D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0xF2,
+0x14,0x6D,0xA0,0x35,
+0xA0,0x35,0x61,0xF6,
+0x80,0x40,0x40,0xF1,
+0x0D,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x05,0xF0,0x16,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x61,0xF6,0x84,0x40,
+0xA1,0xF0,0x1A,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x61,0xF6,
+0x8C,0x40,0xC5,0xF0,
+0x11,0x6D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x37,0x95,0x41,0xF6,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0x01,0x4D,
+0x38,0x95,0x41,0xF6,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0x01,0x4D,
+0x00,0x1C,0x43,0x26,
+0x03,0x6C,0xA0,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x01,0xF4,0x84,0x40,
+0x2A,0xF4,0x13,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x01,0xF4,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0xE4,0x6D,
+0x21,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x33,0x95,0x39,0x95,
+0x1F,0xF6,0x14,0x25,
+0x21,0xF0,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0xFF,0x6D,
+0x01,0x4D,0xAC,0xEA,
+0x42,0x32,0x34,0xD2,
+0x02,0x22,0x01,0x6A,
+0x34,0xD2,0xA0,0x35,
+0xA0,0x35,0x21,0xF0,
+0x80,0x41,0x3A,0xD5,
+0x00,0xF1,0x00,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x3A,0x95,
+0x21,0xF0,0x88,0x41,
+0x00,0xF1,0x00,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xA0,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x01,0xF4,0x84,0x41,
+0x2A,0xF4,0x10,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x08,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x7F,0x4D,0x01,0xF4,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x65,0x4D,
+0x43,0x93,0x21,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x60,0x35,
+0x3A,0x95,0x31,0xF6,
+0x80,0x41,0x0F,0xF4,
+0x00,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x3A,0x95,0x31,0xF6,
+0x84,0x41,0x09,0xF0,
+0x00,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x02,0xF0,0x01,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x31,0xF6,0x88,0x41,
+0x3B,0xD5,0x1B,0xF4,
+0x1F,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x3B,0x95,0x31,0xF6,
+0x8C,0x41,0x11,0xF4,
+0x1F,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x00,0xF2,0x14,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x41,0xF6,0x80,0x41,
+0x00,0xF1,0x02,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x0D,0xF0,
+0x16,0x6D,0xA0,0x35,
+0xA0,0x35,0x41,0xF6,
+0x84,0x41,0xC0,0xF4,
+0x07,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x41,0xF6,0x8C,0x41,
+0xC5,0xF0,0x11,0x6D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x61,0xF6,
+0x8C,0x41,0xC5,0xF0,
+0x11,0x6D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x3A,0x95,0x51,0xF6,
+0x80,0x41,0x0F,0xF4,
+0x00,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x3A,0x95,0x51,0xF6,
+0x84,0x41,0x09,0xF0,
+0x00,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x3B,0x95,0x51,0xF6,
+0x88,0x41,0x3B,0xF4,
+0x03,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x3B,0x95,0x51,0xF6,
+0x8C,0x41,0x31,0xF4,
+0x03,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x00,0xF2,0x14,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x61,0xF6,0x80,0x41,
+0x00,0xF1,0x02,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x05,0xF0,
+0x16,0x6D,0xA0,0x35,
+0xA0,0x35,0x61,0xF6,
+0x84,0x41,0x01,0xF5,
+0x07,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x41,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x37,0x95,0x41,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x38,0x95,
+0x00,0x1C,0x43,0x26,
+0x03,0x6C,0x00,0xF2,
+0x00,0x6A,0x40,0x32,
+0x40,0x32,0xA2,0x67,
+0x41,0xF6,0x8C,0x41,
+0xC5,0xF0,0x11,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x3C,0xD2,0x3C,0x95,
+0x61,0xF6,0x8C,0x41,
+0xC5,0xF0,0x11,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x41,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x37,0x95,
+0x41,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x38,0x95,0x00,0x1C,
+0x43,0x26,0x03,0x6C,
+0x01,0xF4,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x31,0x95,0x01,0xF4,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x32,0x95,
+0x21,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x6D,0x34,0x93,
+0x1F,0xF5,0x1E,0x2B,
+0x21,0xF0,0x80,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x3A,0x95,0x21,0xF0,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x3A,0x95,
+0x13,0x15,0x00,0x6A,
+0x6A,0x15,0x00,0x6B,
+0x56,0x15,0xFF,0x6C,
+0xFF,0x74,0xBF,0xF5,
+0x09,0x61,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x80,0x34,
+0x41,0xD4,0x81,0xF6,
+0x14,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF3,0x1F,0x6B,
+0x60,0x31,0x20,0x31,
+0x2C,0xEA,0x42,0x32,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x42,0x32,0x6C,0xEA,
+0x63,0x9C,0x00,0xF4,
+0x00,0x6D,0xAB,0xED,
+0xAC,0xEB,0x4D,0xEB,
+0x63,0xDC,0x41,0x94,
+0xE0,0xF3,0x1F,0x68,
+0x81,0xF6,0x1C,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x2C,0xEA,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x10,0x6D,0x63,0xF3,
+0x00,0x4C,0x42,0x32,
+0xAB,0xED,0x63,0x9C,
+0x42,0x32,0xA0,0x35,
+0x0C,0xEA,0xA0,0x35,
+0xE0,0xF3,0x1F,0x4D,
+0x40,0x32,0xAC,0xEB,
+0x48,0x32,0x4D,0xEB,
+0x63,0xDC,0x41,0x94,
+0xA1,0xF6,0x04,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x2C,0xEA,
+0x42,0x32,0x42,0x32,
+0x0C,0xEA,0xE7,0xF7,
+0x10,0x6C,0x10,0xF0,
+0x02,0x68,0x00,0xF4,
+0x00,0x30,0x63,0xF3,
+0x00,0x48,0x8B,0xEC,
+0x63,0x98,0x80,0x34,
+0x80,0x34,0xFF,0x4C,
+0x00,0xF5,0x40,0x32,
+0x8C,0xEB,0x4D,0xEB,
+0x63,0xD8,0x41,0x94,
+0xA1,0xF6,0x0C,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x2C,0xEA,
+0x64,0x98,0x42,0x32,
+0x00,0xF4,0x00,0x68,
+0xE0,0xF3,0x1F,0x6D,
+0x0B,0xE8,0x42,0x32,
+0xAC,0xEA,0x0C,0xEB,
+0x4D,0xEB,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x64,0xDA,
+0x41,0x94,0xE0,0xF3,
+0x1F,0x68,0xA1,0xF6,
+0x14,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x2C,0xEA,0x42,0x32,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x10,0x6D,0x63,0xF3,
+0x00,0x4C,0xE0,0xF3,
+0x1F,0x6B,0x42,0x32,
+0xAB,0xED,0x6C,0xEA,
+0xA0,0x35,0x64,0x9C,
+0xA0,0x35,0xE0,0xF3,
+0x1F,0x4D,0x40,0x32,
+0xAC,0xEB,0x48,0x32,
+0x4D,0xEB,0x64,0xDC,
+0x41,0x94,0xA1,0xF6,
+0x1C,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0xE7,0xF7,0x10,0x6D,
+0x63,0xF3,0x00,0x4C,
+0x2C,0xEA,0xAB,0xED,
+0x64,0x9C,0x42,0x32,
+0xA0,0x35,0x42,0x32,
+0xA0,0x35,0xFF,0x4D,
+0x0C,0xEA,0xAC,0xEB,
+0x00,0xF5,0x40,0x32,
+0x4D,0xEB,0x64,0xDC,
+0x41,0x94,0x10,0xF0,
+0x02,0x68,0x00,0xF4,
+0x00,0x30,0x63,0xF3,
+0x00,0x48,0xC1,0xF6,
+0x04,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x2C,0xEA,0x42,0x32,
+0x42,0x32,0x4A,0xC8,
+0x41,0x94,0xC1,0xF6,
+0x0C,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x4C,0xE9,0x22,0x32,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x42,0x32,0x63,0xF3,
+0x00,0x4B,0x4B,0xC8,
+0x44,0x9B,0x80,0xF7,
+0x42,0x32,0x01,0x72,
+0x3F,0xF5,0x02,0x60,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x31,
+0x20,0x31,0x81,0xF4,
+0x80,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x82,0x67,0x10,0xF0,
+0x02,0x68,0x00,0xF4,
+0x00,0x30,0x40,0x6A,
+0x4B,0xEA,0x63,0xF3,
+0x00,0x48,0x40,0x32,
+0xC3,0x98,0x40,0x32,
+0x8C,0xEA,0xE0,0xF3,
+0x1F,0x6B,0x80,0xF5,
+0x42,0x35,0xCC,0xEB,
+0x00,0xF2,0x00,0x6A,
+0x6C,0xEA,0x04,0x22,
+0x00,0xF4,0x00,0x6A,
+0x4B,0xEA,0x4D,0xEB,
+0xB8,0xEB,0xE0,0xF3,
+0x1F,0x68,0x12,0xEA,
+0x42,0x33,0x0C,0xEB,
+0xC2,0x30,0xE0,0xF3,
+0x1F,0x6A,0x0A,0x30,
+0x4C,0xE8,0x00,0xF2,
+0x00,0x6A,0x0C,0xEA,
+0x04,0x22,0x00,0xF4,
+0x00,0x6A,0x4B,0xEA,
+0x4D,0xE8,0xB8,0xE8,
+0xE0,0xF3,0x1F,0x6D,
+0x12,0xEA,0x42,0x30,
+0x3F,0x6A,0x4B,0xEA,
+0xAC,0xE8,0x40,0x32,
+0x3F,0x6D,0x42,0xD5,
+0x40,0x32,0x0C,0xED,
+0x1F,0xF4,0x00,0x4A,
+0xA0,0x35,0x4C,0xEC,
+0xA0,0x35,0x8D,0xED,
+0x81,0xF4,0x80,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x6D,0xED,0x91,0xF4,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x02,0xF0,0x00,0x6B,
+0x60,0x33,0x60,0x33,
+0xFF,0x4B,0xC0,0xF3,
+0x00,0x6C,0x6C,0xEA,
+0x8C,0xE8,0x80,0xF5,
+0x00,0x33,0xA2,0x67,
+0x91,0xF4,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x6D,0xED,0x81,0xF4,
+0x88,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0xBE,0xF6,0x08,0x4D,
+0x82,0x67,0x40,0x9D,
+0x8C,0xEA,0x80,0xF5,
+0x42,0x35,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x04,0x9A,
+0xE0,0xF3,0x1F,0x6A,
+0x02,0x33,0x6A,0x33,
+0x4C,0xEB,0x00,0xF2,
+0x00,0x6A,0x6C,0xEA,
+0x04,0x22,0x00,0xF4,
+0x00,0x6A,0x4B,0xEA,
+0x4D,0xEB,0xB8,0xEB,
+0x00,0xF5,0x02,0x30,
+0x12,0xEA,0x42,0x33,
+0xE0,0xF3,0x1F,0x6A,
+0x4C,0xE8,0x4C,0xEB,
+0x00,0xF2,0x00,0x6A,
+0x0C,0xEA,0x04,0x22,
+0x00,0xF4,0x00,0x6A,
+0x4B,0xEA,0x4D,0xE8,
+0xB8,0xE8,0xE0,0xF3,
+0x1F,0x6D,0x12,0xEA,
+0x42,0x30,0xAC,0xE8,
+0x3F,0x6A,0x42,0x95,
+0x4B,0xEA,0x40,0x32,
+0x0C,0xED,0x40,0x32,
+0x1F,0xF4,0x00,0x4A,
+0x42,0xD5,0xA0,0x35,
+0x4C,0xEC,0xA0,0x35,
+0x8D,0xED,0x81,0xF4,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x6D,0xED,
+0x91,0xF4,0x8C,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0xBE,0xF6,
+0x0C,0x4B,0xA0,0x9B,
+0xC0,0xF3,0x00,0x6C,
+0x8C,0xE8,0x4C,0xED,
+0x80,0xF5,0x00,0x32,
+0x91,0xF4,0x8C,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x4D,0xED,0x58,0x14,
+0x0C,0x91,0xDF,0xF3,
+0x19,0x10,0x1E,0x93,
+0x04,0x04,0x74,0x32,
+0x91,0xE2,0x3E,0xD4,
+0x91,0xF6,0x84,0x40,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0xE0,0xF3,
+0x1F,0x6B,0x60,0x33,
+0x60,0x33,0x3E,0x95,
+0x6C,0xEA,0x42,0x32,
+0x42,0x32,0x3F,0xD3,
+0x91,0xF6,0x8C,0x40,
+0x00,0x1C,0xEE,0x5A,
+0x40,0xDD,0x3F,0x93,
+0x3E,0x94,0x6C,0xEA,
+0x42,0x32,0x42,0x32,
+0x41,0xDC,0xA1,0xF6,
+0x84,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x3F,0x95,0x3E,0x93,
+0xA1,0xF6,0x8C,0x40,
+0xAC,0xEA,0x42,0x32,
+0x42,0x32,0x00,0x1C,
+0xEE,0x5A,0x42,0xDB,
+0x3F,0x94,0x3E,0x95,
+0x8C,0xEA,0x42,0x32,
+0x42,0x32,0xB1,0xF6,
+0x84,0x40,0x00,0x1C,
+0xEE,0x5A,0x43,0xDD,
+0x3F,0x93,0x3E,0x94,
+0x6C,0xEA,0x42,0x32,
+0x42,0x32,0x44,0xDC,
+0xB1,0xF6,0x8C,0x40,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x3F,0x95,
+0x3E,0x93,0xC1,0xF6,
+0x84,0x40,0xAC,0xEA,
+0x42,0x32,0x42,0x32,
+0x00,0x1C,0xEE,0x5A,
+0x45,0xDB,0x3F,0x94,
+0x3E,0x95,0x8C,0xEA,
+0x42,0x32,0x42,0x32,
+0xC1,0xF6,0x8C,0x40,
+0x00,0x1C,0xEE,0x5A,
+0x46,0xDD,0x3F,0x93,
+0x3E,0x94,0x4C,0xEB,
+0x62,0x32,0x42,0x32,
+0x47,0xDC,0x7F,0xF3,
+0x0E,0x10,0x00,0x00,
+0xFB,0x63,0x07,0xD1,
+0x0C,0xF0,0x00,0x6A,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x63,0xF3,0x00,0x49,
+0x08,0x62,0x0A,0xD4,
+0x06,0xD0,0x4B,0xEA,
+0x62,0x99,0x40,0x32,
+0x40,0x32,0xFF,0x4A,
+0x4C,0xEB,0xC9,0xF7,
+0x1B,0x6C,0x04,0xF0,
+0x00,0x6A,0x40,0x32,
+0x8B,0xEC,0x40,0x32,
+0x80,0x34,0x4D,0xEB,
+0x80,0x34,0x62,0xD9,
+0x04,0xD4,0x81,0xF6,
+0x14,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF3,0x1F,0x6B,
+0x60,0x30,0x00,0x30,
+0x0C,0xEA,0x42,0x32,
+0x42,0x32,0x6C,0xEA,
+0x63,0x99,0x00,0xF4,
+0x00,0x6C,0x8B,0xEC,
+0x8C,0xEB,0x4D,0xEB,
+0x63,0xD9,0x04,0x94,
+0x81,0xF6,0x1C,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x0C,0xEA,
+0x42,0x32,0x10,0x6C,
+0xE0,0xF3,0x1F,0x6B,
+0x42,0x32,0x8B,0xEC,
+0x6C,0xEA,0x80,0x34,
+0x63,0x99,0x80,0x34,
+0xE0,0xF3,0x1F,0x4C,
+0x40,0x32,0x48,0x32,
+0x8C,0xEB,0x4D,0xEB,
+0x63,0xD9,0x04,0x94,
+0xA1,0xF6,0x04,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x0C,0xEA,
+0x42,0x32,0xE7,0xF7,
+0x10,0x6C,0xE0,0xF3,
+0x1F,0x6B,0x42,0x32,
+0x8B,0xEC,0x6C,0xEA,
+0x80,0x34,0x63,0x99,
+0x80,0x34,0xFF,0x4C,
+0x00,0xF5,0x40,0x32,
+0x8C,0xEB,0x4D,0xEB,
+0x63,0xD9,0x04,0x94,
+0xA1,0xF6,0x0C,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x0C,0xEA,
+0x42,0x32,0xE0,0xF3,
+0x1F,0x6B,0x42,0x32,
+0x6C,0xEA,0x64,0x99,
+0x00,0xF4,0x00,0x6C,
+0x8B,0xEC,0x8C,0xEB,
+0x4D,0xEB,0x64,0xD9,
+0x04,0x94,0xA1,0xF6,
+0x14,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x0C,0xEA,0x42,0x32,
+0x10,0x6C,0xE0,0xF3,
+0x1F,0x6B,0x42,0x32,
+0x8B,0xEC,0x6C,0xEA,
+0x80,0x34,0x64,0x99,
+0x80,0x34,0xE0,0xF3,
+0x1F,0x4C,0x40,0x32,
+0x48,0x32,0x8C,0xEB,
+0x4D,0xEB,0x64,0xD9,
+0x04,0x94,0xA1,0xF6,
+0x1C,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x0C,0xEA,0x42,0x32,
+0xE7,0xF7,0x10,0x6C,
+0xE0,0xF3,0x1F,0x6B,
+0x42,0x32,0x8B,0xEC,
+0x6C,0xEA,0x80,0x34,
+0x64,0x99,0x80,0x34,
+0xFF,0x4C,0x00,0xF5,
+0x40,0x32,0x8C,0xEB,
+0x4D,0xEB,0x64,0xD9,
+0x04,0x94,0xC1,0xF6,
+0x04,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x0C,0xEA,0x42,0x32,
+0x42,0x32,0x4A,0xC9,
+0x04,0x94,0xC1,0xF6,
+0x0C,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x4C,0xE8,0xFF,0x6A,
+0x01,0x4A,0x40,0x32,
+0x40,0x32,0x0A,0x93,
+0x80,0x4A,0x02,0x30,
+0x80,0x4A,0x02,0x30,
+0x6C,0xEA,0x0B,0xC9,
+0x14,0x22,0x1F,0xF7,
+0x00,0x6A,0x0A,0x94,
+0x4C,0xEB,0x62,0x33,
+0xC0,0xF2,0x63,0xC1,
+0x82,0x33,0x4C,0xEB,
+0x62,0x33,0xC0,0xF2,
+0x67,0xC1,0x00,0x18,
+0xFE,0x5D,0x00,0x65,
+0x08,0x97,0x07,0x91,
+0x06,0x90,0x00,0xEF,
+0x05,0x63,0x12,0x6A,
+0xC0,0xF2,0x43,0xC1,
+0xC0,0xF2,0x47,0xC1,
+0x00,0x18,0xFE,0x5D,
+0x00,0x65,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0xEF,0x05,0x63,
+0xC9,0xF7,0x1B,0x6A,
+0xFB,0x63,0x4B,0xEA,
+0x06,0xD0,0x40,0x30,
+0x07,0xD1,0x08,0x62,
+0x00,0x30,0x40,0xF0,
+0x4C,0xA0,0x03,0x69,
+0x4C,0xE9,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x62,0x67,
+0x04,0xD2,0x63,0xF3,
+0x00,0x4B,0xC3,0xF3,
+0x41,0xA3,0x2E,0xEA,
+0x1A,0x22,0x05,0x29,
+0xE0,0xF2,0x66,0xA3,
+0xFF,0x6A,0x4C,0xEB,
+0x1A,0x23,0x04,0x92,
+0xC9,0xF7,0x17,0x6C,
+0x8B,0xEC,0x63,0xF3,
+0x00,0x4A,0x04,0xD2,
+0xC3,0xF3,0x21,0xC2,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x76,0x9A,
+0x80,0x34,0x80,0x34,
+0x60,0xDC,0x57,0x9A,
+0x41,0xDC,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0x6A,0x00,0xEF,
+0x05,0x63,0x51,0xF4,
+0x80,0x40,0x00,0x1C,
+0xE4,0x5A,0x1C,0x6D,
+0x51,0xF4,0x88,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x1C,0x6D,0xDB,0x17,
+0xF9,0x63,0x0A,0xD0,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x00,0x30,
+0x00,0x30,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x0B,0xD1,
+0xA1,0xF5,0x82,0x40,
+0x22,0x67,0x63,0xF3,
+0x00,0x49,0x0C,0x62,
+0x00,0x1C,0xF1,0x5A,
+0x06,0xD2,0xC0,0xF2,
+0x58,0xC9,0xA1,0xF5,
+0x84,0x40,0x00,0x1C,
+0xF1,0x5A,0x00,0x65,
+0xC0,0xF2,0x5A,0xC9,
+0xA1,0xF5,0x86,0x40,
+0x00,0x1C,0xF1,0x5A,
+0x00,0x65,0xC0,0xF2,
+0x5C,0xC9,0xA1,0xF5,
+0x88,0x40,0x00,0x1C,
+0xF1,0x5A,0x00,0x65,
+0x82,0x67,0xC0,0xF2,
+0x7A,0xA9,0xC0,0xF2,
+0x5E,0xC9,0xC0,0xF2,
+0x58,0xA9,0x69,0xE2,
+0xC0,0xF2,0x7C,0xA9,
+0x69,0xE2,0x51,0xE4,
+0x04,0xD4,0x21,0xF2,
+0x8D,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0x00,0xF6,0x40,0x35,
+0x00,0xF6,0xA3,0x35,
+0x40,0x6A,0xFF,0x6B,
+0x4D,0xED,0x6C,0xED,
+0x21,0xF2,0x8D,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x05,0xD3,0x51,0xF2,
+0x8B,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0x40,0x32,0x51,0xF2,
+0x8C,0x40,0xE0,0xF2,
+0x44,0xC9,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0xE0,0xF2,0x64,0xA9,
+0xFF,0xF7,0x1F,0x6C,
+0x69,0xE2,0xE0,0xF2,
+0x44,0xC9,0x8C,0xEA,
+0x04,0x94,0x8D,0xE2,
+0x43,0xA9,0xFF,0xF7,
+0x1F,0x6C,0xE0,0xF2,
+0x60,0xD9,0x8C,0xEA,
+0x10,0x52,0x03,0x60,
+0x1F,0x5B,0xA0,0xF0,
+0x0C,0x61,0x00,0x6A,
+0xC0,0xF2,0x54,0xC1,
+0xC0,0xF2,0x55,0xA1,
+0x05,0x93,0x01,0x4A,
+0x4C,0xEB,0x03,0x53,
+0x80,0xF0,0x19,0x60,
+0xC0,0xF2,0x55,0xC1,
+0x06,0x94,0x00,0x6A,
+0x11,0x6B,0x63,0xF3,
+0x00,0x4C,0x43,0xCC,
+0xE0,0xF2,0x44,0xCC,
+0x40,0x9C,0x6C,0xEA,
+0x01,0x72,0x75,0x61,
+0xE0,0xF2,0x44,0x9C,
+0x03,0x6B,0x00,0xF7,
+0x42,0x32,0x6C,0xEA,
+0x6E,0x2A,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x40,0xF0,0x4C,0xA2,
+0x4C,0xEB,0x01,0x73,
+0xA0,0xF0,0x0F,0x60,
+0x06,0x94,0xFF,0x6E,
+0x63,0xF3,0x00,0x4C,
+0xE0,0xF2,0x46,0xA4,
+0xA0,0xF0,0x15,0x2A,
+0x40,0x9C,0x01,0x6B,
+0x56,0x32,0x6C,0xEA,
+0xA0,0xF0,0x0F,0x22,
+0x3E,0x6A,0xC0,0xF2,
+0x50,0xC4,0x17,0x6A,
+0xC0,0xF2,0x51,0xC4,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x40,0xF0,
+0x4C,0xA2,0x03,0x6B,
+0xCC,0xEA,0x6C,0xEA,
+0x44,0x22,0x66,0xF7,
+0x6C,0x9C,0xFF,0xF7,
+0x1F,0x73,0x3F,0x60,
+0x0C,0x6A,0xC0,0xF2,
+0x52,0xC4,0x72,0x32,
+0x7F,0x6B,0x6C,0xEA,
+0xC0,0xF2,0x6E,0xA4,
+0xFE,0x4A,0x00,0xF6,
+0x40,0x35,0x46,0x67,
+0x00,0xF6,0xA3,0x35,
+0x6C,0xEA,0xA2,0xEA,
+0x00,0xF1,0x01,0x60,
+0x00,0xF6,0x60,0x35,
+0x00,0xF6,0xA3,0x35,
+0x06,0x92,0x63,0xF3,
+0x00,0x4A,0xE0,0xF2,
+0x40,0x9A,0x04,0xF7,
+0x11,0x5A,0xE0,0xF0,
+0x08,0x61,0x32,0x55,
+0xE0,0xF0,0x05,0x60,
+0x32,0x6D,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x21,0xF4,0x10,0x4A,
+0x44,0x6B,0xC9,0xF7,
+0x1B,0x68,0x0B,0xE8,
+0x60,0xC2,0x00,0x30,
+0xFF,0x6A,0xAC,0xEA,
+0x00,0x30,0xA2,0x67,
+0x51,0xF4,0x80,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x08,0xD2,0x08,0x92,
+0x51,0xF4,0x88,0x40,
+0x00,0x1C,0xE4,0x5A,
+0xA2,0x67,0x00,0x18,
+0xEE,0x5F,0x00,0x65,
+0x06,0x92,0x63,0xF3,
+0x00,0x4A,0x06,0xD2,
+0x66,0xF7,0x6C,0x9A,
+0x7F,0x6A,0x72,0x33,
+0x4C,0xEB,0x1E,0x5B,
+0x23,0x61,0x24,0x5B,
+0x31,0x60,0x0C,0x97,
+0x0B,0x91,0x0A,0x90,
+0x00,0x6A,0x00,0xEF,
+0x07,0x63,0x03,0x6A,
+0xC0,0xF2,0x55,0xC1,
+0x40,0x99,0x08,0x6B,
+0x6D,0xEA,0x40,0xD9,
+0x61,0x17,0x00,0x6A,
+0xC0,0xF2,0x55,0xC1,
+0xC0,0xF2,0x54,0xA1,
+0x05,0x94,0x01,0x4A,
+0x4C,0xEC,0x03,0x54,
+0x2F,0x61,0x03,0x6A,
+0xC0,0xF2,0x54,0xC1,
+0x40,0x99,0x09,0x6B,
+0x6B,0xEB,0x6C,0xEA,
+0x40,0xD9,0x4E,0x17,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x01,0xF2,
+0x0A,0x4C,0x00,0x1C,
+0xE4,0x5A,0x40,0x6D,
+0x0C,0x97,0x0B,0x91,
+0x0A,0x90,0x00,0x6A,
+0x00,0xEF,0x07,0x63,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x01,0xF2,
+0x0A,0x4C,0x00,0x1C,
+0xE4,0x5A,0x83,0x6D,
+0xEF,0x17,0xE0,0xF2,
+0x66,0xA4,0xFF,0x6A,
+0x4C,0xEB,0x5F,0xF7,
+0x0B,0x2B,0x01,0x6A,
+0x4B,0xEA,0xE0,0xF2,
+0x46,0xC4,0x46,0x17,
+0xC0,0xF2,0x54,0xC1,
+0x25,0x17,0x06,0x90,
+0xFF,0x6D,0x63,0xF3,
+0x00,0x48,0xE0,0xF2,
+0x46,0xA0,0xAA,0xEA,
+0x9E,0x61,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x80,0x34,
+0x41,0xF4,0x10,0x4C,
+0x00,0x1C,0xF4,0x5A,
+0x09,0xD5,0x09,0x95,
+0x00,0xF6,0x40,0x31,
+0x00,0xF6,0x23,0x31,
+0x7F,0x6A,0xAC,0xE9,
+0x4C,0xE9,0xE0,0xF2,
+0x60,0x98,0xC0,0xF2,
+0x48,0xA8,0xFF,0xF7,
+0x1F,0x6C,0x43,0xEB,
+0x37,0x61,0xC0,0xF2,
+0x4A,0xA8,0x8C,0xEA,
+0x43,0xEB,0x07,0x61,
+0xC0,0xF2,0x4C,0xA8,
+0x8C,0xEA,0x43,0xEB,
+0x57,0x60,0x01,0x49,
+0xAC,0xE9,0x06,0x93,
+0x63,0xF3,0x00,0x4B,
+0xC0,0xF2,0x50,0xA3,
+0x23,0xEA,0x31,0x60,
+0x22,0x67,0x06,0x92,
+0x63,0xF3,0x00,0x4A,
+0xE0,0xF2,0x40,0x9A,
+0x04,0xF7,0x11,0x5A,
+0x1D,0x61,0x32,0x69,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x21,0xF4,
+0x10,0x4A,0x44,0x6B,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x00,0x30,
+0x00,0x30,0x51,0xF4,
+0x80,0x40,0xB1,0x67,
+0x60,0xC2,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0x51,0xF4,0x88,0x40,
+0x00,0x1C,0xE4,0x5A,
+0xB1,0x67,0x4D,0x17,
+0xFF,0x49,0xD2,0x17,
+0x3A,0x59,0xE2,0x61,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x21,0xF4,
+0x10,0x4A,0x48,0x6B,
+0xE1,0x17,0xC0,0xF2,
+0x71,0xA3,0xFF,0x6A,
+0x4C,0xEB,0x63,0xE9,
+0xCA,0x60,0x23,0x67,
+0xC8,0x17,0x3A,0x55,
+0x1F,0xF7,0x19,0x61,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x21,0xF4,
+0x10,0x4A,0x48,0x6B,
+0x18,0x17,0xC0,0xF2,
+0x4F,0xA4,0x4C,0xEE,
+0xC2,0xED,0xFF,0xF6,
+0x1D,0x60,0x00,0xF6,
+0x40,0x35,0xF8,0x16,
+0x02,0x49,0xA8,0x17,
+0xFB,0x63,0x06,0xD0,
+0x02,0xF0,0x00,0x68,
+0x00,0x30,0xAF,0x40,
+0xFF,0xF0,0x10,0x6E,
+0x15,0x6C,0x08,0x62,
+0x00,0x1C,0x12,0x46,
+0x07,0xD1,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x1A,0x6C,0x46,0xF0,
+0x16,0x6E,0x00,0x1C,
+0x12,0x46,0xAF,0x40,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x04,0xD2,
+0x63,0xF3,0x40,0x9A,
+0x01,0x6B,0x4E,0x32,
+0x6C,0xEA,0x0A,0x22,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x00,0xF3,0x47,0xA3,
+0x01,0x72,0x1C,0x61,
+0x04,0x92,0x63,0xF3,
+0x20,0x9A,0x01,0x6A,
+0x2E,0x31,0x4C,0xE9,
+0x09,0x29,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x00,0xF3,
+0x47,0xA3,0x5A,0x2A,
+0x04,0x93,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x63,0xF3,0x00,0x4B,
+0x04,0xD3,0x04,0x6A,
+0x00,0xF3,0x44,0xC3,
+0x00,0xEF,0x05,0x63,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x31,
+0x24,0xF2,0x02,0x68,
+0x20,0x31,0x00,0x30,
+0x01,0xF6,0x88,0x41,
+0x24,0xF2,0x02,0x6D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x30,0x01,0xF6,
+0x80,0x41,0x24,0xF2,
+0xA2,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x01,0xF6,0x84,0x41,
+0x24,0xF2,0xA2,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x11,0xF6,
+0x80,0x41,0x24,0xF2,
+0xA2,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x11,0xF6,0x84,0x41,
+0x24,0xF2,0xA2,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x11,0xF6,
+0x88,0x41,0x24,0xF2,
+0xA2,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x11,0xF6,0x8C,0x41,
+0x24,0xF2,0xA2,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x01,0x6B,
+0x63,0xF3,0x00,0x4A,
+0x00,0xF3,0x67,0xC2,
+0x04,0x93,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x63,0xF3,0x00,0x4B,
+0x04,0xD3,0x04,0x6A,
+0x00,0xF3,0x44,0xC3,
+0x00,0xEF,0x05,0x63,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x00,0xF3,
+0xB4,0x9B,0x00,0x30,
+0x00,0x30,0x01,0xF6,
+0x80,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x00,0xF3,0xB4,0x9A,
+0x01,0xF6,0x84,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x00,0xF3,
+0xB8,0x9B,0x01,0xF6,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x00,0xF3,0xB4,0x9A,
+0x11,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x00,0xF3,
+0xB4,0x9B,0x11,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x00,0xF3,0xB4,0x9A,
+0x11,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x00,0xF3,
+0xB4,0x9B,0x11,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x00,0xF3,0x27,0xC2,
+0x04,0x93,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x63,0xF3,0x00,0x4B,
+0x04,0xD3,0x04,0x6A,
+0x00,0xF3,0x44,0xC3,
+0x00,0xEF,0x05,0x63,
+0xFB,0x63,0x06,0xD0,
+0x02,0xF0,0x00,0x68,
+0x00,0x30,0xAF,0x40,
+0xFF,0xF0,0x10,0x6E,
+0x15,0x6C,0x08,0x62,
+0x00,0x1C,0x12,0x46,
+0x07,0xD1,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x1A,0x6C,0x46,0xF0,
+0x16,0x6E,0x00,0x1C,
+0x12,0x46,0xAF,0x40,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x05,0xD2,
+0x63,0xF3,0x40,0x9A,
+0x01,0x6B,0x4E,0x32,
+0x6C,0xEA,0x0A,0x22,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x00,0xF3,0x47,0xA3,
+0x01,0x72,0x1D,0x61,
+0x05,0x92,0x63,0xF3,
+0x20,0x9A,0x01,0x6A,
+0x2E,0x31,0x4C,0xE9,
+0x09,0x29,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x00,0xF3,
+0x47,0xA3,0x5C,0x2A,
+0x05,0x92,0x08,0x97,
+0x07,0x91,0x63,0xF3,
+0x00,0x4A,0x05,0xD2,
+0x05,0x93,0x06,0x90,
+0x01,0x6A,0x00,0xF3,
+0x44,0xC3,0x00,0xEF,
+0x05,0x63,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x31,0x24,0xF2,
+0x02,0x68,0x20,0x31,
+0x00,0x30,0x01,0xF6,
+0x88,0x41,0x24,0xF2,
+0x02,0x6D,0x00,0x1C,
+0xD1,0x5A,0x00,0x30,
+0x01,0xF6,0x80,0x41,
+0x24,0xF2,0xA2,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x01,0xF6,
+0x84,0x41,0x24,0xF2,
+0xA2,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x11,0xF6,0x80,0x41,
+0x24,0xF2,0xA2,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x11,0xF6,
+0x84,0x41,0x24,0xF2,
+0xA2,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x11,0xF6,0x88,0x41,
+0x24,0xF2,0xA2,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x11,0xF6,
+0x8C,0x41,0x24,0xF2,
+0xA2,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x01,0x6B,0x63,0xF3,
+0x00,0x4A,0x00,0xF3,
+0x67,0xC2,0x05,0x92,
+0x08,0x97,0x07,0x91,
+0x63,0xF3,0x00,0x4A,
+0x05,0xD2,0x05,0x93,
+0x06,0x90,0x01,0x6A,
+0x00,0xF3,0x44,0xC3,
+0x00,0xEF,0x05,0x63,
+0xC9,0xF7,0x1B,0x68,
+0x02,0xF0,0x10,0x6A,
+0x0B,0xE8,0x40,0x32,
+0x40,0x32,0x00,0x30,
+0xA2,0x67,0x00,0x30,
+0x01,0xF6,0x80,0x40,
+0x02,0xF0,0x10,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x04,0xD2,0x04,0x95,
+0x01,0xF6,0x84,0x40,
+0x02,0xF0,0x10,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x01,0xF6,
+0x88,0x40,0x02,0xF0,
+0x10,0x6D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x04,0x95,0x11,0xF6,
+0x80,0x40,0x02,0xF0,
+0x10,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x04,0x95,0x11,0xF6,
+0x84,0x40,0x02,0xF0,
+0x10,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x04,0x95,0x11,0xF6,
+0x88,0x40,0x02,0xF0,
+0x10,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x04,0x95,0x11,0xF6,
+0x8C,0x40,0x02,0xF0,
+0x10,0x4D,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x00,0xF3,0x27,0xC3,
+0x05,0x92,0x08,0x97,
+0x07,0x91,0x63,0xF3,
+0x00,0x4A,0x05,0xD2,
+0x05,0x93,0x06,0x90,
+0x01,0x6A,0x00,0xF3,
+0x44,0xC3,0x00,0xEF,
+0x05,0x63,0x00,0x00,
+0xFC,0x63,0x05,0xD1,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x06,0x62,0x04,0xD0,
+0x63,0xF3,0x00,0x49,
+0x00,0xF3,0xCC,0x99,
+0x02,0xF0,0x00,0x68,
+0x00,0x30,0xAF,0x40,
+0x00,0x1C,0x12,0x46,
+0x15,0x6C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0xF3,0xD0,0x99,
+0x1A,0x6C,0x00,0x1C,
+0x12,0x46,0xAF,0x40,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x00,0xF3,
+0x44,0xA1,0x0E,0x2A,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x01,0xF6,
+0x00,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF2,0x6C,0x99,
+0x6E,0xEA,0x36,0x22,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0xE0,0xF2,
+0xA8,0x99,0x00,0x30,
+0x00,0x30,0x01,0xF6,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0xE0,0xF2,0xAC,0x99,
+0x01,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xE0,0xF2,
+0xB0,0x99,0x01,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0xE0,0xF2,0xB4,0x99,
+0x11,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xE0,0xF2,
+0xB8,0x99,0x11,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0xE0,0xF2,0xBC,0x99,
+0x11,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0xF3,
+0xA0,0x99,0x11,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x06,0x97,0x05,0x91,
+0x04,0x90,0x63,0xF3,
+0x00,0x4A,0x00,0x6B,
+0x00,0xF3,0x64,0xC2,
+0x02,0x6B,0x00,0xF3,
+0x67,0xC2,0x00,0xEF,
+0x04,0x63,0x00,0x00,
+0xFC,0x63,0x05,0xD1,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x06,0x62,0x04,0xD0,
+0x63,0xF3,0x00,0x49,
+0x00,0xF3,0xCC,0x99,
+0x02,0xF0,0x00,0x68,
+0x00,0x30,0xAF,0x40,
+0x00,0x1C,0x12,0x46,
+0x15,0x6C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0xF3,0xD0,0x99,
+0x1A,0x6C,0x00,0x1C,
+0x12,0x46,0xAF,0x40,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x00,0xF3,
+0x44,0xA1,0x03,0x72,
+0x5B,0x60,0xE0,0xF2,
+0xAC,0x99,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x30,0x00,0x30,
+0x01,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xE0,0xF2,
+0xB0,0x99,0x01,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0xE0,0xF2,0xB4,0x99,
+0x11,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xE0,0xF2,
+0xB8,0x99,0x11,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0xE0,0xF2,0xBC,0x99,
+0x11,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0xF3,
+0xA0,0x99,0x11,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x00,0xF3,0x48,0x99,
+0xE0,0xF2,0x68,0x99,
+0x55,0xE3,0x1F,0xF7,
+0x00,0x6A,0xAC,0xEA,
+0x07,0xF7,0x01,0x5A,
+0x16,0x60,0x01,0xF6,
+0x88,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x06,0x97,0x05,0x91,
+0x04,0x90,0x63,0xF3,
+0x00,0x4A,0x03,0x6B,
+0x00,0xF3,0x64,0xC2,
+0x02,0x6B,0x00,0xF3,
+0x67,0xC2,0x00,0xEF,
+0x04,0x63,0xFF,0x6A,
+0x01,0x4A,0x4B,0xEA,
+0x40,0x32,0xE0,0xF0,
+0x1F,0x4A,0x4C,0xED,
+0x07,0xF7,0x00,0x6A,
+0x4D,0xED,0xDF,0x17,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x01,0xF6,
+0x00,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF2,0xAC,0x99,
+0xAA,0xEA,0x99,0x61,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x06,0x97,0x05,0x91,
+0x04,0x90,0x63,0xF3,
+0x00,0x4A,0x03,0x6B,
+0x00,0xF3,0x64,0xC2,
+0x02,0x6B,0x00,0xF3,
+0x67,0xC2,0x00,0xEF,
+0x04,0x63,0x00,0x00,
+0xFB,0x63,0x08,0x62,
+0x07,0xD1,0x06,0xD0,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x63,0xF3,0x40,0x99,
+0x10,0x6B,0x6D,0xEA,
+0x63,0xF3,0x40,0xD9,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x30,
+0x00,0x30,0x51,0xF4,
+0x80,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0x00,0xF6,0x40,0x32,
+0x00,0xF6,0x43,0x32,
+0x51,0xF4,0x80,0x40,
+0x1A,0x6D,0x00,0x1C,
+0xE4,0x5A,0x04,0xD2,
+0xF1,0xF0,0x88,0x40,
+0x00,0x1C,0xF4,0x5A,
+0x00,0x65,0x04,0x93,
+0x00,0xF6,0x40,0x32,
+0x00,0xF6,0x43,0x32,
+0x49,0xE3,0x92,0x4A,
+0xBF,0xF7,0x1B,0x52,
+0x06,0x61,0x71,0x67,
+0x63,0xF3,0x00,0x4B,
+0x43,0xAB,0x01,0x4A,
+0x43,0xCB,0x04,0x95,
+0xFF,0x6A,0x51,0xF4,
+0x80,0x40,0x00,0x1C,
+0xE4,0x5A,0x4C,0xED,
+0x63,0xF3,0x40,0x99,
+0x11,0x6B,0x6B,0xEB,
+0x6C,0xEA,0x63,0xF3,
+0x40,0xD9,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0x6A,0x00,0xEF,
+0x05,0x63,0x00,0x00,
+0xFA,0x63,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x0A,0x62,
+0x09,0xD1,0x08,0xD0,
+0x66,0xF7,0x2C,0x9B,
+0x7F,0x6A,0x32,0x31,
+0x4C,0xE9,0x00,0xF3,
+0x44,0xA3,0x05,0xD2,
+0x40,0x9B,0x84,0x6B,
+0x6C,0xEA,0x80,0x72,
+0x2A,0x61,0x05,0x93,
+0x01,0x73,0x02,0x60,
+0x04,0x73,0x1B,0x61,
+0x02,0xF0,0x00,0x68,
+0x00,0xF2,0x00,0x6E,
+0x00,0x30,0xC0,0x36,
+0xAF,0x40,0xF3,0xF0,
+0x14,0x4E,0x00,0x1C,
+0x12,0x46,0x15,0x6C,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0xFF,0x6E,
+0x01,0x4E,0xC0,0x36,
+0x1A,0x6C,0x46,0xF0,
+0x16,0x4E,0x00,0x1C,
+0x12,0x46,0xAF,0x40,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x01,0x6A,
+0x4B,0xEA,0x00,0xF3,
+0x44,0xC3,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x30,0x00,0x30,
+0x40,0xF0,0x6C,0xA0,
+0x03,0x6A,0x6C,0xEA,
+0x0A,0x22,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x63,0xF3,
+0x40,0x9C,0x01,0x6B,
+0x5E,0x32,0x6C,0xEA,
+0x74,0x22,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x63,0xF3,
+0x00,0x4C,0x00,0xF3,
+0x44,0x9C,0xFF,0xF7,
+0x1F,0x6B,0x42,0x32,
+0x6C,0xEA,0x16,0x2A,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x80,0xF1,
+0x04,0x4A,0x40,0x9A,
+0x0D,0x72,0x50,0x61,
+0x46,0x6A,0x00,0xF3,
+0x5C,0xC4,0x41,0x6A,
+0x00,0xF3,0x5D,0xC4,
+0x40,0x6A,0x00,0xF3,
+0x5E,0xC4,0x3B,0x6A,
+0x00,0xF3,0x5F,0xC4,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x60,0x9A,
+0x84,0x6A,0x6C,0xEA,
+0x84,0x72,0x34,0x61,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0xE4,0xF4,0x58,0x9C,
+0xFF,0xF7,0x1F,0x72,
+0x29,0x60,0x76,0x32,
+0x01,0x6B,0x6C,0xEA,
+0x25,0x22,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0x40,0xF0,0x6C,0xA2,
+0x03,0x6A,0xFF,0x6D,
+0x6C,0xEA,0x1A,0x22,
+0x05,0x93,0x03,0x73,
+0xA0,0xF0,0x15,0x60,
+0x04,0x53,0xA0,0xF0,
+0x1C,0x60,0xC0,0xF0,
+0x17,0x23,0x01,0x73,
+0x0F,0x61,0x00,0xF3,
+0x5C,0xA4,0xAC,0xEA,
+0x43,0xE9,0xC0,0xF0,
+0x0B,0x60,0x00,0xF3,
+0x5F,0xA4,0xAC,0xEA,
+0x23,0xEA,0xA0,0xF0,
+0x1C,0x61,0x00,0x18,
+0x2E,0x30,0x00,0x65,
+0x0A,0x97,0x09,0x91,
+0x08,0x90,0x00,0x6A,
+0x00,0xEF,0x06,0x63,
+0x4A,0x6A,0x00,0xF3,
+0x5C,0xC4,0x45,0x6A,
+0x00,0xF3,0x5D,0xC4,
+0x46,0x6A,0x00,0xF3,
+0x5E,0xC4,0x40,0x6A,
+0x00,0xF3,0x5F,0xC4,
+0xAF,0x17,0x01,0xF6,
+0x80,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x0E,0x2A,0x11,0xF6,
+0x80,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x27,0xF7,0x1F,0x6B,
+0x60,0x33,0x60,0x33,
+0x27,0xF7,0x1F,0x4B,
+0x6E,0xEA,0x7F,0xF7,
+0x18,0x22,0x9D,0x67,
+0x00,0x1C,0x9A,0x40,
+0x10,0x4C,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x01,0xF6,
+0x88,0x40,0x00,0x1C,
+0xEE,0x5A,0x06,0xD2,
+0x06,0x93,0x01,0xF6,
+0x80,0x40,0xE0,0xF2,
+0x48,0xDB,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x06,0x94,0xE0,0xF2,
+0x4C,0xDC,0x01,0xF6,
+0x84,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x06,0x93,0x11,0xF6,
+0x80,0x40,0xE0,0xF2,
+0x50,0xDB,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x06,0x94,0xE0,0xF2,
+0x54,0xDC,0x11,0xF6,
+0x84,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x06,0x93,0x11,0xF6,
+0x88,0x40,0xE0,0xF2,
+0x58,0xDB,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x06,0x94,0xE0,0xF2,
+0x5C,0xDC,0x11,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x06,0x93,0xFF,0x6C,
+0x00,0xF3,0x40,0xDB,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x4B,0xF7,0x5E,0xA2,
+0x8C,0xEA,0x22,0x72,
+0x02,0x60,0x92,0x72,
+0x1B,0x61,0x01,0xF0,
+0x8D,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0x0F,0x6B,0x4C,0xEB,
+0x0F,0x6A,0x6E,0xEA,
+0xFF,0x6C,0x8C,0xEA,
+0x08,0x5B,0xA1,0x42,
+0x0D,0x61,0xA0,0x34,
+0x80,0x33,0x00,0xF6,
+0xA0,0x32,0x6D,0xEA,
+0x06,0x93,0x8D,0xEA,
+0xAD,0xEA,0xAD,0xEC,
+0x00,0xF3,0x54,0xDB,
+0x00,0xF3,0x98,0xDB,
+0x9D,0x67,0x00,0x1C,
+0xA0,0x40,0x10,0x4C,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x40,0x9C,
+0x80,0x6B,0x6D,0xEA,
+0x63,0xF3,0x40,0xDC,
+0x00,0x17,0x20,0xF3,
+0x40,0xA4,0xAC,0xEA,
+0x43,0xE9,0x5F,0xF7,
+0x18,0x60,0x00,0x18,
+0x6A,0x30,0x00,0x65,
+0x57,0x17,0x05,0x92,
+0x04,0x72,0x11,0x60,
+0xFF,0x72,0x5F,0xF7,
+0x11,0x61,0x00,0xF3,
+0x5E,0xA4,0xAC,0xEA,
+0x43,0xE9,0x17,0x61,
+0x00,0xF3,0x5C,0xA4,
+0xAC,0xEA,0x43,0xE9,
+0x09,0x60,0x00,0x18,
+0xB6,0x2F,0x00,0x65,
+0x43,0x17,0x00,0xF3,
+0x5D,0xA4,0xAC,0xEA,
+0x23,0xEA,0xF7,0x60,
+0x00,0x18,0x33,0x2F,
+0x00,0x65,0x3A,0x17,
+0x00,0xF3,0x5E,0xA4,
+0xAC,0xEA,0x43,0xE9,
+0xEE,0x60,0x20,0xF3,
+0x41,0xA4,0xAC,0xEA,
+0x23,0xEA,0x3F,0xF7,
+0x0C,0x61,0x00,0x18,
+0x6A,0x30,0x00,0x65,
+0x2B,0x17,0x00,0x00,
+0xFB,0x63,0x10,0xF0,
+0x02,0x6E,0x00,0xF4,
+0xC0,0x36,0x07,0xD1,
+0x26,0x67,0x06,0xD0,
+0x08,0x62,0x63,0xF3,
+0x00,0x49,0x66,0xF7,
+0x8C,0x99,0x7F,0x6A,
+0x92,0x30,0x4C,0xE8,
+0xE0,0xF2,0x46,0xA1,
+0x0F,0x2A,0xC9,0xF7,
+0x1B,0x6A,0x4B,0xEA,
+0x40,0x35,0xA0,0x35,
+0x40,0xF0,0x4C,0xA5,
+0xFF,0x6B,0x6C,0xEA,
+0x03,0x6B,0x6C,0xEA,
+0x03,0x22,0xFF,0xF7,
+0x1F,0x74,0x06,0x61,
+0x08,0x97,0x07,0x91,
+0x06,0x90,0x00,0x6A,
+0x00,0xEF,0x05,0x63,
+0x01,0xF0,0x80,0x45,
+0x04,0xD5,0x00,0x1C,
+0xF4,0x5A,0x05,0xD6,
+0x01,0x6B,0x6C,0xEA,
+0x04,0x95,0x05,0x96,
+0x2C,0x22,0x4B,0x58,
+0x06,0x61,0xC0,0xF2,
+0x53,0xA1,0xFF,0x6C,
+0x8C,0xEA,0x6A,0xEA,
+0x74,0x61,0x48,0x40,
+0xE0,0x4A,0xFF,0x6B,
+0x6C,0xEA,0x1E,0x5A,
+0x07,0x60,0x86,0x67,
+0x63,0xF3,0x00,0x4C,
+0xC0,0xF2,0x53,0xA4,
+0x6C,0xEA,0x43,0x2A,
+0x23,0x58,0xD8,0x60,
+0x66,0x67,0x63,0xF3,
+0x00,0x4B,0xC0,0xF2,
+0x53,0xA3,0x02,0x72,
+0xD1,0x60,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x02,0x6A,
+0x80,0x34,0xC0,0xF2,
+0x53,0xC3,0x81,0xF4,
+0x07,0x4C,0x00,0x1C,
+0xE4,0x5A,0x00,0x6D,
+0xC3,0x17,0x4B,0x58,
+0x06,0x61,0xC0,0xF2,
+0x53,0xA1,0xFF,0x6C,
+0x8C,0xEA,0x01,0x72,
+0x40,0x61,0x48,0x40,
+0xE0,0x4A,0xFF,0x6B,
+0x6C,0xEA,0x1E,0x5A,
+0x07,0x60,0x86,0x67,
+0x63,0xF3,0x00,0x4C,
+0xC0,0xF2,0x53,0xA4,
+0x6C,0xEA,0x25,0x2A,
+0x23,0x58,0xAC,0x60,
+0x66,0x67,0x63,0xF3,
+0x00,0x4B,0xC0,0xF2,
+0x53,0xA3,0x02,0x72,
+0xA5,0x60,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x02,0x6A,
+0x80,0x34,0xC0,0xF2,
+0x53,0xC3,0x21,0xF4,
+0x10,0x4C,0x00,0x1C,
+0xE4,0x5A,0x42,0x6D,
+0x97,0x17,0x00,0x6A,
+0xC0,0xF2,0x53,0xC4,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x81,0xF4,
+0x07,0x4C,0x00,0x1C,
+0xE4,0x5A,0x20,0x6D,
+0x89,0x17,0x00,0x6A,
+0xC0,0xF2,0x53,0xC4,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x21,0xF4,
+0x10,0x4C,0x00,0x1C,
+0xE4,0x5A,0x44,0x6D,
+0x7B,0x17,0x31,0xF4,
+0x80,0x45,0xC0,0xF2,
+0x73,0xC1,0x00,0x1C,
+0xE4,0x5A,0x43,0x6D,
+0x73,0x17,0x81,0xF4,
+0x87,0x45,0xC0,0xF2,
+0x73,0xC1,0x00,0x1C,
+0xE4,0x5A,0x10,0x6D,
+0x6B,0x17,0x00,0x65,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0xA6,0x63,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x10,0x3C,
+0x24,0xC8,0x42,0x24,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x03,0x11,0x36,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x22,0xAE,
+0x20,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x30,0x03,0x10,0x36,
+0x20,0x80,0x02,0x3C,
+0x25,0xB0,0x05,0x3C,
+0x00,0x00,0x02,0xAE,
+0x01,0x80,0x02,0x3C,
+0x25,0xC8,0x44,0x24,
+0x33,0x03,0xA3,0x34,
+0x00,0x00,0x24,0xAE,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0xFB,0xFF,0x40,0x10,
+0x30,0x03,0xA2,0x34,
+0x00,0x00,0x46,0x8C,
+0x0F,0x00,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x24,0x30,0xC3,0x00,
+0x40,0x11,0x06,0x00,
+0x23,0x10,0x46,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x46,0x00,
+0xAF,0x0F,0x05,0x3C,
+0xC0,0x10,0x02,0x00,
+0x00,0xA0,0xA5,0x34,
+0x1B,0x00,0xA2,0x00,
+0x02,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x63,0x24,
+0xC2,0x30,0x06,0x00,
+0x10,0x00,0xA4,0x27,
+0xF0,0x43,0x66,0xAC,
+0x12,0x28,0x00,0x00,
+0xA0,0x40,0x00,0x0C,
+0xF4,0x43,0x65,0xAC,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xC0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x21,0xA0,0x80,0x00,
+0x02,0x80,0x12,0x3C,
+0x10,0x00,0xA4,0x27,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x34,0x00,0xB7,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x44,0x00,0xA5,0xAF,
+0x18,0x64,0x42,0x92,
+0x21,0xF0,0x00,0x00,
+0xD4,0x00,0x40,0x10,
+0x21,0xB0,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x43,0x24,
+0xB0,0x1B,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xCD,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xC8,0x3E,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0xC9,0x00,0x40,0x14,
+0x02,0x80,0x17,0x3C,
+0x40,0x64,0xE2,0x92,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x40,0x64,0xE2,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x24,
+0x40,0x64,0xE2,0xA2,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x28,0x64,0x40,0xA0,
+0x48,0x64,0x60,0xAC,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0x62,0x90,
+0xFD,0xFF,0x03,0x24,
+0x42,0xB0,0x13,0x3C,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0x62,0xA0,
+0x00,0x00,0x63,0x92,
+0xEF,0xFF,0x02,0x24,
+0x03,0x00,0x64,0x36,
+0x24,0x18,0x62,0x00,
+0x40,0x00,0x02,0x24,
+0x00,0x00,0x63,0xA2,
+0x02,0x80,0x05,0x3C,
+0x00,0x00,0x82,0xA0,
+0x2A,0x64,0xA2,0x94,
+0x20,0x00,0x83,0x96,
+0xFF,0xFF,0x42,0x30,
+0x13,0x00,0x43,0x10,
+0x02,0x80,0x15,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x94,0x00,0x42,0x34,
+0x2A,0x64,0xA3,0xA4,
+0x00,0x00,0x43,0xA4,
+0x2A,0x64,0xA3,0x94,
+0xB8,0x88,0x04,0x34,
+0xFF,0xFF,0x63,0x30,
+0x80,0x1A,0x03,0x00,
+0x2C,0x64,0xA3,0xAE,
+0x2A,0x64,0xA2,0x94,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x30,
+0x1A,0x00,0x82,0x00,
+0x02,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x12,0x20,0x00,0x00,
+0x34,0x64,0x64,0xA4,
+0x25,0xB0,0x04,0x3C,
+0x84,0x00,0x82,0x34,
+0x00,0x00,0x50,0x8C,
+0x80,0x00,0x84,0x34,
+0x00,0x00,0x82,0x8C,
+0x21,0x18,0x00,0x00,
+0x2C,0x64,0xA6,0x8E,
+0x00,0x88,0x10,0x00,
+0x21,0x80,0x00,0x00,
+0x25,0x80,0x02,0x02,
+0x25,0x88,0x23,0x02,
+0x21,0x20,0x00,0x02,
+0x01,0x32,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x2C,0x64,0xA8,0x8E,
+0x02,0x80,0x03,0x3C,
+0x20,0x64,0x6A,0x24,
+0x05,0x00,0x43,0x91,
+0x23,0x48,0x02,0x01,
+0x21,0x20,0x30,0x01,
+0x21,0x28,0x00,0x00,
+0x2B,0x10,0x90,0x00,
+0xFF,0x00,0x63,0x30,
+0x21,0x28,0xB1,0x00,
+0x80,0x1A,0x03,0x00,
+0x21,0x28,0xA2,0x00,
+0x21,0x38,0x00,0x00,
+0x2B,0x40,0x83,0x00,
+0x23,0x28,0xA7,0x00,
+0x23,0x20,0x83,0x00,
+0x23,0x28,0xA8,0x00,
+0x02,0x80,0x03,0x3C,
+0x50,0x64,0x64,0xAC,
+0x54,0x64,0x65,0xAC,
+0x05,0x00,0x42,0x91,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x12,0x02,0x00,
+0x2B,0x10,0x49,0x00,
+0xA7,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x42,0x91,
+0x00,0x00,0x64,0x92,
+0xFB,0xFF,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x80,0x12,0x02,0x00,
+0x24,0x20,0x83,0x00,
+0x23,0x48,0x22,0x01,
+0x00,0x00,0x64,0xA2,
+0x01,0x00,0x06,0x24,
+0x04,0x00,0x20,0x11,
+0x01,0x00,0x04,0x24,
+0x80,0x10,0x09,0x00,
+0x21,0x10,0x49,0x00,
+0x80,0x30,0x02,0x00,
+0x59,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x44,0x00,0xA2,0x8F,
+0x05,0x00,0x05,0x24,
+0x24,0x00,0x84,0x26,
+0x00,0x00,0x47,0x8C,
+0x14,0x00,0xA6,0x27,
+0xFF,0x3F,0xE7,0x30,
+0x6B,0x21,0x00,0x0C,
+0xDC,0xFF,0xE7,0x24,
+0x31,0x00,0x40,0x10,
+0x21,0x28,0x40,0x00,
+0x18,0x64,0x42,0x92,
+0x02,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x93,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x64,0x42,0x92,
+0x05,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x8E,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0x04,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x16,0x24,
+0x3D,0x64,0x56,0xA0,
+0x04,0x00,0xA3,0x90,
+0x14,0x00,0xA7,0x8F,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xE2,0x28,
+0x16,0x00,0x40,0x14,
+0xFE,0x00,0x66,0x30,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x43,0x24,
+0x68,0x3A,0x64,0x94,
+0xC0,0x10,0x06,0x00,
+0x2A,0x10,0x82,0x00,
+0x10,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x21,0x10,0xC7,0x00,
+0xFD,0xFF,0x42,0x24,
+0xC0,0x10,0x02,0x00,
+0x2A,0x10,0x44,0x00,
+0x0A,0x00,0x40,0x14,
+0xC2,0x10,0x04,0x00,
+0x23,0x30,0x46,0x00,
+0x21,0x18,0xA6,0x00,
+0x05,0x00,0x62,0x90,
+0x07,0x00,0x84,0x30,
+0x01,0x00,0x03,0x24,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0x0B,0xF0,0x62,0x00,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0x62,0x90,
+0xEF,0xFF,0x03,0x24,
+0x21,0x20,0xC0,0x02,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0x62,0xA0,
+0x18,0x64,0x43,0x92,
+0x02,0x80,0x02,0x3C,
+0xE8,0xEB,0x42,0x24,
+0xFF,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x66,0x8C,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0xC0,0x00,
+0x21,0x28,0xC0,0x03,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x18,0x64,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x50,0x24,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xE9,0xFF,0x40,0x10,
+0x05,0x00,0x05,0x24,
+0x44,0x00,0xA3,0x8F,
+0x24,0x00,0x84,0x26,
+0x00,0x00,0x67,0x8C,
+0x14,0x00,0xA6,0x27,
+0xFF,0x3F,0xE7,0x30,
+0x6B,0x21,0x00,0x0C,
+0xDC,0xFF,0xE7,0x24,
+0xE0,0xFF,0x40,0x10,
+0x21,0x28,0x40,0x00,
+0x14,0x00,0xA7,0x8F,
+0x04,0x00,0x42,0x90,
+0x04,0x00,0xE3,0x28,
+0xDB,0xFF,0x60,0x14,
+0xFE,0x00,0x46,0x30,
+0x68,0x3A,0x04,0x96,
+0xC0,0x10,0x06,0x00,
+0x2A,0x10,0x82,0x00,
+0xD6,0xFF,0x40,0x14,
+0x21,0x10,0xC7,0x00,
+0xFD,0xFF,0x42,0x24,
+0xC0,0x10,0x02,0x00,
+0x2A,0x10,0x44,0x00,
+0xD1,0xFF,0x40,0x14,
+0xC2,0x10,0x04,0x00,
+0x23,0x30,0x46,0x00,
+0x21,0x18,0xA6,0x00,
+0x05,0x00,0x62,0x90,
+0x07,0x00,0x84,0x30,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0xC9,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x30,
+0xC4,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x1A,0x64,0x43,0x90,
+0x0C,0x00,0x02,0x24,
+0x0F,0x00,0x63,0x30,
+0x02,0x00,0x62,0x10,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x04,0x24,
+0x90,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x16,0x33,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x40,0x64,0xE2,0x92,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x40,0x64,0xE2,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x40,0x64,0xE2,0xA2,
+0x00,0x00,0x62,0x92,
+0xFB,0xFF,0x03,0x24,
+0x01,0x00,0x06,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x62,0xA2,
+0xC0,0x32,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0xA2,0x90,
+0x02,0x80,0x07,0x3C,
+0x02,0x80,0x04,0x3C,
+0x3B,0x64,0xE2,0xA0,
+0x02,0x00,0xA3,0x90,
+0x21,0x30,0x80,0x00,
+0x3C,0x64,0x83,0xA0,
+0x3C,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x3B,0x64,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x3C,0x64,0xC2,0xA0,
+0xDF,0x32,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x3C,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x3C,0x64,0xC2,0xA0,
+0xDF,0x32,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x3F,0x64,0x64,0xA0,
+0x20,0x64,0x42,0x24,
+0x02,0x00,0x43,0x94,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x02,0x3C,
+0xFF,0xFF,0x63,0x30,
+0xEC,0x63,0x43,0xAC,
+0x3E,0x64,0x80,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x04,0x3C,
+0x28,0x00,0x85,0x34,
+0x02,0x00,0x82,0x94,
+0x04,0x00,0x84,0x24,
+0x05,0x00,0x40,0x14,
+0x2B,0x18,0xA4,0x00,
+0xFB,0xFF,0x60,0x10,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0xBE,0x00,0x63,0x34,
+0x00,0x00,0x62,0x94,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x42,0x2C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x8E,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x19,0x00,0x40,0x10,
+0x98,0x54,0x64,0x24,
+0x98,0x54,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x15,0x00,0x44,0x14,
+0x02,0x80,0x02,0x3C,
+0x3F,0x64,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0xFF,0x00,0x63,0x30,
+0x10,0x00,0x62,0x10,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x05,0x00,0x42,0x28,
+0x0A,0x00,0x40,0x10,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x28,0x5A,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x14,
+0x21,0x10,0x80,0x00,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xBF,0x8F,
+0x21,0x20,0x00,0x00,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x8E,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2C,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x98,0x54,0x43,0x8C,
+0x98,0x54,0x42,0x24,
+0x28,0x00,0x62,0x14,
+0x02,0x80,0x03,0x3C,
+0x37,0x64,0x62,0x90,
+0x01,0x00,0x04,0x24,
+0xFF,0x00,0x42,0x30,
+0x23,0x00,0x44,0x10,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x03,0x00,0x42,0x28,
+0x1D,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0x18,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x39,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x42,0x30,
+0x13,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x3F,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x0E,0x00,0x44,0x10,
+0x02,0x80,0x02,0x3C,
+0x40,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x60,0x14,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xC8,0x3E,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x60,0x14,
+0x21,0x18,0x00,0x00,
+0x58,0x3A,0x42,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x40,0x14,
+0x01,0x00,0x03,0x24,
+0x21,0x18,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x9A,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x0E,0x00,0x40,0x10,
+0x90,0x54,0x65,0x24,
+0x90,0x54,0x62,0x8C,
+0x02,0x80,0x04,0x3C,
+0x88,0x54,0x86,0x24,
+0x09,0x00,0x45,0x14,
+0x01,0x00,0x03,0x24,
+0x88,0x54,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x46,0x14,
+0x21,0x10,0x60,0x00,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xBF,0x8F,
+0x21,0x18,0x00,0x00,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0x00,0x90,0x30,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xB2,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x02,0x80,0x12,0x3C,
+0x0F,0x00,0x00,0x12,
+0x00,0x00,0x00,0x00,
+0x74,0x64,0x43,0x92,
+0x01,0x00,0x02,0x24,
+0x04,0x0C,0x04,0x24,
+0xFF,0x00,0x63,0x30,
+0x2A,0x00,0x62,0x10,
+0x80,0x01,0x10,0x3C,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x74,0x64,0x43,0x92,
+0x02,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x63,0x30,
+0xF3,0xFF,0x62,0x14,
+0x44,0x08,0x04,0x24,
+0xF7,0x5A,0x00,0x0C,
+0x7F,0xFE,0x10,0x3C,
+0x24,0x5B,0x00,0x0C,
+0x04,0x0C,0x04,0x24,
+0xFD,0x00,0x45,0x30,
+0x0E,0x5B,0x00,0x0C,
+0x04,0x0C,0x04,0x24,
+0x24,0x5B,0x00,0x0C,
+0x04,0x0D,0x04,0x24,
+0xFD,0x00,0x45,0x30,
+0x0E,0x5B,0x00,0x0C,
+0x04,0x0D,0x04,0x24,
+0x1A,0x5B,0x00,0x0C,
+0x70,0x0E,0x04,0x24,
+0xFF,0xFF,0x10,0x36,
+0x24,0x28,0x50,0x00,
+0xF7,0x5A,0x00,0x0C,
+0x70,0x0E,0x04,0x24,
+0x1A,0x5B,0x00,0x0C,
+0x8C,0x0E,0x04,0x24,
+0x24,0x28,0x50,0x00,
+0xF7,0x5A,0x00,0x0C,
+0x8C,0x0E,0x04,0x24,
+0x01,0x00,0x02,0x24,
+0x74,0x64,0x42,0xA2,
+0x23,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x24,0x5B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x34,
+0xFF,0x00,0x45,0x30,
+0x0E,0x5B,0x00,0x0C,
+0x04,0x0C,0x04,0x24,
+0x24,0x5B,0x00,0x0C,
+0x04,0x0D,0x04,0x24,
+0x02,0x00,0x42,0x34,
+0xFF,0x00,0x45,0x30,
+0x0E,0x5B,0x00,0x0C,
+0x04,0x0D,0x04,0x24,
+0x1A,0x5B,0x00,0x0C,
+0x70,0x0E,0x04,0x24,
+0x25,0x28,0x50,0x00,
+0xF7,0x5A,0x00,0x0C,
+0x70,0x0E,0x04,0x24,
+0x1A,0x5B,0x00,0x0C,
+0x8C,0x0E,0x04,0x24,
+0x25,0x28,0x50,0x00,
+0xF7,0x5A,0x00,0x0C,
+0x8C,0x0E,0x04,0x24,
+0x03,0x00,0x05,0x3C,
+0x59,0x01,0xA5,0x34,
+0xF7,0x5A,0x00,0x0C,
+0x44,0x08,0x04,0x24,
+0x02,0x00,0x02,0x24,
+0x74,0x64,0x42,0xA2,
+0x23,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x42,0x00,0x46,0x34,
+0xFC,0x37,0x03,0x24,
+0x40,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x03,0x08,0x04,0x24,
+0x03,0x00,0x05,0x24,
+0x00,0x00,0xC0,0xA0,
+0x0E,0x5B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x18,0x64,0x43,0x90,
+0xFC,0x57,0x12,0x24,
+0x07,0x00,0x60,0x10,
+0xFC,0x77,0x11,0x24,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x63,0x30,
+0x26,0x00,0x60,0x14,
+0x21,0x20,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x21,0x00,0x65,0x34,
+0x00,0x00,0xA2,0x90,
+0x18,0x00,0x66,0x34,
+0x40,0x00,0x70,0x34,
+0x01,0x00,0x42,0x34,
+0x42,0x00,0x63,0x34,
+0x00,0x00,0xA2,0xA0,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0xC0,0xA0,
+0x64,0x00,0x04,0x24,
+0x00,0x00,0x62,0xA0,
+0x00,0x00,0x12,0xA6,
+0x72,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x11,0xA6,
+0x72,0x26,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x0E,0x5B,0x00,0x0C,
+0x03,0x08,0x04,0x24,
+0x72,0x26,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0x02,0xA6,
+0x72,0x26,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x00,0x00,0x11,0xA6,
+0x72,0x26,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x00,0x00,0x12,0xA6,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x12,0x34,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x85,0x34,0x00,0x08,
+0x25,0xB0,0x03,0x3C,
+0xB8,0xFF,0xBD,0x27,
+0x2C,0x00,0xB3,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x02,0x80,0x13,0x3C,
+0xFF,0x00,0x90,0x30,
+0x18,0x00,0xA4,0x27,
+0x30,0x00,0xB4,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x40,0x00,0xBF,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x9A,0x40,0x00,0x0C,
+0xFF,0x00,0xB2,0x30,
+0x1A,0x64,0x62,0x92,
+0x0F,0x00,0x11,0x32,
+0x0F,0x00,0x42,0x30,
+0x13,0x00,0x51,0x10,
+0x21,0xA0,0x00,0x00,
+0x04,0x00,0x02,0x32,
+0x40,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0x0C,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x8F,0x00,0x43,0x10,
+0x08,0x00,0x02,0x32,
+0x1A,0x64,0x62,0x92,
+0x04,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0xD2,0x01,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0x02,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x9B,0x00,0x43,0x10,
+0x06,0x00,0x02,0x32,
+0x02,0x80,0x10,0x3C,
+0x19,0x64,0x03,0x92,
+0x1A,0x64,0x62,0x92,
+0x0F,0x00,0x63,0x30,
+0x0F,0x00,0x42,0x30,
+0x2A,0x10,0x43,0x00,
+0x1C,0x00,0x40,0x14,
+0x02,0x80,0x12,0x3C,
+0x19,0x64,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0x17,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x5A,0x5F,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x43,0x30,
+0x52,0x00,0x60,0x14,
+0x04,0x00,0x42,0x30,
+0x10,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x43,0x92,
+0x02,0x80,0x06,0x3C,
+0x1C,0xEC,0xC5,0x90,
+0x0F,0x00,0x63,0x30,
+0x25,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0xDD,0x02,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x19,0x64,0x04,0x92,
+0x80,0xFF,0x02,0x24,
+0xBF,0xFF,0x03,0x24,
+0x26,0x28,0xA2,0x00,
+0x24,0x20,0x83,0x00,
+0x1C,0xEC,0xC5,0xA0,
+0x19,0x64,0x04,0xA2,
+0xA0,0x40,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x1A,0x64,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0x4C,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x30,
+0x03,0x00,0x40,0x10,
+0x08,0x00,0x02,0x32,
+0x1B,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x30,
+0x0C,0x00,0x40,0x14,
+0x08,0x00,0x02,0x32,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x40,0x12,
+0x02,0x80,0x03,0x3C,
+0x10,0x37,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x03,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x90,0x50,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x1A,0x64,0x62,0xA2,
+0x1A,0x64,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x23,0x02,
+0x1A,0x64,0x63,0xA2,
+0xD4,0x34,0x00,0x08,
+0x02,0x80,0x10,0x3C,
+0x10,0x37,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xF2,0xFF,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x3F,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xA2,0xFF,0x60,0x14,
+0x01,0x00,0x04,0x24,
+0x90,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1F,0x35,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xF3,0x27,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0x76,0x01,0x40,0x10,
+0x21,0x88,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x18,0x64,0x45,0x90,
+0x1A,0x64,0x44,0x92,
+0x19,0x64,0x02,0x92,
+0xBF,0xFF,0x03,0x24,
+0x0F,0x00,0x84,0x30,
+0x24,0x10,0x43,0x00,
+0x19,0x64,0x02,0xA2,
+0x10,0x00,0xA5,0xA3,
+0x11,0x00,0xA4,0xA3,
+0x08,0x00,0x24,0x96,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xA5,0x27,
+0x25,0x20,0x82,0x00,
+0x20,0x00,0x84,0x24,
+0xB4,0x23,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x04,0x00,0x03,0x24,
+0x17,0x00,0x02,0x24,
+0x0C,0x00,0x23,0xAE,
+0x14,0x00,0x22,0xAE,
+0xCB,0x09,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0xF6,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x6A,0x34,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x35,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x71,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x9F,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x77,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x1A,0x64,0x62,0xA2,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x92,
+0x10,0x37,0x64,0x94,
+0x04,0x00,0x42,0x34,
+0x00,0x01,0x84,0x30,
+0x1A,0x64,0x62,0xA2,
+0x61,0xFF,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x90,0x50,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xC9,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x65,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xF9,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x61,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x41,0xB0,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x1A,0x64,0x62,0xA2,
+0x1A,0x64,0x63,0x92,
+0x08,0x00,0x85,0x34,
+0x82,0x00,0x02,0x24,
+0x01,0x00,0x63,0x34,
+0x02,0x80,0x17,0x3C,
+0x1A,0x64,0x63,0xA2,
+0x00,0x00,0x80,0xAC,
+0x00,0x00,0xA2,0xA4,
+0x42,0xB0,0x04,0x3C,
+0x60,0x1B,0xE2,0x26,
+0xB0,0x1B,0x45,0x94,
+0x00,0x00,0x83,0x90,
+0xBE,0xFF,0x02,0x24,
+0x03,0x00,0x86,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x01,0xA5,0x30,
+0x90,0xFF,0x02,0x24,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xC2,0xA0,
+0x38,0x00,0xA0,0x10,
+0x25,0xB0,0x06,0x3C,
+0x25,0xB0,0x04,0x3C,
+0x84,0x00,0x82,0x34,
+0x00,0x00,0x46,0x8C,
+0x80,0x00,0x84,0x34,
+0x00,0x00,0x82,0x8C,
+0x02,0x80,0x0B,0x3C,
+0x48,0x64,0x64,0x8D,
+0x00,0x38,0x06,0x00,
+0x21,0x30,0x00,0x00,
+0x25,0xA0,0xC2,0x00,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x0A,0x3C,
+0x25,0xA8,0xE3,0x00,
+0x21,0x28,0x00,0x00,
+0x54,0x64,0x42,0x8D,
+0x21,0x20,0x94,0x00,
+0x2B,0x18,0x94,0x00,
+0x21,0x28,0xB5,0x00,
+0x21,0x28,0xA3,0x00,
+0x2B,0x10,0xA2,0x00,
+0x24,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x54,0x64,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x10,0x01,0x45,0x10,
+0x01,0x00,0x05,0x24,
+0x60,0x1B,0xE2,0x26,
+0xF4,0x43,0x43,0x8C,
+0x42,0xB0,0x07,0x3C,
+0x00,0x00,0xE6,0x90,
+0x18,0x00,0x65,0x00,
+0xFB,0xFF,0x02,0x24,
+0x24,0x30,0xC2,0x00,
+0x00,0x00,0xE6,0xA0,
+0x67,0x46,0x06,0x3C,
+0xCF,0xAC,0xC6,0x34,
+0x01,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x12,0x18,0x00,0x00,
+0x82,0x1A,0x03,0x00,
+0x40,0x10,0x03,0x00,
+0x21,0x10,0x43,0x00,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x19,0x00,0x46,0x00,
+0x10,0x30,0x00,0x00,
+0x23,0x10,0x46,0x00,
+0x42,0x10,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x02,0x33,0x06,0x00,
+0x01,0x00,0x02,0x24,
+0x59,0x27,0x00,0x0C,
+0x0A,0x30,0x46,0x00,
+0x25,0xB0,0x06,0x3C,
+0xF2,0x02,0xC3,0x34,
+0x88,0xFF,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x11,0x00,0xC7,0x34,
+0x00,0x00,0xE2,0x90,
+0x08,0x00,0xC5,0x34,
+0x60,0x1B,0xE4,0x26,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0xE2,0xA0,
+0x00,0x00,0xA3,0x94,
+0xB0,0x1B,0x82,0x94,
+0xFF,0xFF,0x64,0x30,
+0x10,0x00,0x84,0x34,
+0x00,0x00,0xA4,0xA4,
+0xFB,0xFF,0x84,0x30,
+0x00,0x00,0xA4,0xA4,
+0x00,0x01,0x42,0x30,
+0x02,0x00,0x84,0x34,
+0x00,0x00,0xA4,0xA4,
+0x04,0x00,0x40,0x10,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xFF,0xF7,0x84,0x30,
+0x00,0x00,0xA4,0xA4,
+0x28,0x00,0xC4,0x34,
+0x00,0x00,0x83,0x94,
+0xEF,0xFE,0x02,0x24,
+0xFE,0xFF,0x08,0x24,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x83,0xA4,
+0x00,0x00,0x82,0x94,
+0x26,0x00,0xC5,0x34,
+0x02,0x80,0x03,0x3C,
+0x24,0x10,0x48,0x00,
+0x00,0x00,0x82,0xA4,
+0x5A,0x5F,0x64,0x90,
+0x00,0x00,0xA2,0x94,
+0x04,0x00,0x84,0x30,
+0x00,0x24,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x09,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x48,0x00,
+0x00,0x00,0xA2,0xA4,
+0x00,0x00,0xE3,0x90,
+0xFD,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0xE3,0xA0,
+0x00,0x68,0x02,0x40,
+0x00,0x08,0x42,0x30,
+0xFD,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x12,0x3C,
+0x11,0x00,0x43,0x36,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA0,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x26,0x00,0x44,0x36,
+0x00,0x00,0x82,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0x82,0xA4,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x83,0x94,
+0xFF,0xDB,0x02,0x24,
+0x28,0x00,0x45,0x36,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x83,0xA4,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x10,0x01,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x08,0x00,0x51,0x36,
+0x00,0x00,0x23,0x96,
+0x60,0x1B,0xF6,0x26,
+0xB0,0x1B,0xC2,0x96,
+0xFF,0xFF,0x70,0x30,
+0x00,0x18,0x10,0x36,
+0x00,0x00,0x30,0xA6,
+0x00,0x01,0x42,0x30,
+0xFD,0xFF,0x10,0x32,
+0x00,0x00,0x30,0xA6,
+0x05,0x00,0x40,0x10,
+0x42,0xB0,0x02,0x3C,
+0x00,0x00,0x43,0x90,
+0xFB,0xFF,0x04,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x00,0x43,0xA0,
+0x04,0x00,0x10,0x36,
+0x72,0x26,0x00,0x0C,
+0x32,0x00,0x04,0x24,
+0x00,0x00,0x30,0xA6,
+0x22,0x00,0x02,0x24,
+0xF2,0x02,0x43,0x36,
+0xEF,0xFF,0x10,0x32,
+0x00,0x00,0x30,0xA6,
+0xC8,0x00,0x04,0x24,
+0x00,0x00,0x62,0xA0,
+0x72,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0xC2,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x41,0x00,0x40,0x10,
+0x42,0xB0,0x06,0x3C,
+0x84,0x00,0x42,0x36,
+0x00,0x00,0x44,0x8C,
+0x80,0x00,0x46,0x36,
+0x00,0x00,0xC2,0x8C,
+0x00,0x28,0x04,0x00,
+0x21,0x18,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x25,0x30,0x82,0x00,
+0x25,0x38,0xA3,0x00,
+0xF4,0x43,0xC3,0x8E,
+0x23,0x28,0xD4,0x00,
+0x80,0x12,0x05,0x00,
+0x1B,0x00,0x43,0x00,
+0x02,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x80,0x0B,0x3C,
+0x48,0x64,0x63,0x8D,
+0x12,0x10,0x00,0x00,
+0x23,0x10,0x45,0x00,
+0x21,0x10,0x43,0x00,
+0x48,0x64,0x62,0xAD,
+0x48,0x64,0x63,0x8D,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x42,0x34,
+0x58,0x1B,0x63,0x24,
+0x48,0x64,0x63,0xAD,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x63,0x30,
+0x20,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x48,0x64,0x62,0x8D,
+0x02,0x80,0x0A,0x3C,
+0x54,0x64,0x44,0x8D,
+0x21,0x40,0x46,0x00,
+0x2B,0x28,0x06,0x01,
+0x21,0x48,0x67,0x00,
+0x21,0x48,0x25,0x01,
+0x2B,0x20,0x24,0x01,
+0x59,0x00,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x54,0x64,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x47,0x00,0x49,0x10,
+0x01,0x00,0x05,0x24,
+0x42,0xB0,0x02,0x3C,
+0x00,0x00,0x43,0x90,
+0xFB,0xFF,0x04,0x24,
+0x01,0x00,0x06,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x00,0x43,0xA0,
+0x04,0x00,0xA0,0x10,
+0x01,0x00,0x04,0x24,
+0x80,0x10,0x05,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x30,0x02,0x00,
+0x59,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x42,0xB0,0x06,0x3C,
+0x00,0x00,0xC2,0x90,
+0x60,0x1B,0xE5,0x26,
+0xD0,0x1B,0xA8,0x8C,
+0xDC,0x1B,0xA7,0x94,
+0x41,0xB0,0x03,0x3C,
+0x41,0x00,0x42,0x34,
+0x08,0x00,0x64,0x34,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0x68,0xAC,
+0x00,0x00,0x87,0xA4,
+0x1A,0x64,0x63,0x92,
+0xF0,0xFF,0x02,0x24,
+0xDC,0x1B,0xA7,0xA4,
+0x24,0x18,0x62,0x00,
+0x1A,0x64,0x63,0xA2,
+0x1A,0x64,0x62,0x92,
+0xD0,0x1B,0xA8,0xAC,
+0x02,0x00,0x42,0x34,
+0x1A,0x64,0x62,0xA2,
+0xD4,0x34,0x00,0x08,
+0x02,0x80,0x10,0x3C,
+0xC3,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x31,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x74,0x34,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1A,0x64,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x1A,0x64,0x62,0xA2,
+0x1A,0x64,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x63,0x34,
+0x1A,0x64,0x63,0xA2,
+0xCE,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x99,0x99,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x97,0x99,0x63,0x34,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xF6,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x50,0x64,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x00,
+0x0C,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x50,0x64,0x42,0x8D,
+0xA7,0x35,0x00,0x08,
+0x01,0x00,0x05,0x24,
+0x50,0x64,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x02,0x01,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x50,0x64,0x42,0x8D,
+0x78,0x36,0x00,0x08,
+0x01,0x00,0x05,0x24,
+0x50,0x64,0x42,0x8D,
+0x54,0x64,0x43,0x8D,
+0x48,0x64,0x64,0x8D,
+0x23,0x10,0x54,0x00,
+0xA7,0x35,0x00,0x08,
+0x23,0x28,0x44,0x00,
+0x50,0x64,0x42,0x8D,
+0x54,0x64,0x43,0x8D,
+0x48,0x64,0x64,0x8D,
+0x23,0x10,0x46,0x00,
+0x78,0x36,0x00,0x08,
+0x23,0x28,0x44,0x00,
+0x02,0x80,0x02,0x3C,
+0x18,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x1A,0x64,0x43,0x90,
+0x04,0x00,0x04,0x24,
+0x0F,0x00,0x63,0x30,
+0x04,0x00,0x63,0x28,
+0x03,0x00,0x60,0x14,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xAD,0x34,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x84,0xDB,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x62,0xAC,
+0x18,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x3E,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x0E,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x20,0x64,0x42,0x24,
+0x02,0x00,0x43,0x94,
+0x02,0x80,0x02,0x3C,
+0x3E,0x64,0x80,0xA0,
+0xFF,0xFF,0x63,0x30,
+0x10,0x00,0xA4,0x27,
+0xA0,0x40,0x00,0x0C,
+0xEC,0x63,0x43,0xAC,
+0x18,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x41,0x64,0x44,0xA0,
+0x02,0x80,0x02,0x3C,
+0x3F,0x64,0x60,0xA0,
+0x19,0x64,0x44,0x90,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x18,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x30,0xDC,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x02,0x80,0x10,0x3C,
+0x19,0x64,0x02,0x92,
+0x14,0x00,0xBF,0xAF,
+0x0F,0x00,0x42,0x30,
+0x03,0x00,0x42,0x28,
+0x05,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0xC3,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0x19,0x64,0x04,0x92,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x02,0x80,0x04,0x3C,
+0x60,0x1B,0x84,0x24,
+0xE0,0x1B,0x83,0x94,
+0xDC,0x1B,0x85,0x94,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x00,0x63,0x30,
+0x41,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0x08,0x00,0x42,0x34,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA4,
+0x08,0x00,0xE0,0x03,
+0xDC,0x1B,0x83,0xA4,
+0xE0,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x01,0x80,0x03,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x03,0x52,0x34,
+0xBC,0xDC,0x71,0x24,
+0x02,0x80,0x10,0x3C,
+0x08,0x14,0x04,0x26,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x21,0x38,0x00,0x00,
+0x00,0x00,0x51,0xAE,
+0x1B,0x3E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x3A,0x37,0x00,0x08,
+0x08,0x14,0x04,0x26,
+0x02,0x80,0x02,0x3C,
+0x88,0x37,0x43,0x8C,
+0x04,0x00,0x02,0x24,
+0x02,0x1D,0x03,0x00,
+0x0F,0x00,0x63,0x30,
+0x08,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x02,0x3C,
+0x39,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x30,0x00,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0xFF,0x00,0x62,0x30,
+0x2A,0xB0,0x02,0x3C,
+0x38,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x2C,0x00,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0xFF,0x00,0x62,0x30,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0xFF,0x90,0x30,
+0x1C,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x06,0x3C,
+0x60,0x1B,0xD1,0x24,
+0x28,0x1C,0x22,0x8E,
+0x0F,0x00,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x2A,0x00,0x40,0x14,
+0x2A,0xB0,0x02,0x3C,
+0x0A,0x00,0x45,0x34,
+0x63,0x00,0x03,0x24,
+0xFF,0xFF,0x04,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x40,0x10,
+0x64,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0xFE,0xFF,0x40,0x14,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x62,0x24,
+0xFF,0xFF,0x43,0x30,
+0xF5,0xFF,0x64,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0xC2,0x24,
+0x28,0x1C,0x48,0x94,
+0x26,0x1C,0x47,0x94,
+0x20,0x1C,0x49,0x94,
+0x22,0x1C,0x4A,0x94,
+0x24,0x1C,0x4B,0x94,
+0x25,0xB0,0x03,0x3C,
+0x38,0x02,0x6C,0x34,
+0x34,0x02,0x62,0x34,
+0xD2,0x01,0x64,0x34,
+0xD6,0x01,0x65,0x34,
+0xDA,0x01,0x66,0x34,
+0xDE,0x01,0x63,0x34,
+0x00,0x00,0x48,0xA4,
+0x00,0x00,0x89,0xA4,
+0x00,0x00,0xAA,0xA4,
+0x00,0x00,0xCB,0xA4,
+0x00,0x00,0x67,0xA4,
+0x00,0x00,0x80,0xA1,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x42,0x37,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x38,0x02,0x85,0x34,
+0x80,0xFF,0x03,0x24,
+0x00,0x00,0xA3,0xA0,
+0x34,0x02,0x8A,0x34,
+0xD2,0x01,0x85,0x34,
+0xD6,0x01,0x86,0x34,
+0xDA,0x01,0x87,0x34,
+0xDE,0x01,0x84,0x34,
+0x00,0x00,0xA8,0x94,
+0x00,0x00,0xC9,0x94,
+0x00,0x00,0xEB,0x94,
+0x00,0x00,0x8C,0x94,
+0x00,0x00,0x43,0x95,
+0x23,0x10,0x02,0x02,
+0xFF,0xFF,0x50,0x30,
+0x28,0x1C,0x23,0xA6,
+0x00,0x00,0xA0,0xA4,
+0x20,0x1C,0x28,0xA6,
+0x00,0x00,0xC0,0xA4,
+0x22,0x1C,0x29,0xA6,
+0x00,0x00,0xE0,0xA4,
+0x24,0x1C,0x2B,0xA6,
+0x00,0x00,0x80,0xA4,
+0x00,0x00,0x50,0xA5,
+0x87,0x37,0x00,0x08,
+0x26,0x1C,0x2C,0xA6,
+0xD0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xFF,0xFF,0x14,0x24,
+0x02,0x80,0x13,0x3C,
+0x41,0xB0,0x02,0x3C,
+0x60,0x1B,0x66,0x26,
+0x04,0x00,0x42,0x34,
+0x00,0x00,0x44,0x8C,
+0xD4,0x1B,0xC3,0x8C,
+0x02,0x80,0x02,0x3C,
+0x88,0x5F,0x45,0x90,
+0x25,0x90,0x64,0x00,
+0x01,0x00,0x02,0x24,
+0x25,0x03,0xA2,0x10,
+0xD4,0x1B,0xD2,0xAC,
+0x60,0x1B,0x64,0x26,
+0xD0,0x1B,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x52,0x00,
+0x01,0x00,0x42,0x30,
+0x0B,0x00,0x40,0x10,
+0x60,0x1B,0x67,0x26,
+0x25,0xB0,0x10,0x3C,
+0x04,0x00,0x0B,0x36,
+0xD4,0x1B,0x83,0x8C,
+0x00,0x00,0x69,0x8D,
+0x40,0x00,0x02,0x3C,
+0x01,0x00,0x63,0x38,
+0x24,0x10,0x22,0x01,
+0xF0,0x00,0x40,0x10,
+0xD4,0x1B,0x83,0xAC,
+0x60,0x1B,0x67,0x26,
+0xD0,0x1B,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x52,0x00,
+0x04,0x00,0x42,0x30,
+0x11,0x00,0x40,0x10,
+0x60,0x1B,0x71,0x26,
+0x25,0xB0,0x02,0x3C,
+0xD4,0x1B,0xE3,0x8C,
+0xC4,0x38,0xE6,0x8C,
+0xAC,0x1B,0xE5,0x94,
+0xFC,0x00,0x42,0x34,
+0x00,0x00,0x44,0x8C,
+0x04,0x00,0x63,0x38,
+0x21,0x48,0xC5,0x00,
+0x07,0x00,0x89,0x10,
+0xD4,0x1B,0xE3,0xAC,
+0x02,0x80,0x03,0x3C,
+0x48,0x60,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x34,
+0x48,0x60,0x62,0xAC,
+0x60,0x1B,0x71,0x26,
+0xD0,0x1B,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x52,0x00,
+0x08,0x00,0x42,0x30,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x22,0x96,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0xFD,0x02,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xD4,0x1B,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x38,
+0xD4,0x1B,0x22,0xAE,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x20,0x52,0x00,
+0x00,0x08,0x83,0x30,
+0x06,0x00,0x60,0x10,
+0x00,0x10,0x82,0x30,
+0xD4,0x1B,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x42,0x38,
+0xD4,0x1B,0x02,0xAE,
+0x00,0x10,0x82,0x30,
+0xAC,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x72,0x00,
+0x00,0x20,0x42,0x30,
+0xDC,0x00,0x40,0x14,
+0x24,0x10,0x72,0x00,
+0x00,0x80,0x42,0x30,
+0xE3,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x01,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x15,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xD0,0x1B,0x02,0x8E,
+0x02,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x47,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x04,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x79,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x08,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0xA9,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x10,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0xDB,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x20,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x0B,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x40,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x3D,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x67,0x26,
+0xD0,0x1B,0xE6,0x8C,
+0x00,0x04,0x08,0x3C,
+0x24,0x10,0xD2,0x00,
+0x24,0x10,0x48,0x00,
+0x15,0x00,0x40,0x10,
+0x2A,0xB0,0x02,0x3C,
+0x2C,0x00,0x42,0x34,
+0x00,0x00,0x49,0x8C,
+0xFF,0x00,0x02,0x24,
+0xFF,0x00,0x23,0x31,
+0x0B,0x00,0x62,0x10,
+0x02,0x80,0x05,0x3C,
+0x48,0x60,0xA3,0x8C,
+0x27,0x20,0x08,0x00,
+0x24,0x20,0xC4,0x00,
+0x41,0xB0,0x02,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x80,0x63,0x34,
+0x02,0x80,0x02,0x3C,
+0x48,0x60,0xA3,0xAC,
+0xA2,0x5F,0x40,0xA4,
+0xD0,0x1B,0xE4,0xAC,
+0xD4,0x1B,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x48,0x00,
+0xD4,0x1B,0xE2,0xAC,
+0x60,0x1B,0x66,0x26,
+0xD0,0x1B,0xC8,0x8C,
+0x00,0x08,0x04,0x3C,
+0x24,0x18,0x12,0x01,
+0x24,0x10,0x64,0x00,
+0x05,0x00,0x40,0x10,
+0x80,0x00,0x07,0x3C,
+0xD4,0x1B,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x44,0x00,
+0xD4,0x1B,0xC2,0xAC,
+0x24,0x10,0x67,0x00,
+0x1C,0x00,0x40,0x10,
+0x60,0x1B,0x64,0x26,
+0x2A,0xB0,0x02,0x3C,
+0x36,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x23,0xB0,0x04,0x3C,
+0xFF,0x1F,0x02,0x3C,
+0xC0,0x18,0x03,0x00,
+0xF0,0x07,0x63,0x30,
+0xF4,0x38,0xC5,0x8C,
+0x21,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x0A,0x00,0x65,0x10,
+0xF8,0x38,0xC3,0xAC,
+0x02,0x80,0x05,0x3C,
+0x48,0x60,0xA2,0x8C,
+0x27,0x20,0x07,0x00,
+0x24,0x20,0x04,0x01,
+0x00,0x10,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x48,0x60,0xA2,0xAC,
+0x00,0x00,0x64,0xAC,
+0xD0,0x1B,0xC4,0xAC,
+0xD4,0x1B,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x47,0x00,
+0xD4,0x1B,0xC2,0xAC,
+0x60,0x1B,0x64,0x26,
+0xD0,0x1B,0x83,0x8C,
+0x00,0x01,0x05,0x3C,
+0x24,0x18,0x72,0x00,
+0x24,0x10,0x65,0x00,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD4,0x1B,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x45,0x00,
+0xD4,0x1B,0x82,0xAC,
+0x00,0x02,0x05,0x3C,
+0x24,0x10,0x65,0x00,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD4,0x1B,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x45,0x00,
+0xD4,0x1B,0x82,0xAC,
+0x00,0x10,0x05,0x3C,
+0x24,0x10,0x65,0x00,
+0x0C,0x00,0x40,0x10,
+0x60,0x1B,0x63,0x26,
+0xB0,0x1B,0x83,0x94,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x62,0x30,
+0x02,0x00,0x40,0x10,
+0x00,0x08,0x62,0x34,
+0xB0,0x1B,0x82,0xA4,
+0xD4,0x1B,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x45,0x00,
+0xD4,0x1B,0x82,0xAC,
+0x60,0x1B,0x63,0x26,
+0xD0,0x1B,0x62,0x8C,
+0x00,0x20,0x05,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x45,0x00,
+0x0B,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x64,0x94,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x82,0x30,
+0x02,0x00,0x40,0x10,
+0xFF,0xF7,0x82,0x30,
+0xB0,0x1B,0x62,0xA4,
+0xD4,0x1B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x45,0x00,
+0xD4,0x1B,0x62,0xAC,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x20,0xBD,0x02,0x3C,
+0xEC,0x02,0x04,0x36,
+0x4D,0x00,0x07,0x36,
+0xF1,0x02,0x08,0x36,
+0x08,0x00,0x06,0x24,
+0x01,0x00,0x03,0x24,
+0x78,0x02,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x00,0x00,0xE0,0xA0,
+0x00,0x00,0x06,0xA1,
+0x00,0x00,0x80,0xAC,
+0x00,0x00,0x82,0x8C,
+0xFF,0x00,0x03,0x3C,
+0x00,0x00,0xE0,0xA0,
+0xFF,0x00,0x49,0x30,
+0x00,0x00,0x06,0xA1,
+0x25,0x48,0x23,0x01,
+0x00,0x00,0x83,0xAC,
+0xF2,0x02,0x05,0x36,
+0x80,0xFF,0x03,0x24,
+0x0A,0x00,0x0A,0x36,
+0x00,0x00,0x89,0xAC,
+0x00,0x00,0xA0,0xA0,
+0x00,0x00,0x43,0xA1,
+0x00,0x00,0x62,0x8D,
+0x80,0x00,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x02,0x00,0x40,0x10,
+0x84,0xFF,0x02,0x24,
+0x00,0x00,0x42,0xA1,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x02,0x36,
+0x00,0x00,0x43,0x94,
+0xFF,0xBF,0x04,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x00,0x43,0xA4,
+0xD0,0x37,0x00,0x08,
+0x60,0x1B,0x67,0x26,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xD4,0x1B,0x02,0x8E,
+0xD0,0x1B,0x03,0x8E,
+0x00,0x20,0x42,0x38,
+0xD4,0x1B,0x02,0xAE,
+0x24,0x10,0x72,0x00,
+0x00,0x80,0x42,0x30,
+0x1F,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x0C,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x26,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0x1A,0x02,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1F,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x28,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x80,0x37,0x09,0xA2,
+0xBC,0x37,0x03,0xAE,
+0x03,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x07,0x3C,
+0x02,0x80,0x08,0x3C,
+0x48,0x60,0xE5,0x8C,
+0x58,0x60,0x06,0x91,
+0xD0,0x1B,0x04,0x8E,
+0x01,0x00,0x09,0x3C,
+0x00,0x80,0x22,0x35,
+0x27,0x10,0x02,0x00,
+0x80,0xFF,0x03,0x24,
+0x24,0x20,0x82,0x00,
+0x25,0x30,0xC3,0x00,
+0x00,0x01,0xA5,0x34,
+0x41,0xB0,0x02,0x3C,
+0x48,0x60,0xE5,0xAC,
+0x58,0x60,0x06,0xA1,
+0x27,0xA0,0x09,0x00,
+0x00,0x00,0x44,0xAC,
+0xD0,0x1B,0x04,0xAE,
+0x60,0x1B,0x63,0x26,
+0xD4,0x1B,0x62,0x8C,
+0x60,0x1B,0x70,0x26,
+0x00,0x80,0x42,0x38,
+0xD4,0x1B,0x62,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x01,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0xED,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x10,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x25,0x00,0x66,0x10,
+0x60,0x1B,0x62,0x26,
+0x00,0x80,0x22,0x31,
+0xFC,0x01,0x40,0x10,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1D,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x28,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xBC,0x37,0x03,0xAE,
+0x03,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x84,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC4,0x8C,
+0x58,0x60,0xE5,0x90,
+0xD0,0x1B,0x03,0x8E,
+0x01,0x00,0x02,0x3C,
+0x00,0x80,0x42,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x18,0x62,0x00,
+0x00,0x01,0x84,0x34,
+0x40,0x00,0xA5,0x34,
+0x41,0xB0,0x02,0x3C,
+0x48,0x60,0xC4,0xAC,
+0x58,0x60,0xE5,0xA0,
+0x00,0x00,0x43,0xAC,
+0xD0,0x1B,0x03,0xAE,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x01,0x00,0x04,0x3C,
+0x60,0x1B,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x02,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0xBC,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x14,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x25,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0xE3,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1E,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x34,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xC8,0x37,0x03,0xAE,
+0x04,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x88,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC3,0x8C,
+0x58,0x60,0xE4,0x90,
+0xD0,0x1B,0x05,0x8E,
+0x06,0x00,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x02,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x20,0x00,0x84,0x34,
+0x48,0x60,0xC3,0xAC,
+0x58,0x60,0xE4,0xA0,
+0x00,0x00,0x45,0xAC,
+0x04,0x00,0x02,0x3C,
+0xD0,0x1B,0x05,0xAE,
+0x26,0xA0,0x82,0x02,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x02,0x00,0x04,0x3C,
+0x60,0x1B,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x04,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x8A,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x18,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x23,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0xC6,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1C,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x34,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xC8,0x37,0x03,0xAE,
+0x04,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x8C,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC3,0x8C,
+0x58,0x60,0xE4,0x90,
+0xD0,0x1B,0x05,0x8E,
+0x06,0x00,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x02,0x63,0x34,
+0x10,0x00,0x84,0x34,
+0x41,0xB0,0x02,0x3C,
+0x48,0x60,0xC3,0xAC,
+0x58,0x60,0xE4,0xA0,
+0x00,0x00,0x45,0xAC,
+0xD0,0x1B,0x05,0xAE,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x04,0x00,0x04,0x3C,
+0x60,0x1B,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x08,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x5A,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x1C,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x25,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0xAC,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1E,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x40,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xD4,0x37,0x03,0xAE,
+0x05,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x90,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC3,0x8C,
+0x58,0x60,0xE4,0x90,
+0xD0,0x1B,0x05,0x8E,
+0x18,0x00,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x04,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x08,0x00,0x84,0x34,
+0x48,0x60,0xC3,0xAC,
+0x58,0x60,0xE4,0xA0,
+0x00,0x00,0x45,0xAC,
+0x10,0x00,0x02,0x3C,
+0xD0,0x1B,0x05,0xAE,
+0x26,0xA0,0x82,0x02,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x08,0x00,0x04,0x3C,
+0x60,0x1B,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x10,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x28,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x20,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x23,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0x8F,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1C,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x40,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xD4,0x37,0x03,0xAE,
+0x05,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x9C,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC3,0x8C,
+0x58,0x60,0xE4,0x90,
+0xD0,0x1B,0x05,0x8E,
+0x18,0x00,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x04,0x63,0x34,
+0x01,0x00,0x84,0x34,
+0x41,0xB0,0x02,0x3C,
+0x48,0x60,0xC3,0xAC,
+0x58,0x60,0xE4,0xA0,
+0x00,0x00,0x45,0xAC,
+0xD0,0x1B,0x05,0xAE,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x10,0x00,0x04,0x3C,
+0x60,0x1B,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x20,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0xF8,0xFD,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x24,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x25,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0x75,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1E,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x4C,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xE0,0x37,0x03,0xAE,
+0x06,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x94,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC3,0x8C,
+0x58,0x60,0xE4,0x90,
+0xD0,0x1B,0x05,0x8E,
+0x60,0x00,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x08,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x04,0x00,0x84,0x34,
+0x48,0x60,0xC3,0xAC,
+0x58,0x60,0xE4,0xA0,
+0x00,0x00,0x45,0xAC,
+0x40,0x00,0x02,0x3C,
+0xD0,0x1B,0x05,0xAE,
+0x26,0xA0,0x82,0x02,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x20,0x00,0x04,0x3C,
+0x60,0x1B,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x40,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0xC6,0xFD,0x40,0x10,
+0x60,0x1B,0x67,0x26,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x28,0x00,0xA4,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x23,0x31,
+0x23,0x00,0x66,0x10,
+0x00,0x80,0x22,0x31,
+0x58,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0xFF,0x00,0x02,0x24,
+0x1C,0x00,0x62,0x10,
+0xFF,0x00,0x23,0x31,
+0x60,0x1B,0x70,0x26,
+0x4C,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xE0,0x37,0x03,0xAE,
+0x06,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x98,0x37,0x09,0xA2,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x48,0x60,0xC3,0x8C,
+0x58,0x60,0xE4,0x90,
+0xD0,0x1B,0x05,0x8E,
+0x60,0x00,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x08,0x63,0x34,
+0x02,0x00,0x84,0x34,
+0x41,0xB0,0x02,0x3C,
+0x48,0x60,0xC3,0xAC,
+0x58,0x60,0xE4,0xA0,
+0x00,0x00,0x45,0xAC,
+0xD0,0x1B,0x05,0xAE,
+0x60,0x1B,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x40,0x00,0x04,0x3C,
+0x26,0x18,0x64,0x00,
+0x41,0x38,0x00,0x08,
+0xD4,0x1B,0x43,0xAC,
+0xD2,0x36,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x02,0x3C,
+0x08,0x00,0x44,0x34,
+0x00,0x00,0x89,0x8C,
+0xFF,0x00,0x02,0x24,
+0xFF,0x00,0x23,0x31,
+0x27,0x00,0x62,0x10,
+0x00,0x80,0x22,0x31,
+0x43,0x01,0x40,0x14,
+0x00,0x80,0x02,0x3C,
+0x00,0xFF,0x02,0x3C,
+0x24,0x10,0x22,0x01,
+0x09,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0xA8,0x37,0x02,0x92,
+0x20,0xB0,0x03,0x3C,
+0x00,0x12,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x0C,0x00,0x49,0x8C,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x23,0x31,
+0xFF,0x00,0x02,0x24,
+0x17,0x00,0x62,0x10,
+0x60,0x1B,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x70,0x38,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x04,0x38,0x03,0xAE,
+0x21,0x30,0x60,0x00,
+0x01,0x00,0x04,0x24,
+0xA8,0x37,0x09,0xA2,
+0x80,0x00,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x05,0x3C,
+0x48,0x60,0xA3,0x8C,
+0xD0,0x1B,0x04,0x8E,
+0xFF,0xC7,0x02,0x24,
+0x10,0x00,0x63,0x34,
+0x24,0x20,0x82,0x00,
+0x41,0xB0,0x02,0x3C,
+0x48,0x60,0xA3,0xAC,
+0x00,0x00,0x44,0xAC,
+0xD0,0x1B,0x04,0xAE,
+0x60,0x1B,0x63,0x26,
+0xD4,0x1B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x38,
+0x03,0x38,0x00,0x08,
+0xD4,0x1B,0x62,0xAC,
+0x25,0xB0,0x02,0x3C,
+0x56,0x01,0x42,0x34,
+0x00,0x00,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0xD7,0xFC,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x75,0x57,0x00,0x0C,
+0x07,0x00,0x04,0x24,
+0xC0,0x37,0x00,0x08,
+0x60,0x1B,0x64,0x26,
+0xE4,0x1D,0x24,0x96,
+0x58,0x38,0x26,0x96,
+0x01,0x00,0x84,0x24,
+0x00,0x19,0x04,0x00,
+0x25,0x30,0xC2,0x00,
+0xF0,0xFF,0x63,0x30,
+0x20,0x00,0xC5,0x24,
+0x02,0x12,0x03,0x00,
+0xE4,0x1D,0x24,0xA6,
+0x17,0x00,0xA2,0xA0,
+0x16,0x00,0xA3,0xA0,
+0x0C,0x00,0xC4,0x8C,
+0x00,0xF0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0x0F,0x63,0x30,
+0x00,0x1C,0x03,0x00,
+0x24,0x20,0x82,0x00,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0xC4,0xAC,
+0x58,0x38,0x25,0x8E,
+0x01,0x00,0x10,0x24,
+0x01,0x00,0x04,0x24,
+0x31,0x10,0x06,0x3C,
+0x00,0x01,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x2A,0xB0,0x02,0x3C,
+0x01,0x00,0x42,0x34,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x50,0xA0,
+0x00,0x00,0x43,0xA0,
+0xD4,0x1B,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x38,
+0xF5,0x37,0x00,0x08,
+0xD4,0x1B,0x22,0xAE,
+0x24,0x10,0x22,0x01,
+0xE8,0xFD,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x40,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x80,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x80,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x80,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0xFC,0x38,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x00,0xFF,0x02,0x3C,
+0x24,0x10,0x22,0x01,
+0x04,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x41,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x84,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x84,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x84,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x36,0x39,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x24,0x10,0x22,0x01,
+0x1F,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x42,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x88,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x88,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x88,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x6E,0x39,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x24,0x10,0x22,0x01,
+0x3C,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x43,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x8C,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x8C,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x8C,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0xA8,0x39,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x24,0x10,0x22,0x01,
+0x56,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x44,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x90,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x90,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x90,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0xDF,0x39,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x24,0x10,0x22,0x01,
+0x73,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x45,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x9C,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x9C,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x9C,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x19,0x3A,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x24,0x10,0x22,0x01,
+0x8D,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x46,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x94,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x60,0x1B,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x94,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x94,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x50,0x3A,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x24,0x10,0x22,0x01,
+0xAA,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x47,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0D,0x00,0x86,0x10,
+0x60,0x1B,0x62,0x26,
+0x98,0x37,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x10,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x98,0x37,0xC3,0xA0,
+0x60,0x1B,0x62,0x26,
+0x98,0x37,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x8A,0x3A,0x00,0x08,
+0xFF,0x00,0x23,0x31,
+0x00,0x00,0x82,0xAC,
+0xC5,0x3A,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0xD8,0xFF,0xBD,0x27,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xF8,0xEF,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x12,0x3C,
+0x41,0xB0,0x02,0x3C,
+0x60,0x1B,0x50,0x26,
+0x0A,0x00,0x42,0x34,
+0x00,0x00,0x44,0x94,
+0xDE,0x1B,0x03,0x96,
+0xDC,0x1B,0x02,0x96,
+0x25,0x18,0x64,0x00,
+0xFF,0xFF,0x71,0x30,
+0x24,0x10,0x51,0x00,
+0x02,0x00,0x42,0x30,
+0xAF,0x00,0x40,0x14,
+0x02,0x00,0x62,0x38,
+0xDE,0x1B,0x03,0xA6,
+0x60,0x1B,0x46,0x26,
+0xDC,0x1B,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x24,0x28,0x51,0x00,
+0x04,0x00,0xA3,0x30,
+0x08,0x00,0x60,0x10,
+0x08,0x00,0xA2,0x30,
+0xDE,0x1B,0xC2,0x94,
+0x41,0xB0,0x03,0x3C,
+0x0C,0x00,0x63,0x34,
+0x04,0x00,0x42,0x38,
+0x00,0x00,0x64,0x90,
+0xDE,0x1B,0xC2,0xA4,
+0x08,0x00,0xA2,0x30,
+0x06,0x00,0x40,0x10,
+0x10,0x00,0xA2,0x30,
+0xDE,0x1B,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x38,
+0xDE,0x1B,0xC2,0xA4,
+0x10,0x00,0xA2,0x30,
+0x06,0x00,0x40,0x10,
+0x20,0x00,0xA2,0x30,
+0xDE,0x1B,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x42,0x38,
+0xDE,0x1B,0xC2,0xA4,
+0x20,0x00,0xA2,0x30,
+0x06,0x00,0x40,0x10,
+0x80,0x00,0xA2,0x30,
+0xDE,0x1B,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x38,
+0xDE,0x1B,0xC2,0xA4,
+0x80,0x00,0xA2,0x30,
+0x75,0x00,0x40,0x10,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x50,0x34,
+0xDE,0x1B,0xC3,0x94,
+0x00,0x00,0x02,0x92,
+0x80,0x00,0x63,0x38,
+0x20,0x00,0x42,0x30,
+0x62,0x00,0x40,0x10,
+0xDE,0x1B,0xC3,0xA4,
+0xB0,0x1B,0xC2,0x94,
+0x20,0x00,0x03,0x24,
+0x00,0x00,0x03,0xA2,
+0x00,0x01,0x42,0x30,
+0x5D,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x07,0x3C,
+0x18,0x64,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x58,0x00,0x40,0x10,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x04,0x3C,
+0x2C,0x64,0x82,0x8C,
+0x50,0x64,0x64,0x8E,
+0x54,0x64,0x65,0x8E,
+0x21,0x18,0x00,0x00,
+0x21,0x10,0x44,0x00,
+0x2B,0x30,0x44,0x00,
+0x21,0x18,0x65,0x00,
+0x21,0x18,0x66,0x00,
+0x50,0x64,0x62,0xAE,
+0x54,0x64,0x63,0xAE,
+0x18,0x64,0xE4,0x90,
+0x02,0x00,0x02,0x24,
+0xFF,0x00,0x84,0x30,
+0x0B,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x64,0xE2,0x90,
+0x03,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x64,0xE2,0x90,
+0x05,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x90,0x00,0x43,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x10,0x3C,
+0x3C,0x64,0x02,0x92,
+0x02,0x80,0x03,0x3C,
+0x20,0x64,0x74,0x24,
+0xFF,0xFF,0x42,0x24,
+0x3C,0x64,0x02,0xA2,
+0x07,0x00,0x84,0x92,
+0xA4,0x60,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x01,0x00,0x03,0x24,
+0x9F,0x00,0x43,0x10,
+0x25,0xB0,0x06,0x3C,
+0x84,0x00,0xC4,0x34,
+0x80,0x00,0xC6,0x34,
+0x00,0x00,0x82,0x8C,
+0x02,0x80,0x08,0x3C,
+0x00,0x00,0xC4,0x8C,
+0x42,0xB0,0x0A,0x3C,
+0x48,0x64,0x06,0x8D,
+0x21,0x10,0x00,0x00,
+0x50,0x64,0x68,0x8E,
+0x54,0x64,0x69,0x8E,
+0x00,0x00,0x45,0x91,
+0x25,0x10,0x44,0x00,
+0x21,0x10,0x46,0x00,
+0xFB,0xFF,0x04,0x24,
+0x24,0x28,0xA4,0x00,
+0x23,0x40,0x02,0x01,
+0x00,0x00,0x45,0xA1,
+0x04,0x00,0x00,0x11,
+0x01,0x00,0x06,0x24,
+0x80,0x10,0x08,0x00,
+0x21,0x10,0x48,0x00,
+0x80,0x30,0x02,0x00,
+0x01,0x00,0x04,0x24,
+0x59,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x64,0xCD,0xA4,0x94,
+0x34,0x64,0x43,0x94,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0x82,0x30,
+0xFF,0xFF,0x63,0x30,
+0x2B,0x10,0x43,0x00,
+0x5B,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0x64,0xCD,0xA0,0xA4,
+0x0F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0x02,0x00,0x40,0x14,
+0x01,0x00,0x04,0x24,
+0x21,0x20,0x00,0x00,
+0x90,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x48,0x60,0xA3,0x8C,
+0x60,0x1B,0x46,0x26,
+0xDC,0x1B,0xC4,0x94,
+0x10,0x00,0x02,0x3C,
+0x25,0x18,0x62,0x00,
+0x41,0xB0,0x02,0x3C,
+0x7F,0xFF,0x84,0x30,
+0x08,0x00,0x42,0x34,
+0x48,0x60,0xA3,0xAC,
+0x00,0x00,0x44,0xA4,
+0xDC,0x1B,0xC4,0xA4,
+0x60,0x1B,0x46,0x26,
+0xDC,0x1B,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x51,0x00,
+0x00,0x30,0x42,0x30,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xDE,0x1B,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x38,
+0x00,0x20,0x42,0x34,
+0xDE,0x1B,0xC2,0xA4,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x82,0x40,0x00,0x0C,
+0xDE,0x1B,0x02,0xA6,
+0x02,0x80,0x05,0x3C,
+0x19,0x64,0xA2,0xA0,
+0x19,0x64,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x30,
+0x0B,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x19,0x64,0xA2,0x90,
+0xDF,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x19,0x64,0xA2,0xA0,
+0x02,0x80,0x03,0x3C,
+0x18,0x64,0x62,0x90,
+0x05,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x0E,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x48,0x60,0xA3,0x8C,
+0x60,0x1B,0x46,0x26,
+0xDC,0x1B,0xC4,0x94,
+0x00,0x80,0x02,0x3C,
+0x25,0x18,0x62,0x00,
+0x41,0xB0,0x02,0x3C,
+0xFD,0xFF,0x84,0x30,
+0x08,0x00,0x42,0x34,
+0x48,0x60,0xA3,0xAC,
+0x00,0x00,0x44,0xA4,
+0x18,0x3C,0x00,0x08,
+0xDC,0x1B,0xC4,0xA4,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xEF,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x39,0x64,0x82,0x90,
+0xFB,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0x82,0xA0,
+0x19,0x64,0xA4,0x90,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x0C,
+0x08,0x64,0x40,0xAC,
+0xD9,0x3C,0x00,0x08,
+0x02,0x80,0x05,0x3C,
+0xA5,0x3C,0x00,0x08,
+0x64,0xCD,0xA4,0xA4,
+0x02,0x80,0x04,0x3C,
+0x39,0x64,0x82,0x90,
+0x02,0x80,0x03,0x3C,
+0x20,0x64,0x63,0x24,
+0x10,0x00,0x42,0x34,
+0x39,0x64,0x82,0xA0,
+0x06,0x00,0x62,0x90,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x30,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x59,0x27,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x44,0x00,0x02,0x24,
+0x00,0x00,0x02,0xA2,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x84,0xFF,0x40,0x10,
+0x04,0x00,0x04,0x24,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x93,0x3C,0x00,0x08,
+0x02,0x80,0x05,0x3C,
+0x3C,0x64,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x3B,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x3C,0x64,0x03,0xA2,
+0x02,0x80,0x06,0x3C,
+0x39,0x64,0xC3,0x90,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x10,0x00,0x63,0x34,
+0x39,0x64,0xC3,0xA0,
+0x06,0x00,0x82,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x30,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x59,0x27,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x42,0xB0,0x02,0x3C,
+0x44,0x00,0x04,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x09,0x3D,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x00,0x40,0x02,0x40,
+0x00,0x68,0x03,0x40,
+0x00,0x70,0x02,0x40,
+0x00,0x60,0x03,0x40,
+0x02,0x80,0x02,0x3C,
+0x68,0xCD,0x45,0x8C,
+0x25,0xB0,0x03,0x3C,
+0x01,0x80,0x02,0x3C,
+0x18,0x03,0x64,0x34,
+0xB4,0xF4,0x42,0x24,
+0x00,0x00,0x82,0xAC,
+0x6C,0x03,0x63,0x34,
+0x21,0x10,0xA0,0x00,
+0x00,0x00,0x62,0xAC,
+0x01,0x00,0xA5,0x24,
+0x21,0x10,0xA0,0x00,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x62,0xAC,
+0x3A,0x3D,0x00,0x08,
+0x21,0x10,0xA0,0x00,
+0x01,0x80,0x1B,0x3C,
+0x04,0xF5,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x21,0xD8,0xA0,0x03,
+0x82,0xDA,0x1B,0x00,
+0x80,0xDA,0x1B,0x00,
+0x08,0x00,0x7B,0x27,
+0x04,0x00,0x61,0xAF,
+0x08,0x00,0x62,0xAF,
+0x0C,0x00,0x63,0xAF,
+0x10,0x00,0x64,0xAF,
+0x14,0x00,0x65,0xAF,
+0x18,0x00,0x66,0xAF,
+0x1C,0x00,0x67,0xAF,
+0x20,0x00,0x68,0xAF,
+0x24,0x00,0x69,0xAF,
+0x28,0x00,0x6A,0xAF,
+0x2C,0x00,0x6B,0xAF,
+0x30,0x00,0x6C,0xAF,
+0x34,0x00,0x6D,0xAF,
+0x38,0x00,0x6E,0xAF,
+0x3C,0x00,0x6F,0xAF,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x70,0x0A,0x40,
+0x40,0x00,0x70,0xAF,
+0x44,0x00,0x71,0xAF,
+0x48,0x00,0x72,0xAF,
+0x4C,0x00,0x73,0xAF,
+0x50,0x00,0x74,0xAF,
+0x54,0x00,0x75,0xAF,
+0x58,0x00,0x76,0xAF,
+0x5C,0x00,0x77,0xAF,
+0x60,0x00,0x78,0xAF,
+0x64,0x00,0x79,0xAF,
+0x68,0x00,0x7C,0xAF,
+0x6C,0x00,0x7D,0xAF,
+0x70,0x00,0x7E,0xAF,
+0x74,0x00,0x7F,0xAF,
+0x78,0x00,0x68,0xAF,
+0x7C,0x00,0x69,0xAF,
+0x80,0x00,0x6A,0xAF,
+0x00,0x68,0x1A,0x40,
+0x7F,0x00,0x5B,0x33,
+0x2D,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0xA0,0x03,
+0x82,0xDA,0x1B,0x00,
+0x80,0xDA,0x1B,0x00,
+0x08,0x00,0x7B,0x27,
+0x04,0x00,0x61,0xAF,
+0x08,0x00,0x62,0xAF,
+0x0C,0x00,0x63,0xAF,
+0x10,0x00,0x64,0xAF,
+0x14,0x00,0x65,0xAF,
+0x18,0x00,0x66,0xAF,
+0x1C,0x00,0x67,0xAF,
+0x20,0x00,0x68,0xAF,
+0x24,0x00,0x69,0xAF,
+0x28,0x00,0x6A,0xAF,
+0x2C,0x00,0x6B,0xAF,
+0x30,0x00,0x6C,0xAF,
+0x34,0x00,0x6D,0xAF,
+0x38,0x00,0x6E,0xAF,
+0x3C,0x00,0x6F,0xAF,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x70,0x0A,0x40,
+0x40,0x00,0x70,0xAF,
+0x44,0x00,0x71,0xAF,
+0x48,0x00,0x72,0xAF,
+0x4C,0x00,0x73,0xAF,
+0x50,0x00,0x74,0xAF,
+0x54,0x00,0x75,0xAF,
+0x58,0x00,0x76,0xAF,
+0x5C,0x00,0x77,0xAF,
+0x60,0x00,0x78,0xAF,
+0x64,0x00,0x79,0xAF,
+0x68,0x00,0x7C,0xAF,
+0x6C,0x00,0x7D,0xAF,
+0x70,0x00,0x7E,0xAF,
+0x74,0x00,0x7F,0xAF,
+0x78,0x00,0x68,0xAF,
+0x7C,0x00,0x69,0xAF,
+0x80,0x00,0x6A,0xAF,
+0x2D,0x3D,0x00,0x08,
+0x21,0x20,0x60,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x04,0x5B,0x33,
+0x07,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x08,0x3C,
+0xAC,0xDE,0x08,0x25,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x00,0x01,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x5B,0x33,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x08,0x3C,
+0xF8,0xEF,0x08,0x25,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x00,0x01,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x1A,0x3C,
+0x48,0x60,0x5A,0x27,
+0x04,0x00,0x5B,0x97,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x08,0xE8,0x9B,0x27,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x61,0x8F,
+0xFC,0x03,0x70,0x7B,
+0x7C,0x00,0x62,0x7B,
+0xBC,0x00,0x64,0x7B,
+0xFC,0x00,0x66,0x7B,
+0x3C,0x01,0x68,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x6A,0x7B,
+0xBC,0x01,0x6C,0x7B,
+0xFC,0x01,0x6E,0x7B,
+0x3C,0x02,0x70,0x7B,
+0x7C,0x02,0x72,0x7B,
+0xBC,0x02,0x74,0x7B,
+0xFC,0x02,0x76,0x7B,
+0x3C,0x03,0x78,0x7B,
+0x7C,0x03,0x7C,0x7B,
+0xBC,0x03,0x7E,0x7B,
+0x80,0x00,0x7B,0x8F,
+0x19,0x3E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0xA0,0x03,
+0x82,0xDA,0x1B,0x00,
+0x80,0xDA,0x1B,0x00,
+0x08,0x00,0x7B,0x27,
+0x08,0x00,0x5B,0xAF,
+0xFC,0xEB,0x9D,0x27,
+0x00,0x00,0x4A,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x00,0x40,0x11,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x08,0x3C,
+0xA8,0x5F,0x08,0x25,
+0x21,0x48,0x00,0x00,
+0x21,0x58,0x00,0x00,
+0x01,0x00,0x6B,0x25,
+0x1A,0x00,0x40,0x11,
+0x24,0x70,0x4B,0x01,
+0x14,0x00,0xC0,0x11,
+0x01,0x00,0x04,0x24,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x44,0xA3,
+0x26,0x50,0x4B,0x01,
+0x00,0x00,0x4A,0xAF,
+0x80,0x80,0x09,0x00,
+0x21,0x80,0x08,0x02,
+0x00,0x00,0x10,0x8E,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x00,0x02,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x1B,0x3C,
+0x90,0xF7,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x02,0x80,0x1A,0x3C,
+0x48,0x60,0x5A,0x27,
+0xE1,0xFF,0x00,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x29,0x25,
+0x40,0x58,0x0B,0x00,
+0xDC,0x3D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x1B,0x3C,
+0x48,0x60,0x7B,0x27,
+0x21,0x60,0x00,0x00,
+0x04,0x00,0x6C,0xA7,
+0x08,0x00,0x7A,0x8F,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x5A,0x27,
+0x00,0x00,0x5A,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x5A,0x27,
+0x84,0x00,0x44,0x8F,
+0x00,0x00,0x00,0x00,
+0xF9,0xFF,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x41,0x8F,
+0xFC,0x03,0x50,0x7B,
+0x7C,0x00,0x42,0x7B,
+0xBC,0x00,0x44,0x7B,
+0xFC,0x00,0x46,0x7B,
+0x3C,0x01,0x48,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x4A,0x7B,
+0xBC,0x01,0x4C,0x7B,
+0xFC,0x01,0x4E,0x7B,
+0x3C,0x02,0x50,0x7B,
+0x7C,0x02,0x52,0x7B,
+0xBC,0x02,0x54,0x7B,
+0xFC,0x02,0x56,0x7B,
+0x3C,0x03,0x58,0x7B,
+0x7C,0x03,0x5C,0x7B,
+0xBC,0x03,0x5E,0x7B,
+0x80,0x00,0x5B,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x60,0x03,
+0x10,0x00,0x00,0x42,
+0x00,0x60,0x05,0x40,
+0x42,0x28,0x05,0x00,
+0x40,0x28,0x05,0x00,
+0x00,0x60,0x85,0x40,
+0x04,0x00,0x81,0xAC,
+0x08,0x00,0x82,0xAC,
+0x0C,0x00,0x83,0xAC,
+0x20,0x00,0x88,0xAC,
+0x24,0x00,0x89,0xAC,
+0x28,0x00,0x8A,0xAC,
+0x2C,0x00,0x8B,0xAC,
+0x30,0x00,0x8C,0xAC,
+0x34,0x00,0x8D,0xAC,
+0x38,0x00,0x8E,0xAC,
+0x3C,0x00,0x8F,0xAC,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x40,0x00,0x90,0xAC,
+0x44,0x00,0x91,0xAC,
+0x48,0x00,0x92,0xAC,
+0x4C,0x00,0x93,0xAC,
+0x50,0x00,0x94,0xAC,
+0x54,0x00,0x95,0xAC,
+0x58,0x00,0x96,0xAC,
+0x5C,0x00,0x97,0xAC,
+0x60,0x00,0x98,0xAC,
+0x64,0x00,0x99,0xAC,
+0x68,0x00,0x9C,0xAC,
+0x6C,0x00,0x9D,0xAC,
+0x70,0x00,0x9E,0xAC,
+0x74,0x00,0x9F,0xAC,
+0x78,0x00,0x88,0xAC,
+0x7C,0x00,0x89,0xAC,
+0x80,0x00,0x9F,0xAC,
+0xF8,0xFF,0x84,0x24,
+0x00,0x00,0x84,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x84,0x24,
+0x84,0x00,0x86,0x8C,
+0x00,0x00,0x00,0x00,
+0xF9,0xFF,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0x80,0x00,
+0x01,0x00,0xBA,0x34,
+0x04,0x00,0x61,0x8F,
+0xFC,0x03,0x70,0x7B,
+0x7C,0x00,0x62,0x7B,
+0xBC,0x00,0x64,0x7B,
+0xFC,0x00,0x66,0x7B,
+0x3C,0x01,0x68,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x6A,0x7B,
+0xBC,0x01,0x6C,0x7B,
+0xFC,0x01,0x6E,0x7B,
+0x3C,0x02,0x70,0x7B,
+0x7C,0x02,0x72,0x7B,
+0xBC,0x02,0x74,0x7B,
+0xFC,0x02,0x76,0x7B,
+0x3C,0x03,0x78,0x7B,
+0x7C,0x03,0x7C,0x7B,
+0xBC,0x03,0x7E,0x7B,
+0x80,0x00,0x7B,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x60,0x03,
+0x00,0x60,0x9A,0x40,
+0x00,0x60,0x05,0x40,
+0x42,0x28,0x05,0x00,
+0x40,0x28,0x05,0x00,
+0x00,0x60,0x85,0x40,
+0x04,0x00,0x81,0xAC,
+0x08,0x00,0x82,0xAC,
+0x0C,0x00,0x83,0xAC,
+0x20,0x00,0x88,0xAC,
+0x24,0x00,0x89,0xAC,
+0x28,0x00,0x8A,0xAC,
+0x2C,0x00,0x8B,0xAC,
+0x30,0x00,0x8C,0xAC,
+0x34,0x00,0x8D,0xAC,
+0x38,0x00,0x8E,0xAC,
+0x3C,0x00,0x8F,0xAC,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x40,0x00,0x90,0xAC,
+0x44,0x00,0x91,0xAC,
+0x48,0x00,0x92,0xAC,
+0x4C,0x00,0x93,0xAC,
+0x50,0x00,0x94,0xAC,
+0x54,0x00,0x94,0xAC,
+0x58,0x00,0x96,0xAC,
+0x5C,0x00,0x96,0xAC,
+0x60,0x00,0x98,0xAC,
+0x64,0x00,0x99,0xAC,
+0x68,0x00,0x9C,0xAC,
+0x6C,0x00,0x9D,0xAC,
+0x70,0x00,0x9E,0xAC,
+0x78,0x00,0x88,0xAC,
+0x7C,0x00,0x89,0xAC,
+0x80,0x00,0x9F,0xAC,
+0x84,0x00,0x80,0xAC,
+0xF8,0xFF,0x84,0x24,
+0x00,0x00,0x84,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x84,0x24,
+0x84,0x00,0x86,0x8C,
+0xFA,0xFF,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0x80,0x00,
+0x01,0x00,0xBA,0x24,
+0x04,0x00,0x61,0x8F,
+0xFC,0x03,0x70,0x7B,
+0x7C,0x00,0x62,0x7B,
+0xBC,0x00,0x64,0x7B,
+0xFC,0x00,0x66,0x7B,
+0x3C,0x01,0x68,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x6A,0x7B,
+0xBC,0x01,0x6C,0x7B,
+0xFC,0x01,0x6E,0x7B,
+0x3C,0x02,0x70,0x7B,
+0x7C,0x02,0x72,0x7B,
+0xBC,0x02,0x74,0x7B,
+0xFC,0x02,0x76,0x7B,
+0x3C,0x03,0x78,0x7B,
+0x7C,0x03,0x7C,0x7B,
+0xBC,0x03,0x7E,0x7B,
+0x80,0x00,0x7B,0x8F,
+0x08,0x00,0x60,0x03,
+0x00,0x60,0x9A,0x40,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xF0,0x4F,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x1B,0x3C,
+0x00,0x00,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x00,0x00,0x05,0x24,
+0x03,0x00,0xA4,0x24,
+0x00,0xA0,0x80,0x40,
+0x00,0xA0,0x84,0x40,
+0x01,0x80,0x04,0x3C,
+0x40,0x00,0x84,0x24,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x1B,0x3C,
+0x40,0x00,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x02,0x80,0x1A,0x3C,
+0x00,0x00,0x5A,0x27,
+0xFC,0x03,0x5D,0x27,
+0x02,0x80,0x1C,0x3C,
+0x00,0x18,0x9C,0x27,
+0x00,0xF0,0x08,0x3C,
+0x00,0x0C,0x08,0x35,
+0x00,0x60,0x88,0x40,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x84,0x24,
+0xFF,0x7F,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x20,0x85,0x00,
+0x00,0x20,0x84,0x4C,
+0xFF,0xFF,0x05,0x34,
+0x21,0x28,0xA4,0x00,
+0x00,0x28,0x85,0x4C,
+0x02,0x80,0x08,0x3C,
+0x00,0x00,0x08,0x25,
+0x00,0x00,0x00,0xAD,
+0x03,0x80,0x09,0x3C,
+0x04,0xDD,0x29,0x25,
+0x04,0x00,0x08,0x25,
+0xFE,0xFF,0x09,0x15,
+0x00,0x00,0x00,0xAD,
+0x00,0x80,0x04,0x3C,
+0x00,0x00,0x84,0x24,
+0xFF,0x7F,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x20,0x85,0x00,
+0x00,0x00,0x84,0x4C,
+0xFF,0xFF,0x06,0x34,
+0x21,0x30,0xC4,0x00,
+0x24,0x30,0xC5,0x00,
+0x00,0x08,0x86,0x4C,
+0x00,0xA0,0x04,0x40,
+0x10,0x00,0x84,0x34,
+0x00,0xA0,0x84,0x40,
+0x01,0x80,0x1B,0x3C,
+0xEC,0x00,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x85,0x84,
+0x20,0x00,0x06,0x24,
+0x25,0x28,0xA6,0x00,
+0x00,0x00,0x85,0xA4,
+0x01,0x80,0x1B,0x3C,
+0x1C,0x01,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x25,0xB0,0x04,0x3C,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x85,0x8C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xA5,0x30,
+0xFC,0xFF,0xA0,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0x1F,0x07,0x3C,
+0xFF,0xFF,0xE7,0x34,
+0x02,0x80,0x05,0x3C,
+0x58,0x5F,0xA5,0x24,
+0xFF,0xFF,0xA5,0x30,
+0x40,0xB0,0x04,0x3C,
+0x25,0x28,0xA4,0x00,
+0x24,0x28,0xA7,0x00,
+0x21,0x30,0x00,0x00,
+0x43,0xB0,0x02,0x3C,
+0x00,0x80,0x04,0x3C,
+0x40,0x00,0x84,0x34,
+0x00,0x00,0x45,0xAC,
+0x04,0x00,0x46,0xAC,
+0x08,0x00,0x44,0xAC,
+0x10,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x04,0x00,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x64,0x30,
+0x02,0x1C,0x03,0x00,
+0x08,0x00,0x80,0x10,
+0x0F,0x00,0x63,0x30,
+0x01,0x00,0x02,0x24,
+0x0C,0x00,0x62,0x10,
+0x03,0x00,0x02,0x24,
+0x0E,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x60,0x14,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x5B,0x5F,0x40,0xA0,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x5B,0x5F,0x43,0xA0,
+0x02,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x5B,0x5F,0x43,0xA0,
+0x04,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x5B,0x5F,0x43,0xA0,
+0x25,0xB0,0x02,0x3C,
+0xDC,0x02,0x47,0x34,
+0x88,0x40,0x00,0x08,
+0x21,0x30,0x00,0x00,
+0x09,0x00,0xA0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE2,0x90,
+0x00,0x00,0xE3,0x90,
+0x01,0x00,0xC4,0x24,
+0xFF,0x00,0x42,0x30,
+0xFF,0x00,0x63,0x30,
+0x64,0x00,0xC5,0x2C,
+0xF7,0xFF,0x62,0x14,
+0xFF,0xFF,0x86,0x30,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x41,0x04,
+0xFF,0xFF,0x42,0x24,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x42,0x24,
+0x00,0x60,0x02,0x40,
+0x01,0x00,0x41,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x40,0x00,
+0x00,0x60,0x83,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x82,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC4,0x02,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0xE0,0xFF,0xBD,0x27,
+0x2A,0xB0,0x04,0x3C,
+0x00,0x00,0x43,0xAC,
+0x18,0x00,0xBF,0xAF,
+0x2C,0x00,0x84,0x34,
+0x00,0x00,0x88,0x8C,
+0xFF,0x00,0x02,0x24,
+0xFF,0x00,0x05,0x31,
+0x2E,0x00,0xA2,0x10,
+0x00,0x80,0x03,0x31,
+0x00,0xFF,0x02,0x3C,
+0x17,0x00,0x60,0x10,
+0x24,0x10,0x02,0x01,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x82,0xAC,
+0x02,0x80,0x02,0x3C,
+0xFF,0x00,0x03,0x31,
+0x60,0x1B,0x49,0x24,
+0x00,0x1A,0x03,0x00,
+0x20,0x10,0x02,0x3C,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x02,0x24,
+0x21,0x30,0x60,0x00,
+0x0A,0x00,0x04,0x24,
+0x1E,0x00,0xA2,0x10,
+0x00,0x01,0x07,0x24,
+0x7C,0x38,0x25,0x8D,
+0xAC,0x37,0x28,0xA1,
+0x10,0x38,0x23,0xAD,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x18,0x00,0xBF,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xEC,0xFF,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x02,0x3C,
+0x0C,0x53,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x0A,0x00,0x04,0x24,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x68,0x8C,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x49,0x24,
+0xFF,0x00,0x03,0x31,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x05,0x31,
+0xFF,0x00,0x02,0x24,
+0x21,0x30,0x60,0x00,
+0xE4,0xFF,0xA2,0x14,
+0x00,0x01,0x07,0x24,
+0x18,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC0,0x03,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x04,0x00,0x85,0x8C,
+0x00,0xA0,0x03,0x3C,
+0x01,0x00,0x02,0x24,
+0x25,0x28,0xA3,0x00,
+0x00,0x00,0xA4,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xF0,0x03,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x04,0x00,0x82,0x8C,
+0x02,0x00,0x83,0x94,
+0x00,0xA0,0x07,0x3C,
+0x25,0x28,0x47,0x00,
+0x00,0x00,0xA2,0x8C,
+0x10,0x00,0x02,0x24,
+0x13,0x00,0x62,0x10,
+0x11,0x00,0x66,0x28,
+0x06,0x00,0xC0,0x10,
+0x20,0x00,0x02,0x24,
+0x08,0x00,0x02,0x24,
+0x17,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0xFD,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA3,0xAC,
+0x04,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x25,0x10,0x47,0x00,
+0x00,0x00,0x42,0x8C,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xA4,
+0x04,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x67,0x00,
+0x00,0x00,0x62,0x94,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xA0,
+0x04,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x67,0x00,
+0x00,0x00,0x62,0x90,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x47,0x24,
+0x24,0x38,0xE3,0x90,
+0xFF,0xFF,0xA5,0x30,
+0x09,0x00,0xA3,0x10,
+0x21,0x20,0xC0,0x00,
+0x94,0x38,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xC2,0xAC,
+0x9E,0x38,0xE3,0x94,
+0x0E,0x00,0x02,0x24,
+0x14,0x00,0xC2,0xAC,
+0xCB,0x09,0x00,0x08,
+0x0C,0x00,0xC3,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x60,0x1B,0x31,0x26,
+0x7C,0x38,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x01,0x80,0x03,0x3C,
+0x25,0x80,0x02,0x02,
+0x25,0xB0,0x02,0x3C,
+0xF4,0x04,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x60,0x00,0x04,0x26,
+0x80,0x00,0x05,0x26,
+0x00,0x00,0x43,0xAC,
+0xB4,0x23,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x00,0x00,
+0xC6,0x53,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x7C,0x38,0x22,0x8E,
+0x0C,0x00,0x03,0x24,
+0x0C,0x00,0x43,0xAE,
+0x08,0x00,0x42,0xAE,
+0x12,0x00,0x02,0x24,
+0x14,0x00,0x42,0xAE,
+0x21,0x20,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xCB,0x09,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x0D,0x00,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x60,0x14,
+0x21,0x88,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x1C,0x64,0x43,0xA0,
+0x0C,0x00,0x02,0x92,
+0x02,0x80,0x05,0x3C,
+0x38,0x64,0xA2,0xA0,
+0x00,0x00,0x04,0x92,
+0x05,0x00,0x02,0x24,
+0xFF,0x00,0x83,0x30,
+0x41,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x02,0x24,
+0x31,0x00,0x62,0x10,
+0xFF,0x00,0x84,0x30,
+0x09,0x00,0x82,0x2C,
+0x25,0x00,0x40,0x10,
+0x02,0x80,0x10,0x3C,
+0x18,0x64,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x21,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x12,0x61,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x18,0x64,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x37,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x10,0x37,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x53,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x40,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x11,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x40,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x40,0x64,0x62,0xA0,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x06,0x00,0x40,0x10,
+0x04,0x00,0x04,0x24,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0xAA,0x41,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x11,0x24,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x21,0x10,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x0B,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x02,0x24,
+0x3B,0x64,0x62,0xA0,
+0x3B,0x64,0x63,0x90,
+0x02,0x80,0x02,0x3C,
+0x3C,0x64,0x43,0xA0,
+0x00,0x00,0x04,0x92,
+0x82,0x41,0x00,0x08,
+0xFF,0x00,0x84,0x30,
+0x38,0x64,0xA0,0xA0,
+0x0C,0x00,0x03,0x92,
+0x02,0x80,0x02,0x3C,
+0x36,0x64,0x43,0xA0,
+0x00,0x00,0x04,0x92,
+0x7F,0x41,0x00,0x08,
+0xFF,0x00,0x83,0x30,
+0x42,0xB0,0x06,0x3C,
+0x00,0x00,0xC3,0x90,
+0xEF,0xFF,0x02,0x24,
+0x03,0x00,0xC7,0x34,
+0x24,0x18,0x62,0x00,
+0x40,0x00,0x02,0x24,
+0x00,0x00,0xC3,0xA0,
+0x0C,0x00,0x04,0x24,
+0x00,0x00,0xE2,0xA0,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x02,0x80,0x03,0x3C,
+0x5E,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x14,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x45,0x24,
+0x28,0x1C,0xA3,0x8C,
+0x0F,0x00,0x02,0x3C,
+0x24,0x10,0x62,0x00,
+0xCD,0xFF,0x40,0x10,
+0xF0,0xFF,0x02,0x3C,
+0x68,0x3A,0xA4,0x94,
+0xFF,0xFF,0x42,0x34,
+0x24,0x10,0x62,0x00,
+0x00,0xC0,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0x57,0x37,0x00,0x0C,
+0x28,0x1C,0xA2,0xAC,
+0xAA,0x41,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x40,0x64,0x40,0xA0,
+0xAA,0x41,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x12,0x34,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xD8,0x41,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x18,0x00,0xB0,0xAF,
+0x60,0x1B,0x30,0x26,
+0xB0,0x1B,0x03,0x96,
+0x20,0x00,0xBF,0xAF,
+0x00,0x01,0x62,0x30,
+0x0D,0x00,0x40,0x10,
+0x01,0x00,0x66,0x30,
+0x02,0x80,0x04,0x3C,
+0xD0,0x55,0x84,0x24,
+0x03,0x00,0x05,0x24,
+0x22,0x00,0xC0,0x14,
+0x04,0x00,0x62,0x30,
+0x30,0x00,0x40,0x14,
+0x10,0x00,0xA4,0x27,
+0x56,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x40,0xA0,
+0x21,0x20,0x00,0x00,
+0x83,0x0F,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x25,0xB0,0x05,0x3C,
+0x48,0x00,0xA5,0x34,
+0x00,0x00,0xA4,0x8C,
+0x7B,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x60,0x1B,0x23,0x26,
+0x24,0x20,0x82,0x00,
+0x00,0x00,0xA4,0xAC,
+0x30,0x43,0x60,0xAC,
+0xE8,0x39,0x60,0xAC,
+0x04,0x3A,0x60,0xAC,
+0x20,0x3A,0x60,0xAC,
+0x60,0x42,0x60,0xAC,
+0x64,0x42,0x60,0xAC,
+0x70,0x43,0x60,0xAC,
+0xFD,0x61,0x00,0x0C,
+0xD6,0x43,0x60,0xA0,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xAF,0x4F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xFE,0xFE,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x56,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x40,0xA0,
+0x07,0x42,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xFB,0xF6,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x29,0x42,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x01,0x00,0x83,0x90,
+0x02,0x80,0x02,0x3C,
+0x21,0x38,0x80,0x00,
+0x00,0x5E,0x43,0xAC,
+0x01,0x00,0x84,0x90,
+0x00,0x00,0xE2,0x90,
+0x02,0x80,0x06,0x3C,
+0xFF,0x00,0x85,0x30,
+0x80,0x10,0x02,0x00,
+0x25,0x28,0xA2,0x00,
+0x78,0xE3,0xC6,0x24,
+0xFF,0x00,0x84,0x30,
+0x00,0x80,0xA5,0x34,
+0x11,0x27,0x00,0x0C,
+0x03,0x00,0xE7,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x03,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x37,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x43,0x30,
+0x00,0x01,0x42,0x30,
+0x04,0x00,0x40,0x10,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x06,0x00,0x60,0x14,
+0x34,0xEE,0x84,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x07,0x92,
+0x07,0x00,0x02,0x26,
+0x21,0x20,0x00,0x02,
+0x80,0x38,0x07,0x00,
+0x00,0x80,0xE7,0x34,
+0x05,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0xD1,0x52,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x60,0x1B,0x45,0x24,
+0x70,0x43,0xA3,0x8C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x60,0x14,
+0x21,0x80,0x80,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x6C,0x43,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x45,0x00,
+0x64,0x43,0x40,0xA0,
+0x00,0x00,0x84,0x8C,
+0xE7,0x21,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x06,0x8E,
+0x03,0x00,0x04,0x24,
+0x4B,0x17,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x84,0x90,
+0x14,0x0E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x82,0x94,
+0x21,0x90,0x80,0x00,
+0x28,0x00,0x43,0x24,
+0x20,0x00,0x42,0x24,
+0xC2,0x18,0x03,0x00,
+0xC2,0x28,0x02,0x00,
+0x07,0x00,0x42,0x30,
+0x02,0x00,0x40,0x14,
+0xC0,0x20,0x03,0x00,
+0xC0,0x20,0x05,0x00,
+0xF3,0x27,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x51,0x24,
+0x21,0x38,0x00,0x02,
+0x1B,0x00,0x00,0x12,
+0x0A,0x00,0x04,0x24,
+0x02,0x00,0x46,0x92,
+0x10,0x38,0x25,0x8E,
+0x64,0x01,0x00,0x0C,
+0x08,0x00,0xC6,0x24,
+0x52,0x01,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x08,0x00,0x02,0x96,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0x25,0x28,0x45,0x00,
+0x74,0x03,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0xCC,0x55,0x84,0x24,
+0x14,0x28,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0xCF,0x46,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEC,0x37,0x26,0x8E,
+0x58,0x38,0x25,0x8E,
+0x01,0x00,0x04,0x24,
+0x01,0x00,0x02,0x24,
+0x00,0x01,0x07,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0x82,0x90,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x63,0x24,
+0x07,0x00,0x40,0x10,
+0x21,0x20,0x60,0x00,
+0xD0,0x07,0x02,0x24,
+0x58,0x3A,0x62,0xAC,
+0x01,0x00,0x03,0x24,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0xE4,0x43,0x83,0xA0,
+0x21,0x10,0x00,0x00,
+0x58,0x3A,0x60,0xAC,
+0x08,0x00,0xE0,0x03,
+0xE4,0x43,0x60,0xA0,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x25,0xB0,0x10,0x3C,
+0x21,0x28,0x80,0x00,
+0x06,0x00,0x06,0x24,
+0x14,0x00,0xBF,0xAF,
+0xCE,0x53,0x00,0x0C,
+0x50,0x00,0x04,0x36,
+0x02,0x80,0x04,0x3C,
+0x50,0x00,0x05,0x36,
+0x48,0x37,0x84,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x44,0xEE,0x84,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x13,0x57,0x00,0x0C,
+0x54,0xEE,0x84,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x04,0x00,0x83,0x8C,
+0x00,0x00,0x85,0x90,
+0x01,0x00,0x86,0x90,
+0x02,0x00,0x87,0x90,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x42,0x43,0xAC,
+0x7C,0x42,0x45,0xA0,
+0x7D,0x42,0x46,0xA0,
+0x7E,0x42,0x47,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x00,0x00,0x82,0x90,
+0x02,0x80,0x03,0x3C,
+0x21,0x30,0x80,0x00,
+0x20,0x64,0x62,0xA0,
+0x20,0x64,0x64,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x80,0x14,
+0x20,0x64,0x68,0x24,
+0x01,0x00,0x02,0x24,
+0x01,0x00,0x02,0xA1,
+0x03,0x00,0x03,0x24,
+0xD0,0x07,0x02,0x24,
+0x04,0x00,0x03,0xA1,
+0x02,0x00,0x02,0xA5,
+0x0C,0x00,0x03,0x24,
+0x12,0x00,0x02,0x24,
+0x05,0x00,0x03,0xA1,
+0x06,0x00,0x02,0xA1,
+0x21,0x10,0x00,0x00,
+0x07,0x00,0x00,0xA1,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xC2,0x90,
+0x07,0x00,0xC7,0x90,
+0x04,0x00,0xC3,0x90,
+0x02,0x00,0xC4,0x94,
+0x05,0x00,0xC5,0x90,
+0x06,0x00,0xC6,0x90,
+0x01,0x00,0x02,0xA1,
+0x21,0x10,0x00,0x00,
+0x04,0x00,0x03,0xA1,
+0x02,0x00,0x04,0xA5,
+0x05,0x00,0x05,0xA1,
+0x06,0x00,0x06,0xA1,
+0x07,0x00,0x07,0xA1,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x83,0x8C,
+0x00,0x00,0x85,0x90,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x88,0x42,0x43,0xAC,
+0x84,0x42,0x45,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x05,0x3C,
+0x01,0x80,0x03,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x21,0x30,0x80,0x00,
+0x18,0x03,0xA2,0x34,
+0xFC,0x0D,0x63,0x24,
+0x01,0x00,0x04,0x24,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x43,0xAC,
+0x66,0x00,0xC4,0x10,
+0x02,0x80,0x02,0x3C,
+0x09,0x00,0xC0,0x10,
+0x02,0x00,0x02,0x24,
+0x36,0x00,0xC2,0x10,
+0x03,0x00,0x02,0x24,
+0x8B,0x00,0xC2,0x10,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x50,0x24,
+0x70,0x08,0x02,0x24,
+0x34,0x1C,0x02,0xAE,
+0xE0,0x08,0x03,0x24,
+0x40,0x08,0x02,0x24,
+0x38,0x1C,0x03,0xAE,
+0x44,0x1C,0x02,0xAE,
+0x78,0x08,0x03,0x24,
+0x0C,0x08,0x02,0x24,
+0x48,0x1C,0x03,0xAE,
+0x4C,0x1C,0x02,0xAE,
+0x10,0x08,0x03,0x24,
+0x20,0x08,0x02,0x24,
+0x50,0x1C,0x03,0xAE,
+0x54,0x1C,0x02,0xAE,
+0x24,0x08,0x03,0x24,
+0x58,0x08,0x02,0x24,
+0x58,0x1C,0x03,0xAE,
+0x5C,0x1C,0x02,0xAE,
+0x50,0x0C,0x03,0x24,
+0x54,0x0C,0x02,0x24,
+0x60,0x1C,0x03,0xAE,
+0x64,0x1C,0x02,0xAE,
+0x14,0x0C,0x03,0x24,
+0x10,0x0C,0x02,0x24,
+0x20,0x08,0xA4,0x34,
+0x68,0x1C,0x03,0xAE,
+0x60,0x08,0x05,0x24,
+0x6C,0x1C,0x02,0xAE,
+0x80,0x0C,0x03,0x24,
+0x84,0x0C,0x02,0x24,
+0x40,0x1C,0x05,0xAE,
+0x70,0x1C,0x03,0xAE,
+0x74,0x1C,0x02,0xAE,
+0x31,0x1C,0x00,0xA2,
+0xEE,0x5A,0x00,0x0C,
+0x3C,0x1C,0x05,0xAE,
+0x00,0x01,0x42,0x30,
+0x31,0x00,0x40,0x14,
+0xB8,0x08,0x02,0x24,
+0xA0,0x08,0x02,0x24,
+0x78,0x1C,0x02,0xAE,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xA8,0x08,0x03,0x24,
+0x78,0x1C,0x43,0xAC,
+0x74,0x08,0x03,0x24,
+0xE4,0x08,0x04,0x24,
+0x34,0x1C,0x43,0xAC,
+0x48,0x08,0x03,0x24,
+0x38,0x1C,0x44,0xAC,
+0x44,0x1C,0x43,0xAC,
+0x7C,0x08,0x04,0x24,
+0x0C,0x08,0x03,0x24,
+0x48,0x1C,0x44,0xAC,
+0x4C,0x1C,0x43,0xAC,
+0x18,0x08,0x04,0x24,
+0x30,0x08,0x03,0x24,
+0x50,0x1C,0x44,0xAC,
+0x54,0x1C,0x43,0xAC,
+0x34,0x08,0x04,0x24,
+0x5C,0x08,0x03,0x24,
+0x58,0x1C,0x44,0xAC,
+0x5C,0x1C,0x43,0xAC,
+0x60,0x0C,0x04,0x24,
+0x64,0x0C,0x03,0x24,
+0x60,0x1C,0x44,0xAC,
+0x64,0x1C,0x43,0xAC,
+0x24,0x0C,0x04,0x24,
+0x20,0x0C,0x03,0x24,
+0x68,0x08,0x05,0x24,
+0x68,0x1C,0x44,0xAC,
+0x6C,0x1C,0x43,0xAC,
+0x90,0x0C,0x04,0x24,
+0x94,0x0C,0x03,0x24,
+0x31,0x1C,0x46,0xA0,
+0x40,0x1C,0x45,0xAC,
+0x70,0x1C,0x44,0xAC,
+0x74,0x1C,0x43,0xAC,
+0x3C,0x1C,0x45,0xAC,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xC0,0x43,0x00,0x08,
+0x78,0x1C,0x02,0xAE,
+0x60,0x1B,0x50,0x24,
+0x70,0x08,0x02,0x24,
+0x34,0x1C,0x02,0xAE,
+0xE0,0x08,0x03,0x24,
+0x44,0x08,0x02,0x24,
+0x38,0x1C,0x03,0xAE,
+0x44,0x1C,0x02,0xAE,
+0x78,0x08,0x03,0x24,
+0x0C,0x08,0x02,0x24,
+0x48,0x1C,0x03,0xAE,
+0x4C,0x1C,0x02,0xAE,
+0x14,0x08,0x03,0x24,
+0x28,0x08,0x02,0x24,
+0x50,0x1C,0x03,0xAE,
+0x54,0x1C,0x02,0xAE,
+0x2C,0x08,0x03,0x24,
+0x58,0x08,0x02,0x24,
+0x58,0x1C,0x03,0xAE,
+0x5C,0x1C,0x02,0xAE,
+0x58,0x0C,0x03,0x24,
+0x5C,0x0C,0x02,0x24,
+0x60,0x1C,0x03,0xAE,
+0x64,0x1C,0x02,0xAE,
+0x1C,0x0C,0x03,0x24,
+0x18,0x0C,0x02,0x24,
+0x28,0x08,0xA4,0x34,
+0x68,0x1C,0x03,0xAE,
+0x64,0x08,0x05,0x24,
+0x6C,0x1C,0x02,0xAE,
+0x88,0x0C,0x03,0x24,
+0x8C,0x0C,0x02,0x24,
+0x31,0x1C,0x06,0xA2,
+0x40,0x1C,0x05,0xAE,
+0x70,0x1C,0x03,0xAE,
+0x74,0x1C,0x02,0xAE,
+0xEE,0x5A,0x00,0x0C,
+0x3C,0x1C,0x05,0xAE,
+0x00,0x01,0x42,0x30,
+0x2B,0x00,0x40,0x14,
+0xBC,0x08,0x02,0x24,
+0xA4,0x08,0x02,0x24,
+0xC0,0x43,0x00,0x08,
+0x78,0x1C,0x02,0xAE,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xAC,0x08,0x03,0x24,
+0x78,0x1C,0x43,0xAC,
+0x74,0x08,0x03,0x24,
+0xE4,0x08,0x04,0x24,
+0x34,0x1C,0x43,0xAC,
+0x4C,0x08,0x03,0x24,
+0x38,0x1C,0x44,0xAC,
+0x44,0x1C,0x43,0xAC,
+0x7C,0x08,0x04,0x24,
+0x0C,0x08,0x03,0x24,
+0x48,0x1C,0x44,0xAC,
+0x4C,0x1C,0x43,0xAC,
+0x1C,0x08,0x04,0x24,
+0x38,0x08,0x03,0x24,
+0x50,0x1C,0x44,0xAC,
+0x54,0x1C,0x43,0xAC,
+0x3C,0x08,0x04,0x24,
+0x5C,0x08,0x03,0x24,
+0x58,0x1C,0x44,0xAC,
+0x5C,0x1C,0x43,0xAC,
+0x68,0x0C,0x04,0x24,
+0x6C,0x0C,0x03,0x24,
+0x60,0x1C,0x44,0xAC,
+0x64,0x1C,0x43,0xAC,
+0x2C,0x0C,0x04,0x24,
+0x28,0x0C,0x03,0x24,
+0x6C,0x08,0x05,0x24,
+0x68,0x1C,0x44,0xAC,
+0x6C,0x1C,0x43,0xAC,
+0x98,0x0C,0x04,0x24,
+0x9C,0x0C,0x03,0x24,
+0x31,0x1C,0x46,0xA0,
+0x40,0x1C,0x45,0xAC,
+0x70,0x1C,0x44,0xAC,
+0x74,0x1C,0x43,0xAC,
+0xEA,0x43,0x00,0x08,
+0x3C,0x1C,0x45,0xAC,
+0xC0,0x43,0x00,0x08,
+0x78,0x1C,0x02,0xAE,
+0x49,0x44,0x00,0x08,
+0x21,0x18,0x00,0x00,
+0x20,0x00,0x62,0x2C,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x06,0x10,0x64,0x00,
+0x01,0x00,0x42,0x30,
+0xFA,0xFF,0x40,0x10,
+0x01,0x00,0x63,0x24,
+0xFF,0xFF,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0xFF,0xFF,0x02,0x24,
+0x21,0x88,0xA0,0x00,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x90,0xC0,0x00,
+0x21,0x28,0xC0,0x00,
+0x0B,0x00,0x22,0x12,
+0x21,0x98,0x80,0x00,
+0x1A,0x5B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x44,0x44,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x27,0x28,0x11,0x00,
+0x24,0x28,0xB0,0x00,
+0x04,0x10,0x52,0x00,
+0x25,0x28,0xA2,0x00,
+0x21,0x20,0x60,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xF7,0x5A,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x21,0x30,0x80,0x00,
+0xA4,0x37,0x44,0x8C,
+0x50,0x44,0x00,0x08,
+0xFF,0xFF,0x05,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1A,0x5B,0x00,0x0C,
+0x21,0x88,0xA0,0x00,
+0x21,0x80,0x40,0x00,
+0x44,0x44,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x24,0x80,0x11,0x02,
+0x06,0x10,0x50,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x02,0x80,0x12,0x3C,
+0x60,0x1B,0x52,0x26,
+0x14,0x00,0xB1,0xAF,
+0x21,0x88,0x80,0x00,
+0x24,0x08,0x04,0x24,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x1A,0x5B,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x58,0x1C,0x44,0x8E,
+0x21,0xA0,0x40,0x00,
+0x1A,0x5B,0x00,0x0C,
+0xC0,0x8D,0x11,0x00,
+0xFF,0x7F,0x05,0x3C,
+0x7F,0x80,0x03,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0xFF,0xFF,0x63,0x34,
+0x24,0x28,0x85,0x02,
+0x24,0x08,0x04,0x24,
+0xF7,0x5A,0x00,0x0C,
+0x24,0x80,0x43,0x00,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x00,0x80,0x13,0x3C,
+0x58,0x1C,0x44,0x8E,
+0x25,0x80,0x11,0x02,
+0x25,0x80,0x13,0x02,
+0xF7,0x5A,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x25,0x28,0x93,0x02,
+0xF7,0x5A,0x00,0x0C,
+0x24,0x08,0x04,0x24,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x78,0x1C,0x44,0x8E,
+0x0F,0x00,0x05,0x3C,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0xFF,0xA5,0x34,
+0x72,0x44,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x60,0x1B,0x27,0x26,
+0x33,0x1C,0xE5,0x90,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xD0,0x12,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x02,0x00,0x06,0x24,
+0x00,0x00,0x43,0xAC,
+0x34,0x00,0xA6,0x10,
+0x21,0x80,0x80,0x00,
+0x03,0x00,0x03,0x24,
+0x3A,0x00,0xA3,0x10,
+0x2E,0x00,0x02,0x2E,
+0x10,0x00,0x02,0x2E,
+0x07,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x04,0x32,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x82,0x44,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xFA,0xFF,0xA6,0x14,
+0xFF,0x00,0x04,0x32,
+0x31,0x1C,0xE4,0x90,
+0x01,0x00,0x02,0x24,
+0x33,0x00,0x82,0x10,
+0x02,0x00,0x82,0x28,
+0x38,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x38,0x00,0x85,0x10,
+0x60,0x1B,0x22,0x26,
+0x2E,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x72,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0xFF,0xFC,0x06,0x3C,
+0xFF,0xFF,0xC6,0x34,
+0x24,0x30,0x46,0x00,
+0x00,0x08,0x04,0x24,
+0x50,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x60,0x1B,0x22,0x26,
+0x31,0x1C,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x07,0x00,0x83,0x10,
+0x02,0x00,0x82,0x28,
+0x2C,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x2C,0x00,0x82,0x10,
+0x03,0x00,0x02,0x24,
+0xDB,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0xCA,0x44,0x00,0x08,
+0xFF,0x00,0x04,0x32,
+0x25,0x00,0x82,0x2C,
+0xCC,0xFF,0x40,0x14,
+0x03,0x00,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC7,0xFF,0x40,0x14,
+0x10,0x00,0x02,0x2E,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0xDC,0x44,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xCC,0xFF,0x80,0x14,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0xDC,0x44,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xB2,0xFF,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0xCA,0x44,0x00,0x08,
+0xFF,0x00,0x04,0x32,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x60,0x1B,0x28,0x26,
+0x33,0x1C,0x06,0x91,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x7C,0x14,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x02,0x00,0x07,0x24,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x00,0x00,0x43,0xAC,
+0x21,0x90,0xA0,0x00,
+0x39,0x00,0xC7,0x10,
+0xFF,0x00,0x90,0x30,
+0x03,0x00,0x03,0x24,
+0x3F,0x00,0xC3,0x10,
+0x2E,0x00,0x02,0x2E,
+0x10,0x00,0x02,0x2E,
+0x0C,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x04,0x3C,
+0xFF,0xFF,0x84,0x34,
+0x24,0x20,0x44,0x02,
+0x00,0x15,0x10,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x25,0x20,0x44,0x00,
+0x6D,0x44,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xF5,0xFF,0xC7,0x14,
+0x0F,0x00,0x04,0x3C,
+0x31,0x1C,0x04,0x91,
+0x01,0x00,0x02,0x24,
+0x33,0x00,0x82,0x10,
+0x02,0x00,0x82,0x28,
+0x38,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x38,0x00,0x86,0x10,
+0x60,0x1B,0x22,0x26,
+0x2E,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x72,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0xFF,0xFC,0x06,0x3C,
+0xFF,0xFF,0xC6,0x34,
+0x24,0x30,0x46,0x00,
+0x00,0x08,0x04,0x24,
+0x50,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x60,0x1B,0x22,0x26,
+0x31,0x1C,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x07,0x00,0x83,0x10,
+0x02,0x00,0x82,0x28,
+0x2C,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x2C,0x00,0x82,0x10,
+0x03,0x00,0x02,0x24,
+0xD6,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x37,0x45,0x00,0x08,
+0x0F,0x00,0x04,0x3C,
+0x25,0x00,0x02,0x2E,
+0xC7,0xFF,0x40,0x14,
+0x03,0x00,0x03,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC1,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0x4E,0x45,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xCC,0xFF,0x80,0x14,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0x4E,0x45,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xAD,0xFF,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x37,0x45,0x00,0x08,
+0x0F,0x00,0x04,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x14,0x00,0xBF,0xAF,
+0x82,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x40,0x01,0x44,0x34,
+0x21,0x18,0x40,0x00,
+0x1F,0x00,0x02,0x2E,
+0x00,0x23,0x04,0x00,
+0x10,0x00,0x40,0x10,
+0x10,0x00,0x05,0x2E,
+0x00,0x01,0x64,0x34,
+0x06,0x00,0xA0,0x10,
+0x00,0x23,0x04,0x00,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x6D,0x44,0x00,0x0C,
+0xF1,0xFF,0x10,0x26,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x6D,0x44,0x00,0x0C,
+0xE2,0xFF,0x10,0x26,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x90,0x8C,
+0x21,0x88,0xA0,0x00,
+0x44,0x44,0x00,0x0C,
+0x21,0x20,0xA0,0x00,
+0x24,0x80,0x11,0x02,
+0x06,0x10,0x50,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x21,0x90,0x82,0x00,
+0xFF,0xFF,0x02,0x24,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x88,0xA0,0x00,
+0x21,0x20,0xA0,0x00,
+0x21,0x18,0x40,0x02,
+0x10,0x00,0xA2,0x10,
+0x21,0x98,0xC0,0x00,
+0x00,0x00,0x50,0x8E,
+0x44,0x44,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x27,0x18,0x11,0x00,
+0x24,0x18,0x70,0x00,
+0x04,0x10,0x53,0x00,
+0x25,0x18,0x62,0x00,
+0x00,0x00,0x43,0xAE,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0x66,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x38,0x82,0x00,
+0xFF,0xFF,0x02,0x24,
+0x27,0x40,0x05,0x00,
+0x08,0x00,0xA2,0x10,
+0x24,0x18,0xC5,0x00,
+0x00,0x00,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x02,0x01,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE6,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0xFF,0xFF,0x02,0x24,
+0x21,0x80,0xA0,0x00,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x88,0xC0,0x00,
+0x21,0x28,0xC0,0x00,
+0x08,0x00,0x02,0x12,
+0x21,0x90,0x80,0x00,
+0x1A,0x5B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x27,0x28,0x10,0x00,
+0x24,0x28,0xA2,0x00,
+0x24,0x10,0x30,0x02,
+0x25,0x28,0xA2,0x00,
+0x21,0x20,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xF7,0x5A,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xD0,0xFF,0xBD,0x27,
+0x48,0x18,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x20,0x00,0xB2,0xAF,
+0x00,0x00,0x62,0xAC,
+0x21,0x90,0x80,0x00,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x21,0x98,0xC0,0x00,
+0x21,0x88,0xA0,0x00,
+0x28,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x18,0x00,0xB0,0xAF,
+0x0F,0x00,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x21,0x20,0x40,0x02,
+0x0A,0x00,0x22,0x12,
+0x21,0x28,0x60,0x02,
+0xB4,0x44,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x44,0x44,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x27,0x28,0x11,0x00,
+0x24,0x28,0xB0,0x00,
+0x04,0x10,0x53,0x00,
+0x25,0x28,0xA2,0x00,
+0x1F,0x45,0x00,0x0C,
+0xFF,0x00,0x44,0x32,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xEC,0x18,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0xE0,0xFF,0xBD,0x27,
+0x00,0x00,0x43,0xAC,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xB4,0x44,0x00,0x0C,
+0x21,0x88,0xA0,0x00,
+0x21,0x80,0x40,0x00,
+0x44,0x44,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x24,0x80,0x11,0x02,
+0x06,0x10,0x50,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x24,0x00,0xB5,0xAF,
+0xFF,0x00,0x84,0x30,
+0x21,0xA8,0xC0,0x00,
+0x28,0x00,0xB6,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xB0,0xA0,0x00,
+0x7F,0x43,0x00,0x0C,
+0x21,0x98,0x00,0x00,
+0x21,0x00,0xA0,0x16,
+0x80,0x10,0x13,0x00,
+0x8E,0x46,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFD,0x00,0x02,0x24,
+0x23,0x00,0x02,0x12,
+0x05,0x00,0x04,0x24,
+0xFC,0x00,0x02,0x24,
+0x37,0x00,0x02,0x12,
+0x00,0x00,0x00,0x00,
+0xFB,0x00,0x02,0x24,
+0x30,0x00,0x02,0x12,
+0x32,0x00,0x04,0x24,
+0xFA,0x00,0x02,0x24,
+0x2D,0x00,0x02,0x12,
+0x05,0x00,0x04,0x24,
+0xF9,0x00,0x02,0x24,
+0x29,0x00,0x02,0x12,
+0x0F,0x00,0x05,0x3C,
+0x04,0x00,0xD1,0x8C,
+0xFF,0xFF,0xA5,0x34,
+0x21,0x20,0x00,0x02,
+0x12,0x46,0x00,0x0C,
+0x21,0x30,0x20,0x02,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x19,0x00,0x02,0x24,
+0x28,0x00,0x02,0x12,
+0x21,0x90,0x00,0x00,
+0x02,0x00,0x62,0x26,
+0xFF,0x00,0x53,0x30,
+0x2B,0x18,0x75,0x02,
+0x0F,0x00,0x60,0x10,
+0x80,0x10,0x13,0x00,
+0x21,0x30,0x56,0x00,
+0x00,0x00,0xD0,0x8C,
+0xFF,0x00,0x02,0x24,
+0x0A,0x00,0x02,0x12,
+0xFE,0x00,0x02,0x24,
+0xDC,0xFF,0x02,0x16,
+0x32,0x00,0x04,0x24,
+0x43,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x62,0x26,
+0xFF,0x00,0x53,0x30,
+0x2B,0x18,0x75,0x02,
+0xF3,0xFF,0x60,0x14,
+0x80,0x10,0x13,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x01,0x00,0x04,0x24,
+0x72,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x7C,0x46,0x00,0x08,
+0x02,0x00,0x62,0x26,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x8A,0x46,0x00,0x08,
+0x02,0x00,0x62,0x26,
+0x0F,0x00,0x14,0x3C,
+0x21,0x20,0x00,0x02,
+0x3B,0x46,0x00,0x0C,
+0xFF,0xFF,0x85,0x36,
+0x21,0x20,0x00,0x02,
+0xFF,0xFF,0x85,0x36,
+0xD2,0xFF,0x51,0x10,
+0x21,0x30,0x20,0x02,
+0x12,0x46,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x43,0x26,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x01,0x00,0x42,0x26,
+0xFF,0x00,0x52,0x30,
+0x0A,0x00,0x43,0x2E,
+0xF2,0xFF,0x60,0x14,
+0x21,0x20,0x00,0x02,
+0x7F,0x43,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x58,0xE2,0x46,0x24,
+0x7F,0x00,0x84,0x30,
+0x09,0x00,0x02,0x24,
+0x21,0x28,0xC0,0x00,
+0x05,0x00,0x82,0x10,
+0x0A,0x00,0x03,0x24,
+0x0A,0x00,0x02,0x24,
+0x02,0x00,0x82,0x10,
+0x0B,0x00,0x03,0x24,
+0x21,0x18,0x80,0x00,
+0x04,0x00,0xA3,0xA0,
+0x04,0x00,0xC4,0x90,
+0x6F,0x0E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x4C,0x00,0xBF,0xAF,
+0x48,0x00,0xBE,0xAF,
+0x40,0x00,0xB6,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0x38,0x00,0xB4,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0x60,0x1B,0x55,0x24,
+0x44,0x00,0xB7,0xAF,
+0x58,0x38,0xA3,0x96,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x05,0x3C,
+0x25,0x98,0x62,0x00,
+0x80,0xE3,0xA5,0x24,
+0x24,0x00,0x64,0x26,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x60,0xA6,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x2A,0x00,0x64,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x30,0x00,0x64,0x26,
+0x20,0x00,0x63,0x96,
+0x02,0x80,0x02,0x3C,
+0xCC,0x55,0x42,0x24,
+0x03,0xFF,0x63,0x30,
+0x80,0x00,0x63,0x34,
+0x74,0x00,0x54,0x24,
+0x20,0x00,0x63,0xA6,
+0x21,0x20,0x80,0x02,
+0x20,0x00,0x02,0x24,
+0x40,0x00,0x72,0x26,
+0xFB,0x50,0x00,0x0C,
+0x1C,0x00,0xA2,0xAF,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0x40,0x02,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x1C,0x00,0xA2,0x8F,
+0x21,0x20,0x80,0x02,
+0x42,0x00,0x72,0x26,
+0x02,0x00,0x42,0x24,
+0x16,0x51,0x00,0x0C,
+0x1C,0x00,0xA2,0xAF,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0x40,0x02,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x02,0x80,0x03,0x3C,
+0xCC,0x55,0x63,0x24,
+0x1C,0x00,0xA2,0x8F,
+0x0C,0x00,0x66,0x8C,
+0x60,0x00,0x71,0x24,
+0x1C,0x00,0xB0,0x27,
+0x10,0x00,0x67,0x24,
+0x21,0x28,0x00,0x00,
+0x02,0x00,0x42,0x24,
+0x44,0x00,0x64,0x26,
+0x1C,0x00,0xA2,0xAF,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x20,0x02,
+0x1B,0x52,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x21,0xB0,0x40,0x00,
+0x08,0x00,0x06,0x24,
+0x09,0x00,0x42,0x2C,
+0x21,0x20,0x40,0x02,
+0x21,0x38,0x20,0x02,
+0x0B,0x30,0xC2,0x02,
+0x01,0x00,0x05,0x24,
+0x20,0x00,0xA2,0xAF,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x03,0x3C,
+0xCC,0x55,0x63,0x24,
+0x48,0x00,0x67,0x24,
+0x21,0x20,0x40,0x00,
+0x03,0x00,0x05,0x24,
+0x01,0x00,0x06,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x40,0x00,
+0x06,0x00,0x05,0x24,
+0x02,0x00,0x06,0x24,
+0x18,0x00,0xA7,0x27,
+0x18,0x00,0xA0,0xA7,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x21,0x90,0x40,0x00,
+0xDC,0x3A,0xA2,0x8E,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x3B,0x00,0x40,0x10,
+0x21,0xF0,0x00,0x02,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x80,0x02,
+0x44,0x47,0x00,0x08,
+0x42,0x56,0x57,0x24,
+0x21,0x10,0x30,0x02,
+0x01,0x00,0x43,0x90,
+0xDC,0x3A,0xA4,0x8E,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x71,0x24,
+0x2B,0x20,0x24,0x02,
+0x2F,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x30,0x02,
+0x00,0x00,0x47,0x90,
+0x02,0x80,0x14,0x3C,
+0x2D,0x00,0x03,0x24,
+0x21,0x28,0x37,0x02,
+0xD8,0x5E,0x84,0x26,
+0xF1,0xFF,0xE3,0x14,
+0x20,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x78,0x43,0xA3,0x96,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x47,0x90,
+0xBD,0xFF,0x63,0x30,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x0C,0x00,0x63,0x34,
+0x01,0x00,0xE7,0x30,
+0x4C,0xE6,0xA5,0x24,
+0xDB,0x5E,0x44,0x24,
+0x10,0x00,0x06,0x24,
+0x06,0x00,0xE0,0x14,
+0x78,0x43,0xA3,0xA6,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x03,0x3C,
+0x5C,0xE6,0xA5,0x24,
+0xDB,0x5E,0x64,0x24,
+0x10,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x30,0x02,
+0x01,0x00,0x46,0x90,
+0x21,0x20,0x40,0x02,
+0xD8,0x5E,0x87,0x26,
+0x2D,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xBE,0xAF,
+0x21,0x90,0x40,0x00,
+0x21,0x10,0x30,0x02,
+0x01,0x00,0x43,0x90,
+0xDC,0x3A,0xA4,0x8E,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x71,0x24,
+0x2B,0x20,0x24,0x02,
+0xD4,0xFF,0x80,0x14,
+0x21,0x10,0x30,0x02,
+0x20,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x13,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x1C,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x24,
+0x01,0x01,0x42,0x2C,
+0x1A,0x00,0x40,0x14,
+0x21,0x20,0x60,0x02,
+0x4C,0x00,0xBF,0x8F,
+0x48,0x00,0xBE,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0xCC,0x55,0x63,0x24,
+0x21,0x20,0x40,0x02,
+0xF8,0xFF,0xC6,0x26,
+0x68,0x00,0x67,0x24,
+0x32,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xBE,0xAF,
+0x1C,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x24,
+0x01,0x01,0x42,0x2C,
+0xE8,0xFF,0x40,0x10,
+0x21,0x20,0x60,0x02,
+0x21,0x28,0x00,0x00,
+0xC6,0x53,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x64,0x8E,
+0x04,0x00,0x65,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0x10,0x00,0x66,0x8E,
+0x14,0x00,0x67,0x8E,
+0xFF,0xFF,0x42,0x34,
+0x1C,0x00,0xA8,0x8F,
+0x24,0x20,0x82,0x00,
+0x00,0x40,0x03,0x3C,
+0xFF,0xE0,0x02,0x24,
+0x24,0x28,0xA2,0x00,
+0x25,0x20,0x83,0x00,
+0x00,0x80,0x02,0x3C,
+0xFF,0x81,0x03,0x24,
+0x25,0x30,0xC2,0x00,
+0x24,0x38,0xE3,0x00,
+0x00,0x10,0xA5,0x34,
+0x02,0x80,0x03,0x3C,
+0x80,0x00,0x84,0x34,
+0x20,0x00,0x02,0x24,
+0x08,0x00,0x64,0xAE,
+0x00,0x00,0x68,0xA6,
+0x02,0x00,0x62,0xA2,
+0x14,0x00,0x67,0xAE,
+0x04,0x00,0x65,0xAE,
+0x10,0x00,0x66,0xAE,
+0x60,0x1B,0x62,0x24,
+0xEC,0x37,0x46,0x8C,
+0x58,0x38,0x45,0x8C,
+0x01,0x00,0x04,0x24,
+0x00,0x01,0x07,0x24,
+0x01,0x00,0x02,0x24,
+0x15,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x52,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x4C,0x00,0xBF,0x8F,
+0x48,0x00,0xBE,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0xA0,0xFF,0xBD,0x27,
+0x5C,0x00,0xBF,0xAF,
+0x58,0x00,0xBE,0xAF,
+0x54,0x00,0xB7,0xAF,
+0x50,0x00,0xB6,0xAF,
+0x4C,0x00,0xB5,0xAF,
+0x48,0x00,0xB4,0xAF,
+0x44,0x00,0xB3,0xAF,
+0x40,0x00,0xB2,0xAF,
+0x3C,0x00,0xB1,0xAF,
+0x38,0x00,0xB0,0xAF,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x0B,0x3C,
+0x74,0xEF,0x82,0x24,
+0x88,0xEF,0x63,0x25,
+0x88,0xEF,0x6B,0x91,
+0x01,0x00,0x45,0x90,
+0x0D,0x00,0x48,0x90,
+0x0C,0x00,0x58,0x90,
+0x74,0xEF,0x97,0x90,
+0x02,0x00,0x54,0x90,
+0x0E,0x00,0x50,0x90,
+0x01,0x00,0x69,0x90,
+0x30,0x00,0xAB,0xAF,
+0x03,0x00,0x4B,0x90,
+0x04,0x00,0x76,0x90,
+0x05,0x00,0x6A,0x90,
+0x02,0x00,0x6F,0x90,
+0x06,0x00,0x64,0x90,
+0x07,0x00,0x75,0x90,
+0x03,0x00,0x71,0x90,
+0x00,0x2A,0x05,0x00,
+0x30,0x00,0xA3,0x8F,
+0x00,0x42,0x08,0x00,
+0x25,0x40,0x18,0x01,
+0x25,0x28,0xB7,0x00,
+0x00,0xA4,0x14,0x00,
+0x00,0x84,0x10,0x00,
+0x25,0xA0,0x85,0x02,
+0x25,0x80,0x08,0x02,
+0x00,0x4A,0x09,0x00,
+0x00,0x5E,0x0B,0x00,
+0x02,0x80,0x08,0x3C,
+0x05,0x00,0x46,0x90,
+0x09,0x00,0x47,0x90,
+0x25,0x48,0x23,0x01,
+0x00,0x52,0x0A,0x00,
+0x60,0x1B,0x03,0x25,
+0x25,0x58,0x74,0x01,
+0x04,0x00,0x5E,0x90,
+0x06,0x00,0x53,0x90,
+0x08,0x00,0x59,0x90,
+0x0A,0x00,0x52,0x90,
+0x07,0x00,0x4C,0x90,
+0x0B,0x00,0x4D,0x90,
+0x0F,0x00,0x4E,0x90,
+0x11,0x00,0x58,0x90,
+0x25,0x50,0x56,0x01,
+0x10,0x00,0x56,0x90,
+0x10,0x00,0xAB,0xAF,
+0x7A,0x43,0x62,0x90,
+0x00,0x32,0x06,0x00,
+0x00,0x3A,0x07,0x00,
+0x00,0x7C,0x0F,0x00,
+0x00,0x24,0x04,0x00,
+0x25,0x30,0xDE,0x00,
+0x25,0x38,0xF9,0x00,
+0x25,0x20,0x8A,0x00,
+0x1C,0x00,0x43,0x30,
+0x00,0x9C,0x13,0x00,
+0x00,0x94,0x12,0x00,
+0x25,0x78,0xE9,0x01,
+0x00,0x8E,0x11,0x00,
+0x00,0xAE,0x15,0x00,
+0x25,0x98,0x66,0x02,
+0x25,0x90,0x47,0x02,
+0x03,0x00,0x46,0x30,
+0x25,0xA8,0xA4,0x02,
+0x25,0x88,0x2F,0x02,
+0x10,0x00,0xA7,0x27,
+0x83,0x18,0x03,0x00,
+0x02,0x00,0xC4,0x24,
+0x28,0x00,0xB1,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x21,0x18,0xE3,0x00,
+0x01,0x00,0x02,0x24,
+0x04,0x10,0x82,0x00,
+0x18,0x00,0x65,0x90,
+0xFF,0x00,0x46,0x30,
+0x00,0x66,0x0C,0x00,
+0x00,0x6E,0x0D,0x00,
+0x00,0x76,0x0E,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x60,0x93,0x01,
+0x25,0x68,0xB2,0x01,
+0x25,0x70,0xD0,0x01,
+0x10,0x00,0xC4,0x2C,
+0x37,0x02,0x42,0x34,
+0x0F,0x00,0x03,0x24,
+0x14,0x00,0xAC,0xAF,
+0x18,0x00,0xAD,0xAF,
+0x1C,0x00,0xAE,0xAF,
+0x20,0x00,0xB6,0xA3,
+0x21,0x00,0xB8,0xA3,
+0x0A,0x30,0x64,0x00,
+0x00,0x00,0x45,0xA0,
+0x21,0x28,0x00,0x00,
+0x21,0x20,0xE5,0x00,
+0x00,0x00,0x82,0x90,
+0x01,0x00,0xA5,0x24,
+0x2B,0x10,0xC2,0x00,
+0x02,0x00,0x40,0x10,
+0x11,0x00,0xA3,0x2C,
+0x00,0x00,0x86,0xA0,
+0xF9,0xFF,0x60,0x14,
+0x21,0x20,0xE5,0x00,
+0x21,0x30,0xE0,0x00,
+0x21,0x28,0x00,0x00,
+0x25,0xB0,0x07,0x3C,
+0x01,0x00,0xC2,0x90,
+0x00,0x00,0xC3,0x90,
+0x21,0x20,0xA7,0x00,
+0x00,0x11,0x02,0x00,
+0x25,0x10,0x43,0x00,
+0x01,0x00,0xA5,0x24,
+0xFF,0x00,0x42,0x30,
+0x08,0x00,0xA3,0x2C,
+0xA8,0x01,0x82,0xA0,
+0xF6,0xFF,0x60,0x14,
+0x02,0x00,0xC6,0x24,
+0x21,0x00,0xA2,0x93,
+0x20,0x00,0xA4,0x93,
+0x02,0x80,0x03,0x3C,
+0x00,0x11,0x02,0x00,
+0x71,0x5F,0x65,0x90,
+0x25,0x10,0x44,0x00,
+0xFF,0x00,0x42,0x30,
+0xA7,0x01,0xE3,0x34,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x02,0x24,
+0x0F,0x00,0xA2,0x10,
+0x60,0x1B,0x04,0x25,
+0x60,0x1B,0x02,0x25,
+0x74,0x43,0x40,0xAC,
+0x5C,0x00,0xBF,0x8F,
+0x58,0x00,0xBE,0x8F,
+0x54,0x00,0xB7,0x8F,
+0x50,0x00,0xB6,0x8F,
+0x4C,0x00,0xB5,0x8F,
+0x48,0x00,0xB4,0x8F,
+0x44,0x00,0xB3,0x8F,
+0x40,0x00,0xB2,0x8F,
+0x3C,0x00,0xB1,0x8F,
+0x38,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x60,0x00,0xBD,0x27,
+0x78,0x43,0x82,0x94,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0xEF,0xFF,0x40,0x10,
+0x60,0x1B,0x02,0x25,
+0x99,0x43,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x62,0x30,
+0xEA,0xFF,0x40,0x10,
+0x60,0x1B,0x02,0x25,
+0x03,0x00,0x63,0x30,
+0x14,0x00,0x65,0x10,
+0x03,0x00,0x02,0x24,
+0x0E,0x00,0x62,0x10,
+0x60,0x1B,0x02,0x25,
+0x74,0x43,0x40,0xAC,
+0x21,0x88,0x00,0x00,
+0x21,0x80,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x20,0x02,
+0x90,0xEF,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x21,0x30,0x00,0x02,
+0x21,0x20,0x20,0x02,
+0x83,0x0F,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x58,0x48,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x11,0x34,
+0x02,0x00,0x10,0x24,
+0x76,0x48,0x00,0x08,
+0x74,0x43,0x85,0xAC,
+0x00,0x80,0x11,0x34,
+0x01,0x00,0x10,0x24,
+0x76,0x48,0x00,0x08,
+0x74,0x43,0x85,0xAC,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0xFF,0xFF,0x90,0x30,
+0x14,0x00,0xBF,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x22,0x00,0x04,0x24,
+0x21,0x30,0x40,0x00,
+0x0D,0x00,0x40,0x10,
+0x21,0x20,0x40,0x00,
+0x08,0x00,0x45,0x94,
+0x02,0x00,0x02,0x24,
+0x0C,0x00,0xC2,0xAC,
+0x02,0x80,0x02,0x3C,
+0x1B,0x00,0x03,0x24,
+0x25,0x28,0xA2,0x00,
+0x14,0x00,0xC3,0xAC,
+0x14,0x00,0xBF,0x8F,
+0x20,0x00,0xB0,0xA4,
+0x10,0x00,0xB0,0x8F,
+0xCB,0x09,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0xCC,0x55,0x43,0x8C,
+0x21,0x90,0x80,0x00,
+0x3C,0x00,0x64,0x24,
+0xF3,0x27,0x00,0x0C,
+0x1C,0x00,0x73,0x24,
+0x02,0x80,0x05,0x3C,
+0x21,0x88,0x40,0x00,
+0xCC,0x55,0xA5,0x24,
+0x19,0x00,0x40,0x10,
+0x74,0x03,0x06,0x24,
+0x08,0x00,0x50,0x94,
+0x0A,0x00,0x02,0x24,
+0x14,0x00,0x22,0xAE,
+0x02,0x80,0x02,0x3C,
+0x25,0x80,0x02,0x02,
+0x0C,0x00,0x33,0xAE,
+0x3C,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x10,0x26,
+0x18,0x00,0x12,0xAE,
+0x21,0x20,0x20,0x02,
+0xCB,0x09,0x00,0x0C,
+0x14,0x00,0x12,0xAE,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x40,0x02,
+0x21,0x30,0x60,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xEC,0xEF,0x84,0x24,
+0x13,0x57,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xD1,0x43,0x40,0xA0,
+0xD0,0x43,0x40,0xA0,
+0x21,0x30,0x40,0x00,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0xA2,0x24,
+0x21,0x20,0xA6,0x00,
+0xFF,0x00,0x45,0x30,
+0x20,0x00,0xA3,0x2C,
+0xFB,0xFF,0x60,0x14,
+0xAF,0x43,0x80,0xA0,
+0x08,0x00,0xE0,0x03,
+0xCF,0x43,0xC0,0xA0,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0xFF,0xFF,0x92,0x30,
+0x2A,0x00,0x04,0x24,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0xF3,0x27,0x00,0x0C,
+0xFF,0x00,0xB1,0x30,
+0x02,0x80,0x05,0x3C,
+0x21,0x80,0x40,0x00,
+0xD0,0x55,0xA5,0x24,
+0x13,0x00,0x40,0x10,
+0x06,0x00,0x06,0x24,
+0x08,0x00,0x44,0x94,
+0x0A,0x00,0x02,0x24,
+0x0C,0x00,0x02,0xAE,
+0x02,0x80,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x20,0x00,0x84,0x24,
+0x19,0x00,0x03,0x24,
+0x14,0x00,0x03,0xAE,
+0x06,0x00,0x92,0xA4,
+0xCE,0x53,0x00,0x0C,
+0x08,0x00,0x91,0xA0,
+0x21,0x20,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xCB,0x09,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x02,0x00,0x83,0x90,
+0x21,0x10,0x80,0x00,
+0x02,0x80,0x12,0x3C,
+0x0F,0x00,0x63,0x30,
+0xC0,0x18,0x03,0x00,
+0x21,0x88,0x62,0x00,
+0x10,0x00,0xA4,0x27,
+0x30,0x00,0x25,0x26,
+0x02,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x60,0x1B,0x50,0x26,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x04,0x00,0x40,0x10,
+0x18,0x00,0x24,0x26,
+0x00,0x10,0x62,0x30,
+0x0B,0x00,0x40,0x10,
+0x04,0x00,0x62,0x30,
+0x21,0x18,0x00,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xF5,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x48,0x37,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xED,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xD0,0x55,0x53,0x24,
+0x22,0x00,0x34,0x26,
+0x21,0x20,0x80,0x02,
+0x21,0x28,0x60,0x02,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xE4,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x28,0x00,0x24,0x26,
+0x21,0x28,0x60,0x02,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xDE,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x1C,0xF0,0x84,0x24,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0x0E,0x00,0x40,0x10,
+0x00,0x20,0x62,0x30,
+0x25,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x14,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x14,0x00,0xA4,0x27,
+0xFF,0xDE,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0xFE,0xFF,0x04,0x24,
+0xCC,0x39,0x00,0xAE,
+0xA1,0x48,0x00,0x0C,
+0xB0,0x39,0x00,0xAE,
+0x25,0xB0,0x11,0x3C,
+0x60,0x1B,0x50,0x26,
+0x4C,0x00,0x22,0x36,
+0x21,0x20,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x00,0x00,0x40,0xA0,
+0x48,0x00,0x31,0x36,
+0x83,0x0F,0x00,0x0C,
+0xFB,0x3E,0x00,0xA2,
+0x00,0x00,0x23,0x8E,
+0x7B,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x23,0xAE,
+0xD6,0x43,0x00,0xA2,
+0xE8,0x39,0x00,0xAE,
+0x04,0x3A,0x00,0xAE,
+0x20,0x3A,0x00,0xAE,
+0x70,0x43,0x00,0xAE,
+0x56,0x53,0x00,0x0C,
+0x30,0x43,0x00,0xAE,
+0xFD,0x61,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x20,0x49,0x00,0x08,
+0x21,0x18,0x00,0x00,
+0x10,0x00,0xA5,0x97,
+0x2D,0x10,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0xAB,0xFF,0x40,0x14,
+0xFF,0xFF,0x03,0x24,
+0x9A,0x40,0x00,0x0C,
+0x14,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x14,0x00,0xA4,0x27,
+0xFF,0xFE,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x59,0x49,0x00,0x08,
+0x25,0xB0,0x11,0x3C,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0x84,0x42,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x88,0x42,0x82,0x8C,
+0x08,0x00,0xE0,0x03,
+0x20,0x3A,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0x20,0x3A,0x80,0xAC,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0x60,0x1B,0x10,0x26,
+0x02,0x00,0x02,0x24,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0x60,0x3A,0x02,0xA2,
+0xAC,0x55,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x58,0x3A,0x00,0xAE,
+0x14,0x00,0xBF,0xAF,
+0x6F,0x27,0x00,0x0C,
+0x24,0x46,0xC6,0x24,
+0x02,0x80,0x02,0x3C,
+0x69,0x5F,0x44,0x90,
+0x02,0x80,0x03,0x3C,
+0x4A,0xFC,0x65,0x90,
+0x10,0x27,0x02,0x24,
+0x0B,0x10,0x04,0x00,
+0x01,0x00,0x84,0x2C,
+0x58,0x3A,0x02,0xAE,
+0xE5,0x43,0x05,0xA2,
+0xE4,0x43,0x04,0xA2,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xA8,0xFF,0xBD,0x27,
+0x48,0x00,0xB6,0xAF,
+0x40,0x00,0xB4,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x30,0x00,0xB0,0xAF,
+0x54,0x00,0xBF,0xAF,
+0x50,0x00,0xBE,0xAF,
+0x4C,0x00,0xB7,0xAF,
+0x44,0x00,0xB5,0xAF,
+0x3C,0x00,0xB3,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x02,0x00,0x82,0x90,
+0x00,0x00,0x83,0x8C,
+0x21,0xB0,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x18,0x00,0x12,0x26,
+0x21,0x20,0x40,0x02,
+0x39,0x52,0x00,0x0C,
+0xFF,0x3F,0x74,0x30,
+0x02,0x80,0x04,0x3C,
+0x48,0x37,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x0B,0x00,0x40,0x14,
+0x02,0x80,0x15,0x3C,
+0x60,0x1B,0xB1,0x26,
+0xB0,0x1B,0x23,0x96,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0x05,0x00,0x40,0x10,
+0x00,0x10,0x62,0x30,
+0x03,0x00,0x40,0x14,
+0x00,0x01,0x62,0x30,
+0x0E,0x00,0x40,0x10,
+0x20,0x00,0xB3,0x27,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0x32,0x00,0x05,0x26,
+0x21,0x20,0x60,0x02,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x20,0x00,0xA5,0x97,
+0x00,0x00,0x00,0x00,
+0xF5,0x00,0xA0,0x14,
+0x02,0x80,0x04,0x3C,
+0x21,0x20,0x60,0x02,
+0x34,0x00,0x05,0x26,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x20,0x00,0xA2,0x97,
+0x21,0x20,0x60,0x02,
+0x30,0x00,0x05,0x26,
+0xFF,0x3F,0x42,0x30,
+0x02,0x00,0x06,0x24,
+0x68,0x3A,0x22,0xA6,
+0xCE,0x53,0x00,0x0C,
+0x2C,0x00,0xA2,0xAF,
+0x20,0x00,0xA3,0x97,
+0x21,0x20,0x20,0x02,
+0x00,0x04,0x63,0x30,
+0x02,0x00,0x60,0x14,
+0x09,0x00,0x02,0x24,
+0x14,0x00,0x02,0x24,
+0x2C,0x43,0x82,0xA0,
+0x60,0x1B,0xB1,0x26,
+0x2C,0x43,0x23,0x92,
+0x25,0xB0,0x02,0x3C,
+0x1E,0x00,0x5E,0x26,
+0xE2,0xFF,0x93,0x26,
+0x89,0x00,0x42,0x34,
+0x21,0x20,0xC0,0x03,
+0x01,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x21,0x38,0x60,0x02,
+0x00,0x00,0x43,0xA0,
+0x6B,0x21,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x36,0x01,0x40,0x10,
+0x02,0x00,0x45,0x24,
+0x24,0x00,0xA6,0x8F,
+0xCE,0x53,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x21,0x20,0xC0,0x03,
+0x32,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x24,0x00,0xB7,0x8F,
+0x6B,0x21,0x00,0x0C,
+0x21,0x38,0x60,0x02,
+0x08,0x00,0x40,0x10,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xA6,0x8F,
+0x21,0x20,0x97,0x00,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x24,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0xB8,0xE3,0x02,
+0x02,0x80,0x02,0x3C,
+0x6A,0x5F,0x44,0x90,
+0x02,0x00,0x03,0x24,
+0x22,0x01,0x83,0x10,
+0x21,0x20,0xC0,0x03,
+0x60,0x1B,0xA3,0x26,
+0x30,0x43,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x66,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x1E,0x00,0x40,0x14,
+0x60,0x1B,0xB1,0x26,
+0x23,0x10,0xD2,0x03,
+0x2B,0x10,0x54,0x00,
+0x1A,0x00,0x40,0x10,
+0x21,0x80,0xC0,0x03,
+0x02,0x80,0x11,0x3C,
+0x21,0x20,0x00,0x02,
+0xDD,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x6B,0x21,0x00,0x0C,
+0x21,0x38,0x60,0x02,
+0x21,0x80,0x40,0x00,
+0x02,0x00,0x44,0x24,
+0x58,0xE3,0x25,0x26,
+0x4C,0x01,0x40,0x10,
+0x06,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4E,0x01,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x24,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x02,0x02,
+0x02,0x00,0x70,0x24,
+0x23,0x20,0x12,0x02,
+0x41,0x01,0x40,0x10,
+0x2B,0x20,0x94,0x00,
+0xEB,0xFF,0x80,0x14,
+0x21,0x20,0x00,0x02,
+0x60,0x1B,0xB1,0x26,
+0x70,0x43,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0xA5,0x00,0x40,0x14,
+0x21,0x20,0xC0,0x03,
+0x02,0x80,0x03,0x3C,
+0x66,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x98,0x00,0x40,0x10,
+0x18,0x08,0x04,0x24,
+0x71,0x23,0x00,0x0C,
+0x60,0x1B,0xB0,0x26,
+0xE8,0x39,0x02,0xAE,
+0xB8,0x88,0x02,0x34,
+0x7F,0x49,0x00,0x0C,
+0x04,0x3A,0x02,0xAE,
+0x9A,0x40,0x00,0x0C,
+0x28,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x28,0x00,0xA4,0x27,
+0x00,0x01,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x25,0xB0,0x02,0x3C,
+0x02,0x00,0x03,0x24,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x97,0x0F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xA4,0x27,
+0xB3,0x21,0x00,0x0C,
+0x21,0x28,0xE0,0x02,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x43,0x30,
+0x78,0x00,0x60,0x10,
+0x0F,0x00,0x53,0x30,
+0x28,0x1C,0x02,0x8E,
+0x0F,0xFF,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x24,0x10,0x43,0x00,
+0x40,0x00,0x04,0x3C,
+0x25,0x10,0x44,0x00,
+0x28,0x1C,0x02,0xAE,
+0x10,0x00,0xA4,0x27,
+0x49,0x52,0x00,0x0C,
+0x21,0x28,0xE0,0x02,
+0x40,0x02,0x71,0x36,
+0x21,0x20,0x20,0x02,
+0x57,0x5D,0x00,0x74,
+0x21,0x28,0x40,0x00,
+0x21,0x28,0xE0,0x02,
+0x75,0x52,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x60,0x1B,0xA5,0x26,
+0x21,0x80,0x40,0x00,
+0x70,0x43,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x16,0x00,0x40,0x10,
+0x50,0x00,0x71,0x36,
+0x7B,0x43,0xA2,0x90,
+0x7C,0x43,0xA3,0x90,
+0x2A,0x43,0xA4,0x90,
+0x00,0x13,0x02,0x00,
+0x00,0x1D,0x03,0x00,
+0x25,0x10,0x43,0x00,
+0x04,0x00,0x03,0x24,
+0xCE,0x00,0x83,0x10,
+0x25,0x80,0x02,0x02,
+0x74,0x43,0xA3,0x8C,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x60,0x14,
+0x01,0x00,0x02,0x24,
+0x78,0x43,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x30,
+0xD0,0x00,0x40,0x14,
+0x00,0x10,0x02,0x3C,
+0x01,0x00,0x02,0x24,
+0xC7,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x5C,0xF0,0x84,0x24,
+0x21,0x28,0x20,0x02,
+0x21,0x38,0xC0,0x02,
+0x13,0x57,0x00,0x0C,
+0x21,0x30,0x00,0x02,
+0x21,0x20,0x20,0x02,
+0x57,0x5D,0x00,0x74,
+0x21,0x28,0x00,0x02,
+0x60,0x1B,0xB1,0x26,
+0x9A,0x40,0x00,0x0C,
+0x28,0x00,0xA4,0x27,
+0xB0,0x1B,0x22,0x96,
+0x28,0x00,0xA4,0x27,
+0xFF,0xDF,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x22,0xA6,
+0x2A,0x43,0x22,0x92,
+0x60,0x1B,0xA3,0x8E,
+0xB0,0x39,0x20,0xAE,
+0xFC,0xFF,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x03,0x00,0x42,0x2C,
+0xCC,0x39,0x20,0xAE,
+0xDC,0x43,0x20,0xAE,
+0xE0,0x43,0x20,0xAE,
+0x29,0x00,0x40,0x10,
+0x25,0x00,0x63,0x34,
+0xFB,0xFF,0x02,0x24,
+0x24,0x10,0x62,0x00,
+0x60,0x1B,0xA2,0xAE,
+0x2C,0x00,0xA4,0x8F,
+0xA1,0x48,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x70,0x43,0x23,0x8E,
+0x01,0x00,0x02,0x24,
+0x18,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x74,0x43,0x33,0x8E,
+0x00,0x00,0x00,0x00,
+0x14,0xFF,0x63,0x16,
+0x1E,0x00,0x44,0x26,
+0xE2,0xFF,0x87,0x26,
+0x4A,0x00,0x05,0x24,
+0x6B,0x21,0x00,0x0C,
+0x24,0x00,0xA6,0x27,
+0x0E,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x32,0x5F,0x84,0x24,
+0x06,0x00,0x45,0x24,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0xD2,0x43,0x25,0x96,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x74,0xF0,0x84,0x24,
+0xD2,0x43,0x22,0x96,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD4,0x43,0x33,0xA2,
+0x60,0x1B,0xA3,0x26,
+0x01,0x00,0x02,0x24,
+0xB4,0x00,0x04,0x24,
+0x88,0x48,0x00,0x0C,
+0xD6,0x43,0x62,0xA0,
+0xCE,0x49,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB0,0x4A,0x00,0x08,
+0x60,0x1B,0xA3,0xAE,
+0x13,0x57,0x00,0x0C,
+0x40,0xF0,0x84,0x24,
+0xFF,0xFF,0x02,0x24,
+0x9A,0x4A,0x00,0x08,
+0x2C,0x00,0xA2,0xAF,
+0x28,0x1C,0x03,0x8E,
+0x0F,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x6C,0x4A,0x00,0x08,
+0x28,0x1C,0x03,0xAE,
+0x02,0x5B,0x00,0x0C,
+0xC5,0x03,0x05,0x24,
+0x06,0x00,0x05,0x3C,
+0x08,0x03,0xA5,0x34,
+0xF7,0x5A,0x00,0x0C,
+0x4C,0x0C,0x04,0x24,
+0x4B,0x4A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x2D,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x6B,0x21,0x00,0x0C,
+0x21,0x38,0x60,0x02,
+0x94,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x24,0x00,0xAB,0x8F,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x60,0x19,
+0x21,0x40,0x00,0x00,
+0x02,0x00,0x49,0x24,
+0x21,0x50,0x20,0x02,
+0x02,0x00,0x0C,0x24,
+0x02,0x4B,0x00,0x08,
+0x21,0x68,0x20,0x01,
+0x78,0x43,0x82,0x90,
+0x00,0x00,0x23,0x91,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x43,0x00,
+0x78,0x43,0x82,0xA0,
+0x01,0x00,0x08,0x25,
+0x2A,0x10,0x0B,0x01,
+0x11,0x00,0x40,0x10,
+0x01,0x00,0x29,0x25,
+0xF6,0xFF,0x0C,0x15,
+0x21,0x20,0x0A,0x01,
+0x7A,0x43,0x43,0x91,
+0x00,0x00,0x25,0x91,
+0x02,0x00,0xA2,0x91,
+0x1C,0x00,0x64,0x30,
+0x1C,0x00,0xA5,0x30,
+0x03,0x00,0x42,0x30,
+0x03,0x00,0x63,0x30,
+0x2A,0x30,0x43,0x00,
+0x2A,0x38,0xA4,0x00,
+0x0A,0x10,0x66,0x00,
+0x0A,0x20,0xA7,0x00,
+0x25,0x10,0x44,0x00,
+0xFE,0x4A,0x00,0x08,
+0x7A,0x43,0x42,0xA1,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x43,0x90,
+0x02,0x80,0x02,0x3C,
+0x4C,0xE6,0x47,0x24,
+0x10,0x00,0x65,0x30,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x5C,0xE6,0x66,0x24,
+0x60,0x1B,0x44,0x24,
+0x25,0x4B,0x00,0x08,
+0x21,0x40,0x00,0x00,
+0x00,0x00,0x43,0x90,
+0x7B,0x43,0x82,0x90,
+0x01,0x00,0x08,0x25,
+0x24,0x10,0x43,0x00,
+0x7B,0x43,0x82,0xA0,
+0x10,0x00,0x02,0x29,
+0x07,0x00,0x40,0x10,
+0x01,0x00,0x84,0x24,
+0x21,0x10,0x07,0x01,
+0xF6,0xFF,0xA0,0x14,
+0x21,0x18,0x06,0x01,
+0x00,0x00,0x63,0x90,
+0x1E,0x4B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0xC0,0x03,
+0x21,0x38,0x60,0x02,
+0x3D,0x00,0x05,0x24,
+0x6B,0x21,0x00,0x0C,
+0x24,0x00,0xA6,0x27,
+0x4B,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x24,0x00,0xA6,0x8F,
+0xF8,0x5E,0x84,0x24,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0xC8,0x47,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x47,0x4A,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x03,0x24,
+0x9A,0x4A,0x00,0x08,
+0x2C,0x00,0xA3,0xAF,
+0x2A,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x6B,0x21,0x00,0x0C,
+0x21,0x38,0x60,0x02,
+0x31,0x00,0x40,0x10,
+0x60,0x1B,0xA5,0x26,
+0x02,0x00,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x2C,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x6B,0x5F,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x3F,0x00,0x83,0x10,
+0xFF,0xEF,0x03,0x24,
+0xFC,0x23,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x42,0x34,
+0x24,0x10,0x43,0x00,
+0x1C,0x4A,0x00,0x08,
+0xFC,0x23,0x22,0xAE,
+0x25,0xB0,0x02,0x3C,
+0xF6,0x01,0x42,0x34,
+0x00,0x00,0x40,0xA4,
+0x92,0x4A,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0x78,0x43,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0x37,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x00,0x10,0x02,0x3C,
+0x25,0x80,0x02,0x02,
+0x0F,0x00,0x08,0x24,
+0x01,0x00,0x03,0x24,
+0x0C,0x00,0x02,0x25,
+0x04,0x10,0x43,0x00,
+0x24,0x10,0x50,0x00,
+0x16,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x08,0x25,
+0xFA,0xFF,0x01,0x05,
+0x0C,0x00,0x02,0x25,
+0x00,0x12,0x16,0x00,
+0x00,0x1B,0x16,0x00,
+0x25,0x18,0x62,0x00,
+0x00,0x21,0x16,0x00,
+0x25,0x18,0x64,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x18,0x76,0x00,
+0xF6,0x01,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x92,0x4A,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0xFC,0x23,0xA2,0x8C,
+0xFF,0xF7,0x03,0x24,
+0xFF,0xEF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x1C,0x4A,0x00,0x08,
+0xFC,0x23,0xA2,0xAC,
+0x68,0x4B,0x00,0x08,
+0xFF,0x00,0x16,0x31,
+0x60,0x1B,0xA2,0x26,
+0x46,0x4A,0x00,0x08,
+0x70,0x43,0x40,0xAC,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x41,0x4A,0x00,0x08,
+0x30,0x43,0x40,0xAC,
+0x46,0x4A,0x00,0x08,
+0x70,0x43,0x20,0xAE,
+0x21,0x20,0x00,0x02,
+0x45,0x12,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0x4A,0x00,0x08,
+0x60,0x1B,0xB1,0x26,
+0xFC,0x23,0x22,0x8E,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x10,0x42,0x34,
+0x1C,0x4A,0x00,0x08,
+0xFC,0x23,0x22,0xAE,
+0xE0,0xFF,0xBD,0x27,
+0xF4,0xFF,0xA5,0x24,
+0x24,0x00,0x84,0x24,
+0x21,0x38,0xA0,0x00,
+0x10,0x00,0xA6,0x27,
+0x18,0x00,0xBF,0xAF,
+0x6B,0x21,0x00,0x0C,
+0x03,0x00,0x05,0x24,
+0x21,0x20,0x40,0x00,
+0x0B,0x00,0x40,0x10,
+0xFF,0xFF,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x40,0x59,0x43,0x90,
+0x02,0x00,0x84,0x90,
+0xFF,0x00,0x62,0x30,
+0x23,0x28,0x64,0x00,
+0x00,0x2E,0x05,0x00,
+0x2B,0x10,0x44,0x00,
+0x23,0x18,0x83,0x00,
+0x05,0x00,0x40,0x14,
+0x03,0x2E,0x05,0x00,
+0x18,0x00,0xBF,0x8F,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x00,0x2E,0x03,0x00,
+0x18,0x00,0xBF,0x8F,
+0x03,0x2E,0x05,0x00,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0xCC,0x55,0x84,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0xFB,0x50,0x00,0x0C,
+0x74,0x00,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0xA4,0x27,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA2,0x97,
+0x25,0xB0,0x04,0x3C,
+0x94,0x00,0x85,0x34,
+0x9A,0x00,0x87,0x34,
+0x26,0xB0,0x06,0x3C,
+0x00,0x08,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x0A,0x00,0x0B,0x24,
+0x00,0x00,0xE3,0xA4,
+0x98,0x00,0x88,0x34,
+0x96,0x00,0x89,0x34,
+0x7A,0x00,0xCA,0x34,
+0x50,0x00,0x02,0x24,
+0x04,0x00,0x03,0x24,
+0x00,0x00,0x02,0xA5,
+0x00,0x00,0x2B,0xA5,
+0x00,0x00,0x43,0xA1,
+0x10,0x00,0xA2,0x97,
+0x89,0x00,0x83,0x34,
+0x14,0x00,0x07,0x24,
+0x40,0x11,0x02,0x00,
+0xA0,0xFF,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0x9C,0x00,0x85,0x34,
+0x7C,0x00,0xC6,0x34,
+0x00,0x00,0xC2,0xA4,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x67,0xA0,
+0x00,0x00,0xAB,0xA0,
+0x00,0x00,0x82,0x94,
+0xFF,0xFD,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA4,
+0x00,0x00,0x83,0x94,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x00,0x02,0x63,0x34,
+0x20,0x00,0xBD,0x27,
+0xD7,0x43,0x40,0xA0,
+0x00,0x00,0x83,0xA4,
+0x08,0x00,0xE0,0x03,
+0x2C,0x43,0x47,0xA0,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0xCC,0x55,0x04,0x26,
+0x30,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x18,0x51,0x00,0x0C,
+0x24,0x00,0xB3,0xAF,
+0xFF,0xFF,0x51,0x30,
+0xCC,0x55,0x04,0x26,
+0xFD,0x50,0x00,0x0C,
+0x02,0x80,0x15,0x3C,
+0x60,0x1B,0xA3,0x26,
+0x01,0x00,0x24,0x32,
+0x28,0x43,0x62,0xA4,
+0x03,0x00,0x80,0x14,
+0x02,0x00,0x12,0x24,
+0x40,0x10,0x11,0x00,
+0x04,0x00,0x52,0x30,
+0x02,0x00,0x02,0x24,
+0x69,0x00,0x42,0x12,
+0x00,0x00,0x00,0x00,
+0x11,0x00,0x80,0x10,
+0x02,0x00,0x12,0x24,
+0x04,0x00,0x02,0x24,
+0x13,0x00,0x42,0x12,
+0x25,0xB0,0x10,0x3C,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x20,0x02,
+0x13,0x57,0x00,0x0C,
+0xC4,0xF0,0x84,0x24,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x40,0x10,0x11,0x00,
+0x04,0x00,0x52,0x30,
+0x04,0x00,0x02,0x24,
+0xEF,0xFF,0x42,0x16,
+0x25,0xB0,0x10,0x3C,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x60,0x1B,0xB3,0x26,
+0x16,0x01,0x03,0x36,
+0x3F,0x3F,0x02,0x24,
+0x00,0x00,0x62,0xA4,
+0x10,0x00,0xA4,0x27,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x72,0xA6,
+0x50,0x02,0x03,0x36,
+0x0F,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x21,0x20,0x00,0x00,
+0x83,0x0F,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x28,0x43,0x66,0x96,
+0xE0,0x3D,0x65,0x92,
+0x02,0x80,0x04,0x3C,
+0xD4,0xF0,0x84,0x24,
+0x01,0x00,0x14,0x24,
+0x13,0x57,0x00,0x0C,
+0x4C,0x00,0x10,0x36,
+0x02,0x80,0x11,0x3C,
+0x00,0x00,0x14,0xA2,
+0x97,0x0F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1B,0x52,0x00,0x0C,
+0x2C,0x56,0x24,0x26,
+0x21,0x28,0x40,0x00,
+0x2C,0x56,0x24,0x26,
+0xB3,0x21,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x0F,0x00,0x50,0x30,
+0x2C,0x56,0x24,0x26,
+0x49,0x52,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x40,0x02,0x10,0x36,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x21,0x30,0x40,0x00,
+0x21,0x28,0x00,0x02,
+0x13,0x57,0x00,0x0C,
+0x04,0xF1,0x84,0x24,
+0x21,0x20,0x00,0x02,
+0x57,0x5D,0x00,0x74,
+0x21,0x28,0x20,0x02,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x06,0x00,0x06,0x24,
+0x37,0x3A,0x84,0x24,
+0xCE,0x53,0x00,0x0C,
+0xD6,0x1E,0x74,0xA2,
+0xCF,0x46,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAF,0x4B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x62,0x96,
+0x10,0x00,0xA4,0x27,
+0x00,0x01,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x62,0xA6,
+0x71,0x23,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE8,0x39,0x62,0xAE,
+0xA1,0x48,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x60,0x1B,0xA2,0x8E,
+0x30,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x21,0x00,0x42,0x34,
+0x60,0x1B,0xA2,0xAE,
+0x24,0x00,0xB3,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x25,0xB0,0x11,0x3C,
+0x60,0x1B,0xB0,0x26,
+0x3F,0x3F,0x02,0x24,
+0x16,0x01,0x25,0x36,
+0x01,0x20,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x10,0x00,0xA4,0x27,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x03,0xA6,
+0x98,0x42,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x52,0x10,
+0x50,0x02,0x23,0x36,
+0x0F,0x00,0x02,0x24,
+0x60,0x1B,0xB0,0x26,
+0x00,0x00,0x62,0xA0,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0x10,0x00,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x21,0x20,0x00,0x00,
+0x83,0x0F,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0xE0,0x3D,0x05,0x92,
+0x28,0x43,0x06,0x96,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x18,0xF1,0x84,0x24,
+0x28,0x43,0x04,0x96,
+0xB4,0x53,0x00,0x0C,
+0x78,0x42,0x00,0xAE,
+0xE8,0x39,0x02,0xAE,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x75,0x4C,0x00,0x08,
+0x0C,0x00,0x02,0x24,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x21,0x90,0x80,0x00,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x9A,0x40,0x00,0x0C,
+0xFF,0x00,0xB1,0x30,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x50,0x24,
+0x10,0x00,0xA4,0x27,
+0x01,0x00,0x02,0x24,
+0xA0,0x40,0x00,0x0C,
+0xE7,0x43,0x02,0xA2,
+0x58,0x42,0x00,0xA2,
+0x21,0x48,0x00,0x00,
+0x22,0x00,0x20,0x12,
+0x21,0x78,0x00,0x00,
+0x21,0xC0,0x00,0x02,
+0x21,0x18,0xF2,0x01,
+0x01,0x00,0x68,0x90,
+0x58,0x42,0x02,0x92,
+0x00,0x00,0x6A,0x90,
+0x21,0x38,0x00,0x00,
+0x21,0x10,0x02,0x01,
+0x14,0x00,0x00,0x11,
+0x58,0x42,0x02,0xA2,
+0x21,0x70,0x00,0x03,
+0x3C,0x00,0x0D,0x24,
+0x01,0x00,0x0C,0x24,
+0x02,0x00,0x0B,0x24,
+0x01,0x00,0xE2,0x24,
+0xC0,0x18,0x09,0x00,
+0x21,0x30,0x47,0x01,
+0x01,0x00,0x24,0x25,
+0xFF,0x00,0x47,0x30,
+0x1F,0x00,0x22,0x2D,
+0x21,0x18,0x6E,0x00,
+0x2B,0x28,0xE8,0x00,
+0x0B,0x00,0x40,0x10,
+0xFF,0x00,0x89,0x30,
+0xC8,0x40,0x66,0xA0,
+0xCC,0x40,0x6B,0xA0,
+0xCA,0x40,0x6D,0xA4,
+0xF2,0xFF,0xA0,0x14,
+0xC9,0x40,0x6C,0xA0,
+0x03,0x00,0xE2,0x25,
+0xFF,0x00,0x4F,0x30,
+0x2B,0x18,0xF1,0x01,
+0xE2,0xFF,0x60,0x14,
+0x21,0x18,0xF2,0x01,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x54,0x61,0x43,0x90,
+0xFF,0x00,0x02,0x24,
+0x09,0x00,0x62,0x10,
+0x21,0x80,0x80,0x00,
+0x21,0x20,0x00,0x02,
+0x05,0x49,0x00,0x0C,
+0xFE,0xFF,0x05,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x4A,0x11,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x02,
+0x05,0x49,0x00,0x0C,
+0xFE,0xFF,0x05,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x54,0x61,0x43,0x90,
+0xFF,0x00,0x02,0x24,
+0x09,0x00,0x62,0x10,
+0x21,0x80,0x80,0x00,
+0x21,0x20,0x00,0x02,
+0x05,0x49,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x4A,0x11,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x02,
+0x05,0x49,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x80,0xFF,0xBD,0x27,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x08,0x3C,
+0x78,0x00,0xBE,0xAF,
+0x7C,0x00,0xBF,0xAF,
+0x74,0x00,0xB7,0xAF,
+0x70,0x00,0xB6,0xAF,
+0x6C,0x00,0xB5,0xAF,
+0x68,0x00,0xB4,0xAF,
+0x64,0x00,0xB3,0xAF,
+0x60,0x00,0xB2,0xAF,
+0x5C,0x00,0xB1,0xAF,
+0x58,0x00,0xB0,0xAF,
+0xA4,0xF0,0xC2,0x24,
+0x4C,0xF1,0x03,0x25,
+0x01,0x00,0x44,0x90,
+0x01,0x00,0x65,0x90,
+0xA4,0xF0,0xCB,0x90,
+0x4C,0xF1,0x0A,0x91,
+0x02,0x00,0x47,0x90,
+0x02,0x00,0x66,0x90,
+0x03,0x00,0x48,0x90,
+0x03,0x00,0x69,0x90,
+0x00,0x22,0x04,0x00,
+0x00,0x2A,0x05,0x00,
+0x25,0x20,0x8B,0x00,
+0x25,0x28,0xAA,0x00,
+0x00,0x3C,0x07,0x00,
+0x00,0x34,0x06,0x00,
+0x25,0x38,0xE4,0x00,
+0x25,0x30,0xC5,0x00,
+0x00,0x46,0x08,0x00,
+0x00,0x4E,0x09,0x00,
+0x25,0x40,0x07,0x01,
+0x25,0x48,0x26,0x01,
+0x00,0x02,0x04,0x24,
+0x40,0x00,0xA8,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x48,0x00,0xA9,0xAF,
+0xBD,0x01,0x40,0x10,
+0x21,0xF0,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x52,0x24,
+0xDC,0x3A,0x45,0x8E,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x50,0xF1,0x84,0x24,
+0x08,0x00,0xD1,0x97,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x10,0x3C,
+0x25,0x88,0x22,0x02,
+0xD0,0x55,0x10,0x26,
+0x21,0x28,0x00,0x02,
+0x24,0x00,0x24,0x26,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x20,0xA6,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x2A,0x00,0x24,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x21,0x28,0x00,0x02,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x30,0x00,0x24,0x26,
+0x18,0x00,0x03,0x24,
+0x0C,0x00,0xC3,0xAF,
+0xE4,0x1D,0x42,0x96,
+0x20,0x00,0x25,0x26,
+0x38,0x00,0x37,0x26,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x22,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xE4,0x1D,0x42,0xA6,
+0x17,0x00,0xA4,0xA0,
+0x02,0x80,0x04,0x3C,
+0x16,0x00,0xA3,0xA0,
+0x16,0x51,0x00,0x0C,
+0x40,0x56,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0xE0,0x02,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x3A,0x00,0x24,0x26,
+0x18,0x00,0xA5,0x27,
+0x02,0x00,0x06,0x24,
+0x03,0x00,0x02,0x24,
+0xCE,0x53,0x00,0x0C,
+0x18,0x00,0xA2,0xA7,
+0x0C,0x00,0xC3,0x8F,
+0x02,0x80,0x07,0x3C,
+0x21,0x28,0x00,0x00,
+0x04,0x00,0x63,0x24,
+0x0C,0x00,0xC3,0xAF,
+0x78,0x3A,0x46,0x8E,
+0x0C,0x00,0xC3,0x27,
+0x3C,0x00,0x24,0x26,
+0xDC,0x55,0xE7,0x24,
+0x50,0x00,0xA3,0xAF,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x21,0xB8,0x40,0x00,
+0x21,0x80,0x00,0x00,
+0x18,0x00,0xA5,0x27,
+0x21,0x10,0x12,0x02,
+0xCC,0x3A,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x10,
+0x21,0x20,0xB0,0x00,
+0x01,0x00,0x10,0x26,
+0x0D,0x00,0x02,0x2E,
+0xF8,0xFF,0x40,0x14,
+0x08,0x00,0x83,0xA0,
+0x09,0x00,0x02,0x2E,
+0xBE,0x00,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x50,0x00,0xA2,0x8F,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0x06,0x24,
+0x20,0x00,0xA7,0x27,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x50,0x00,0xA3,0x8F,
+0x21,0x20,0x40,0x00,
+0xF8,0xFF,0x06,0x26,
+0x32,0x00,0x05,0x24,
+0x28,0x00,0xA7,0x27,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0x98,0x42,0x83,0x8C,
+0x02,0x00,0x02,0x24,
+0xB7,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0xF3,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x4F,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x43,0x24,
+0xDC,0x3A,0x62,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x11,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x60,0x00,
+0x40,0x56,0x52,0x24,
+0x21,0x98,0x60,0x00,
+0x02,0x80,0x14,0x3C,
+0x21,0x20,0x32,0x02,
+0x00,0x00,0x83,0x90,
+0x2D,0x00,0x02,0x24,
+0x02,0x01,0x62,0x10,
+0x02,0x80,0x05,0x3C,
+0x01,0x00,0x82,0x90,
+0xDC,0x3A,0x03,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0xF6,0xFF,0x60,0x14,
+0x21,0x20,0x32,0x02,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0x98,0x42,0x83,0x8C,
+0x02,0x00,0x02,0x24,
+0xB2,0x00,0x62,0x10,
+0x0C,0x00,0x11,0x24,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x43,0x24,
+0xDC,0x3A,0x62,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x26,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x40,0x56,0x56,0x24,
+0x21,0xA8,0x60,0x00,
+0xDD,0x00,0x14,0x24,
+0xC6,0x4D,0x00,0x08,
+0x02,0x80,0x13,0x3C,
+0x01,0x00,0x02,0x92,
+0xDC,0x3A,0xA3,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0x1B,0x00,0x60,0x10,
+0x02,0x80,0x03,0x3C,
+0x21,0x80,0x36,0x02,
+0x00,0x00,0x02,0x92,
+0x02,0x00,0x12,0x26,
+0x21,0x20,0x40,0x02,
+0x60,0xE3,0x65,0x26,
+0xF3,0xFF,0x54,0x14,
+0x06,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x50,0x00,0xA2,0x8F,
+0xDD,0x00,0x05,0x24,
+0x21,0x38,0x40,0x02,
+0x07,0x00,0x06,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x08,0x00,0x04,0x92,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x65,0x24,
+0x21,0xB8,0x40,0x00,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x3A,0x64,0x44,0xA0,
+0x30,0x43,0xA3,0xAC,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x64,0x24,
+0xDC,0x3A,0x82,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x20,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x40,0x56,0x56,0x24,
+0x42,0x56,0x75,0x24,
+0x21,0xA0,0x80,0x00,
+0xF3,0x4D,0x00,0x08,
+0xDD,0x00,0x13,0x24,
+0x01,0x00,0x02,0x92,
+0xDC,0x3A,0x83,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0x14,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x36,0x02,
+0x00,0x00,0x02,0x92,
+0x21,0x90,0x35,0x02,
+0x21,0x20,0x40,0x02,
+0x48,0x00,0xA5,0x27,
+0xF3,0xFF,0x53,0x14,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x01,0x00,0x06,0x92,
+0x50,0x00,0xA2,0x8F,
+0x21,0x38,0x40,0x02,
+0xDD,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0x70,0x43,0x83,0x8C,
+0x01,0x00,0x02,0x24,
+0x8D,0x00,0x62,0x10,
+0x06,0x00,0x02,0x24,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x62,0x24,
+0xDC,0x3A,0x43,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x23,0x02,
+0x10,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x40,0x56,0x46,0x24,
+0x21,0x20,0x60,0x00,
+0x44,0x00,0x05,0x24,
+0x21,0x80,0x26,0x02,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x70,0x00,0x45,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x24,0x02,
+0xF6,0xFF,0x60,0x14,
+0x21,0x80,0x26,0x02,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x62,0x24,
+0x2A,0x43,0x43,0x90,
+0x04,0x00,0x07,0x24,
+0x21,0x20,0xC0,0x03,
+0x01,0x00,0x63,0x38,
+0x0B,0x38,0x03,0x00,
+0x21,0x28,0x00,0x00,
+0xC7,0x0E,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x21,0x10,0x00,0x00,
+0x7C,0x00,0xBF,0x8F,
+0x78,0x00,0xBE,0x8F,
+0x74,0x00,0xB7,0x8F,
+0x70,0x00,0xB6,0x8F,
+0x6C,0x00,0xB5,0x8F,
+0x68,0x00,0xB4,0x8F,
+0x64,0x00,0xB3,0x8F,
+0x60,0x00,0xB2,0x8F,
+0x5C,0x00,0xB1,0x8F,
+0x58,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x80,0x00,0xBD,0x27,
+0x50,0x00,0xA3,0x8F,
+0x21,0x30,0x00,0x02,
+0x01,0x00,0x05,0x24,
+0x20,0x00,0xA7,0x27,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x44,0x24,
+0x98,0x42,0x83,0x8C,
+0x02,0x00,0x02,0x24,
+0x4B,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0xDC,0x3A,0x83,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x23,0x02,
+0x46,0xFF,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x40,0x56,0x46,0x24,
+0x21,0x20,0x60,0x00,
+0x55,0x4E,0x00,0x08,
+0x30,0x00,0x05,0x24,
+0x01,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x24,0x02,
+0x3B,0xFF,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x26,0x02,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xF5,0xFF,0x45,0x14,
+0x02,0x80,0x07,0x3C,
+0x01,0x00,0x66,0x90,
+0x50,0x00,0xA2,0x8F,
+0x42,0x56,0xE7,0x24,
+0x21,0x20,0xE0,0x02,
+0x21,0x38,0x27,0x02,
+0x30,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x8F,0x4D,0x00,0x08,
+0x21,0xB8,0x40,0x00,
+0xDC,0x3A,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x22,0x02,
+0x4B,0xFF,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x40,0x56,0x56,0x24,
+0x42,0x56,0x75,0x24,
+0x21,0xA0,0x80,0x00,
+0x76,0x4E,0x00,0x08,
+0xDD,0x00,0x13,0x24,
+0x01,0x00,0x02,0x92,
+0xDC,0x3A,0x83,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0x3F,0xFF,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x36,0x02,
+0x00,0x00,0x02,0x92,
+0x21,0x90,0x35,0x02,
+0x21,0x20,0x40,0x02,
+0x40,0x00,0xA5,0x27,
+0xF3,0xFF,0x53,0x14,
+0x04,0x00,0x06,0x24,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x01,0x00,0x06,0x92,
+0x50,0x00,0xA3,0x8F,
+0x21,0x38,0x40,0x02,
+0xDD,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0xB3,0x4D,0x00,0x08,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x64,0xF1,0x84,0x24,
+0x01,0x00,0x06,0x92,
+0x50,0x00,0xA2,0x8F,
+0x02,0x80,0x07,0x3C,
+0x42,0x56,0xE7,0x24,
+0x21,0x38,0x27,0x02,
+0x21,0x20,0xE0,0x02,
+0x44,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x22,0x4E,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x2A,0x43,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x62,0x10,
+0x05,0x00,0x02,0x24,
+0x70,0xFF,0x62,0x14,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x07,0x3C,
+0x21,0x20,0xE0,0x02,
+0x24,0xE3,0xE7,0x24,
+0xDD,0x00,0x05,0x24,
+0x06,0x00,0x06,0x24,
+0x50,0x00,0xA3,0x8F,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x0B,0x4E,0x00,0x08,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x15,0x3C,
+0x42,0x56,0xA5,0x24,
+0x21,0x28,0x25,0x02,
+0xD8,0x5E,0xA4,0x26,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x06,0x24,
+0x02,0x80,0x03,0x3C,
+0x71,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x25,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x78,0x43,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xBD,0xFF,0x42,0x30,
+0x78,0x43,0x02,0xA6,
+0x78,0x43,0x63,0x96,
+0x02,0x80,0x02,0x3C,
+0xCC,0xE6,0x44,0x8C,
+0x0C,0x00,0x63,0x34,
+0xFF,0xF7,0x02,0x24,
+0x20,0x00,0x80,0x10,
+0x24,0x10,0x62,0x00,
+0x00,0x01,0x42,0x34,
+0x78,0x43,0x62,0xA6,
+0x02,0x80,0x03,0x3C,
+0x5E,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x15,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x05,0x3C,
+0xDB,0x5E,0x84,0x26,
+0x4C,0xE6,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x46,0x90,
+0x50,0x00,0xA3,0x8F,
+0x21,0x20,0xE0,0x02,
+0xD8,0x5E,0xA7,0x26,
+0x2D,0x00,0x05,0x24,
+0x25,0x51,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x21,0xB8,0x40,0x00,
+0x01,0x00,0x02,0x24,
+0xAD,0x4D,0x00,0x08,
+0x70,0x43,0x02,0xAE,
+0x78,0x43,0x02,0x96,
+0xB5,0x4E,0x00,0x08,
+0x02,0x00,0x42,0x34,
+0xDB,0x5E,0x84,0x26,
+0xC8,0x4E,0x00,0x08,
+0x5C,0xE6,0xA5,0x24,
+0xBF,0x4E,0x00,0x08,
+0x78,0x43,0x62,0xA6,
+0x02,0x80,0x02,0x3C,
+0x24,0xE3,0x42,0x24,
+0x06,0x00,0x48,0x90,
+0x02,0x00,0x03,0x24,
+0x21,0x20,0xE0,0x02,
+0x01,0x00,0x08,0x35,
+0x21,0x38,0x40,0x00,
+0xDD,0x00,0x05,0x24,
+0x07,0x00,0x06,0x24,
+0x04,0x00,0x43,0xA0,
+0xA2,0x4E,0x00,0x08,
+0x06,0x00,0x48,0xA0,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x78,0xF1,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x3C,0xF1,0xA5,0x24,
+0x2C,0x4E,0x00,0x08,
+0xFF,0xFF,0x02,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0x60,0x1B,0x10,0x26,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0x9F,0xFE,0x42,0x30,
+0x80,0x00,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x32,0x00,0x02,0x24,
+0xCC,0x39,0x02,0xAE,
+0x8C,0x42,0x00,0xAE,
+0x90,0x42,0x00,0xAE,
+0x05,0x4D,0x00,0x0C,
+0xB0,0x39,0x00,0xAE,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xBF,0xAF,
+0x60,0x1B,0x42,0x24,
+0xD1,0x43,0x43,0x90,
+0x01,0x00,0x07,0x24,
+0x04,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x08,0x00,0x67,0x10,
+0x21,0x30,0x00,0x00,
+0xD0,0x43,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x47,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0xD1,0x48,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x4B,0x17,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0xD1,0x48,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x14,0x3C,
+0x60,0x1B,0x92,0x26,
+0xB0,0x1B,0x43,0x96,
+0x00,0x00,0x85,0x8C,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x01,0x00,0x63,0x30,
+0xFF,0x3F,0xB3,0x30,
+0x18,0x00,0x11,0x26,
+0x0A,0x00,0x60,0x14,
+0x21,0x20,0x00,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x39,0x52,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x02,0x80,0x04,0x3C,
+0x48,0x37,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0xF7,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0xB0,0x1B,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x30,
+0xEA,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x03,0x96,
+0x04,0x00,0x04,0x24,
+0x21,0x10,0x80,0x00,
+0x00,0x40,0x63,0x30,
+0x0A,0x10,0x03,0x00,
+0x21,0x10,0x22,0x02,
+0x1C,0x00,0x43,0x94,
+0x1A,0x00,0x45,0x94,
+0x38,0x00,0x60,0x14,
+0x02,0x00,0x02,0x24,
+0x1A,0x00,0xA2,0x10,
+0x01,0x00,0x02,0x24,
+0x13,0x00,0xA4,0x14,
+0x00,0x00,0x00,0x00,
+0x98,0x42,0x43,0x8E,
+0x00,0x00,0x00,0x00,
+0x0B,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x9A,0x40,0x00,0x0C,
+0x14,0x00,0xA4,0x27,
+0x60,0x1B,0x83,0x26,
+0xB0,0x1B,0x62,0x94,
+0x14,0x00,0xA4,0x27,
+0xFF,0xDF,0x42,0x30,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x62,0xA4,
+0x32,0x4F,0x00,0x08,
+0xFF,0xFF,0x04,0x24,
+0xF1,0x4E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x32,0x4F,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0xCC,0xF1,0x84,0x24,
+0x5B,0x4F,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x98,0x42,0x43,0x8E,
+0x00,0x00,0x00,0x00,
+0xF4,0xFF,0x62,0x14,
+0xE2,0xFF,0x67,0x26,
+0x36,0x00,0x04,0x26,
+0x10,0x00,0x05,0x24,
+0x6B,0x21,0x00,0x0C,
+0x10,0x00,0xA6,0x27,
+0x19,0x00,0x40,0x10,
+0x02,0x00,0x45,0x24,
+0x10,0x00,0xA6,0x8F,
+0x02,0x80,0x04,0x3C,
+0xCE,0x53,0x00,0x0C,
+0x08,0x5E,0x84,0x24,
+0x03,0x00,0x02,0x24,
+0x14,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x94,0x42,0x42,0xAE,
+0xB0,0x1B,0x42,0x96,
+0x14,0x00,0xA4,0x27,
+0xDF,0xFF,0x42,0x30,
+0x40,0x00,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x42,0xA6,
+0xB1,0x18,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x32,0x4F,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0xF4,0xF1,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x21,0x28,0x60,0x00,
+0x5B,0x4F,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x10,0xF2,0x84,0x24,
+0x5B,0x4F,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0x60,0x1B,0x10,0x26,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xB0,0x1B,0x02,0x96,
+0x10,0x00,0xA4,0x27,
+0xEF,0xFF,0x42,0x30,
+0x20,0x00,0x42,0x34,
+0xA0,0x40,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x01,0x00,0x02,0x24,
+0x32,0x00,0x03,0x24,
+0x94,0x42,0x02,0xAE,
+0xB0,0x39,0x03,0xAE,
+0xCC,0x39,0x00,0xAE,
+0x8C,0x42,0x00,0xAE,
+0x90,0x42,0x00,0xAE,
+0xB1,0x18,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x21,0x90,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x21,0x98,0xA0,0x00,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x31,0x00,0x40,0x10,
+0x10,0xF3,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x40,0x02,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x00,0xA6,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x2A,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x30,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x05,0x3C,
+0x03,0xFF,0x63,0x30,
+0xC0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x60,0x1B,0xA5,0x24,
+0x0C,0x00,0x22,0xAE,
+0xE4,0x1D,0xA3,0x94,
+0x20,0x00,0x07,0x26,
+0x38,0x00,0x04,0x26,
+0xFF,0x0F,0x62,0x30,
+0x00,0x11,0x02,0x00,
+0x02,0x32,0x02,0x00,
+0x01,0x00,0x63,0x24,
+0xE4,0x1D,0xA3,0xA4,
+0x17,0x00,0xE6,0xA0,
+0x16,0x00,0xE2,0xA0,
+0x02,0x00,0x05,0x24,
+0x10,0x00,0xA6,0x27,
+0x0C,0x00,0x27,0x26,
+0x4C,0x51,0x00,0x0C,
+0x10,0x00,0xB3,0xA7,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0xC7,0x0E,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x21,0x88,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xF3,0x27,0x00,0x0C,
+0x21,0x98,0xA0,0x00,
+0x02,0x80,0x04,0x3C,
+0x21,0x90,0x40,0x00,
+0x34,0x00,0x40,0x10,
+0x20,0xF3,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x50,0x96,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x20,0x02,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0x20,0x00,0x00,0xA6,
+0x02,0x80,0x05,0x3C,
+0x48,0x37,0xA5,0x24,
+0x2A,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0xD0,0x55,0xA5,0x24,
+0x30,0x00,0x04,0x26,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x11,0x3C,
+0x03,0xFF,0x63,0x30,
+0xA0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x60,0x1B,0x31,0x26,
+0x0C,0x00,0x42,0xAE,
+0xE4,0x1D,0x23,0x96,
+0x20,0x00,0x06,0x26,
+0x38,0x00,0x04,0x26,
+0xFF,0x0F,0x62,0x30,
+0x00,0x11,0x02,0x00,
+0x02,0x2A,0x02,0x00,
+0x01,0x00,0x63,0x24,
+0xE4,0x1D,0x23,0xA6,
+0x0C,0x00,0x47,0x26,
+0x17,0x00,0xC5,0xA0,
+0x16,0x00,0xC2,0xA0,
+0x02,0x00,0x05,0x24,
+0x10,0x00,0xA6,0x27,
+0x4C,0x51,0x00,0x0C,
+0x10,0x00,0xB3,0xA7,
+0x2A,0x43,0x23,0x92,
+0x04,0x00,0x07,0x24,
+0x21,0x20,0x40,0x02,
+0x01,0x00,0x63,0x38,
+0x0B,0x38,0x03,0x00,
+0x21,0x28,0x00,0x00,
+0xC7,0x0E,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x2C,0x00,0xB1,0xAF,
+0xFF,0xFF,0x05,0x24,
+0x21,0x88,0x80,0x00,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA4,0x27,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB2,0xAF,
+0xC6,0x53,0x00,0x0C,
+0x28,0x00,0xB0,0xAF,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x00,0x00,
+0x25,0x80,0x02,0x02,
+0x21,0x20,0x00,0x02,
+0xC6,0x53,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x20,0x00,0x02,0x96,
+0x24,0x00,0x04,0x26,
+0x10,0x00,0xA5,0x27,
+0x03,0xFF,0x42,0x30,
+0xC8,0x00,0x42,0x34,
+0x20,0x00,0x02,0xA6,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x25,0xB0,0x03,0x3C,
+0x50,0x00,0x62,0x34,
+0x00,0x00,0x44,0x8C,
+0x54,0x00,0x65,0x34,
+0x58,0x00,0x66,0x34,
+0x18,0x00,0xA4,0xAF,
+0x00,0x00,0xA2,0x8C,
+0x5C,0x00,0x63,0x34,
+0x2A,0x00,0x04,0x26,
+0x1C,0x00,0xA2,0xAF,
+0x00,0x00,0xC7,0x8C,
+0x18,0x00,0xA5,0x27,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0xA7,0xAF,
+0x00,0x00,0x62,0x8C,
+0x1A,0x00,0x12,0x24,
+0xCE,0x53,0x00,0x0C,
+0x24,0x00,0xA2,0xAF,
+0x30,0x00,0x04,0x26,
+0x20,0x00,0xA5,0x27,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x13,0x00,0x03,0x24,
+0x14,0x00,0x23,0xAE,
+0x0C,0x00,0x32,0xAE,
+0x08,0x00,0x05,0x8E,
+0x04,0x00,0x04,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0x14,0x00,0x06,0x8E,
+0xFF,0xFF,0x42,0x34,
+0x10,0x00,0x07,0x8E,
+0xFF,0xE0,0x03,0x24,
+0x24,0x28,0xA2,0x00,
+0x00,0x40,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0x25,0x28,0xA2,0x00,
+0xFF,0x81,0x03,0x24,
+0xFE,0xFF,0x02,0x3C,
+0x24,0x30,0xC3,0x00,
+0xFF,0xFF,0x42,0x34,
+0x00,0x12,0x84,0x34,
+0x00,0x80,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0x25,0x38,0xE3,0x00,
+0x00,0x26,0xC6,0x34,
+0x80,0x00,0xA5,0x34,
+0x20,0x00,0x02,0x24,
+0x00,0x00,0x12,0xA6,
+0x10,0x00,0x07,0xAE,
+0x02,0x00,0x02,0xA2,
+0x14,0x00,0x06,0xAE,
+0x04,0x00,0x04,0xAE,
+0x08,0x00,0x05,0xAE,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xFF,0x00,0x82,0x30,
+0x02,0x80,0x04,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0xD0,0x55,0x84,0x24,
+0x08,0x00,0x05,0x24,
+0x48,0x00,0x06,0x24,
+0x18,0x00,0x07,0x24,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xA2,0xAF,
+0x89,0x1B,0x00,0x0C,
+0x14,0x00,0xA0,0xAF,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x0F,0x00,0x42,0x30,
+0x05,0x00,0x42,0x28,
+0x07,0x00,0x40,0x10,
+0x01,0x00,0x04,0x24,
+0x90,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x01,0x00,0x04,0x24,
+0x90,0x50,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x90,0x50,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x20,0x00,0x00,
+0x90,0x50,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xFF,0x00,0x84,0x30,
+0x02,0x00,0x02,0x24,
+0x03,0x00,0x83,0x28,
+0x0D,0x00,0x82,0x10,
+0x21,0x28,0x00,0x00,
+0x06,0x00,0x60,0x10,
+0x04,0x00,0x02,0x24,
+0x01,0x00,0x02,0x24,
+0x0B,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0xFD,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x04,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x06,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0x00,0x90,0x30,
+0x1C,0x00,0xBF,0xAF,
+0xB3,0x50,0x00,0x0C,
+0xFF,0x00,0xA4,0x30,
+0x02,0x80,0x04,0x3C,
+0xD0,0x55,0x84,0x24,
+0x08,0x00,0x05,0x24,
+0xC8,0x00,0x06,0x24,
+0x1A,0x00,0x07,0x24,
+0x10,0x00,0xB0,0xAF,
+0x89,0x1B,0x00,0x0C,
+0x14,0x00,0xA2,0xAF,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x05,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x60,0x1B,0xA5,0x24,
+0x28,0x1C,0xA3,0x8C,
+0x68,0x3A,0xA6,0x94,
+0xF0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x01,0x00,0x02,0x3C,
+0x00,0xC0,0xC6,0x24,
+0x25,0x18,0x62,0x00,
+0xFF,0x00,0x90,0x30,
+0x28,0x1C,0xA3,0xAC,
+0x57,0x37,0x00,0x0C,
+0xFF,0xFF,0xC4,0x30,
+0x02,0x80,0x04,0x3C,
+0xD0,0x55,0x84,0x24,
+0x04,0x00,0x05,0x24,
+0xA4,0x00,0x06,0x24,
+0x10,0x00,0x07,0x24,
+0x10,0x00,0xB0,0xAF,
+0x89,0x1B,0x00,0x0C,
+0x14,0x00,0xA0,0xAF,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x08,0x00,0x82,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0xFB,0x50,0x00,0x0C,
+0x74,0x00,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0xA4,0x27,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA2,0x97,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0xFB,0x50,0x00,0x0C,
+0x10,0x00,0xA5,0xA7,
+0x21,0x20,0x40,0x00,
+0x10,0x00,0xA5,0x27,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x0A,0x00,0x82,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x16,0x51,0x00,0x0C,
+0x74,0x00,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0xA4,0x27,
+0xCE,0x53,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA2,0x97,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x05,0xA2,
+0x01,0x00,0x06,0xA2,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x88,0xC0,0x00,
+0x02,0x00,0x84,0x24,
+0x30,0x00,0xB2,0x8F,
+0x0D,0x00,0xC0,0x14,
+0x21,0x28,0xE0,0x00,
+0x00,0x00,0x43,0x8E,
+0x21,0x10,0x11,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x63,0x24,
+0x00,0x00,0x43,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x00,0x42,0x24,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xCE,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0x8E,
+0x21,0x10,0x11,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x63,0x24,
+0x00,0x00,0x43,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x00,0x42,0x24,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0xA0,0x00,
+0x18,0x00,0xB2,0xAF,
+0x21,0x28,0xC0,0x00,
+0x21,0x90,0xE0,0x00,
+0x21,0x30,0x00,0x02,
+0x1C,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0xCE,0x53,0x00,0x0C,
+0x21,0x88,0x80,0x00,
+0x00,0x00,0x43,0x8E,
+0x21,0x10,0x30,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x21,0x18,0x70,0x00,
+0x00,0x00,0x43,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x7F,0x00,0x84,0x30,
+0x6D,0x00,0x82,0x2C,
+0x0A,0x00,0x40,0x10,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0xAC,0xF3,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x0B,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x0A,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x09,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x07,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x06,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x03,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x05,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x04,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x02,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x7F,0x00,0x84,0x30,
+0x0C,0x00,0x82,0x2C,
+0x0A,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0x60,0xF5,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x6C,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x60,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x48,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x30,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x24,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x18,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x12,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x0C,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x16,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x0B,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x04,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x02,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xC8,0xFF,0xBD,0x27,
+0x24,0x00,0xB5,0xAF,
+0x02,0x80,0x15,0x3C,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xB8,0x80,0x00,
+0x21,0xA0,0x00,0x00,
+0x21,0x98,0x00,0x00,
+0x60,0x1B,0xB6,0x26,
+0x60,0x1B,0xA2,0x26,
+0x21,0x10,0x62,0x02,
+0xFB,0x1B,0x51,0x90,
+0xFE,0x00,0x03,0x24,
+0x1E,0x00,0x23,0x12,
+0xFF,0x00,0x02,0x24,
+0x21,0x00,0x22,0x12,
+0x21,0x10,0x80,0x02,
+0x91,0x51,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x21,0x88,0x40,0x00,
+0x21,0x80,0x00,0x00,
+0x21,0x90,0xC0,0x02,
+0x21,0x10,0x12,0x02,
+0xEE,0x1B,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x82,0x24,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x42,0x2C,
+0x05,0x00,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0x91,0x51,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x51,0x10,
+0x01,0x00,0x03,0x24,
+0x0D,0x00,0x02,0x2A,
+0xF3,0xFF,0x40,0x14,
+0x21,0x10,0x12,0x02,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x14,0x00,0x62,0x10,
+0xFF,0x00,0x22,0x32,
+0x21,0x10,0xF4,0x02,
+0x00,0x00,0x51,0xA0,
+0x01,0x00,0x94,0x26,
+0x01,0x00,0x73,0x26,
+0x0D,0x00,0x62,0x2A,
+0xDB,0xFF,0x40,0x14,
+0x60,0x1B,0xA2,0x26,
+0x21,0x10,0x80,0x02,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xF0,0x51,0x00,0x08,
+0x80,0x00,0x51,0x34,
+0xD0,0xFF,0xBD,0x27,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x21,0x88,0x80,0x00,
+0x21,0x80,0xA0,0x00,
+0x0D,0x00,0x06,0x24,
+0x21,0x28,0x00,0x00,
+0x28,0x00,0xBF,0xAF,
+0xBD,0x53,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xC1,0x51,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x02,0xAE,
+0x21,0x20,0x20,0x02,
+0x10,0x00,0xA5,0x27,
+0xCE,0x53,0x00,0x0C,
+0x21,0x30,0x40,0x00,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x21,0x28,0x00,0x00,
+0x21,0x10,0x85,0x00,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x60,0x10,
+0x0D,0x00,0xA2,0x2C,
+0xFA,0xFF,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xFF,0xFF,0xA5,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x00,0x00,0x82,0x94,
+0x21,0x30,0x80,0x00,
+0x10,0x00,0x85,0x24,
+0x42,0x1A,0x02,0x00,
+0xC2,0x11,0x02,0x00,
+0x02,0x00,0x42,0x30,
+0x01,0x00,0x63,0x30,
+0x25,0x18,0x43,0x00,
+0x01,0x00,0x04,0x24,
+0x07,0x00,0x64,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x10,
+0x0A,0x00,0xC5,0x24,
+0x02,0x00,0x02,0x24,
+0x02,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xC5,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x00,0x00,0x82,0x94,
+0x21,0x30,0x80,0x00,
+0x04,0x00,0x85,0x24,
+0x42,0x1A,0x02,0x00,
+0xC2,0x11,0x02,0x00,
+0x02,0x00,0x42,0x30,
+0x01,0x00,0x63,0x30,
+0x25,0x18,0x43,0x00,
+0x01,0x00,0x04,0x24,
+0x04,0x00,0x64,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xC5,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x0E,0x00,0xA3,0x2C,
+0x21,0x88,0xA0,0x00,
+0x0D,0x00,0x02,0x24,
+0x0A,0x88,0x43,0x00,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x21,0x98,0x80,0x00,
+0x21,0x90,0x00,0x00,
+0x15,0x00,0x20,0x12,
+0x21,0x80,0x00,0x00,
+0x5D,0x52,0x00,0x08,
+0x01,0x00,0x14,0x24,
+0x2B,0x10,0x11,0x02,
+0x11,0x00,0x40,0x10,
+0x21,0x10,0x40,0x02,
+0x21,0x18,0x70,0x02,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0xF6,0xFF,0x41,0x04,
+0x01,0x00,0x10,0x26,
+0x61,0x51,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x04,0x10,0x54,0x00,
+0x25,0x90,0x42,0x02,
+0x2B,0x10,0x11,0x02,
+0xF3,0xFF,0x40,0x14,
+0x21,0x18,0x70,0x02,
+0x21,0x10,0x40,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x0E,0x00,0xA3,0x2C,
+0x21,0x88,0xA0,0x00,
+0x0D,0x00,0x02,0x24,
+0x0A,0x88,0x43,0x00,
+0x20,0x00,0xB4,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x21,0xA0,0x80,0x00,
+0x21,0x90,0x00,0x00,
+0x0A,0x00,0x20,0x12,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x13,0x24,
+0x21,0x10,0x90,0x02,
+0x00,0x00,0x44,0x90,
+0x61,0x51,0x00,0x0C,
+0x01,0x00,0x10,0x26,
+0x04,0x10,0x53,0x00,
+0x2B,0x18,0x11,0x02,
+0xF9,0xFF,0x60,0x14,
+0x25,0x90,0x42,0x02,
+0x21,0x10,0x40,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0xFF,0xFF,0x02,0x24,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x30,0xA0,0x00,
+0x1B,0x00,0x82,0x10,
+0x20,0x00,0x10,0x24,
+0x20,0x00,0x82,0x28,
+0x06,0x00,0x40,0x14,
+0x40,0x18,0x04,0x00,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x21,0x18,0x64,0x00,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x00,0x19,0x03,0x00,
+0x60,0x1B,0x42,0x24,
+0x47,0x39,0x84,0x24,
+0x21,0x20,0x64,0x00,
+0x21,0x18,0x62,0x00,
+0x01,0x00,0x02,0x24,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0xE6,0x1D,0x62,0xA0,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0xF0,0x00,0x47,0x24,
+0x05,0x00,0x10,0x24,
+0xD6,0x1E,0x43,0x24,
+0xC3,0x52,0x00,0x08,
+0xF0,0x00,0x05,0x24,
+0x01,0x00,0x10,0x26,
+0x20,0x00,0x02,0x2E,
+0x30,0x00,0xA5,0x24,
+0xDE,0xFF,0x40,0x10,
+0x30,0x00,0xE7,0x24,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x40,0x14,
+0x30,0x00,0x63,0x24,
+0x02,0x80,0x04,0x3C,
+0x47,0x39,0x84,0x24,
+0x01,0x00,0x02,0x24,
+0x21,0x20,0xA4,0x00,
+0xE6,0x1D,0xE2,0xA0,
+0x21,0x28,0xC0,0x00,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xB3,0x52,0x00,0x08,
+0x21,0x10,0x00,0x02,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x30,0x00,0xB2,0x8F,
+0x21,0x88,0x80,0x00,
+0x21,0x20,0xA0,0x00,
+0x21,0x28,0x20,0x02,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x96,0x52,0x00,0x0C,
+0xFF,0xFF,0xF0,0x30,
+0x20,0x00,0x03,0x24,
+0xFF,0x00,0x44,0x30,
+0x21,0x28,0x00,0x02,
+0x21,0x30,0x20,0x02,
+0x07,0x00,0x43,0x10,
+0x21,0x38,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x11,0x27,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xA8,0x80,0x00,
+0x60,0x1B,0x54,0x24,
+0x47,0x39,0x73,0x24,
+0x05,0x00,0x11,0x24,
+0x01,0x00,0x12,0x24,
+0xF0,0x00,0x10,0x24,
+0x03,0x53,0x00,0x08,
+0x28,0x00,0xBF,0xAF,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2A,
+0x0E,0x00,0x40,0x10,
+0x21,0x10,0x20,0x02,
+0x21,0x10,0x14,0x02,
+0xE6,0x1D,0x43,0x90,
+0x21,0x20,0x13,0x02,
+0x21,0x28,0xA0,0x02,
+0x06,0x00,0x06,0x24,
+0xF6,0xFF,0x72,0x14,
+0x30,0x00,0x10,0x26,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x01,0x00,0x31,0x26,
+0xFF,0xFF,0x31,0x26,
+0x21,0x10,0x20,0x02,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x98,0x80,0x00,
+0x60,0x1B,0x56,0x24,
+0x47,0x39,0x75,0x24,
+0x21,0x88,0x00,0x00,
+0x01,0x00,0x14,0x24,
+0x21,0x80,0x00,0x00,
+0x2C,0x00,0xBF,0xAF,
+0x2F,0x53,0x00,0x08,
+0x18,0x00,0xB2,0xAF,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2A,
+0x1E,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x90,0x16,0x02,
+0xE6,0x1D,0x42,0x92,
+0x21,0x20,0x15,0x02,
+0x21,0x28,0x60,0x02,
+0x06,0x00,0x06,0x24,
+0xF6,0xFF,0x54,0x14,
+0x30,0x00,0x10,0x26,
+0xF7,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x01,0x00,0x31,0x26,
+0xFF,0xFF,0x31,0x26,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0xFF,0x00,0x24,0x32,
+0xE6,0x1D,0x40,0xA2,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x78,0xE3,0xC6,0x24,
+0x68,0xE3,0xE7,0x24,
+0x21,0x28,0x00,0x00,
+0x11,0x27,0x00,0x08,
+0x30,0x00,0xBD,0x27,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x60,0x1B,0x52,0x24,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x21,0x80,0x00,0x00,
+0x02,0x80,0x1E,0x3C,
+0x02,0x80,0x17,0x3C,
+0x02,0x80,0x16,0x3C,
+0x01,0x00,0x13,0x24,
+0xFF,0xF7,0x15,0x24,
+0xFF,0xEF,0x14,0x24,
+0x21,0x88,0x40,0x02,
+0xE6,0x1D,0x22,0x92,
+0xC0,0x50,0x10,0x00,
+0x6A,0x5F,0xC7,0x93,
+0x43,0x00,0x53,0x10,
+0x21,0x30,0x52,0x01,
+0xD4,0x23,0xC2,0x8C,
+0xBF,0xFF,0x03,0x24,
+0x24,0x28,0x43,0x00,
+0x80,0x07,0xA3,0x34,
+0x24,0x10,0x75,0x00,
+0x33,0x00,0xF3,0x10,
+0x24,0x10,0x54,0x00,
+0xD4,0x23,0xC2,0xAC,
+0x21,0x50,0x52,0x01,
+0xD4,0x23,0x48,0x8D,
+0xFD,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x40,0x02,0x01,
+0xFB,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x40,0x02,0x01,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x40,0x02,0x01,
+0xFF,0xFD,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xD8,0x23,0x49,0x8D,
+0x24,0x40,0x02,0x01,
+0xFF,0xFB,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0xFF,0x03,0x3C,
+0x24,0x40,0x02,0x01,
+0xFF,0x7F,0x63,0x34,
+0xFF,0xE7,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x48,0x23,0x01,
+0x1F,0x00,0x03,0x3C,
+0x24,0x40,0x02,0x01,
+0x25,0x48,0x23,0x01,
+0xFF,0x00,0x04,0x32,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x10,0x26,
+0x78,0xE3,0xE6,0x26,
+0x68,0xE3,0xC7,0x26,
+0xD8,0x23,0x49,0xAD,
+0x11,0x27,0x00,0x0C,
+0xD4,0x23,0x48,0xAD,
+0x20,0x00,0x02,0x2A,
+0xCF,0xFF,0x40,0x14,
+0x30,0x00,0x31,0x26,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x6B,0x5F,0x44,0x90,
+0x24,0x18,0x75,0x00,
+0x80,0x0F,0xA2,0x34,
+0x00,0x10,0x63,0x34,
+0xC8,0xFF,0x87,0x14,
+0x24,0x10,0x54,0x00,
+0x78,0x53,0x00,0x08,
+0xD4,0x23,0xC3,0xAC,
+0x70,0x53,0x00,0x08,
+0xE6,0x1D,0x20,0xA2,
+0x80,0x20,0x04,0x00,
+0x70,0x17,0x82,0x2C,
+0x04,0x00,0x40,0x14,
+0x70,0x17,0x03,0x24,
+0x21,0x4E,0x82,0x2C,
+0x20,0x4E,0x03,0x24,
+0x0B,0x18,0x82,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xC2,0x53,0x00,0x08,
+0xFF,0x00,0xA5,0x30,
+0x00,0x00,0x85,0xA0,
+0xFF,0xFF,0xC6,0x24,
+0x01,0x00,0x84,0x24,
+0xFC,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xAC,
+0xFF,0xFF,0xC6,0x24,
+0xFD,0xFF,0xC0,0x14,
+0x04,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x38,0x80,0x00,
+0x08,0x00,0xC0,0x10,
+0xFF,0xFF,0xC3,0x24,
+0xFF,0xFF,0x06,0x24,
+0x00,0x00,0xA2,0x90,
+0xFF,0xFF,0x63,0x24,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0xE2,0xA0,
+0xFB,0xFF,0x66,0x14,
+0x01,0x00,0xE7,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x2B,0x10,0xA4,0x00,
+0x0D,0x00,0x40,0x14,
+0xFF,0xFF,0x02,0x24,
+0xFF,0xFF,0xC6,0x24,
+0x08,0x00,0xC2,0x10,
+0x21,0x18,0x80,0x00,
+0xFF,0xFF,0x07,0x24,
+0x00,0x00,0xA2,0x90,
+0xFF,0xFF,0xC6,0x24,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x62,0xA0,
+0xFB,0xFF,0xC7,0x14,
+0x01,0x00,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x21,0x28,0xA6,0x00,
+0x21,0x18,0x86,0x00,
+0xFF,0xFF,0xC6,0x24,
+0xFA,0xFF,0xC2,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x07,0x24,
+0xFF,0xFF,0xA5,0x24,
+0x00,0x00,0xA2,0x90,
+0xFF,0xFF,0x63,0x24,
+0xFF,0xFF,0xC6,0x24,
+0xFB,0xFF,0xC7,0x14,
+0x00,0x00,0x62,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x0C,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0xA3,0x90,
+0x01,0x00,0x84,0x24,
+0x23,0x10,0x43,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x04,0x00,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xFF,0xFF,0xC6,0x24,
+0xF6,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xC0,0x00,
+0x0D,0x54,0x00,0x08,
+0x21,0x18,0x86,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x45,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x84,0x24,
+0xFA,0xFF,0x83,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x09,0x00,0xC0,0x10,
+0xFF,0xFF,0xC3,0x24,
+0xFF,0x00,0xA5,0x30,
+0xFF,0xFF,0x06,0x24,
+0x00,0x00,0x82,0x90,
+0xFF,0xFF,0x63,0x24,
+0x05,0x00,0x45,0x10,
+0x01,0x00,0x84,0x24,
+0xFB,0xFF,0x66,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0xFF,0xFF,0x82,0x24,
+0x21,0x38,0x00,0x00,
+0x1F,0x00,0xC0,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x40,0xFB,0x4B,0x24,
+0x00,0x00,0x87,0x90,
+0x00,0x00,0xA3,0x90,
+0xFF,0xFF,0xC6,0x24,
+0x01,0x00,0x84,0x24,
+0x21,0x10,0xEB,0x00,
+0x16,0x00,0xE0,0x10,
+0x01,0x00,0xA5,0x24,
+0x14,0x00,0x60,0x10,
+0x21,0x48,0x6B,0x00,
+0x10,0x00,0xE3,0x10,
+0x20,0x00,0xE8,0x24,
+0x00,0x00,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x02,0x00,0x40,0x10,
+0x20,0x00,0x6A,0x24,
+0xFF,0x00,0x07,0x31,
+0x00,0x00,0x22,0x91,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x02,0x00,0x40,0x10,
+0xFF,0x00,0xE7,0x30,
+0xFF,0x00,0x43,0x31,
+0xFF,0x00,0x63,0x30,
+0x03,0x00,0xE3,0x14,
+0x00,0x00,0x00,0x00,
+0xE5,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0xE3,0x00,
+0x21,0x18,0x80,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x21,0x38,0x80,0x00,
+0xFF,0xFF,0x03,0x24,
+0xFF,0xFF,0xC6,0x24,
+0x06,0x00,0xC3,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0xF9,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xE0,0x00,
+0x00,0x00,0x82,0x80,
+0x5C,0x54,0x00,0x08,
+0x21,0x18,0x80,0x00,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x82,0x80,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x12,0x00,0xC0,0x10,
+0x21,0x18,0x80,0x00,
+0x00,0x00,0x82,0x80,
+0x6D,0x54,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x82,0x80,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0x05,0x00,0x40,0x10,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0xC6,0x24,
+0xF9,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x80,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x00,0x00,0x83,0x90,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0x84,0x24,
+0x23,0x10,0x62,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x00,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xF7,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x00,0x00,
+0x0B,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x83,0x90,
+0xFF,0xFF,0xC6,0x24,
+0x23,0x10,0x62,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x00,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xF5,0xFF,0x60,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x83,0x80,
+0x00,0x2E,0x05,0x00,
+0x21,0x10,0x80,0x00,
+0x9E,0x54,0x00,0x08,
+0x03,0x2E,0x05,0x00,
+0x07,0x00,0x60,0x10,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x43,0x80,
+0x00,0x00,0x00,0x00,
+0xFB,0xFF,0x65,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x00,0x00,0x82,0x80,
+0xAA,0x54,0x00,0x08,
+0x21,0x18,0x80,0x00,
+0x01,0x00,0x63,0x24,
+0x00,0x00,0x62,0x80,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x23,0x10,0x64,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0xA0,0x00,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x21,0x88,0x80,0x00,
+0xA4,0x54,0x00,0x0C,
+0x00,0x86,0x10,0x00,
+0x21,0x18,0x51,0x00,
+0x03,0x86,0x10,0x00,
+0x00,0x00,0x62,0x80,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x50,0x10,
+0x21,0x10,0x60,0x00,
+0xFF,0xFF,0x63,0x24,
+0x2B,0x10,0x71,0x00,
+0xF9,0xFF,0x40,0x10,
+0x21,0x10,0x00,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x21,0x30,0x80,0x00,
+0x0D,0x00,0xA0,0x10,
+0xFF,0xFF,0xA3,0x24,
+0x00,0x00,0x82,0x80,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x05,0x24,
+0xFF,0xFF,0x63,0x24,
+0x05,0x00,0x65,0x10,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0xC2,0x80,
+0x00,0x00,0x00,0x00,
+0xFA,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0xC4,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x40,0x10,
+0x21,0x40,0x00,0x00,
+0x00,0x00,0xA9,0x80,
+0x00,0x00,0x00,0x00,
+0x17,0x00,0x20,0x11,
+0x21,0x30,0xA0,0x00,
+0x00,0x3E,0x02,0x00,
+0x03,0x3E,0x07,0x00,
+0x21,0x18,0x20,0x01,
+0x15,0x00,0xE3,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x1E,0x02,0x00,
+0x03,0x1E,0x03,0x00,
+0xF8,0xFF,0x60,0x14,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xEB,0xFF,0x40,0x14,
+0x01,0x00,0x08,0x25,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x01,
+0x00,0x00,0xA2,0x90,
+0xEF,0x54,0x00,0x08,
+0x00,0x16,0x02,0x00,
+0x00,0x00,0xC2,0x90,
+0xEF,0x54,0x00,0x08,
+0x00,0x16,0x02,0x00,
+0x00,0x00,0x87,0x90,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xE0,0x10,
+0x21,0x10,0x80,0x00,
+0x00,0x00,0xA4,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x1E,0x04,0x00,
+0x03,0x1E,0x03,0x00,
+0x09,0x00,0x60,0x10,
+0x21,0x30,0xA0,0x00,
+0x00,0x3E,0x07,0x00,
+0x03,0x3E,0x07,0x00,
+0x0B,0x00,0xE3,0x10,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0xC3,0x80,
+0x00,0x00,0x00,0x00,
+0xFB,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x47,0x90,
+0x00,0x00,0x00,0x00,
+0xF0,0xFF,0xE0,0x14,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x1D,0x00,0x80,0x10,
+0x21,0x88,0xA0,0x00,
+0xDB,0x54,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x21,0x80,0x02,0x02,
+0x00,0x00,0x02,0x82,
+0x21,0x28,0x20,0x02,
+0x21,0x20,0x00,0x02,
+0x22,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0xFF,0x54,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x40,0x10,
+0x21,0x18,0x40,0x00,
+0x00,0x00,0x42,0x80,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x5C,0xFC,0x43,0xAC,
+0x21,0x18,0x00,0x02,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x60,0xA0,
+0x30,0x55,0x00,0x08,
+0x01,0x00,0x63,0x24,
+0x02,0x80,0x02,0x3C,
+0x5C,0xFC,0x50,0x8C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x00,0x12,
+0x21,0x18,0x00,0x00,
+0xDB,0x54,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x21,0x80,0x02,0x02,
+0x00,0x00,0x02,0x82,
+0x21,0x28,0x20,0x02,
+0x21,0x20,0x00,0x02,
+0xE0,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x80,0x02,0x3C,
+0x5C,0xFC,0x40,0xAC,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x90,0x8C,
+0x21,0x90,0x80,0x00,
+0x21,0x88,0xA0,0x00,
+0x21,0x18,0x00,0x00,
+0x0F,0x00,0x00,0x12,
+0x21,0x20,0x00,0x02,
+0xDB,0x54,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x02,0x02,
+0x00,0x00,0x02,0x82,
+0x21,0x28,0x20,0x02,
+0x21,0x20,0x00,0x02,
+0x07,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0xFF,0x54,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x40,0x00,
+0x09,0x00,0x40,0x14,
+0x00,0x00,0x42,0xAE,
+0x21,0x18,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x42,0x80,
+0x00,0x00,0x00,0x00,
+0xF5,0xFF,0x40,0x10,
+0x01,0x00,0x64,0x24,
+0x00,0x00,0x60,0xA0,
+0x69,0x55,0x00,0x08,
+0x00,0x00,0x44,0xAE,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x21,0x88,0x80,0x00,
+0x21,0x20,0xA0,0x00,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xA4,0x54,0x00,0x0C,
+0x21,0x98,0xA0,0x00,
+0x21,0x90,0x40,0x00,
+0x08,0x00,0x40,0x16,
+0x21,0x10,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xA4,0x54,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x21,0x80,0x40,0x00,
+0x2A,0x10,0x52,0x00,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x02,
+0x21,0x30,0x40,0x02,
+0xF7,0x53,0x00,0x0C,
+0xFF,0xFF,0x10,0x26,
+0x0B,0x00,0x40,0x10,
+0x2A,0x18,0x12,0x02,
+0xF8,0xFF,0x60,0x10,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x85,0x55,0x00,0x08,
+0x21,0x10,0x20,0x02,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xFF,0xFF,0xF2,0x30,
+0xFF,0xFF,0xB0,0x30,
+0x2B,0x10,0x12,0x02,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x21,0x88,0x80,0x00,
+0x0B,0x00,0x40,0x14,
+0x21,0x98,0xC0,0x00,
+0xFF,0xFF,0x02,0x26,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x02,
+0x21,0x30,0x40,0x02,
+0xF7,0x53,0x00,0x0C,
+0xFF,0xFF,0x50,0x30,
+0x0B,0x00,0x40,0x10,
+0x2B,0x18,0x12,0x02,
+0xF7,0xFF,0x60,0x10,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x21,0x10,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0x87,0x90,
+0x00,0x00,0x00,0x00,
+0x27,0x00,0xE0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA6,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0xC0,0x10,
+0xDF,0xFF,0x02,0x24,
+0x24,0x18,0xC2,0x00,
+0x24,0x10,0xE2,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x1E,0x03,0x00,
+0x0A,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0xDF,0xFF,0x02,0x24,
+0x24,0x18,0xC2,0x00,
+0x24,0x10,0xE2,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0x43,0x00,
+0xEE,0x55,0x00,0x08,
+0xDF,0xFF,0x08,0x24,
+0x00,0x00,0xA6,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x06,0x01,
+0x00,0x16,0x02,0x00,
+0xF0,0xFF,0xC0,0x10,
+0x03,0x16,0x02,0x00,
+0xEF,0xFF,0x62,0x14,
+0xDF,0xFF,0x02,0x24,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x87,0x90,
+0x01,0x00,0xA5,0x24,
+0x24,0x10,0x07,0x01,
+0x00,0x1E,0x02,0x00,
+0xF2,0xFF,0xE0,0x14,
+0x03,0x1E,0x03,0x00,
+0x00,0x00,0xA6,0x90,
+0xDF,0xFF,0x02,0x24,
+0x24,0x18,0xC2,0x00,
+0x24,0x10,0xE2,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0x43,0x00,
+0xA8,0xFF,0xBD,0x27,
+0x44,0x00,0xB5,0xAF,
+0x40,0x00,0xB4,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x54,0x00,0xBF,0xAF,
+0x50,0x00,0xBE,0xAF,
+0x4C,0x00,0xB7,0xAF,
+0x48,0x00,0xB6,0xAF,
+0x3C,0x00,0xB3,0xAF,
+0x30,0x00,0xB0,0xAF,
+0x21,0x90,0xA0,0x00,
+0x00,0x00,0xA5,0x90,
+0x21,0xA0,0x80,0x00,
+0x21,0xA8,0xC0,0x00,
+0x00,0x26,0x05,0x00,
+0x03,0x26,0x04,0x00,
+0x11,0x00,0x80,0x10,
+0x21,0x88,0x80,0x02,
+0x25,0x00,0x02,0x24,
+0x29,0x00,0x82,0x10,
+0x0A,0x00,0x02,0x24,
+0x1B,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x1E,0x00,0x80,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x25,0xA2,
+0x01,0x00,0x31,0x26,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x05,0x00,
+0x03,0x26,0x04,0x00,
+0xF2,0xFF,0x80,0x14,
+0x25,0x00,0x02,0x24,
+0x02,0x00,0x80,0x12,
+0x23,0x10,0x34,0x02,
+0x00,0x00,0x20,0xA2,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0xE7,0xFF,0x80,0x16,
+0x00,0x00,0x00,0x00,
+0x4E,0x57,0x00,0x0C,
+0x0D,0x00,0x04,0x24,
+0x0A,0x00,0x04,0x24,
+0x4E,0x57,0x00,0x0C,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x05,0x00,
+0x20,0x56,0x00,0x08,
+0x03,0x26,0x04,0x00,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x73,0x00,0x02,0x24,
+0x00,0x1E,0x05,0x00,
+0x03,0x1E,0x03,0x00,
+0x2C,0x00,0x62,0x10,
+0x10,0x00,0xB3,0x27,
+0x23,0x00,0x02,0x24,
+0x21,0xF0,0x60,0x02,
+0x21,0x38,0x00,0x00,
+0x34,0x00,0x62,0x10,
+0x1C,0x00,0x04,0x24,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0x68,0x00,0x03,0x24,
+0x36,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0x39,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0xA2,0x34,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x78,0x00,0x03,0x24,
+0x3C,0x00,0x43,0x10,
+0x20,0x00,0xA6,0x30,
+0x00,0x1E,0x05,0x00,
+0x03,0x1E,0x03,0x00,
+0x64,0x00,0x02,0x24,
+0x49,0x00,0x62,0x10,
+0x40,0x00,0x02,0x24,
+0x81,0x00,0x62,0x10,
+0x21,0x00,0x02,0x24,
+0x92,0x00,0x62,0x10,
+0x63,0x00,0x02,0x24,
+0xA2,0x00,0x62,0x10,
+0x11,0x00,0xB3,0x27,
+0x10,0x00,0xA5,0xA3,
+0x21,0x80,0xC0,0x03,
+0x2B,0x10,0x13,0x02,
+0xB4,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x6C,0x00,0x80,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x02,0x92,
+0x01,0x00,0x10,0x26,
+0x00,0x00,0x22,0xA2,
+0x65,0x56,0x00,0x08,
+0x01,0x00,0x31,0x26,
+0x00,0x00,0xA2,0x8E,
+0x04,0x00,0xB5,0x26,
+0x21,0x80,0x40,0x00,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0xA6,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x63,0x00,0x80,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x22,0xA2,
+0x01,0x00,0x10,0x26,
+0x72,0x56,0x00,0x08,
+0x01,0x00,0x31,0x26,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x68,0x00,0x03,0x24,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0xCC,0xFF,0x43,0x14,
+0x01,0x00,0x07,0x24,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0xC9,0xFF,0x43,0x14,
+0x0C,0x00,0x04,0x24,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x78,0x00,0x03,0x24,
+0x20,0x00,0xA2,0x34,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0xC7,0xFF,0x43,0x14,
+0x04,0x00,0x04,0x24,
+0x20,0x00,0xA6,0x30,
+0x00,0x00,0xA5,0x8E,
+0x35,0x00,0xE0,0x14,
+0x04,0x00,0xB5,0x26,
+0xCD,0xFF,0x80,0x04,
+0x02,0x80,0x02,0x3C,
+0x2C,0xF6,0x42,0x24,
+0x00,0x00,0x47,0x8C,
+0x07,0x10,0x85,0x00,
+0x0F,0x00,0x42,0x30,
+0x21,0x10,0x47,0x00,
+0x00,0x00,0x43,0x90,
+0xFC,0xFF,0x84,0x24,
+0x25,0x18,0xC3,0x00,
+0x00,0x00,0x63,0xA2,
+0xF8,0xFF,0x81,0x04,
+0x01,0x00,0x73,0x26,
+0x65,0x56,0x00,0x08,
+0x21,0x80,0xC0,0x03,
+0x00,0x00,0xA2,0x8E,
+0x04,0x00,0xB5,0x26,
+0x28,0x00,0x40,0x04,
+0x21,0x28,0x40,0x00,
+0x21,0x80,0x60,0x02,
+0x02,0x80,0x02,0x3C,
+0x30,0xF6,0x42,0x24,
+0x00,0x00,0x46,0x8C,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xA6,0x00,
+0xC3,0x27,0x05,0x00,
+0x10,0x10,0x00,0x00,
+0x83,0x10,0x02,0x00,
+0x23,0x10,0x44,0x00,
+0x80,0x18,0x02,0x00,
+0x21,0x18,0x62,0x00,
+0x40,0x18,0x03,0x00,
+0x23,0x18,0xA3,0x00,
+0x30,0x00,0x63,0x24,
+0x00,0x00,0x63,0xA2,
+0x21,0x28,0x40,0x00,
+0xF3,0xFF,0x40,0x14,
+0x01,0x00,0x73,0x26,
+0xC5,0x56,0x00,0x08,
+0xFF,0xFF,0x63,0x26,
+0x00,0x00,0x65,0x80,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0xA0,
+0x00,0x00,0x05,0xA2,
+0xFF,0xFF,0x63,0x24,
+0x01,0x00,0x10,0x26,
+0x2B,0x10,0x03,0x02,
+0xF7,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x65,0x56,0x00,0x08,
+0x21,0x80,0xC0,0x03,
+0x58,0x00,0xC3,0x34,
+0x30,0x00,0x02,0x24,
+0x12,0x00,0xB3,0x27,
+0x10,0x00,0xA2,0xA3,
+0x96,0x56,0x00,0x08,
+0x11,0x00,0xA3,0xA3,
+0x2D,0x00,0x02,0x24,
+0x23,0x28,0x05,0x00,
+0x11,0x00,0xB3,0x27,
+0xA9,0x56,0x00,0x08,
+0x10,0x00,0xA2,0xA3,
+0x00,0x00,0x04,0x82,
+0x4E,0x57,0x00,0x0C,
+0x01,0x00,0x10,0x26,
+0x66,0x56,0x00,0x08,
+0x2B,0x10,0x13,0x02,
+0x00,0x00,0x04,0x82,
+0x4E,0x57,0x00,0x0C,
+0x01,0x00,0x10,0x26,
+0x72,0x56,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA3,0x8E,
+0x28,0x00,0xB0,0x27,
+0x2C,0x00,0xA4,0x27,
+0x2B,0x10,0x04,0x02,
+0x28,0x00,0xA3,0xAF,
+0x0B,0x00,0x40,0x10,
+0x04,0x00,0xB5,0x26,
+0x21,0xB8,0x80,0x00,
+0x02,0x80,0x16,0x3C,
+0x00,0x00,0x06,0x92,
+0x21,0x20,0x60,0x02,
+0x01,0x00,0x10,0x26,
+0x08,0x57,0x00,0x0C,
+0x20,0xF6,0xC5,0x26,
+0x2B,0x18,0x17,0x02,
+0xF9,0xFF,0x60,0x14,
+0x21,0x98,0x62,0x02,
+0x64,0x56,0x00,0x08,
+0xFF,0xFF,0x73,0x26,
+0x00,0x00,0xA2,0x8E,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x56,0x24,
+0x21,0x80,0x40,0x00,
+0x2B,0x10,0x56,0x00,
+0xF8,0xFF,0x40,0x10,
+0x04,0x00,0xB5,0x26,
+0x02,0x80,0x17,0x3C,
+0x00,0x00,0x06,0x82,
+0x21,0x20,0x60,0x02,
+0x01,0x00,0x10,0x26,
+0x08,0x57,0x00,0x0C,
+0x24,0xF6,0xE5,0x26,
+0x2B,0x18,0x16,0x02,
+0xF9,0xFF,0x60,0x14,
+0x21,0x98,0x62,0x02,
+0x64,0x56,0x00,0x08,
+0xFF,0xFF,0x73,0x26,
+0x00,0x00,0xA2,0x8E,
+0x04,0x00,0xB5,0x26,
+0x64,0x56,0x00,0x08,
+0x10,0x00,0xA2,0xA3,
+0xE8,0xFF,0xBD,0x27,
+0x20,0x00,0xA6,0xAF,
+0x20,0x00,0xA6,0x27,
+0x10,0x00,0xBF,0xAF,
+0x24,0x00,0xA7,0xAF,
+0xFF,0x55,0x00,0x0C,
+0x1C,0x00,0xA5,0xAF,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x20,0x00,0xA4,0xAF,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x24,0x00,0xA5,0xAF,
+0x28,0x00,0xA6,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x2C,0x00,0xA7,0xAF,
+0xF3,0x27,0x00,0x0C,
+0xA0,0x00,0x04,0x24,
+0x19,0x00,0x40,0x10,
+0x21,0x80,0x40,0x00,
+0x08,0x00,0x44,0x94,
+0x20,0x00,0xA5,0x8F,
+0x02,0x80,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x20,0x00,0x84,0x24,
+0xFF,0x55,0x00,0x0C,
+0x24,0x00,0xA6,0x27,
+0x01,0x00,0x42,0x24,
+0x13,0x00,0x03,0x24,
+0x81,0x00,0x44,0x2C,
+0x14,0x00,0x03,0xAE,
+0x0A,0x00,0x80,0x14,
+0x0C,0x00,0x02,0xAE,
+0xAB,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x88,0x88,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x88,0x88,0x63,0x34,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x34,0x57,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xCB,0x09,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x02,0x80,0x06,0x3C,
+0x60,0xFC,0xC5,0x8C,
+0x02,0x80,0x02,0x3C,
+0x40,0xFC,0x42,0x24,
+0x03,0x00,0xA3,0x30,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x64,0x80,
+0x01,0x00,0xA5,0x24,
+0x4E,0x57,0x00,0x0C,
+0x60,0xFC,0xC5,0xAC,
+0x10,0x00,0xBF,0x8F,
+0x08,0x00,0x04,0x24,
+0x4E,0x57,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x00,0x26,0x04,0x00,
+0x03,0x26,0x04,0x00,
+0x00,0x00,0x84,0x48,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x04,0x00,
+0x03,0x26,0x04,0x00,
+0xF7,0xFF,0x82,0x24,
+0x05,0x00,0x42,0x2C,
+0x06,0x00,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x20,0x00,0x02,0x24,
+0x03,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x44,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x42,0x2C,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0xD8,0x63,0x50,0xAC,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x25,0xB0,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0x01,0x80,0x02,0x3C,
+0x04,0x30,0x86,0x00,
+0xF1,0x02,0xA7,0x34,
+0xED,0x02,0xA4,0x34,
+0xD4,0x5D,0x42,0x24,
+0x18,0x03,0xA5,0x34,
+0x08,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xAC,
+0x00,0x00,0xE3,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0xE0,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0xFF,0x90,0x30,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x63,0x24,
+0x6A,0x37,0x62,0x94,
+0x10,0x00,0xA4,0x27,
+0x25,0x80,0x02,0x02,
+0x25,0xB0,0x02,0x3C,
+0x1E,0x03,0x42,0x34,
+0x00,0x00,0x50,0xA4,
+0xA0,0x40,0x00,0x0C,
+0x6A,0x37,0x70,0xA4,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0xFF,0x90,0x30,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x63,0x24,
+0x6A,0x37,0x62,0x94,
+0x27,0x80,0x10,0x00,
+0x10,0x00,0xA4,0x27,
+0x24,0x80,0x02,0x02,
+0x25,0xB0,0x02,0x3C,
+0x1E,0x03,0x42,0x34,
+0x00,0x00,0x50,0xA4,
+0xA0,0x40,0x00,0x0C,
+0x6A,0x37,0x70,0xA4,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x0A,0x00,0x67,0x34,
+0x00,0x00,0xE2,0x90,
+0xFF,0xFF,0xB2,0x30,
+0x21,0x98,0xC0,0x00,
+0xFF,0x00,0x91,0x30,
+0x20,0x00,0x40,0x12,
+0xFF,0x00,0x50,0x30,
+0x21,0xA0,0xE0,0x00,
+0x0C,0x00,0x77,0x34,
+0x0B,0x00,0x76,0x34,
+0x21,0xF0,0xE0,0x00,
+0xC0,0xFF,0x15,0x24,
+0x25,0x10,0x15,0x02,
+0xFF,0x00,0x50,0x30,
+0x00,0x00,0xD1,0xA2,
+0x00,0x00,0x90,0xA2,
+0x00,0x00,0x82,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x50,0x30,
+0xC0,0x00,0x03,0x32,
+0x07,0x00,0x60,0x10,
+0x21,0x20,0xC0,0x03,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x50,0x30,
+0xC0,0x00,0x03,0x32,
+0xFB,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE2,0x8E,
+0x04,0x00,0x23,0x26,
+0x64,0x00,0x04,0x24,
+0x00,0x00,0x62,0xAE,
+0x43,0x26,0x00,0x0C,
+0xFF,0x00,0x71,0x30,
+0xFC,0xFF,0x42,0x26,
+0xFF,0xFF,0x52,0x30,
+0xE7,0xFF,0x40,0x16,
+0x04,0x00,0x73,0x26,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x25,0xB0,0x06,0x3C,
+0x31,0x00,0xC2,0x34,
+0xFF,0xFF,0x84,0x30,
+0x00,0x00,0x44,0xA0,
+0x32,0x00,0xC7,0x34,
+0x00,0x00,0xE3,0x90,
+0xFC,0xFF,0x02,0x24,
+0x02,0x22,0x04,0x00,
+0x24,0x18,0x62,0x00,
+0x03,0x00,0x84,0x30,
+0x25,0x20,0x83,0x00,
+0x33,0x00,0xC6,0x34,
+0x72,0x00,0x02,0x24,
+0x00,0x00,0xE4,0xA0,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0xC3,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0x05,0x00,0x61,0x04,
+0x21,0x10,0x00,0x00,
+0x17,0x58,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x11,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC3,0x90,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0xF8,0xFF,0x61,0x04,
+0x64,0x00,0x44,0x2C,
+0x64,0x00,0x44,0x2C,
+0x07,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x30,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0xA3,0xA0,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0xA2,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x06,0x3C,
+0x31,0x00,0xC2,0x34,
+0xFF,0xFF,0x84,0x30,
+0x00,0x00,0x44,0xA0,
+0x32,0x00,0xC3,0x34,
+0x00,0x00,0x62,0x90,
+0x02,0x22,0x04,0x00,
+0x03,0x00,0x84,0x30,
+0x25,0x20,0x82,0x00,
+0x00,0x00,0x64,0xA0,
+0x33,0x00,0xC7,0x34,
+0xFF,0x00,0xA5,0x30,
+0x30,0x00,0xC6,0x34,
+0xF2,0xFF,0x03,0x24,
+0x00,0x00,0xC5,0xA0,
+0x00,0x00,0xE3,0xA0,
+0x00,0x00,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x00,0x40,0x04,
+0x21,0x20,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x3C,0x58,0x00,0x08,
+0x21,0x30,0xE0,0x00,
+0x0B,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC3,0x90,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0xF8,0xFF,0x60,0x04,
+0x64,0x00,0x82,0x2C,
+0x64,0x00,0x82,0x2C,
+0xF1,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xB0,0xAF,
+0xF8,0x02,0x45,0x34,
+0x25,0xB0,0x10,0x3C,
+0xFF,0x00,0x83,0x30,
+0x01,0x00,0x02,0x24,
+0x1C,0x00,0xBF,0xAF,
+0x03,0x00,0x06,0x36,
+0x0A,0x00,0x62,0x10,
+0x0A,0x00,0x04,0x24,
+0x00,0x00,0xA2,0x90,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0xA2,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x20,0x00,0x43,0x34,
+0x20,0x00,0x42,0x30,
+0x02,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC3,0xA0,
+0x43,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x04,0x36,
+0x00,0x00,0x82,0x90,
+0xFE,0xFF,0x03,0x24,
+0xF8,0x02,0x06,0x36,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA0,
+0x00,0x00,0xC3,0x90,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0x00,0x00,
+0x03,0x00,0x63,0x34,
+0x00,0x00,0xC3,0xA0,
+0xF3,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xFF,0x00,0x84,0x30,
+0x21,0x38,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0xA3,0x24,
+0x07,0x10,0xA4,0x00,
+0x01,0x00,0x42,0x30,
+0xFF,0x00,0x65,0x30,
+0x01,0x00,0xE6,0x24,
+0x02,0x00,0x40,0x14,
+0x04,0x00,0xA3,0x2C,
+0xFF,0x00,0xC7,0x30,
+0xF7,0xFF,0x60,0x14,
+0x21,0x10,0xE0,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x8C,0x30,
+0x21,0x48,0x00,0x00,
+0x21,0x38,0x00,0x00,
+0x40,0x10,0x07,0x00,
+0xFF,0x00,0x42,0x30,
+0x21,0x50,0x46,0x00,
+0x01,0x00,0xE3,0x24,
+0x07,0x10,0xEC,0x00,
+0x01,0x00,0x42,0x30,
+0xFF,0x00,0x67,0x30,
+0x21,0x58,0x25,0x01,
+0x01,0x00,0x24,0x25,
+0x09,0x00,0x40,0x14,
+0x04,0x00,0xE8,0x2C,
+0x00,0x00,0x63,0x91,
+0xFF,0x00,0x89,0x30,
+0x21,0x20,0x25,0x01,
+0x00,0x00,0x43,0xA1,
+0x00,0x00,0x83,0x90,
+0x01,0x00,0x22,0x25,
+0xFF,0x00,0x49,0x30,
+0x01,0x00,0x43,0xA1,
+0xED,0xFF,0x00,0x15,
+0x40,0x10,0x07,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x01,0x00,0x12,0x24,
+0x21,0x80,0x00,0x00,
+0xB9,0x58,0x00,0x08,
+0xFF,0x00,0x11,0x24,
+0xF3,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x40,0x10,
+0x00,0x02,0x03,0x2E,
+0x0F,0x00,0x60,0x10,
+0x21,0x10,0x00,0x02,
+0x10,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x51,0x10,
+0x0F,0x00,0x44,0x30,
+0x77,0x58,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x50,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x50,0x30,
+0x21,0x20,0x00,0x02,
+0xEE,0xFF,0x40,0x16,
+0x10,0x00,0xA5,0x27,
+0x21,0x10,0x00,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xB8,0xFF,0xBD,0x27,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x21,0x98,0xA0,0x00,
+0xFF,0x00,0x96,0x30,
+0x01,0x00,0x10,0x24,
+0x01,0x00,0x17,0x24,
+0x21,0xA0,0x00,0x00,
+0x21,0x88,0x00,0x00,
+0x21,0xA8,0x00,0x00,
+0x04,0x00,0xA0,0x10,
+0x21,0x18,0x00,0x00,
+0x10,0x00,0xC2,0x2E,
+0x0E,0x00,0x40,0x14,
+0x21,0x20,0xA0,0x00,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x08,0x00,0x06,0x24,
+0xBD,0x53,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x18,0x00,0xA4,0x27,
+0xFF,0x00,0x05,0x24,
+0xBD,0x53,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x48,0x58,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xF8,0x58,0x00,0x08,
+0x10,0x00,0xBE,0x27,
+0x1C,0x00,0x40,0x14,
+0x21,0x20,0xA0,0x02,
+0x37,0x00,0xE0,0x12,
+0x00,0x02,0x22,0x2E,
+0x35,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x32,
+0xF8,0xFF,0x40,0x10,
+0x20,0x00,0x02,0x32,
+0x21,0x20,0x20,0x02,
+0xF3,0x57,0x00,0x0C,
+0x10,0x00,0xA5,0x27,
+0x2D,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x10,0x00,0xB0,0x93,
+0x00,0x00,0x00,0x00,
+0x29,0x00,0x02,0x12,
+0x0F,0x00,0x15,0x32,
+0x77,0x58,0x00,0x0C,
+0x21,0x20,0xA0,0x02,
+0x02,0x81,0x10,0x00,
+0x10,0x00,0x16,0x12,
+0x21,0xA0,0x40,0x00,
+0x40,0x10,0x14,0x00,
+0x21,0x10,0x51,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x51,0x30,
+0xF4,0x58,0x00,0x08,
+0x01,0x00,0x10,0x24,
+0x18,0x00,0xA5,0x27,
+0x86,0x58,0x00,0x0C,
+0x21,0x30,0x60,0x02,
+0x40,0x10,0x14,0x00,
+0x21,0x10,0x51,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x51,0x30,
+0xF4,0x58,0x00,0x08,
+0x01,0x00,0x10,0x24,
+0x40,0x90,0x02,0x00,
+0x10,0x00,0x40,0x1A,
+0x21,0x80,0x00,0x00,
+0x21,0x20,0x30,0x02,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0xF3,0x57,0x00,0x0C,
+0x10,0x00,0xA5,0x27,
+0x01,0x00,0x03,0x26,
+0x21,0x20,0xD0,0x03,
+0xFF,0x00,0x70,0x30,
+0x04,0x00,0x40,0x10,
+0x2A,0x18,0x12,0x02,
+0x10,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x82,0xA0,
+0xF3,0xFF,0x60,0x14,
+0x21,0x20,0x30,0x02,
+0xF4,0x58,0x00,0x08,
+0x20,0x00,0x10,0x24,
+0x48,0x58,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x63,0x92,
+0xFF,0x00,0x02,0x24,
+0x0F,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x01,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xF0,0xFF,0x43,0x14,
+0x01,0x00,0x03,0x24,
+0x02,0x00,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0xEB,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0x43,0x14,
+0x01,0x00,0x03,0x24,
+0x04,0x00,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0xE3,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xDF,0xFF,0x43,0x14,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x67,0x92,
+0x00,0x00,0x00,0x00,
+0xDC,0xFF,0xE2,0x14,
+0x01,0x00,0x03,0x24,
+0x07,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x7F,0xFF,0x47,0x10,
+0x21,0x18,0x00,0x00,
+0x33,0x59,0x00,0x08,
+0x01,0x00,0x03,0x24,
+0xC0,0xFF,0xBD,0x27,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x21,0xF0,0xC0,0x00,
+0xFF,0x00,0xB6,0x30,
+0xFF,0xFF,0x95,0x30,
+0xFF,0x00,0x05,0x24,
+0x10,0x00,0xA4,0x27,
+0x08,0x00,0x06,0x24,
+0x34,0x00,0xB7,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xBD,0x53,0x00,0x0C,
+0x0F,0x00,0x17,0x24,
+0x21,0x98,0x00,0x00,
+0x40,0x10,0x13,0x00,
+0xFF,0x00,0x52,0x30,
+0x07,0x10,0x76,0x02,
+0x01,0x00,0x42,0x30,
+0x21,0xA0,0x5E,0x02,
+0x21,0x88,0xA0,0x02,
+0x21,0x20,0xA0,0x02,
+0x13,0x00,0x40,0x10,
+0x01,0x00,0xA3,0x26,
+0x01,0x00,0x62,0x26,
+0xFF,0x00,0x53,0x30,
+0x04,0x00,0x63,0x2E,
+0xF4,0xFF,0x60,0x14,
+0x40,0x10,0x13,0x00,
+0x21,0x10,0xE0,0x02,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x85,0x92,
+0xFF,0xFF,0x75,0x30,
+0x20,0x58,0x00,0x0C,
+0x21,0x80,0xA0,0x02,
+0x01,0x00,0x85,0x92,
+0x21,0x20,0xA0,0x02,
+0x01,0x00,0xA2,0x26,
+0x20,0x58,0x00,0x0C,
+0xFF,0xFF,0x55,0x30,
+0x10,0x00,0xA3,0x27,
+0x21,0x90,0x72,0x00,
+0x21,0x20,0x20,0x02,
+0xF3,0x57,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x21,0x20,0x00,0x02,
+0xF3,0x57,0x00,0x0C,
+0x01,0x00,0x45,0x26,
+0x00,0x00,0x84,0x92,
+0x00,0x00,0x42,0x92,
+0x01,0x00,0x03,0x24,
+0x04,0x18,0x63,0x02,
+0x03,0x00,0x82,0x10,
+0x27,0x30,0x03,0x00,
+0x7B,0x59,0x00,0x08,
+0x24,0xB8,0xD7,0x00,
+0x01,0x00,0x83,0x92,
+0x01,0x00,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0xD2,0xFF,0x62,0x10,
+0x01,0x00,0x62,0x26,
+0x7C,0x59,0x00,0x08,
+0x24,0xB8,0xD7,0x00,
+0x98,0xFF,0xBD,0x27,
+0x50,0x00,0xB4,0xAF,
+0xFF,0x00,0x94,0x30,
+0x01,0x00,0x04,0x24,
+0x64,0x00,0xBF,0xAF,
+0x60,0x00,0xBE,0xAF,
+0x5C,0x00,0xB7,0xAF,
+0x58,0x00,0xB6,0xAF,
+0x4C,0x00,0xB3,0xAF,
+0x48,0x00,0xB2,0xAF,
+0x44,0x00,0xB1,0xAF,
+0x21,0x98,0xC0,0x00,
+0xFF,0x00,0xB1,0x30,
+0x54,0x00,0xB5,0xAF,
+0x48,0x58,0x00,0x0C,
+0x40,0x00,0xB0,0xAF,
+0xA0,0x58,0x00,0x0C,
+0x01,0x00,0x16,0x24,
+0x21,0x18,0x40,0x00,
+0xFF,0x01,0x42,0x2C,
+0x01,0x00,0x17,0x24,
+0x01,0x00,0x1E,0x24,
+0x21,0x90,0x00,0x00,
+0x0E,0x00,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x64,0x00,0xBF,0x8F,
+0x60,0x00,0xBE,0x8F,
+0x5C,0x00,0xB7,0x8F,
+0x58,0x00,0xB6,0x8F,
+0x54,0x00,0xB5,0x8F,
+0x50,0x00,0xB4,0x8F,
+0x4C,0x00,0xB3,0x8F,
+0x48,0x00,0xB2,0x8F,
+0x44,0x00,0xB1,0x8F,
+0x40,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x68,0x00,0xBD,0x27,
+0xFF,0x01,0x02,0x24,
+0x23,0x10,0x43,0x00,
+0x1A,0x00,0xA4,0x27,
+0xFF,0x00,0x05,0x24,
+0x08,0x00,0x06,0x24,
+0xFF,0xFF,0x50,0x30,
+0x18,0x00,0xB4,0xA3,
+0xBD,0x53,0x00,0x0C,
+0x19,0x00,0xB1,0xA3,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x02,
+0x86,0x58,0x00,0x0C,
+0x1A,0x00,0xA6,0x27,
+0x19,0x00,0xA4,0x93,
+0x77,0x58,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0xA8,0x40,0x00,
+0xFF,0xFF,0x42,0x30,
+0x2B,0x10,0x02,0x02,
+0xDF,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x09,0x00,0xC2,0x12,
+0x20,0x00,0x02,0x24,
+0x22,0x00,0xC2,0x12,
+0x00,0x00,0x00,0x00,
+0x3B,0x00,0xE0,0x12,
+0x00,0x02,0x42,0x2E,
+0x39,0x00,0x40,0x10,
+0x01,0x00,0x02,0x24,
+0xF9,0xFF,0xC2,0x16,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x40,0x02,
+0x10,0x00,0xA5,0x27,
+0xF3,0x57,0x00,0x0C,
+0x01,0x00,0x13,0x24,
+0x41,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x10,0x00,0xA5,0x93,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xA4,0x30,
+0x3C,0x00,0x82,0x10,
+0x0F,0x00,0xA3,0x30,
+0x02,0x11,0x04,0x00,
+0x21,0x20,0x60,0x00,
+0x29,0x00,0xA3,0xA3,
+0x28,0x00,0xA2,0xA3,
+0x77,0x58,0x00,0x0C,
+0x11,0x00,0xA5,0xA3,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA3,0x93,
+0x18,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x5F,0x00,0x62,0x10,
+0x40,0x10,0x10,0x00,
+0x21,0x10,0x52,0x00,
+0x01,0x00,0x42,0x24,
+0xED,0x59,0x00,0x08,
+0xFF,0xFF,0x52,0x30,
+0x19,0x00,0xA5,0x93,
+0x01,0x00,0x44,0x26,
+0xFF,0xFF,0x84,0x30,
+0x5E,0x59,0x00,0x0C,
+0x1A,0x00,0xA6,0x27,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x43,0x30,
+0x0F,0x00,0x02,0x24,
+0x12,0x00,0x62,0x10,
+0x40,0x10,0x15,0x00,
+0x21,0x10,0x52,0x00,
+0x01,0x00,0x42,0x24,
+0x21,0x20,0xA0,0x00,
+0xFF,0xFF,0x52,0x30,
+0x18,0x00,0xB4,0xA3,
+0x77,0x58,0x00,0x0C,
+0x19,0x00,0xA5,0xA3,
+0x21,0xA8,0x40,0x00,
+0x02,0x80,0x03,0x3C,
+0xD4,0xE6,0x62,0x8C,
+0x02,0x80,0x04,0x3C,
+0x01,0x00,0x16,0x24,
+0x01,0x00,0x42,0x24,
+0x04,0x00,0x43,0x28,
+0xC6,0xFF,0x60,0x14,
+0xD4,0xE6,0x82,0xAC,
+0x21,0xF0,0x00,0x00,
+0x48,0x58,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x21,0x20,0xC0,0x03,
+0x64,0x00,0xBF,0x8F,
+0x60,0x00,0xBE,0x8F,
+0x5C,0x00,0xB7,0x8F,
+0x58,0x00,0xB6,0x8F,
+0x54,0x00,0xB5,0x8F,
+0x50,0x00,0xB4,0x8F,
+0x4C,0x00,0xB3,0x8F,
+0x48,0x00,0xB2,0x8F,
+0x44,0x00,0xB1,0x8F,
+0x40,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x68,0x00,0xBD,0x27,
+0xA0,0x58,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFF,0x01,0x03,0x24,
+0x23,0x18,0x62,0x00,
+0xFF,0xFF,0x70,0x30,
+0xFF,0xFF,0xA2,0x32,
+0x2B,0x10,0x02,0x02,
+0xE7,0xFF,0x40,0x14,
+0x21,0x20,0x40,0x02,
+0x18,0x00,0xB0,0x93,
+0x19,0x00,0xA2,0x93,
+0x00,0x81,0x10,0x00,
+0x25,0x80,0x02,0x02,
+0xFF,0x00,0x10,0x32,
+0x20,0x58,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x21,0x20,0x40,0x02,
+0xF3,0x57,0x00,0x0C,
+0x11,0x00,0xA5,0x27,
+0x11,0x00,0xA3,0x93,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x64,0x30,
+0x9D,0xFF,0x90,0x10,
+0x20,0x00,0x16,0x24,
+0xFF,0x00,0x02,0x24,
+0xCD,0xFF,0x82,0x10,
+0x0F,0x00,0x63,0x30,
+0x02,0x11,0x04,0x00,
+0x21,0x20,0x60,0x00,
+0x29,0x00,0xA3,0xA3,
+0x77,0x58,0x00,0x0C,
+0x28,0x00,0xA2,0xA3,
+0x38,0x00,0xA4,0x27,
+0xFF,0x00,0x05,0x24,
+0x08,0x00,0x06,0x24,
+0xBD,0x53,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA4,0x93,
+0xC3,0x58,0x00,0x0C,
+0x38,0x00,0xA5,0x27,
+0x1F,0x00,0x40,0x14,
+0x01,0x00,0x44,0x26,
+0x40,0x10,0x10,0x00,
+0x21,0x10,0x52,0x00,
+0x01,0x00,0x42,0x24,
+0x20,0x5A,0x00,0x08,
+0xFF,0xFF,0x52,0x30,
+0x40,0x88,0x10,0x00,
+0x27,0x00,0x20,0x1A,
+0x21,0x80,0x00,0x00,
+0xFF,0x00,0x16,0x24,
+0x21,0x20,0x50,0x02,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0xF3,0x57,0x00,0x0C,
+0x10,0x00,0xA5,0x27,
+0x01,0x00,0x03,0x26,
+0xFF,0x00,0x70,0x30,
+0x05,0x00,0x40,0x10,
+0x2A,0x18,0x11,0x02,
+0x10,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x56,0x00,
+0x0B,0x98,0x02,0x00,
+0xF3,0xFF,0x60,0x14,
+0x21,0x20,0x50,0x02,
+0x15,0x00,0x60,0x16,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x52,0x30,
+0xED,0x59,0x00,0x08,
+0x01,0x00,0x16,0x24,
+0x29,0x00,0xA5,0x93,
+0xFF,0xFF,0x84,0x30,
+0x5E,0x59,0x00,0x0C,
+0x38,0x00,0xA6,0x27,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x43,0x30,
+0x0F,0x00,0x02,0x24,
+0xDB,0xFF,0x62,0x10,
+0x40,0x10,0x10,0x00,
+0x28,0x00,0xA4,0x93,
+0xAD,0x59,0x00,0x0C,
+0x38,0x00,0xA6,0x27,
+0xA0,0x58,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x20,0x5A,0x00,0x08,
+0x21,0x90,0x40,0x00,
+0x19,0x00,0xA3,0x93,
+0x29,0x00,0xA6,0x93,
+0x0F,0x00,0x13,0x24,
+0x0E,0x00,0x10,0x24,
+0x25,0x18,0x66,0x00,
+0x01,0x00,0x62,0x30,
+0x0A,0x98,0x02,0x02,
+0x02,0x00,0x64,0x30,
+0xFD,0x00,0x62,0x32,
+0x0A,0x98,0x44,0x00,
+0x04,0x00,0x65,0x30,
+0xFB,0x00,0x62,0x32,
+0x0A,0x98,0x45,0x00,
+0x08,0x00,0x63,0x30,
+0xF7,0x00,0x62,0x32,
+0x0A,0x98,0x43,0x00,
+0x0F,0x00,0x64,0x32,
+0x0F,0x00,0x16,0x24,
+0x25,0x00,0x96,0x10,
+0x21,0x28,0xC0,0x00,
+0x01,0x00,0x44,0x26,
+0xFF,0xFF,0x84,0x30,
+0x5E,0x59,0x00,0x0C,
+0x1A,0x00,0xA6,0x27,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x42,0x30,
+0x03,0x00,0x56,0x10,
+0x21,0x20,0x80,0x02,
+0xAD,0x59,0x00,0x0C,
+0x38,0x00,0xA6,0x27,
+0x19,0x00,0xA5,0x93,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x65,0x02,
+0x01,0x00,0x42,0x30,
+0x0A,0x80,0xC2,0x02,
+0x26,0x18,0x65,0x02,
+0x02,0x00,0x63,0x30,
+0xFD,0x00,0x04,0x32,
+0x0B,0x80,0x83,0x00,
+0x26,0x10,0x65,0x02,
+0x04,0x00,0x42,0x30,
+0xFB,0x00,0x03,0x32,
+0x0B,0x80,0x62,0x00,
+0x26,0x28,0x65,0x02,
+0x08,0x00,0xA5,0x30,
+0xF7,0x00,0x02,0x32,
+0x0B,0x80,0x45,0x00,
+0x0F,0x00,0x03,0x32,
+0x0D,0x00,0x76,0x10,
+0x00,0x00,0x00,0x00,
+0xA0,0x58,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x90,0x40,0x00,
+0x19,0x00,0xB0,0xA3,
+0x20,0x5A,0x00,0x08,
+0x18,0x00,0xB4,0xA3,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x52,0x30,
+0x01,0x00,0x16,0x24,
+0xED,0x59,0x00,0x08,
+0x18,0x00,0xB4,0xA3,
+0x20,0x5A,0x00,0x08,
+0x21,0xB8,0x00,0x00,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0xA5,0x30,
+0x00,0x00,0x85,0xA4,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xA5,0x30,
+0x00,0x00,0x85,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x82,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x82,0x94,
+0x08,0x00,0xE0,0x03,
+0xFF,0xFF,0x42,0x30,
+0x00,0x00,0x82,0x90,
+0x08,0x00,0xE0,0x03,
+0xFF,0x00,0x42,0x30,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0xFF,0xFF,0xA5,0x30,
+0x00,0x00,0x85,0xA4,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0xFF,0x00,0xA5,0x30,
+0x00,0x00,0x85,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x82,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x82,0x94,
+0x08,0x00,0xE0,0x03,
+0xFF,0xFF,0x42,0x30,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x82,0x90,
+0x08,0x00,0xE0,0x03,
+0xFF,0x00,0x42,0x30,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xA4,0x6C,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x83,0x90,
+0x30,0x00,0x02,0x24,
+0x05,0x00,0x62,0x10,
+0x21,0x20,0x00,0x00,
+0x31,0x00,0x02,0x24,
+0x02,0x00,0x62,0x10,
+0x01,0x00,0x04,0x24,
+0x07,0x00,0x04,0x24,
+0x75,0x57,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xE0,0x6C,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x62,0xAC,
+0x08,0x00,0xE0,0x03,
+0x94,0x5F,0x80,0xAC,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x47,0x34,
+0x00,0x00,0xE3,0x90,
+0xFF,0x00,0x84,0x30,
+0x04,0x00,0x84,0x24,
+0xFF,0x00,0x65,0x30,
+0x01,0x00,0x02,0x24,
+0x04,0x30,0x82,0x00,
+0x07,0x18,0x85,0x00,
+0x25,0xB0,0x02,0x3C,
+0xE8,0x03,0x42,0x34,
+0x01,0x00,0x63,0x30,
+0x21,0x20,0xC0,0x00,
+0x00,0x00,0x45,0xA0,
+0x02,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE6,0xA0,
+0x08,0x00,0xE0,0x03,
+0x24,0x10,0x85,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0xD8,0xE6,0x42,0x24,
+0x04,0x00,0x43,0x8C,
+0x00,0x00,0x02,0xAE,
+0x04,0x00,0x50,0xAC,
+0x00,0x00,0x70,0xAC,
+0x04,0x00,0x03,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x1C,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x04,0x00,0x03,0x8E,
+0x00,0x00,0x02,0x8E,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0x10,0xAE,
+0xA0,0x40,0x00,0x0C,
+0x04,0x00,0x10,0xAE,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x1F,0xF7,0x00,0x6A,
+0x82,0x34,0x4C,0xEC,
+0x82,0x34,0x8C,0x32,
+0x89,0xE2,0x48,0x32,
+0x89,0xE2,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x48,0x32,
+0x69,0xE2,0x04,0xF5,
+0x68,0x9A,0x01,0xF6,
+0x01,0x6C,0x8B,0xEC,
+0x8C,0xEB,0x04,0xF5,
+0x68,0xDA,0x20,0xE8,
+0x00,0x65,0x00,0x00,
+0x1F,0xF7,0x00,0x6A,
+0x82,0x34,0x4C,0xEC,
+0x82,0x34,0x8C,0x32,
+0x89,0xE2,0x48,0x32,
+0x89,0xE2,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0x48,0x32,
+0x69,0xE2,0x04,0xF5,
+0x68,0x9A,0x01,0xF6,
+0x01,0x6C,0x8B,0xEC,
+0x8C,0xEB,0x00,0xF2,
+0x00,0x6C,0x8D,0xEB,
+0x04,0xF5,0x68,0xDA,
+0x20,0xE8,0x00,0x65,
+0xFF,0x6B,0x6C,0xED,
+0x04,0x5D,0x6C,0xEC,
+0x69,0x60,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x4B,0xF7,
+0x5E,0xA2,0xEF,0x4A,
+0x6C,0xEA,0x02,0x5A,
+0x0C,0x60,0x02,0x74,
+0x38,0x60,0x03,0x54,
+0x1D,0x61,0x03,0x74,
+0x2C,0x60,0x04,0xF0,
+0x00,0x6A,0x40,0x32,
+0x40,0x32,0x20,0xE8,
+0xFF,0x4A,0x02,0x74,
+0x3D,0x60,0x03,0x54,
+0x18,0x61,0x03,0x74,
+0xF4,0x61,0x01,0x75,
+0x43,0x60,0x02,0x55,
+0x31,0x61,0x02,0x75,
+0x42,0x60,0x03,0x75,
+0xEC,0x61,0x02,0xF0,
+0x00,0x6A,0x40,0x32,
+0x1E,0xF0,0x00,0x4A,
+0x20,0xE8,0x00,0x65,
+0x01,0x74,0xE3,0x61,
+0x02,0xF0,0x0F,0x6A,
+0x40,0x32,0x20,0xE8,
+0x40,0x32,0x01,0x74,
+0xDC,0x61,0x03,0xF7,
+0x10,0x6A,0x40,0x32,
+0x40,0x32,0x10,0xF0,
+0x00,0x4A,0x20,0xE8,
+0x00,0x65,0x01,0x75,
+0x1B,0x60,0x02,0x55,
+0x08,0x61,0x02,0x75,
+0x29,0x60,0x03,0x75,
+0xCC,0x61,0x02,0xF0,
+0x10,0x6A,0x40,0x32,
+0xDE,0x17,0xC7,0x2D,
+0x02,0xF0,0x10,0x6A,
+0x40,0x32,0x40,0x32,
+0x1E,0xF0,0x15,0x4A,
+0x20,0xE8,0x00,0x65,
+0xBE,0x2D,0x02,0xF0,
+0x00,0x6A,0xF7,0x17,
+0x03,0xF7,0x10,0x6A,
+0x40,0x32,0xCD,0x17,
+0x02,0xF0,0x10,0x6A,
+0x40,0x32,0x40,0x32,
+0x1E,0xF0,0x10,0x4A,
+0x20,0xE8,0x00,0x65,
+0x02,0xF0,0x00,0x6A,
+0xF8,0x17,0x02,0xF0,
+0x00,0x6A,0x40,0x32,
+0x1E,0xF0,0x05,0x4A,
+0x20,0xE8,0x00,0x65,
+0x02,0xF0,0x10,0x6A,
+0x40,0x32,0xF7,0x17,
+0xFC,0x63,0x06,0xD0,
+0x8C,0x30,0x81,0xE0,
+0x08,0x30,0x81,0xE0,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x08,0x30,0x41,0xE0,
+0xC9,0xF7,0x1B,0x6D,
+0x04,0xF0,0x00,0x6A,
+0x40,0x32,0xAB,0xED,
+0x40,0x32,0xA0,0x35,
+0xA0,0x35,0xFF,0x4A,
+0x04,0xF5,0x40,0xD8,
+0x07,0x62,0x80,0xF1,
+0x44,0x45,0x40,0x9A,
+0x08,0x6B,0x6B,0xEB,
+0x04,0xF5,0x44,0xD8,
+0x04,0xF5,0x48,0x98,
+0xC4,0x67,0x6C,0xEA,
+0xFF,0x6B,0x02,0x4B,
+0x6B,0xEB,0x6C,0xEA,
+0x02,0xF0,0x01,0x6B,
+0x6B,0xEB,0x6C,0xEA,
+0x04,0xF5,0x48,0xD8,
+0x04,0xD5,0x00,0x18,
+0x45,0x28,0x05,0xD6,
+0x04,0x95,0x05,0x96,
+0x04,0xF5,0x4A,0xA0,
+0x60,0xF1,0x00,0x4D,
+0xB9,0xE6,0x40,0xC6,
+0x00,0x6A,0xC4,0xF4,
+0x58,0xD8,0xC4,0xF4,
+0x5C,0xD8,0xE4,0xF4,
+0x40,0xD8,0xE4,0xF4,
+0x44,0xD8,0xE4,0xF4,
+0x48,0xD8,0xE4,0xF4,
+0x4C,0xD8,0xE4,0xF4,
+0x50,0xD8,0xE4,0xF4,
+0x54,0xD8,0x07,0x97,
+0x06,0x90,0x00,0xEF,
+0x04,0x63,0x00,0x00,
+0xFF,0x63,0x00,0xD0,
+0x04,0x67,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0xFF,0x6F,
+0x80,0x34,0xA0,0xF1,
+0x4F,0x44,0xEC,0xEE,
+0x01,0xD1,0x59,0xE6,
+0x40,0xA6,0xEC,0xED,
+0xC7,0x67,0x4C,0xEE,
+0xAC,0x32,0xA9,0xE2,
+0x48,0x32,0xA9,0xE2,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x48,0x32,0x69,0xE2,
+0x04,0xF5,0x48,0x9A,
+0x07,0x6B,0x80,0xF1,
+0x04,0x4C,0x6C,0xEA,
+0xEC,0xEA,0x48,0x32,
+0xEC,0xE8,0x89,0xE2,
+0x00,0x6D,0x80,0x9A,
+0x0D,0x65,0x70,0x67,
+0x2E,0x26,0x32,0x24,
+0x65,0x67,0x01,0x69,
+0x51,0x67,0x44,0xEB,
+0x8C,0xEA,0x36,0x2A,
+0x01,0x4B,0xEC,0xEB,
+0x1D,0x5B,0xF8,0x61,
+0x6F,0x40,0xFF,0x6A,
+0x4C,0xEB,0xE8,0x67,
+0xE3,0xEB,0x10,0x61,
+0x01,0x69,0xE2,0x67,
+0x51,0x67,0x44,0xEB,
+0x8C,0xEA,0x05,0x22,
+0xCA,0xED,0x26,0x60,
+0x01,0x4D,0xEC,0xED,
+0x03,0x67,0xFF,0x4B,
+0xEC,0xEB,0x48,0x67,
+0x43,0xEB,0xF2,0x60,
+0xC3,0xED,0x70,0x67,
+0x0A,0x60,0x68,0x67,
+0xAB,0xE6,0x42,0xEB,
+0x00,0x6B,0x05,0x61,
+0xE8,0x67,0xCB,0xE7,
+0xAD,0xE2,0xFF,0x6A,
+0x4C,0xEB,0x01,0x91,
+0x00,0x90,0x43,0x67,
+0x20,0xE8,0x01,0x63,
+0xC3,0xE8,0x65,0x67,
+0xF8,0x61,0xCF,0xE0,
+0x01,0x91,0x00,0x90,
+0xEC,0xEB,0x43,0x67,
+0x20,0xE8,0x01,0x63,
+0x0B,0x65,0xCC,0x17,
+0x70,0x67,0xED,0x17,
+0xC9,0xF7,0x1B,0x6E,
+0xCB,0xEE,0xC0,0x36,
+0xFF,0x6F,0xC0,0x36,
+0xEC,0xEC,0xFF,0x63,
+0x60,0xF1,0x40,0x46,
+0x01,0xD1,0x00,0xD0,
+0x49,0xE4,0x40,0xA2,
+0x07,0x67,0xEC,0xED,
+0x4C,0xE8,0xA0,0xF1,
+0x4F,0x46,0x55,0xE5,
+0x40,0xA5,0x27,0x67,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x4C,0xE9,0x8C,0x32,
+0x89,0xE2,0x48,0x32,
+0x89,0xE2,0x63,0xF3,
+0x00,0x4B,0x48,0x32,
+0x69,0xE2,0x04,0xF5,
+0x48,0x9A,0x07,0x6B,
+0x80,0xF1,0x04,0x4E,
+0x6C,0xEA,0xEC,0xEA,
+0x48,0x32,0xC9,0xE2,
+0x00,0x6D,0x80,0x9A,
+0x2D,0x65,0x70,0x67,
+0x30,0x21,0x34,0x24,
+0x01,0x6A,0x65,0x67,
+0x0A,0x65,0xC7,0x67,
+0x48,0x67,0x44,0xEB,
+0x8C,0xEA,0x36,0x2A,
+0x01,0x4B,0xCC,0xEB,
+0x1D,0x5B,0xF8,0x61,
+0x6F,0x40,0xFF,0x6A,
+0x4C,0xEB,0xC9,0x67,
+0xC3,0xEB,0x10,0x61,
+0x01,0x6F,0xC2,0x67,
+0x47,0x67,0x44,0xEB,
+0x8C,0xEA,0x05,0x22,
+0x2A,0xED,0x26,0x60,
+0x01,0x4D,0xCC,0xED,
+0x03,0x67,0xFF,0x4B,
+0xCC,0xEB,0x49,0x67,
+0x43,0xEB,0xF2,0x60,
+0x23,0xED,0x70,0x67,
+0x0A,0x60,0x69,0x67,
+0xAB,0xE1,0x42,0xEB,
+0x00,0x6B,0x05,0x61,
+0xC9,0x67,0x2B,0xE6,
+0xAD,0xE2,0xFF,0x6A,
+0x4C,0xEB,0x01,0x91,
+0x00,0x90,0x43,0x67,
+0x20,0xE8,0x01,0x63,
+0x23,0xE8,0x65,0x67,
+0xF8,0x61,0x2F,0xE0,
+0x01,0x91,0x00,0x90,
+0xEC,0xEB,0x43,0x67,
+0x20,0xE8,0x01,0x63,
+0x2B,0x65,0xCC,0x17,
+0x70,0x67,0xED,0x17,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0xFB,0x63,0x00,0x6D,
+0x63,0xF3,0x00,0x4E,
+0x07,0xD1,0x06,0xD0,
+0x08,0x62,0x05,0x67,
+0x26,0x67,0x85,0x67,
+0x04,0xD5,0x00,0x18,
+0xCF,0x5B,0x05,0xD6,
+0x04,0xF5,0x4A,0xA1,
+0xFF,0x6B,0x05,0x96,
+0x6C,0xEA,0x48,0x32,
+0xC9,0xE2,0xC0,0xF5,
+0x74,0x9A,0x60,0xF5,
+0x40,0x9A,0x4D,0xE3,
+0x66,0x33,0xC4,0xF4,
+0x74,0xD9,0x04,0x95,
+0x00,0x6B,0x69,0xE1,
+0x01,0x4B,0x1D,0x53,
+0x04,0xF5,0x0C,0xC2,
+0x24,0xF5,0x09,0xC2,
+0x44,0xF5,0x06,0xC2,
+0xF6,0x61,0x00,0x6A,
+0x01,0x4D,0x64,0xF5,
+0x44,0xD9,0x20,0x55,
+0x7F,0x49,0x15,0x49,
+0xD8,0x61,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0xEF,0x05,0x63,
+0xF8,0x63,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x07,0xD2,
+0x0E,0x62,0x0D,0xD1,
+0x0C,0xD0,0x63,0xF3,
+0x00,0x4A,0x27,0xF1,
+0x44,0x9A,0xFF,0x6B,
+0x6C,0xEC,0x6C,0x65,
+0xFF,0xF7,0x1F,0x72,
+0x00,0x6C,0x05,0xD4,
+0x01,0x61,0x05,0xD3,
+0x07,0x93,0xFF,0xF7,
+0x1F,0x6A,0x8B,0x67,
+0x63,0xF3,0x00,0x4B,
+0x27,0xF1,0x44,0xDB,
+0x00,0x6A,0x04,0xD2,
+0x00,0xF1,0x18,0x24,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x22,0x67,0xBD,0xF2,
+0x14,0x4D,0xFF,0x6E,
+0x00,0xF5,0x84,0x43,
+0x05,0x10,0x01,0x49,
+0x1D,0x51,0x60,0xC4,
+0x01,0x4C,0x0B,0x60,
+0xA9,0xE1,0x60,0xA2,
+0x46,0x67,0x6C,0xEA,
+0xF6,0x22,0x01,0x49,
+0x4D,0x43,0x1D,0x51,
+0x40,0xC4,0x01,0x4C,
+0xF5,0x61,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x00,0x69,
+0x63,0xF3,0x00,0x4A,
+0x5D,0xF0,0x0C,0x4B,
+0xDC,0xF7,0x14,0x4C,
+0x0A,0x65,0x4B,0x65,
+0x2C,0x65,0x11,0x67,
+0x48,0x67,0x6A,0x67,
+0x00,0x6D,0x5D,0xE0,
+0x79,0xE0,0xAD,0xE6,
+0x40,0xA3,0xB1,0xE7,
+0x01,0x4D,0xA0,0xF3,
+0x48,0xC4,0x80,0xF0,
+0x51,0xA3,0x05,0x55,
+0x20,0xF4,0x59,0xC4,
+0xF4,0x61,0x48,0x67,
+0x51,0xE1,0x49,0x67,
+0x4D,0xE1,0x40,0xA3,
+0x01,0x49,0x1D,0x51,
+0xC0,0xF4,0x4A,0xC4,
+0x5D,0xA3,0x05,0x48,
+0xE0,0xF4,0x47,0xC4,
+0xE1,0x61,0x6B,0x67,
+0x00,0xF1,0x0A,0x23,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x10,0xF0,0x02,0x6F,
+0x00,0xF4,0xE0,0x37,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x00,0x69,0x63,0xF3,
+0x00,0x4E,0x5D,0xF3,
+0x08,0x4F,0xDD,0xF2,
+0x14,0x4D,0x28,0x32,
+0xED,0xE2,0x60,0x9B,
+0xD1,0xE2,0xA9,0xE2,
+0xC0,0xF5,0x74,0xDC,
+0x40,0x9A,0x01,0x49,
+0x04,0x51,0x60,0xF5,
+0x40,0xDC,0xF3,0x61,
+0x10,0xF0,0x02,0x6F,
+0x00,0xF4,0xE0,0x37,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x04,0x69,0x63,0xF3,
+0x00,0x4F,0x5D,0xF3,
+0x08,0x4E,0xDD,0xF2,
+0x14,0x4D,0x28,0x33,
+0xC9,0xE3,0x40,0x9A,
+0xF1,0xE3,0xAD,0xE3,
+0x4A,0x32,0xC0,0xF5,
+0x54,0xDC,0x40,0x9B,
+0x01,0x49,0x1D,0x51,
+0x4A,0x32,0x60,0xF5,
+0x40,0xDC,0xF1,0x61,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x00,0x69,0x04,0x67,
+0xD1,0x67,0xC4,0xF4,
+0x14,0x48,0x06,0xD4,
+0x08,0xD1,0x09,0x10,
+0x08,0x94,0x01,0x49,
+0x7F,0x48,0x7F,0x4C,
+0x15,0x4C,0x20,0x51,
+0x15,0x48,0x08,0xD4,
+0x5E,0x60,0x8D,0x98,
+0x01,0x6B,0x82,0x32,
+0x52,0x32,0x6C,0xEA,
+0xFF,0x6B,0x6C,0xEA,
+0xEF,0x22,0x07,0x6A,
+0x4C,0xEC,0x6C,0xEC,
+0x88,0x32,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x80,0x34,
+0x80,0xF1,0x04,0x4C,
+0x89,0xE2,0x6B,0x98,
+0x40,0x9A,0x91,0x67,
+0x6C,0xEA,0x4C,0xD8,
+0x00,0x18,0x45,0x28,
+0x0A,0xD6,0x20,0xF0,
+0x96,0xA0,0xFF,0x6A,
+0xA2,0x67,0x4C,0xEC,
+0x00,0x18,0x33,0x28,
+0x2C,0xED,0x20,0xF0,
+0x56,0xA0,0x04,0x94,
+0xFF,0x6B,0x6C,0xEA,
+0x43,0xEC,0x0A,0x96,
+0x01,0x60,0x04,0xD2,
+0xC1,0xD8,0xC2,0xD8,
+0xC3,0xD8,0xC4,0xD8,
+0xC5,0xD8,0xC6,0xD8,
+0xC7,0xD8,0xC8,0xD8,
+0x06,0x93,0x48,0x32,
+0xA6,0x67,0x69,0xE2,
+0xC0,0xF5,0x74,0x9A,
+0x60,0xF5,0x40,0x9A,
+0x4D,0xE3,0x66,0x33,
+0x60,0xD8,0x08,0x92,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x71,0xE2,0x66,0x67,
+0xA9,0xE4,0x01,0x4D,
+0x1D,0x55,0x04,0xF5,
+0x6C,0xC2,0x24,0xF5,
+0x69,0xC2,0x44,0xF5,
+0x66,0xC2,0xF6,0x61,
+0x64,0xF5,0xC4,0xDC,
+0x08,0x94,0x01,0x49,
+0x7F,0x48,0x7F,0x4C,
+0x15,0x4C,0x20,0x51,
+0x15,0x48,0x08,0xD4,
+0xA2,0x61,0x05,0x92,
+0x06,0x2A,0x07,0x93,
+0x63,0xF3,0x00,0x4B,
+0x07,0xD3,0x27,0xF1,
+0x44,0xDB,0x0E,0x97,
+0x0D,0x91,0x0C,0x90,
+0x00,0xEF,0x08,0x63,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x22,0x67,0xBD,0xF2,
+0x14,0x4C,0x00,0xF5,
+0x04,0x4B,0x89,0xE1,
+0x40,0xA2,0x01,0x49,
+0x1D,0x51,0x40,0xC3,
+0x01,0x4B,0xF9,0x61,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x00,0x69,0x63,0xF3,
+0x00,0x4B,0x7D,0xF1,
+0x10,0x4C,0x1D,0xF0,
+0x10,0x4A,0x0B,0x65,
+0x4C,0x65,0x2A,0x65,
+0x11,0x67,0x68,0x67,
+0x8A,0x67,0x00,0x6D,
+0x7D,0xE0,0x99,0xE0,
+0xAD,0xE6,0x40,0xA3,
+0xB1,0xE7,0x01,0x4D,
+0xA0,0xF3,0x48,0xC4,
+0x80,0xF0,0x51,0xA3,
+0x05,0x55,0x20,0xF4,
+0x59,0xC4,0xF4,0x61,
+0x48,0x67,0x51,0xE1,
+0x49,0x67,0x4D,0xE1,
+0x40,0xA3,0x01,0x49,
+0x1D,0x51,0xC0,0xF4,
+0x4A,0xC4,0x5D,0xA3,
+0x05,0x48,0xE0,0xF4,
+0x47,0xC4,0xE1,0x61,
+0x10,0xF0,0x02,0x6F,
+0x00,0xF4,0xE0,0x37,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x2B,0x67,0x63,0xF3,
+0x00,0x4F,0x5D,0xF3,
+0x08,0x4E,0xDD,0xF2,
+0x14,0x4D,0x28,0x32,
+0xCD,0xE2,0x60,0x9B,
+0xF1,0xE2,0xA9,0xE2,
+0xC0,0xF5,0x74,0xDC,
+0x40,0x9A,0x01,0x49,
+0x1D,0x51,0x60,0xF5,
+0x40,0xDC,0xF3,0x61,
+0x17,0x17,0x00,0x00,
+0xFF,0xF7,0x1F,0x6F,
+0x8C,0xEF,0xE0,0xF1,
+0x10,0x6E,0xEC,0xEE,
+0xFB,0x63,0xD2,0x36,
+0x06,0xD0,0xCC,0x30,
+0xC1,0xE0,0x08,0x30,
+0xC1,0xE0,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x08,0x30,
+0x41,0xE0,0x08,0x62,
+0x07,0xD1,0x25,0x67,
+0x04,0xF5,0xA8,0x98,
+0x02,0xF0,0x00,0x6A,
+0xFF,0x6B,0x4D,0xED,
+0x00,0xF2,0x00,0x6A,
+0xEC,0xEA,0x43,0x32,
+0x02,0x4B,0x6B,0xEB,
+0x47,0x32,0x6C,0xED,
+0x40,0x32,0x4D,0xED,
+0x04,0xF5,0x20,0xD8,
+0x04,0xF5,0xA8,0xD8,
+0x87,0x67,0x04,0xD5,
+0x00,0x18,0xCD,0x28,
+0x05,0xD6,0x04,0x95,
+0x08,0x6B,0x07,0x6C,
+0x6B,0xEB,0x8C,0xEA,
+0xAC,0xEB,0x4D,0xEB,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x04,0xF5,0x68,0xD8,
+0x40,0x32,0x8C,0xEB,
+0x80,0xF1,0x04,0x4A,
+0x68,0x33,0x4D,0xE3,
+0x40,0x9B,0x2C,0xEA,
+0x04,0xF5,0x44,0xD8,
+0x05,0x96,0x00,0x18,
+0x45,0x28,0x86,0x67,
+0x05,0x96,0x04,0xF5,
+0x8A,0xA0,0x00,0x18,
+0x33,0x28,0xA6,0x67,
+0x08,0x97,0x07,0x91,
+0x06,0x90,0x00,0xEF,
+0x05,0x63,0x00,0x00,
+0xFF,0x6A,0xFD,0x63,
+0x04,0x62,0x00,0x18,
+0xCF,0x5B,0x4C,0xEC,
+0x04,0x97,0x00,0xEF,
+0x03,0x63,0x00,0x00,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x02,0xF0,0x00,0x6D,
+0x63,0xF3,0x00,0x4C,
+0x1F,0x6B,0x04,0xF5,
+0x48,0x9C,0xFF,0x4B,
+0x00,0x53,0xAD,0xEA,
+0x04,0xF5,0x48,0xDC,
+0x7F,0x4C,0x15,0x4C,
+0xF6,0x60,0x20,0xE8,
+0x00,0x65,0x00,0x65,
+0x00,0x1C,0x95,0x5D,
+0x00,0x65,0x00,0x65,
+0x83,0xED,0xAB,0xE4,
+0x01,0x61,0x8B,0xE5,
+0x20,0xE8,0x00,0x65,
+0xC9,0xF7,0x1B,0x6A,
+0xF9,0x63,0x4B,0xEA,
+0x0A,0xD0,0x40,0x30,
+0x00,0x30,0x01,0xF5,
+0x83,0x40,0x0C,0x62,
+0x00,0x1C,0xF4,0x5A,
+0x0B,0xD1,0x05,0xD2,
+0x05,0x93,0x70,0x6A,
+0x6C,0xEA,0x3A,0x2A,
+0x67,0x40,0x3B,0x4B,
+0x01,0x6A,0x4B,0xEA,
+0x40,0xC3,0x05,0x93,
+0x70,0x6A,0x4C,0xEB,
+0x08,0xD3,0x3C,0x2B,
+0x9D,0x67,0x00,0x1C,
+0x9A,0x40,0x10,0x4C,
+0x02,0xF0,0x00,0x6A,
+0x40,0x31,0xAF,0x41,
+0x00,0x1C,0x3B,0x46,
+0x18,0x6C,0x9D,0x67,
+0x10,0x4C,0x00,0x1C,
+0xA0,0x40,0x02,0x67,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x10,0xF0,
+0x00,0x6A,0xD0,0x67,
+0x4D,0xEE,0x18,0x6C,
+0x00,0x1C,0x12,0x46,
+0xAF,0x41,0x00,0x1C,
+0x43,0x26,0x03,0x6C,
+0x08,0x92,0x6A,0x2A,
+0xC9,0xF7,0x1B,0x6A,
+0x7D,0x67,0x4B,0xEA,
+0x40,0x32,0x20,0xF0,
+0x60,0xA3,0x0C,0x97,
+0x0B,0x91,0x0A,0x90,
+0x40,0x32,0x42,0x4A,
+0x07,0x63,0x60,0xC2,
+0x00,0xEF,0x00,0x65,
+0x8F,0x6A,0xA3,0x67,
+0x01,0xF5,0x83,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x4C,0xED,0x05,0x93,
+0x70,0x6A,0x4C,0xEB,
+0x08,0xD3,0xC4,0x23,
+0x9D,0x67,0x00,0x1C,
+0x9A,0x40,0x10,0x4C,
+0x02,0xF0,0x00,0x6D,
+0xA0,0x31,0xAF,0x41,
+0x00,0x1C,0x3B,0x46,
+0x00,0x6C,0x9D,0x67,
+0x10,0x4C,0x00,0x1C,
+0xA0,0x40,0x06,0xD2,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x00,0x1C,
+0x7F,0x43,0x01,0x6C,
+0x9D,0x67,0x00,0x1C,
+0x9A,0x40,0x10,0x4C,
+0xAF,0x41,0x00,0x1C,
+0x3B,0x46,0x00,0x6C,
+0x9D,0x67,0x10,0x4C,
+0x00,0x1C,0xA0,0x40,
+0x07,0xD2,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x00,0x6C,0x01,0xF1,
+0x00,0x68,0x06,0x96,
+0x00,0x30,0x01,0x6A,
+0xFF,0x48,0x40,0x32,
+0x40,0x32,0x0C,0xEE,
+0x4D,0xEE,0xAF,0x41,
+0x00,0x1C,0x12,0x46,
+0x00,0x6C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x01,0x6C,0x07,0x93,
+0x01,0x6E,0xC0,0x36,
+0x6C,0xE8,0xC0,0x36,
+0xAF,0x41,0x0D,0xEE,
+0x00,0x1C,0x12,0x46,
+0x00,0x6C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x00,0x6C,0x76,0x17,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x01,0xF5,
+0x03,0x4C,0x00,0x1C,
+0xE4,0x5A,0x05,0x95,
+0x06,0x96,0xAF,0x41,
+0x00,0x1C,0x12,0x46,
+0x00,0x6C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x00,0x1C,0x7F,0x43,
+0x01,0x6C,0x07,0x96,
+0xAF,0x41,0x00,0x1C,
+0x12,0x46,0x00,0x6C,
+0x00,0x1C,0x72,0x26,
+0x64,0x6C,0x00,0x1C,
+0x7F,0x43,0x00,0x6C,
+0x0C,0x97,0x0B,0x91,
+0x0A,0x90,0x00,0xEF,
+0x07,0x63,0x00,0x00,
+0xF8,0x63,0x0D,0xD1,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x0E,0x62,0x0C,0xD0,
+0x63,0xF3,0x00,0x49,
+0x03,0x99,0x01,0x6A,
+0x80,0xF7,0x02,0x30,
+0x4C,0xE8,0x08,0x28,
+0x42,0x99,0x03,0x6B,
+0x40,0xF7,0x42,0x32,
+0x6C,0xEA,0x01,0x72,
+0xC0,0xF1,0x13,0x60,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0x43,0x9C,0x01,0x6B,
+0x80,0xF7,0x42,0x32,
+0x6C,0xEA,0xC0,0xF1,
+0x00,0x22,0x42,0x9C,
+0x03,0x6B,0x40,0xF7,
+0x42,0x32,0x6C,0xEA,
+0x01,0x72,0xA0,0xF1,
+0x18,0x61,0x44,0x9C,
+0x80,0xF7,0x42,0x32,
+0x01,0x72,0x60,0xF2,
+0x0C,0x60,0xC0,0xF2,
+0x87,0xA4,0x06,0xD4,
+0x10,0xF0,0x02,0x68,
+0x00,0xF4,0x00,0x30,
+0x63,0xF3,0x00,0x48,
+0xC0,0xF2,0x46,0xA0,
+0x07,0x2A,0xBD,0x67,
+0xAC,0xAD,0x01,0x6A,
+0xC0,0xF2,0x46,0xC0,
+0xC0,0xF2,0xA4,0xC8,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x01,0xF5,
+0x03,0x4C,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0x70,0x6B,0x4C,0xEB,
+0x0D,0x2B,0xC0,0xF2,
+0x44,0xA8,0x06,0x93,
+0x53,0xE3,0x63,0xEA,
+0x07,0xD4,0x02,0x61,
+0x6B,0xE2,0x07,0xD2,
+0x07,0x95,0x03,0x5D,
+0x20,0xF3,0x09,0x60,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x63,0xF3,0x00,0x4D,
+0x9D,0x67,0x62,0x9D,
+0x98,0xA4,0x3F,0x6E,
+0x24,0x6A,0xC0,0xF2,
+0x82,0xC5,0x83,0x67,
+0x62,0x33,0xCC,0xEC,
+0x62,0x33,0xCC,0xEB,
+0x93,0xE2,0x20,0x6A,
+0x7B,0xE2,0xC0,0xF2,
+0x43,0xA5,0x06,0x95,
+0x4F,0xE5,0x43,0xED,
+0x07,0xD3,0x02,0x60,
+0xAB,0xE2,0x07,0xD2,
+0x07,0x95,0x60,0xF1,
+0x04,0x25,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0xC0,0xF2,
+0x43,0xA3,0x06,0x95,
+0x43,0xED,0x20,0xF2,
+0x12,0x60,0x07,0x92,
+0x24,0x68,0x83,0xEA,
+0x40,0xF2,0x06,0x61,
+0x07,0x94,0x20,0x6D,
+0x08,0xD5,0xC3,0xEC,
+0x0B,0x60,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x45,0xAA,
+0x3F,0x6B,0x6C,0xEA,
+0x89,0xE2,0x08,0xD2,
+0x06,0x6A,0x03,0xEA,
+0x80,0xF2,0x0F,0x60,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x08,0x32,0x63,0xF3,
+0x00,0x4B,0x69,0xE2,
+0xA6,0x9A,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x63,0xF3,
+0x00,0x4B,0xC3,0x9B,
+0xE0,0xF3,0x1F,0x6F,
+0x80,0xF5,0xA2,0x35,
+0x86,0x67,0xEC,0xEC,
+0x60,0xF2,0x00,0x24,
+0x00,0xF2,0x00,0x68,
+0x44,0x67,0x0C,0xEA,
+0x04,0x22,0x00,0xF4,
+0x00,0x6A,0x4B,0xEA,
+0x4D,0xEC,0xB8,0xEC,
+0xC2,0x33,0x6A,0x33,
+0xEC,0xEB,0x12,0xEA,
+0x42,0x34,0x43,0x67,
+0x0C,0xEA,0xEC,0xEC,
+0x04,0x22,0x00,0xF4,
+0x00,0x6A,0x4B,0xEA,
+0x4D,0xEB,0xB8,0xEB,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x80,0xF5,
+0xA0,0x35,0x00,0x30,
+0x00,0x30,0x12,0xEA,
+0x42,0x31,0xEC,0xE9,
+0x3F,0x6A,0x2C,0xEA,
+0x40,0x32,0x40,0x32,
+0x4D,0xED,0x8D,0xED,
+0x81,0xF4,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x04,0xD5,0x91,0xF4,
+0x84,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x02,0xF0,0x00,0x6D,
+0xA0,0x35,0xA0,0x35,
+0xFF,0x4D,0x4C,0xED,
+0xC0,0xF3,0x00,0x6A,
+0x4C,0xE9,0x80,0xF5,
+0x20,0x32,0x4D,0xED,
+0x04,0xD5,0x91,0xF4,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0x42,0x9B,0xC0,0xF7,
+0x42,0x32,0xC0,0xF1,
+0x13,0x2A,0x08,0x94,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x8C,0x32,
+0x65,0xE2,0xA0,0xF0,
+0xAC,0xA1,0x00,0x30,
+0x00,0x30,0x21,0xF2,
+0x82,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF0,0xAD,0xA1,
+0x21,0xF2,0x83,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF0,
+0xAE,0xA1,0x21,0xF2,
+0x84,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF0,0xAF,0xA1,
+0x21,0xF2,0x85,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF0,
+0xB0,0xA1,0x21,0xF2,
+0x86,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF0,0xB1,0xA1,
+0x21,0xF2,0x87,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF0,
+0xB2,0xA1,0x21,0xF2,
+0x88,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF0,0xB3,0xA1,
+0x21,0xF2,0x89,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x4B,0xF7,
+0x5E,0xA2,0x22,0x72,
+0x03,0x60,0x92,0x72,
+0x80,0xF0,0x0D,0x61,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x42,0x9A,0x3F,0x6B,
+0x42,0x32,0x6C,0xEA,
+0x24,0x6B,0x53,0xE3,
+0x07,0x92,0x01,0x6B,
+0x6E,0xEA,0x6C,0xEA,
+0x00,0xF2,0x18,0x22,
+0x07,0x95,0xA6,0x33,
+0x64,0x32,0x69,0xE2,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x07,0xD2,0x63,0xF3,
+0x00,0x4B,0xC0,0xF2,
+0x43,0xA3,0x06,0x95,
+0x43,0xED,0xC0,0xF1,
+0x02,0x60,0x07,0x92,
+0x24,0x68,0x83,0xEA,
+0x06,0x60,0x42,0x9B,
+0x3F,0x6B,0x42,0x32,
+0x6C,0xEA,0x07,0x93,
+0x61,0xE2,0x06,0x6D,
+0x03,0xED,0xA0,0xF1,
+0x1F,0x60,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x08,0x32,
+0x63,0xF3,0x00,0x4B,
+0x69,0xE2,0xA6,0x9A,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x63,0xF3,0x00,0x4B,
+0xC4,0x9B,0xE0,0xF3,
+0x1F,0x6F,0x80,0xF5,
+0xA2,0x35,0xC2,0x34,
+0x8A,0x34,0xEC,0xEC,
+0xC0,0xF1,0x07,0x24,
+0x00,0xF2,0x00,0x68,
+0x44,0x67,0x0C,0xEA,
+0x04,0x22,0x00,0xF4,
+0x00,0x6A,0x4B,0xEA,
+0x4D,0xEC,0xB8,0xEC,
+0x00,0xF5,0xC2,0x33,
+0xEC,0xEB,0x12,0xEA,
+0x42,0x34,0x43,0x67,
+0x0C,0xEA,0xEC,0xEC,
+0x04,0x22,0x00,0xF4,
+0x00,0x6A,0x4B,0xEA,
+0x4D,0xEB,0xB8,0xEB,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x80,0xF5,
+0xA0,0x35,0x00,0x30,
+0x00,0x30,0x12,0xEA,
+0x42,0x31,0xEC,0xE9,
+0x3F,0x6A,0x2C,0xEA,
+0x40,0x32,0x40,0x32,
+0x4D,0xED,0x8D,0xED,
+0x81,0xF4,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x04,0xD5,0x91,0xF4,
+0x8C,0x40,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x02,0xF0,0x00,0x6D,
+0xA0,0x35,0xA0,0x35,
+0xFF,0x4D,0x4C,0xED,
+0xC0,0xF3,0x00,0x6A,
+0x4C,0xE9,0x80,0xF5,
+0x20,0x32,0x4D,0xED,
+0x91,0xF4,0x8C,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x04,0xD5,0x0E,0x97,
+0x0D,0x91,0x0C,0x90,
+0x00,0x6A,0x00,0xEF,
+0x08,0x63,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x80,0x34,
+0x81,0xF4,0x00,0x4C,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x08,0xF0,
+0x00,0x6B,0x6B,0xEB,
+0x60,0x33,0xA2,0x67,
+0x6C,0xED,0xD1,0x67,
+0x03,0x10,0x01,0x48,
+0x25,0x58,0x0E,0x60,
+0x08,0x32,0xC9,0xE2,
+0x46,0x9A,0x6C,0xEA,
+0xAE,0xEA,0xF7,0x2A,
+0x62,0x9E,0x40,0x6C,
+0x3F,0x6A,0x8B,0xEC,
+0x0C,0xEA,0x8C,0xEB,
+0x4D,0xEB,0x62,0xDE,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x4B,0xF7,0x5E,0xA2,
+0x22,0x72,0x02,0x60,
+0x92,0x72,0x2A,0x61,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x81,0xF4,
+0x08,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x68,
+0x08,0xF0,0x00,0x6B,
+0x6B,0xEB,0x60,0x33,
+0xA2,0x67,0x10,0xF0,
+0x02,0x6E,0x00,0xF4,
+0xC0,0x36,0x6C,0xED,
+0x63,0xF3,0x00,0x4E,
+0x03,0x10,0x01,0x48,
+0x25,0x58,0x10,0x60,
+0x08,0x32,0xC9,0xE2,
+0x46,0x9A,0x6C,0xEA,
+0xAE,0xEA,0xF7,0x2A,
+0x62,0x9E,0x3F,0x6A,
+0x07,0xF7,0x01,0x6C,
+0x0C,0xEA,0x8B,0xEC,
+0x40,0x32,0x8C,0xEB,
+0x4D,0xEB,0x62,0xDE,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x21,0xF2,
+0x04,0x4C,0x00,0x1C,
+0xEE,0x5A,0x00,0x68,
+0x27,0xF7,0x1F,0x6B,
+0x60,0x33,0x60,0x33,
+0x27,0xF7,0x1F,0x4B,
+0x4C,0xEB,0x04,0xD3,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0x03,0xF4,0x0E,0x4A,
+0x03,0xF5,0x16,0x4B,
+0x09,0xD2,0x0A,0xD3,
+0x0C,0x10,0x0A,0x93,
+0x9D,0x67,0x10,0x4C,
+0x75,0xE1,0x00,0x1C,
+0xF7,0x53,0x04,0x6E,
+0xE0,0xF0,0x04,0x22,
+0x01,0x48,0x21,0x58,
+0x22,0x60,0x09,0x92,
+0x0C,0x31,0x9D,0x67,
+0x10,0x4C,0x55,0xE1,
+0x00,0x1C,0xF7,0x53,
+0x04,0x6E,0xEB,0x2A,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x63,0xF3,0x00,0x4D,
+0x07,0xF7,0x00,0x6A,
+0x62,0x9D,0x4B,0xEA,
+0x40,0x32,0xFF,0x4A,
+0x3F,0x6C,0x4C,0xEB,
+0x0C,0xEC,0x10,0xF0,
+0x00,0x6A,0x80,0x34,
+0x40,0x32,0x80,0x34,
+0x40,0x32,0x8D,0xEB,
+0xFF,0x4A,0x4C,0xEB,
+0x62,0xDD,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x63,0xF3,
+0x00,0x4C,0x63,0x9C,
+0x08,0xF0,0x00,0x6A,
+0x40,0x32,0x40,0x32,
+0x4D,0xEB,0x63,0xDC,
+0x79,0x15,0x02,0xF0,
+0x00,0x68,0x00,0x30,
+0x60,0x6E,0xAF,0x40,
+0x00,0x1C,0x12,0x46,
+0x24,0x6C,0xE0,0xF3,
+0x08,0x6C,0x00,0x1C,
+0x43,0x26,0x00,0x65,
+0x9D,0x67,0x00,0x1C,
+0x9A,0x40,0x14,0x4C,
+0xAF,0x40,0x00,0x1C,
+0x3B,0x46,0x24,0x6C,
+0x1F,0x6C,0x4C,0xEC,
+0x06,0xD4,0x9D,0x67,
+0x00,0x1C,0xA0,0x40,
+0x14,0x4C,0x00,0x1C,
+0x72,0x26,0x64,0x6C,
+0x77,0x15,0x42,0x9B,
+0x3F,0x6B,0x6C,0xEA,
+0x07,0x93,0x43,0xEB,
+0x63,0xE2,0x18,0x60,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x45,0xAA,0x07,0x94,
+0x3F,0x6B,0x6C,0xEA,
+0x43,0xEC,0x8B,0xE2,
+0x08,0xD2,0xDF,0xF5,
+0x0D,0x61,0x00,0x6D,
+0x08,0xD5,0xCA,0x15,
+0x42,0x9B,0x3F,0x6B,
+0x6C,0xEA,0x07,0x93,
+0x61,0xE2,0xB4,0x15,
+0x00,0x68,0xE6,0x17,
+0x08,0x95,0xC9,0xF7,
+0x1B,0x68,0x0B,0xE8,
+0xAC,0x32,0x65,0xE2,
+0xA0,0xF1,0xB4,0xA1,
+0x00,0x30,0x00,0x30,
+0x21,0xF2,0x82,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF1,
+0xB5,0xA1,0x21,0xF2,
+0x83,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF1,0xB6,0xA1,
+0x21,0xF2,0x84,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF1,
+0xB7,0xA1,0x21,0xF2,
+0x85,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF1,0xB8,0xA1,
+0x21,0xF2,0x86,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF1,
+0xB9,0xA1,0x21,0xF2,
+0x87,0x40,0x00,0x1C,
+0xE4,0x5A,0x00,0x65,
+0xA0,0xF1,0xBA,0xA1,
+0x21,0xF2,0x88,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x00,0x65,0xA0,0xF1,
+0xBB,0xA1,0x21,0xF2,
+0x89,0x40,0x2C,0x16,
+0x78,0x60,0x08,0x32,
+0xC9,0xF7,0x1B,0x6C,
+0x69,0xE2,0x8B,0xEC,
+0x80,0x34,0xA6,0x9A,
+0x80,0x34,0x81,0xF4,
+0x00,0x4C,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x81,0xF4,
+0x14,0x4C,0x00,0x6D,
+0xCA,0x15,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0xAC,0x9A,
+0x72,0x15,0x42,0x9B,
+0x07,0x94,0x3F,0x6B,
+0x42,0x32,0x6C,0xEA,
+0x43,0xEC,0x83,0xE2,
+0x3F,0xF6,0x1F,0x61,
+0x00,0x68,0x18,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0xAC,0x9A,0x42,0x16,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0x63,0xF3,0x00,0x4D,
+0x07,0xF7,0x00,0x6A,
+0x62,0x9D,0x4B,0xEA,
+0x3F,0x6C,0x40,0x32,
+0xFF,0x4A,0x0C,0xEC,
+0x4C,0xEB,0x80,0x34,
+0x10,0xF0,0x00,0x6A,
+0x4B,0xEA,0x80,0x34,
+0x40,0x32,0x8D,0xEB,
+0x40,0x32,0x4D,0xEB,
+0x27,0x17,0x36,0x60,
+0x08,0x32,0xC9,0xF7,
+0x1B,0x6C,0x69,0xE2,
+0x8B,0xEC,0x80,0x34,
+0xA6,0x9A,0x80,0x34,
+0x81,0xF4,0x08,0x4C,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x80,0x34,
+0x81,0xF4,0x1C,0x4C,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x6D,0x63,0x16,
+0x07,0x93,0xFF,0x4B,
+0x66,0x33,0x64,0x32,
+0x69,0xE2,0x01,0x4A,
+0xE5,0x15,0x00,0x18,
+0x98,0x5D,0x00,0x65,
+0x7D,0x67,0x6C,0xAB,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0xC0,0xF2,0x64,0xCA,
+0xC9,0x14,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0xAC,0x9B,
+0x80,0x34,0x81,0xF4,
+0x00,0x4C,0x89,0x17,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0xAC,0x9B,0x80,0x34,
+0x81,0xF4,0x08,0x4C,
+0xCB,0x17,0x00,0x00,
+0x82,0x34,0x1F,0xF7,
+0x00,0x6A,0x4C,0xEC,
+0x82,0x35,0x20,0x5D,
+0x1B,0x60,0xAC,0x32,
+0xA9,0xE2,0x48,0x32,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0xA9,0xE2,0x63,0xF3,
+0x00,0x4B,0x48,0x32,
+0x69,0xE2,0xE4,0xF4,
+0x58,0x9A,0xC9,0xF7,
+0x1B,0x6C,0x8B,0xEC,
+0x80,0x34,0x80,0x34,
+0x52,0x32,0x7F,0x6B,
+0x60,0xF3,0x14,0x4C,
+0x6C,0xEA,0x40,0xDC,
+0x20,0xE8,0x00,0x65,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0xCA,0xF2,0x4C,0x9A,
+0xC9,0xF7,0x1B,0x6C,
+0x8B,0xEC,0x80,0x34,
+0x80,0x34,0x52,0x32,
+0x7F,0x6B,0x60,0xF3,
+0x14,0x4C,0x6C,0xEA,
+0x40,0xDC,0x20,0xE8,
+0x00,0x65,0x00,0x00,
+0xFC,0x63,0x04,0xD0,
+0xC9,0xF7,0x1B,0x68,
+0x0B,0xE8,0x00,0x30,
+0x00,0x30,0x01,0xF5,
+0x83,0x40,0x06,0x62,
+0x00,0x1C,0xF4,0x5A,
+0x05,0xD1,0x08,0x6D,
+0x4D,0xED,0xFF,0x69,
+0x01,0xF5,0x83,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x2C,0xED,0x01,0xF5,
+0x83,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0xA2,0x67,0xF7,0x6B,
+0x01,0xF5,0x83,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x6C,0xED,0x21,0xF2,
+0x8D,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0xA2,0x67,0x3F,0x6B,
+0x21,0xF2,0x8D,0x40,
+0x00,0x1C,0xE4,0x5A,
+0x6C,0xED,0x21,0xF2,
+0x8D,0x40,0x00,0x1C,
+0xF4,0x5A,0x00,0x65,
+0x80,0x6D,0xAB,0xED,
+0x4D,0xED,0x21,0xF2,
+0x8D,0x40,0x00,0x1C,
+0xE4,0x5A,0x2C,0xED,
+0x06,0x97,0x05,0x91,
+0x04,0x90,0x00,0xEF,
+0x04,0x63,0x00,0x65,
+0x00,0x1C,0x10,0x60,
+0x00,0x65,0x00,0x65,
+0x00,0x1C,0x12,0x60,
+0x00,0x65,0x00,0x65,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x30,0xF2,
+0x63,0x42,0x90,0x34,
+0x80,0xC3,0x20,0xF2,
+0x10,0x4A,0x40,0x9A,
+0x02,0xF0,0x00,0x6B,
+0x60,0x33,0xFF,0x4B,
+0x20,0xE8,0x6C,0xEA,
+0xC9,0xF7,0x1B,0x6A,
+0x4B,0xEA,0xFF,0x6D,
+0x40,0x32,0x8C,0xED,
+0x40,0x32,0x30,0xF2,
+0x83,0x42,0xB0,0x33,
+0x60,0xC4,0x20,0xF2,
+0x10,0x4A,0x60,0x9A,
+0x02,0xF0,0x00,0x6A,
+0x40,0x32,0xFF,0x4A,
+0x4C,0xEB,0x83,0x67,
+0x05,0x23,0x01,0x6C,
+0x84,0xED,0xFF,0xF7,
+0x1F,0x6A,0x4C,0xEC,
+0x20,0xE8,0x44,0x67,
+0xC9,0xF7,0x1B,0x6A,
+0xFB,0x63,0x4B,0xEA,
+0x07,0xD1,0x40,0x31,
+0x08,0x62,0x06,0xD0,
+0x20,0x31,0x40,0xF0,
+0x4C,0xA1,0xFF,0x6C,
+0x8C,0xEA,0x02,0x72,
+0x14,0x61,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x04,0xD2,
+0x66,0xF7,0x56,0xAA,
+0x01,0x72,0x09,0x61,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x0C,0xF4,0x58,0xA2,
+0x04,0x67,0x4C,0xE8,
+0x05,0x20,0x08,0x97,
+0x07,0x91,0x06,0x90,
+0x00,0xEF,0x05,0x63,
+0x00,0x18,0x12,0x60,
+0x04,0x6C,0x04,0x94,
+0x68,0xF2,0x68,0x9C,
+0x4D,0xE3,0x68,0xF2,
+0x68,0xDC,0x00,0x18,
+0x12,0x60,0x06,0x6C,
+0x04,0x94,0x68,0xF2,
+0x6C,0x9C,0x4D,0xE3,
+0x68,0xF2,0x6C,0xDC,
+0x00,0x18,0x12,0x60,
+0x07,0x6C,0x04,0x94,
+0x68,0xF2,0x70,0x9C,
+0x4D,0xE3,0x68,0xF2,
+0x70,0xDC,0x00,0x18,
+0x12,0x60,0x05,0x6C,
+0x04,0x94,0x68,0xF2,
+0x74,0x9C,0x4D,0xE3,
+0x68,0xF2,0x74,0xDC,
+0x00,0x18,0x1B,0x60,
+0x90,0x67,0x04,0x6C,
+0x00,0x18,0x1B,0x60,
+0x02,0x67,0x4D,0xE8,
+0xFF,0xF7,0x1F,0x6A,
+0x4C,0xE8,0x30,0xF2,
+0x63,0x41,0x08,0x6A,
+0x40,0xC3,0xC7,0x28,
+0x40,0xF0,0x40,0xA9,
+0xFF,0xF7,0x1F,0x6B,
+0x6C,0xEA,0xFB,0xF7,
+0x1F,0x6B,0x6C,0xEA,
+0x04,0xF0,0x00,0x6B,
+0x40,0xF0,0x40,0xC9,
+0x6D,0xEA,0x40,0xF0,
+0x40,0xC9,0x04,0x94,
+0x47,0x41,0x7D,0x4A,
+0x66,0xF7,0xB4,0xAC,
+0x01,0x4D,0x66,0xF7,
+0xB4,0xCC,0xC0,0x9A,
+0x47,0x41,0x79,0x4A,
+0xE0,0x9A,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0xFF,0xF7,
+0x1F,0x6A,0x7F,0xF1,
+0x00,0x4C,0x00,0x1C,
+0x13,0x57,0x4C,0xED,
+0xA0,0x17,0x00,0x65,
+0x02,0x80,0x03,0x3C,
+0x3A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x10,0x00,0x40,0x14,
+0x01,0x00,0x04,0x24,
+0x3A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x0B,0x00,0x40,0x14,
+0x02,0x00,0x04,0x24,
+0x3A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x30,
+0x06,0x00,0x40,0x14,
+0x08,0x00,0x04,0x24,
+0x3A,0x64,0x63,0x90,
+0x04,0x00,0x04,0x24,
+0x01,0x00,0x02,0x24,
+0x04,0x00,0x63,0x30,
+0x0A,0x20,0x43,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xBF,0xAF,
+0x18,0x64,0x43,0x90,
+0x05,0x00,0x02,0x24,
+0xFF,0x00,0x63,0x30,
+0x05,0x00,0x62,0x10,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x10,0x37,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x63,0x30,
+0xF8,0xFF,0x60,0x10,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0xF2,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x6B,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x40,0x00,
+0xCA,0x50,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x2A,0x64,0x43,0x94,
+0x02,0x80,0x02,0x3C,
+0xFF,0xFF,0x63,0x30,
+0x8A,0x60,0x00,0x08,
+0x08,0x64,0x43,0xAC,
+0x02,0x80,0x03,0x3C,
+0x41,0x64,0x62,0x90,
+0xFF,0x00,0x84,0x30,
+0x03,0x00,0x40,0x10,
+0x21,0x28,0x00,0x00,
+0x41,0x64,0x60,0xA0,
+0x01,0x00,0x05,0x24,
+0x06,0x00,0x80,0x10,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x02,0x24,
+0x10,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x3C,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x28,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0xF4,0xFF,0xA0,0x10,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x02,0x80,0x02,0x3C,
+0x3C,0x64,0x43,0x90,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x62,0x2C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x09,0x32,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x02,0x80,0x02,0x3C,
+0xE8,0x03,0x03,0x24,
+0x64,0x64,0x43,0xAC,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x04,0x00,0x82,0x8C,
+0x02,0x00,0x03,0x24,
+0x21,0x80,0x80,0x00,
+0x02,0x17,0x02,0x00,
+0x03,0x00,0x42,0x30,
+0x06,0x00,0x43,0x10,
+0x02,0x80,0x11,0x3C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x18,0x64,0x22,0x92,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x40,0x10,
+0x10,0x00,0xA4,0x27,
+0x9A,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x18,0x64,0x23,0x92,
+0x02,0x80,0x02,0x3C,
+0xBC,0xEB,0x42,0x24,
+0xFF,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x66,0x8C,
+0x00,0x00,0x04,0x8E,
+0x04,0x00,0x05,0x8E,
+0x09,0xF8,0xC0,0x00,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x1A,0x64,0x43,0x90,
+0x0C,0x00,0x02,0x24,
+0x0F,0x00,0x63,0x30,
+0x05,0x00,0x62,0x10,
+0x10,0x00,0xA4,0x27,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE1,0x60,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x38,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x60,0x10,
+0x02,0x80,0x05,0x3C,
+0x3E,0x64,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x3E,0x64,0xA2,0xA0,
+0xA0,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE1,0x60,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x3D,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x28,0x64,0x60,0xA0,
+0xFF,0x00,0x85,0x30,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x39,0x64,0x60,0xA0,
+0x08,0x00,0xA4,0x2C,
+0x41,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x40,0x64,0x60,0xA0,
+0x18,0x64,0x45,0xA0,
+0x2A,0x00,0x80,0x10,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x05,0x00,
+0x84,0xF9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x60,0x1B,0xA5,0x24,
+0xD0,0x1B,0xA2,0x8C,
+0x00,0x70,0x03,0x3C,
+0x41,0xB0,0x04,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x02,0x80,0x05,0x3C,
+0x60,0x1B,0xA5,0x24,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x70,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0x02,0x80,0x05,0x3C,
+0x60,0x1B,0xA5,0x24,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x70,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x20,0x82,0x00,
+0x02,0x80,0x07,0x3C,
+0x41,0xB0,0x02,0x3C,
+0x01,0x00,0x03,0x24,
+0x00,0x00,0x44,0xAC,
+0x3B,0x64,0xE3,0xA0,
+0x3B,0x64,0xE6,0x90,
+0x02,0x80,0x02,0x3C,
+0xD0,0x1B,0xA4,0xAC,
+0x3C,0x64,0x46,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0x18,0x64,0x02,0x92,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x90,0x80,0x00,
+0x13,0x00,0x40,0x10,
+0xFF,0x00,0xB1,0x30,
+0x02,0x80,0x03,0x3C,
+0x5E,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x13,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x1A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0x06,0x00,0x40,0x10,
+0x08,0x00,0x02,0x24,
+0x00,0x00,0x44,0x96,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x83,0x30,
+0x0B,0x00,0x62,0x10,
+0x02,0x80,0x02,0x3C,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x12,0x34,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x60,0x61,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x38,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x16,0x00,0x60,0x14,
+0x00,0x10,0x82,0x34,
+0x00,0x00,0x42,0xA6,
+0x18,0x64,0x02,0x92,
+0x05,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0xED,0xFF,0x43,0x14,
+0x02,0x80,0x03,0x3C,
+0x3A,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x22,0x02,
+0xE8,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x39,0x64,0x82,0x90,
+0x02,0x80,0x03,0x3C,
+0x04,0x00,0x42,0x34,
+0x39,0x64,0x82,0xA0,
+0x2A,0x64,0x62,0x94,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x30,
+0x6B,0x61,0x00,0x08,
+0x08,0x64,0x62,0xAC,
+0x0C,0x00,0x04,0x24,
+0xAD,0x34,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x7A,0x61,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x02,0x80,0x03,0x3C,
+0x3D,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x3D,0x64,0x60,0xA0,
+0x02,0x80,0x04,0x3C,
+0x39,0x64,0x83,0x90,
+0xFD,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0x39,0x64,0x83,0xA0,
+0x39,0x64,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x30,
+0x4C,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x28,0x64,0xA2,0x90,
+0x02,0x80,0x04,0x3C,
+0x01,0x00,0x42,0x24,
+0x28,0x64,0xA2,0xA0,
+0x39,0x64,0x83,0x90,
+0xEF,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0x02,0x80,0x02,0x3C,
+0x39,0x64,0x83,0xA0,
+0x20,0x64,0x42,0x24,
+0x01,0x00,0x44,0x90,
+0x28,0x64,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x18,0x83,0x00,
+0x13,0x00,0x60,0x10,
+0x25,0xB0,0x06,0x3C,
+0x02,0x80,0x03,0x3C,
+0x10,0x37,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x3A,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x40,0x64,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xE2,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x40,0x64,0x62,0x90,
+0x10,0x00,0xBF,0x8F,
+0x18,0x00,0xBD,0x27,
+0x01,0x00,0x42,0x24,
+0x40,0x64,0x62,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x84,0x00,0xC4,0x34,
+0x80,0x00,0xC6,0x34,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0xC4,0x8C,
+0x02,0x80,0x08,0x3C,
+0x21,0x10,0x00,0x00,
+0x48,0x64,0x06,0x8D,
+0x42,0xB0,0x0A,0x3C,
+0x25,0x10,0x44,0x00,
+0x02,0x80,0x04,0x3C,
+0x50,0x64,0x88,0x8C,
+0x54,0x64,0x89,0x8C,
+0x00,0x00,0x45,0x91,
+0x21,0x10,0x46,0x00,
+0xFB,0xFF,0x04,0x24,
+0x24,0x28,0xA4,0x00,
+0x23,0x40,0x02,0x01,
+0x00,0x00,0x45,0xA1,
+0x04,0x00,0x00,0x11,
+0x01,0x00,0x06,0x24,
+0x80,0x10,0x08,0x00,
+0x21,0x10,0x48,0x00,
+0x80,0x30,0x02,0x00,
+0x01,0x00,0x04,0x24,
+0x59,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x04,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x10,0x00,0xBF,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x10,0x00,0xBF,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xBF,0x8F,
+0x18,0x00,0xBD,0x27,
+0x40,0x64,0x40,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x9A,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x3D,0x64,0x40,0xA0,
+0x28,0x64,0x60,0xA0,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x37,0x64,0x40,0xA0,
+0x39,0x64,0x60,0xA0,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x41,0x64,0x40,0xA0,
+0x40,0x64,0x60,0xA0,
+0x02,0x80,0x02,0x3C,
+0x19,0x64,0x44,0x90,
+0x01,0x00,0x05,0x24,
+0xAD,0x34,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0xA0,0x40,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x42,0x11,0x05,0x00,
+0x0F,0x00,0x46,0x30,
+0xE8,0xFF,0xBD,0x27,
+0x09,0x00,0xC3,0x28,
+0x14,0x00,0xBF,0xAF,
+0x14,0x00,0x60,0x10,
+0x10,0x00,0xB0,0xAF,
+0x82,0x16,0x05,0x00,
+0x01,0x00,0x42,0x30,
+0x14,0x00,0x40,0x10,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0xA2,0x00,
+0x44,0x00,0x40,0x14,
+0xC2,0x15,0x04,0x00,
+0x01,0x00,0x42,0x30,
+0x57,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x14,0xEC,0x63,0x24,
+0x21,0x18,0xC3,0x00,
+0x02,0x80,0x04,0x3C,
+0x3A,0x64,0x85,0x90,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x45,0x00,
+0x4E,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x24,0x10,0xA2,0x00,
+0x1E,0x00,0x40,0x10,
+0xC2,0x15,0x04,0x00,
+0x02,0x80,0x06,0x3C,
+0x39,0x64,0xC2,0x90,
+0xFD,0xFF,0x03,0x24,
+0x42,0xB0,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0xC2,0xA0,
+0x3D,0x64,0x60,0xA0,
+0x00,0x00,0x82,0x90,
+0xEF,0xFF,0x03,0x24,
+0x03,0x00,0x85,0x34,
+0x24,0x10,0x43,0x00,
+0x40,0x00,0x03,0x24,
+0x00,0x00,0x82,0xA0,
+0x00,0x00,0xA3,0xA0,
+0x39,0x64,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x30,
+0xE6,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x01,0x00,0x42,0x30,
+0x0A,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x14,0xEC,0x63,0x24,
+0x21,0x18,0xC3,0x00,
+0x02,0x80,0x04,0x3C,
+0x3A,0x64,0x85,0x90,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x45,0x00,
+0x23,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x06,0x3C,
+0x39,0x64,0xC2,0x90,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0xC2,0xA0,
+0x48,0x62,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x42,0xB0,0x04,0x3C,
+0x00,0x00,0x82,0x90,
+0xEF,0xFF,0x03,0x24,
+0x03,0x00,0x90,0x34,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA0,
+0x40,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x20,0x64,0x42,0x24,
+0x00,0x00,0x03,0xA2,
+0x04,0x00,0x43,0x90,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x63,0x30,
+0x80,0x30,0x03,0x00,
+0x21,0x30,0xC3,0x00,
+0x59,0x27,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x44,0x00,0x02,0x24,
+0x00,0x00,0x02,0xA2,
+0x32,0x62,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x04,0x24,
+0xDC,0x50,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x6B,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x40,0x00,
+0xCA,0x50,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x48,0x62,0x00,0x08,
+0x02,0x80,0x06,0x3C,
+0x82,0x16,0x05,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x01,0x00,0x42,0x30,
+0x14,0x00,0xBF,0xAF,
+0x0E,0x00,0x40,0x10,
+0x10,0x00,0xB0,0xAF,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0xA2,0x00,
+0x37,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x38,0x64,0x43,0x90,
+0x02,0x00,0x02,0x24,
+0xFF,0x00,0x63,0x30,
+0x4A,0x00,0x62,0x10,
+0x01,0x00,0x04,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xDC,0x50,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0xA2,0x00,
+0x0E,0x00,0x40,0x14,
+0x02,0x80,0x06,0x3C,
+0x39,0x64,0xC2,0x90,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0xC2,0xA0,
+0x39,0x64,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x30,
+0x18,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x39,0x64,0xC2,0x90,
+0xFD,0xFF,0x03,0x24,
+0x42,0xB0,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0xC2,0xA0,
+0x3D,0x64,0x60,0xA0,
+0x00,0x00,0x82,0x90,
+0xEF,0xFF,0x03,0x24,
+0x03,0x00,0x85,0x34,
+0x24,0x10,0x43,0x00,
+0x40,0x00,0x03,0x24,
+0x00,0x00,0x82,0xA0,
+0x00,0x00,0xA3,0xA0,
+0x39,0x64,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x30,
+0xEA,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x42,0xB0,0x04,0x3C,
+0x00,0x00,0x82,0x90,
+0xEF,0xFF,0x03,0x24,
+0x03,0x00,0x90,0x34,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA0,
+0x40,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x03,0xA2,
+0x20,0x64,0x42,0x24,
+0x04,0x00,0x43,0x90,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x63,0x30,
+0x80,0x30,0x03,0x00,
+0x21,0x30,0xC3,0x00,
+0x59,0x27,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x44,0x00,0x02,0x24,
+0x00,0x00,0x02,0xA2,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x81,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x0C,0x00,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0xAD,0x34,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0xFF,0x00,0xA5,0x30,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x12,0x00,0xA0,0x14,
+0xFF,0x00,0x90,0x30,
+0x4D,0x00,0x00,0x12,
+0x02,0x80,0x11,0x3C,
+0x39,0x64,0x22,0x92,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0x22,0xA2,
+0x1B,0x00,0x00,0x16,
+0x00,0x00,0x00,0x00,
+0x39,0x64,0x22,0x92,
+0xFD,0xFF,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0x22,0xA2,
+0x10,0x00,0xB0,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x3A,0x64,0x43,0x90,
+0x0F,0x00,0x02,0x24,
+0x0F,0x00,0x63,0x30,
+0x26,0x00,0x62,0x10,
+0x02,0x80,0x11,0x3C,
+0x39,0x64,0x22,0x92,
+0x01,0x00,0x03,0x24,
+0x01,0x00,0x04,0x24,
+0x01,0x00,0x42,0x34,
+0x39,0x64,0x22,0xA2,
+0x02,0x80,0x02,0x3C,
+0x37,0x64,0x43,0xA0,
+0xDC,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE7,0xFF,0x00,0x12,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x03,0x3C,
+0x37,0x64,0x64,0xA0,
+0x39,0x64,0x22,0x92,
+0x02,0x80,0x03,0x3C,
+0x20,0x64,0x63,0x24,
+0x02,0x00,0x42,0x34,
+0x39,0x64,0x22,0xA2,
+0x04,0x00,0x62,0x90,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x30,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x59,0x27,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x42,0xB0,0x02,0x3C,
+0x44,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x36,0x64,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xC6,0xFF,0x60,0x10,
+0x02,0x80,0x11,0x3C,
+0x39,0x64,0x22,0x92,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x04,0x24,
+0x04,0x00,0x42,0x34,
+0x39,0x64,0x22,0xA2,
+0x2A,0x64,0x66,0x94,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x05,0x24,
+0xFF,0xFF,0xC6,0x30,
+0xCA,0x50,0x00,0x0C,
+0x08,0x64,0x46,0xAC,
+0xF8,0x62,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0xFF,0x00,0xA5,0x30,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x03,0x00,0xA0,0x14,
+0xFF,0x00,0x91,0x30,
+0x42,0x00,0x20,0x12,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x10,0x3C,
+0x39,0x64,0x02,0x92,
+0xFB,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x39,0x64,0x02,0xA2,
+0x10,0x00,0xA0,0x14,
+0x08,0x64,0x60,0xAC,
+0x39,0x64,0x02,0x92,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0x02,0xA2,
+0x1A,0x00,0x20,0x16,
+0x00,0x00,0x00,0x00,
+0x39,0x64,0x02,0x92,
+0xFD,0xFF,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x39,0x64,0x02,0xA2,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x04,0x24,
+0x37,0x64,0x64,0xA0,
+0x39,0x64,0x02,0x92,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x42,0x34,
+0x39,0x64,0x02,0xA2,
+0x38,0x64,0x62,0x90,
+0x02,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x29,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0xDC,0x50,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xE8,0xFF,0x20,0x12,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x03,0x3C,
+0x37,0x64,0x64,0xA0,
+0x39,0x64,0x02,0x92,
+0x02,0x80,0x03,0x3C,
+0x20,0x64,0x63,0x24,
+0x02,0x00,0x42,0x34,
+0x39,0x64,0x02,0xA2,
+0x04,0x00,0x62,0x90,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x30,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x59,0x27,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x42,0xB0,0x02,0x3C,
+0x44,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x19,0x64,0x64,0x90,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0xAD,0x34,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x81,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x04,0x24,
+0xAD,0x34,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x60,0x63,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB2,0xAF,
+0x0C,0x00,0xB1,0xAF,
+0x08,0x00,0xB0,0xAF,
+0x21,0x40,0xE0,0x00,
+0x21,0x90,0xA0,0x03,
+0x21,0x60,0xC0,0x00,
+0x21,0x78,0x80,0x00,
+0x45,0x00,0xE0,0x14,
+0x21,0x50,0xA0,0x00,
+0x2B,0x10,0xA6,0x00,
+0x78,0x00,0x40,0x10,
+0xFF,0xFF,0x02,0x34,
+0x2B,0x10,0x46,0x00,
+0x8F,0x01,0x40,0x10,
+0x21,0x28,0xC0,0x00,
+0xFF,0x00,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x10,0x00,0x03,0x24,
+0x2B,0x10,0x46,0x00,
+0x18,0x00,0x04,0x24,
+0x21,0x30,0x60,0x00,
+0x0B,0x30,0x82,0x00,
+0x02,0x80,0x03,0x3C,
+0x06,0x10,0xC5,0x00,
+0xA4,0xF9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x86,0x00,
+0x23,0x30,0x44,0x00,
+0x08,0x00,0xC0,0x10,
+0x02,0x4C,0x0C,0x00,
+0x23,0x10,0x46,0x00,
+0x06,0x10,0x4F,0x00,
+0x04,0x18,0xCA,0x00,
+0x25,0x50,0x62,0x00,
+0x04,0x60,0xCC,0x00,
+0x04,0x78,0xCF,0x00,
+0x02,0x4C,0x0C,0x00,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x87,0x31,
+0x02,0x24,0x0F,0x00,
+0x12,0x18,0x00,0x00,
+0x10,0x28,0x00,0x00,
+0x00,0x14,0x05,0x00,
+0x25,0x28,0x44,0x00,
+0x18,0x00,0x67,0x00,
+0x12,0x58,0x00,0x00,
+0x2B,0x18,0xAB,0x00,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0xAC,0x00,
+0x2B,0x10,0xAC,0x00,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0xAB,0x00,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0xAC,0x00,
+0x0B,0x28,0x62,0x00,
+0x23,0x28,0xAB,0x00,
+0x1B,0x00,0xA9,0x00,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0xE4,0x31,
+0x12,0x18,0x00,0x00,
+0x10,0x40,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x66,0x64,0x00,0x08,
+0x18,0x00,0x67,0x00,
+0x2B,0x10,0xA7,0x00,
+0x0A,0x00,0x40,0x10,
+0xFF,0xFF,0x02,0x34,
+0x10,0x00,0xB2,0x8F,
+0x0C,0x00,0xB1,0x8F,
+0x08,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x21,0x18,0xA0,0x00,
+0x00,0x00,0xA4,0xAF,
+0x04,0x00,0xA5,0xAF,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x2B,0x10,0x47,0x00,
+0xD2,0x00,0x40,0x10,
+0x00,0x01,0xE3,0x2C,
+0xFF,0x00,0x02,0x3C,
+0x10,0x00,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x2B,0x10,0x47,0x00,
+0x18,0x00,0x04,0x24,
+0x21,0x28,0x60,0x00,
+0x0B,0x28,0x82,0x00,
+0x06,0x10,0xA8,0x00,
+0x02,0x80,0x03,0x3C,
+0xA4,0xF9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0xCE,0x00,0xC0,0x14,
+0x23,0x38,0x46,0x00,
+0x2B,0x10,0x0A,0x01,
+0x04,0x00,0x40,0x14,
+0x23,0x20,0xEC,0x01,
+0x2B,0x10,0xEC,0x01,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xE4,0x01,
+0x23,0x18,0x48,0x01,
+0x23,0x50,0x62,0x00,
+0x21,0x78,0x80,0x00,
+0x04,0x00,0x40,0x12,
+0x21,0xC0,0xE0,0x01,
+0x21,0xC8,0x40,0x01,
+0x00,0x00,0x58,0xAE,
+0x04,0x00,0x59,0xAE,
+0x00,0x00,0xA2,0x8F,
+0x04,0x00,0xA3,0x8F,
+0x10,0x00,0xB2,0x8F,
+0x0C,0x00,0xB1,0x8F,
+0x08,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x53,0x00,0xC0,0x10,
+0x01,0x00,0x02,0x24,
+0xFF,0xFF,0x02,0x34,
+0x2B,0x10,0x4C,0x00,
+0x59,0x00,0x40,0x14,
+0xFF,0x00,0x02,0x3C,
+0x00,0x01,0x83,0x2D,
+0x08,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0x0A,0x28,0x43,0x00,
+0x06,0x10,0xAC,0x00,
+0x02,0x80,0x03,0x3C,
+0xA4,0xF9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0x5B,0x00,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x23,0x50,0x4C,0x01,
+0x02,0x4C,0x0C,0x00,
+0xFF,0xFF,0x8D,0x31,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x24,0x0F,0x00,
+0x12,0x18,0x00,0x00,
+0x10,0x28,0x00,0x00,
+0x00,0x14,0x05,0x00,
+0x25,0x28,0x44,0x00,
+0x18,0x00,0x6D,0x00,
+0x12,0x58,0x00,0x00,
+0x2B,0x18,0xAB,0x00,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0xAC,0x00,
+0x2B,0x10,0xAC,0x00,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0xAB,0x00,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0xAC,0x00,
+0x0B,0x28,0x62,0x00,
+0x23,0x28,0xAB,0x00,
+0x1B,0x00,0xA9,0x00,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0xE4,0x31,
+0x12,0x18,0x00,0x00,
+0x10,0x40,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x6D,0x00,
+0x00,0x14,0x08,0x00,
+0x12,0x58,0x00,0x00,
+0x25,0x40,0x44,0x00,
+0x2B,0x18,0x0B,0x01,
+0x1B,0x00,0xA9,0x00,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x40,0x0C,0x01,
+0x2B,0x10,0x0C,0x01,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0x0B,0x01,
+0x21,0x18,0x0C,0x01,
+0x00,0x00,0x42,0x38,
+0x0B,0x40,0x62,0x00,
+0xAB,0xFF,0x40,0x12,
+0x23,0x78,0x0B,0x01,
+0x06,0xC0,0xCF,0x00,
+0x21,0xC8,0x00,0x00,
+0x00,0x00,0x58,0xAE,
+0x23,0x64,0x00,0x08,
+0x04,0x00,0x59,0xAE,
+0x1B,0x00,0x47,0x00,
+0x02,0x00,0xE0,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x02,0x34,
+0x12,0x60,0x00,0x00,
+0x2B,0x10,0x4C,0x00,
+0xAB,0xFF,0x40,0x10,
+0x00,0x01,0x83,0x2D,
+0xFF,0x00,0x02,0x3C,
+0x10,0x00,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x2B,0x10,0x4C,0x00,
+0x18,0x00,0x04,0x24,
+0x21,0x28,0x60,0x00,
+0x0B,0x28,0x82,0x00,
+0x02,0x80,0x03,0x3C,
+0x06,0x10,0xAC,0x00,
+0xA4,0xF9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0xA7,0xFF,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x23,0x38,0x46,0x00,
+0x04,0x60,0xCC,0x00,
+0x06,0x58,0xEA,0x00,
+0x02,0x4C,0x0C,0x00,
+0x1B,0x00,0x69,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x8D,0x31,
+0x06,0x18,0xEF,0x00,
+0x04,0x10,0xCA,0x00,
+0x25,0x50,0x43,0x00,
+0x02,0x24,0x0A,0x00,
+0x12,0x28,0x00,0x00,
+0x10,0x40,0x00,0x00,
+0x00,0x14,0x08,0x00,
+0x25,0x40,0x44,0x00,
+0x18,0x00,0xAD,0x00,
+0x12,0x28,0x00,0x00,
+0x2B,0x18,0x05,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x69,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x05,0x00,0x60,0x10,
+0x04,0x78,0xCF,0x00,
+0x21,0x40,0x0C,0x01,
+0x2B,0x10,0x0C,0x01,
+0x93,0x00,0x40,0x10,
+0x2B,0x10,0x05,0x01,
+0x23,0x40,0x05,0x01,
+0x1B,0x00,0x09,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x44,0x31,
+0x12,0x18,0x00,0x00,
+0x10,0x58,0x00,0x00,
+0x00,0x14,0x0B,0x00,
+0x25,0x58,0x44,0x00,
+0x18,0x00,0x6D,0x00,
+0x12,0x28,0x00,0x00,
+0x2B,0x18,0x65,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x09,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x77,0xFF,0x60,0x10,
+0x23,0x50,0x65,0x01,
+0x21,0x58,0x6C,0x01,
+0x2B,0x10,0x6C,0x01,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0x65,0x01,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0x6C,0x01,
+0x0B,0x58,0x62,0x00,
+0x41,0x64,0x00,0x08,
+0x23,0x50,0x65,0x01,
+0x08,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0x0A,0x28,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x06,0x10,0xA8,0x00,
+0xA4,0xF9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0x34,0xFF,0xC0,0x10,
+0x23,0x38,0x46,0x00,
+0x06,0x10,0xEC,0x00,
+0x04,0x18,0xC8,0x00,
+0x25,0x40,0x62,0x00,
+0x06,0x58,0xEA,0x00,
+0x02,0x6C,0x08,0x00,
+0x1B,0x00,0x6D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x11,0x31,
+0x06,0x10,0xEF,0x00,
+0x04,0x18,0xCA,0x00,
+0x25,0x50,0x62,0x00,
+0x02,0x24,0x0A,0x00,
+0x04,0x60,0xCC,0x00,
+0x12,0x80,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x14,0x09,0x00,
+0x25,0x48,0x44,0x00,
+0x12,0x28,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x11,0x02,
+0x12,0x70,0x00,0x00,
+0x2B,0x18,0x2E,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x6D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x0A,0x00,0x60,0x10,
+0x04,0x78,0xCF,0x00,
+0x21,0x48,0x28,0x01,
+0x2B,0x10,0x28,0x01,
+0x06,0x00,0x40,0x14,
+0xFF,0xFF,0xB0,0x24,
+0x2B,0x10,0x2E,0x01,
+0x03,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x10,0x26,
+0x21,0x48,0x28,0x01,
+0x23,0x48,0x2E,0x01,
+0x1B,0x00,0x2D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x44,0x31,
+0x12,0x28,0x00,0x00,
+0x10,0x58,0x00,0x00,
+0x00,0x14,0x0B,0x00,
+0x25,0x58,0x44,0x00,
+0x18,0x00,0xB1,0x00,
+0x12,0x70,0x00,0x00,
+0x2B,0x18,0x6E,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x2D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x0B,0x00,0x60,0x10,
+0x00,0x14,0x10,0x00,
+0x21,0x58,0x68,0x01,
+0x2B,0x10,0x68,0x01,
+0x06,0x00,0x40,0x14,
+0xFF,0xFF,0xA5,0x24,
+0x2B,0x10,0x6E,0x01,
+0x04,0x00,0x40,0x10,
+0x00,0x14,0x10,0x00,
+0xFF,0xFF,0xA5,0x24,
+0x21,0x58,0x68,0x01,
+0x00,0x14,0x10,0x00,
+0x25,0x10,0x45,0x00,
+0x23,0x58,0x6E,0x01,
+0x19,0x00,0x4C,0x00,
+0x10,0x28,0x00,0x00,
+0x2B,0x18,0x65,0x01,
+0x12,0x48,0x00,0x00,
+0x05,0x00,0x60,0x14,
+0x23,0x20,0x2C,0x01,
+0x07,0x00,0xAB,0x14,
+0x2B,0x10,0xE9,0x01,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x24,0x01,
+0x23,0x18,0xA8,0x00,
+0x23,0x28,0x62,0x00,
+0x21,0x48,0x80,0x00,
+0xEA,0xFE,0x40,0x12,
+0x23,0x18,0xE9,0x01,
+0x23,0x20,0x65,0x01,
+0x2B,0x10,0xE3,0x01,
+0x23,0x50,0x82,0x00,
+0x04,0x28,0xEA,0x00,
+0x06,0x18,0xC3,0x00,
+0x25,0xC0,0xA3,0x00,
+0x06,0xC8,0xCA,0x00,
+0x00,0x00,0x58,0xAE,
+0x23,0x64,0x00,0x08,
+0x04,0x00,0x59,0xAE,
+0x00,0x01,0xC3,0x2C,
+0x08,0x00,0x02,0x24,
+0x21,0x30,0x00,0x00,
+0xBD,0x63,0x00,0x08,
+0x0A,0x30,0x43,0x00,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0x0C,0x01,
+0xB7,0x64,0x00,0x08,
+0x0B,0x40,0x62,0x00,
+0x25,0xB0,0x03,0x3C,
+0x4D,0x00,0x64,0x34,
+0xF1,0x02,0x65,0x34,
+0x08,0x00,0x02,0x24,
+0x00,0x00,0x80,0xA0,
+0xEC,0x02,0x66,0x34,
+0x00,0x00,0xA2,0xA0,
+0xF0,0x02,0x63,0x34,
+0xFF,0x00,0x02,0x3C,
+0x00,0x00,0x60,0xA0,
+0x00,0x00,0xC2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x68,0x95,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x7F,0x00,0x02,0x3C,
+0x0D,0x98,0x44,0x34,
+0x80,0x04,0x03,0x3C,
+0x25,0x20,0x83,0x00,
+0x00,0x08,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x00,0x30,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x25,0x20,0x83,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0xD8,0x1B,0x44,0xAC,
+0xD0,0x1B,0x44,0xAC,
+0x08,0x00,0x63,0x34,
+0x86,0x00,0x04,0x24,
+0x00,0x00,0x64,0xA4,
+0xDC,0x1B,0x44,0xA4,
+0xD4,0x1B,0x40,0xAC,
+0xDE,0x1B,0x40,0xA4,
+0x08,0x00,0xE0,0x03,
+0xE0,0x1B,0x44,0xA4,
+0x77,0x65,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x42,0xB0,0x03,0x3C,
+0x01,0x00,0x63,0x34,
+0x02,0x00,0x02,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x00,0x00,0x62,0xA0,
+0x10,0x00,0xBF,0xAF,
+0x09,0x32,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x05,0x24,
+0x59,0x27,0x00,0x0C,
+0x00,0x50,0x06,0x24,
+0x1F,0x00,0x06,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x00,0x40,0xC6,0x34,
+0x03,0x00,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x59,0x27,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x03,0x64,0x34,
+0x30,0x96,0x42,0x24,
+0x00,0x00,0x82,0xAC,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xB6,0x00,0x63,0x34,
+0x00,0x00,0x64,0x90,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x62,0x24,
+0x48,0x01,0x03,0x24,
+0x70,0x37,0x43,0xAC,
+0x6C,0x37,0x43,0xAC,
+0xAB,0x1B,0x44,0xA0,
+0xE2,0x3D,0x40,0xA0,
+0x66,0x37,0x40,0xA0,
+0x8D,0x6D,0x00,0x0C,
+0x21,0x98,0x40,0x00,
+0xFD,0xFF,0x02,0x3C,
+0xFB,0xFF,0x03,0x3C,
+0x21,0xA0,0x60,0x02,
+0xFF,0xFF,0x55,0x34,
+0xFF,0xFF,0x76,0x34,
+0x21,0x88,0x00,0x00,
+0x02,0x80,0x1E,0x3C,
+0x02,0x80,0x17,0x3C,
+0x21,0x90,0x60,0x02,
+0x40,0x10,0x11,0x00,
+0x21,0x10,0x51,0x00,
+0x00,0x11,0x02,0x00,
+0x21,0x10,0x53,0x00,
+0xD4,0x1D,0x42,0x24,
+0x07,0x00,0x03,0x24,
+0xFF,0xFF,0x63,0x24,
+0x00,0x00,0x40,0xA4,
+0xFD,0xFF,0x61,0x04,
+0x02,0x00,0x42,0x24,
+0xC0,0x80,0x11,0x00,
+0x34,0x3F,0xC4,0x27,
+0x21,0x20,0x04,0x02,
+0x21,0x28,0x00,0x00,
+0x02,0x00,0x06,0x24,
+0xE4,0x1D,0x40,0xA6,
+0xC6,0x53,0x00,0x0C,
+0xE6,0x1D,0x40,0xA2,
+0x21,0x20,0x13,0x02,
+0xD4,0x23,0x83,0x8C,
+0x6A,0x5F,0xE7,0x92,
+0xBF,0xFF,0x02,0x24,
+0x24,0x28,0x62,0x00,
+0x01,0x00,0x02,0x24,
+0x61,0x00,0xE2,0x10,
+0x80,0x07,0xA6,0x34,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0xC3,0x00,
+0xFF,0xEF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0xD4,0x23,0x82,0xAC,
+0x21,0x30,0x14,0x02,
+0xD4,0x23,0xC4,0x8C,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x95,0x00,
+0x24,0x20,0x96,0x00,
+0xFF,0xFD,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0xFF,0xFB,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xD8,0x23,0xC5,0x8C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0xE7,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0xFF,0xFF,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xFF,0x7F,0x42,0x34,
+0xC0,0xFF,0x03,0x24,
+0x24,0x28,0xA2,0x00,
+0x24,0x20,0x83,0x00,
+0x1F,0x00,0x02,0x3C,
+0x01,0x00,0x31,0x26,
+0x25,0x28,0xA2,0x00,
+0x08,0x00,0x84,0x34,
+0x20,0x00,0x22,0x2A,
+0xD4,0x23,0xC4,0xAC,
+0xD8,0x23,0xC5,0xAC,
+0xC3,0xFF,0x40,0x14,
+0x30,0x00,0x52,0x26,
+0x02,0x80,0x04,0x3C,
+0x88,0x1E,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0xC6,0x53,0x00,0x0C,
+0x20,0x00,0x06,0x24,
+0x02,0x80,0x02,0x3C,
+0x69,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x3C,0x00,0x60,0x10,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x62,0x24,
+0x25,0x03,0x40,0xA0,
+0xCB,0x70,0x00,0x74,
+0x24,0x03,0x40,0xA0,
+0xE1,0x71,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x42,0x6D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE9,0x6C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x80,0x09,0x3C,
+0x02,0x80,0x0A,0x3C,
+0x02,0x80,0x0B,0x3C,
+0x02,0x80,0x0C,0x3C,
+0x02,0x80,0x0D,0x3C,
+0x02,0x80,0x0E,0x3C,
+0x02,0x80,0x0F,0x3C,
+0x88,0x54,0x22,0x25,
+0x90,0x54,0x43,0x25,
+0x98,0x54,0x64,0x25,
+0xA0,0x54,0x85,0x25,
+0xA8,0x54,0xA6,0x25,
+0xB0,0x54,0xC7,0x25,
+0xB8,0x54,0xE8,0x25,
+0x38,0x00,0xBD,0x27,
+0x04,0x00,0x42,0xAC,
+0x88,0x54,0x22,0xAD,
+0x04,0x00,0x63,0xAC,
+0x90,0x54,0x43,0xAD,
+0x04,0x00,0x84,0xAC,
+0x98,0x54,0x64,0xAD,
+0x04,0x00,0xA5,0xAC,
+0xA0,0x54,0x85,0xAD,
+0x04,0x00,0xC6,0xAC,
+0xA8,0x54,0xA6,0xAD,
+0x04,0x00,0xE7,0xAC,
+0xB0,0x54,0xC7,0xAD,
+0xB8,0x54,0xE8,0xAD,
+0x08,0x00,0xE0,0x03,
+0x04,0x00,0x08,0xAD,
+0x02,0x80,0x02,0x3C,
+0x6B,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x9E,0xFF,0x67,0x14,
+0x80,0x0F,0xA2,0x34,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0xC3,0x00,
+0xCF,0x65,0x00,0x08,
+0x00,0x10,0x42,0x34,
+0x83,0x6E,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0xB6,0x70,0x00,0x74,
+0x24,0x39,0x80,0xAE,
+0x2F,0x71,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x5E,0x5F,0x64,0x90,
+0x92,0x00,0x02,0x24,
+0x03,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x69,0x71,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0xCA,0x71,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0xF9,0x65,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0x14,0x99,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x18,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x00,0x00,0x43,0xAC,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x02,0x26,
+0xFF,0xFF,0x50,0x30,
+0x64,0x00,0x03,0x2E,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x02,0x26,
+0x64,0x40,0x00,0x0C,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x65,0x26,
+0xA4,0x5F,0x40,0xA4,
+0x28,0x1C,0xA4,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x42,0x34,
+0xF0,0xFF,0x03,0x3C,
+0x00,0x00,0x47,0x90,
+0xFF,0xFF,0x63,0x34,
+0x0F,0xFF,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x02,0x00,0x02,0x24,
+0x01,0x00,0x06,0x24,
+0x02,0x80,0x03,0x3C,
+0xE1,0x3D,0xA2,0xA0,
+0x02,0x80,0x02,0x3C,
+0x28,0x1C,0xA4,0xAC,
+0x78,0x5F,0x66,0xA0,
+0x88,0x5F,0x40,0xA0,
+0xFF,0x07,0x03,0x24,
+0xF0,0xFF,0x02,0x24,
+0x02,0x80,0x15,0x3C,
+0xAA,0x1B,0xA2,0xA0,
+0xAE,0x1B,0xA3,0xA4,
+0x00,0x70,0x02,0x24,
+0xFF,0xFF,0x03,0x24,
+0x10,0x00,0xE7,0x30,
+0xA8,0x1B,0xA6,0xA0,
+0xAC,0x1B,0xA2,0xA4,
+0x49,0xFC,0xA3,0xA2,
+0x65,0x00,0xE0,0x14,
+0xB0,0x1B,0xA0,0xA4,
+0x02,0x80,0x14,0x3C,
+0x21,0x80,0x00,0x00,
+0x21,0x88,0x00,0x00,
+0xA8,0xFA,0x92,0x26,
+0xFF,0x00,0x24,0x32,
+0xC3,0x58,0x00,0x0C,
+0x21,0x28,0x12,0x02,
+0x08,0x00,0x03,0x26,
+0xFF,0xFF,0x70,0x30,
+0x01,0x00,0x22,0x26,
+0x80,0x00,0x03,0x2E,
+0xF8,0xFF,0x60,0x14,
+0xFF,0xFF,0x51,0x30,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0xA8,0xFA,0x84,0x96,
+0x20,0x00,0x63,0x30,
+0x5E,0x00,0x60,0x10,
+0x12,0x87,0x02,0x34,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x02,0x24,
+0x48,0xFC,0x62,0xA0,
+0x48,0xFC,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x5F,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0x4C,0x87,0x02,0x3C,
+0x54,0x00,0x65,0x34,
+0x00,0xE0,0x42,0x34,
+0x50,0x00,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x12,0x01,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0xA4,0xAC,
+0x60,0x1B,0x46,0x24,
+0x21,0x60,0x00,0x00,
+0x10,0x00,0x05,0x24,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x02,0x26,
+0x21,0x18,0xD0,0x00,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x04,0x2E,
+0x9C,0x1D,0x65,0xA0,
+0x64,0x1D,0x65,0xA0,
+0xF9,0xFF,0x80,0x14,
+0x80,0x1D,0x65,0xA0,
+0x01,0x00,0x8C,0x25,
+0x02,0x00,0x82,0x2D,
+0xF4,0xFF,0x40,0x14,
+0x0E,0x00,0xC6,0x24,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x46,0x24,
+0x21,0x80,0x00,0x00,
+0x04,0x00,0x05,0x24,
+0x01,0x00,0x02,0x26,
+0x21,0x18,0x06,0x02,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x04,0x2E,
+0xC6,0x1D,0x60,0xA0,
+0xFA,0xFF,0x80,0x14,
+0xB8,0x1D,0x65,0xA0,
+0x12,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x4A,0xFC,0x43,0xA0,
+0x02,0x80,0x12,0x3C,
+0x5E,0x5F,0x43,0x92,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x48,0x58,0x00,0x0C,
+0x4C,0xFC,0x43,0xA0,
+0x49,0xFC,0xA5,0x26,
+0xF3,0x57,0x00,0x0C,
+0xFA,0x01,0x04,0x24,
+0x48,0x58,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x25,0xB0,0x05,0x3C,
+0x48,0x37,0x84,0x24,
+0x50,0x00,0xA5,0x34,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x60,0x1B,0x65,0x26,
+0x01,0x00,0x02,0x24,
+0x06,0x00,0x03,0x24,
+0x05,0x00,0x04,0x24,
+0x33,0x1C,0xA2,0xA0,
+0x66,0x57,0x00,0x0C,
+0xE0,0x3D,0xA3,0xA0,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x14,0x3C,
+0x21,0x20,0x00,0x00,
+0x80,0x00,0x05,0x24,
+0xB5,0x57,0x00,0x0C,
+0xA8,0xFA,0x86,0x26,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0xA8,0xFA,0x84,0x96,
+0x20,0x00,0x63,0x30,
+0xA6,0xFF,0x60,0x14,
+0x02,0x80,0x03,0x3C,
+0x12,0x87,0x02,0x34,
+0xA2,0xFF,0x82,0x10,
+0x02,0x80,0x03,0x3C,
+0x48,0xFC,0x60,0xA0,
+0x48,0xFC,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xA5,0xFF,0x40,0x10,
+0x25,0xB0,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x5A,0x5F,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x43,0x30,
+0xAA,0x00,0x60,0x14,
+0x04,0x00,0x42,0x30,
+0x9D,0xFF,0x40,0x10,
+0x25,0xB0,0x03,0x3C,
+0x25,0xB0,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x50,0x00,0x84,0x34,
+0xF7,0xFA,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xA8,0xFA,0x86,0x26,
+0x7B,0x00,0xC4,0x90,
+0x68,0x00,0xC3,0x90,
+0x02,0x80,0x07,0x3C,
+0x02,0x80,0x02,0x3C,
+0x1F,0x00,0x63,0x30,
+0x02,0x00,0x85,0x2C,
+0x4A,0xFC,0x43,0xA0,
+0xD7,0x00,0xA0,0x14,
+0x4D,0xFC,0xE4,0xA0,
+0x79,0x00,0xC2,0x90,
+0x02,0x80,0x16,0x3C,
+0x03,0x00,0x42,0x30,
+0x4E,0xFC,0xC2,0xA2,
+0x4D,0xFC,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x2C,
+0xC7,0x00,0x40,0x14,
+0xBF,0xFF,0x03,0x24,
+0xA8,0xFA,0x82,0x26,
+0x7D,0x00,0x44,0x90,
+0x60,0x1B,0x65,0x8E,
+0x69,0x00,0x46,0x90,
+0x01,0x00,0x83,0x30,
+0xBF,0xFF,0x02,0x24,
+0x24,0x28,0xA2,0x00,
+0x80,0x19,0x03,0x00,
+0x04,0x00,0x84,0x30,
+0x01,0x00,0xC6,0x30,
+0x25,0x28,0xA3,0x00,
+0x83,0x20,0x04,0x00,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0xD0,0x2C,
+0x4B,0xFC,0x44,0xA0,
+0x60,0x1B,0x65,0xAE,
+0xA8,0xFA,0x82,0x26,
+0x7C,0x00,0x44,0x90,
+0x02,0x80,0x12,0x3C,
+0xC0,0x46,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x00,0x16,
+0x21,0x40,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x67,0x5F,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0x62,0x10,
+0xFC,0xFF,0x08,0x24,
+0x21,0x40,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x6C,0x5F,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x64,0x00,0x83,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xA8,0xFA,0x4A,0x24,
+0x60,0x1B,0x69,0x24,
+0x21,0x60,0x00,0x00,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x02,0x26,
+0x21,0x30,0x30,0x01,
+0x03,0x00,0x03,0x2E,
+0x08,0x00,0x04,0x2E,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x07,0x2E,
+0x04,0x00,0x60,0x14,
+0x21,0x88,0x00,0x00,
+0x01,0x00,0x11,0x24,
+0x02,0x00,0x02,0x24,
+0x0A,0x88,0x44,0x00,
+0x21,0x10,0x51,0x01,
+0x61,0x00,0x43,0x90,
+0x55,0x00,0x44,0x90,
+0x5B,0x00,0x45,0x90,
+0x21,0x18,0x03,0x01,
+0x21,0x20,0x04,0x01,
+0x21,0x28,0x05,0x01,
+0x9C,0x1D,0xC3,0xA0,
+0x64,0x1D,0xC4,0xA0,
+0xEB,0xFF,0xE0,0x14,
+0x80,0x1D,0xC5,0xA0,
+0x01,0x00,0x8C,0x25,
+0x02,0x00,0x82,0x2D,
+0x0E,0x00,0x29,0x25,
+0xE5,0xFF,0x40,0x14,
+0x03,0x00,0x4A,0x25,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x60,0x1B,0x47,0x24,
+0xA8,0xFA,0x66,0x24,
+0x21,0x80,0x00,0x00,
+0x03,0x00,0x02,0x2E,
+0x21,0x20,0x07,0x02,
+0x90,0x00,0x40,0x10,
+0x08,0x00,0x03,0x2E,
+0x71,0x00,0xC3,0x90,
+0x6E,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xC6,0x1D,0x82,0xA0,
+0xB8,0x1D,0x83,0xA0,
+0x01,0x00,0x02,0x26,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x03,0x2E,
+0xF4,0xFF,0x60,0x14,
+0x03,0x00,0x02,0x2E,
+0x4E,0xFC,0xC3,0x92,
+0x03,0x00,0x02,0x24,
+0x52,0xFF,0x62,0x14,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xA8,0xFA,0x4F,0x24,
+0x78,0xDE,0x71,0x24,
+0x21,0x60,0x00,0x00,
+0x21,0x68,0x00,0x00,
+0x21,0x80,0x00,0x00,
+0x21,0x70,0xAF,0x01,
+0x21,0x10,0xD0,0x01,
+0x73,0x00,0x44,0x90,
+0x21,0x18,0xB0,0x01,
+0x00,0x19,0x03,0x00,
+0x0F,0x00,0x8A,0x30,
+0x21,0x58,0x71,0x00,
+0x02,0x49,0x04,0x00,
+0x21,0x38,0x00,0x00,
+0x21,0x40,0x67,0x01,
+0x00,0x00,0x03,0x91,
+0x00,0x31,0x09,0x00,
+0x01,0x00,0xE7,0x24,
+0x02,0x11,0x03,0x00,
+0x00,0x21,0x02,0x00,
+0x0F,0x00,0x63,0x30,
+0x2B,0x10,0x49,0x00,
+0x0A,0x20,0xC2,0x00,
+0x2B,0x28,0x6A,0x00,
+0x00,0x00,0xA5,0x38,
+0x25,0x18,0x83,0x00,
+0xFF,0xFF,0xE7,0x30,
+0x25,0x20,0x8A,0x00,
+0x0A,0x18,0x85,0x00,
+0x10,0x00,0xE2,0x2C,
+0xEF,0xFF,0x40,0x14,
+0x00,0x00,0x03,0xA1,
+0x01,0x00,0x02,0x26,
+0xFF,0xFF,0x50,0x30,
+0x03,0x00,0x03,0x2E,
+0xE3,0xFF,0x60,0x14,
+0x21,0x10,0xD0,0x01,
+0x01,0x00,0x8C,0x25,
+0x02,0x00,0x82,0x2D,
+0xDC,0xFF,0x40,0x14,
+0x03,0x00,0xAD,0x25,
+0xC0,0x66,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x02,0x25,
+0x00,0x46,0x02,0x00,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x03,0x46,0x08,0x00,
+0xA8,0xFA,0x4A,0x24,
+0x60,0x1B,0x69,0x24,
+0x3C,0x67,0x00,0x08,
+0x21,0x60,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x50,0x00,0x84,0x34,
+0xBA,0xFA,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xA8,0xFA,0x82,0x92,
+0xA8,0xFA,0x86,0x26,
+0x50,0x00,0xC3,0x90,
+0x01,0x00,0xC5,0x90,
+0x21,0x20,0x40,0x00,
+0x02,0x80,0x07,0x3C,
+0x10,0x00,0xA2,0xA3,
+0x29,0x00,0x02,0x24,
+0x4D,0xFC,0xE3,0xA0,
+0x11,0x00,0xA5,0xA3,
+0x47,0x00,0x82,0x10,
+0x02,0x80,0x12,0x3C,
+0xA8,0xFA,0x86,0x26,
+0x68,0x00,0xC2,0x90,
+0x4D,0xFC,0xE4,0x90,
+0x02,0x80,0x03,0x3C,
+0x1F,0x00,0x42,0x30,
+0x04,0x00,0x84,0x2C,
+0x29,0x00,0x80,0x14,
+0x4A,0xFC,0x62,0xA0,
+0x7A,0x00,0xC4,0x90,
+0x60,0x1B,0x65,0x8E,
+0x79,0x00,0xC6,0x90,
+0x01,0x00,0x83,0x30,
+0xBF,0xFF,0x02,0x24,
+0x24,0x28,0xA2,0x00,
+0x80,0x19,0x03,0x00,
+0x04,0x00,0x84,0x30,
+0x25,0x28,0xA3,0x00,
+0x03,0x00,0xC6,0x30,
+0x83,0x20,0x04,0x00,
+0x02,0x80,0x16,0x3C,
+0x02,0x80,0x02,0x3C,
+0x4B,0xFC,0x44,0xA0,
+0x4E,0xFC,0xC6,0xA2,
+0x60,0x1B,0x65,0xAE,
+0x4D,0xFC,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x42,0x2C,
+0x06,0x00,0x40,0x14,
+0x21,0x80,0x00,0x00,
+0xA8,0xFA,0x83,0x26,
+0x69,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x01,0x00,0x50,0x2C,
+0xA8,0xFA,0x82,0x26,
+0x51,0x00,0x44,0x90,
+0x29,0x67,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x62,0x8E,
+0x02,0x80,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x21,0x80,0x00,0x00,
+0x4B,0xFC,0x80,0xA0,
+0x26,0x67,0x00,0x08,
+0x60,0x1B,0x62,0xAE,
+0x02,0x80,0x16,0x3C,
+0x10,0x67,0x00,0x08,
+0x02,0x00,0x02,0x24,
+0x60,0x1B,0x64,0x8E,
+0xBF,0xFF,0x02,0x24,
+0x02,0x80,0x16,0x3C,
+0x24,0x20,0x82,0x00,
+0x02,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x4E,0xFC,0xC3,0xA2,
+0x4B,0xFC,0x40,0xA0,
+0xCE,0x67,0x00,0x08,
+0x60,0x1B,0x64,0xAE,
+0x21,0x28,0x07,0x02,
+0x06,0x00,0x60,0x10,
+0x21,0x20,0xA0,0x00,
+0x67,0x00,0xC3,0x90,
+0x6F,0x00,0xC2,0x90,
+0xB8,0x1D,0xA3,0xA0,
+0x66,0x67,0x00,0x08,
+0xC6,0x1D,0xA2,0xA0,
+0x72,0x00,0xC3,0x90,
+0x70,0x00,0xC2,0x90,
+0x65,0x67,0x00,0x08,
+0xC6,0x1D,0x82,0xA0,
+0xFF,0x00,0xA3,0x30,
+0x81,0x00,0x02,0x24,
+0xB7,0xFF,0x62,0x14,
+0x01,0x00,0x02,0x24,
+0x54,0x00,0xC3,0x90,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x62,0x10,
+0x02,0x00,0x02,0x24,
+0x04,0x00,0x62,0x10,
+0x11,0x00,0x02,0x24,
+0x02,0x80,0x12,0x3C,
+0xB6,0x67,0x00,0x08,
+0x5E,0x5F,0x42,0xA2,
+0x22,0x00,0x02,0x24,
+0xB6,0x67,0x00,0x08,
+0x5E,0x5F,0x42,0xA2,
+0x02,0x80,0x12,0x3C,
+0x12,0x00,0x02,0x24,
+0xB6,0x67,0x00,0x08,
+0x5E,0x5F,0x42,0xA2,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x25,0xB0,0x10,0x3C,
+0x18,0x03,0x03,0x36,
+0x40,0xA0,0x42,0x24,
+0x00,0x00,0x62,0xAC,
+0x20,0x00,0xBF,0xAF,
+0x45,0x66,0x00,0x0C,
+0x1C,0x00,0xB1,0xAF,
+0xBC,0x68,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4F,0x6B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x35,0x6C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF3,0x6E,0x00,0x74,
+0x00,0x00,0x00,0x00,
+0x9B,0x6B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4D,0x65,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x92,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x03,0x36,
+0x00,0x00,0x62,0x94,
+0x02,0x80,0x11,0x3C,
+0x40,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA4,
+0x8C,0x65,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x5A,0x65,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x79,0x65,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x6C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xBC,0x6B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x04,0x3C,
+0x4C,0x7C,0x84,0x24,
+0x1E,0x6C,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x01,0x80,0x04,0x3C,
+0x88,0x82,0x84,0x24,
+0x1E,0x6C,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x01,0x80,0x04,0x3C,
+0x01,0x8F,0x84,0x24,
+0x1E,0x6C,0x00,0x0C,
+0x04,0x00,0x05,0x24,
+0x38,0x5B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x04,0x3C,
+0xEC,0x9D,0x84,0x24,
+0x1E,0x6C,0x00,0x0C,
+0x03,0x00,0x05,0x24,
+0x60,0x1B,0x23,0x26,
+0xE0,0x3D,0x64,0x90,
+0x14,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x68,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x67,0x00,0x60,0x10,
+0x43,0x00,0x02,0x36,
+0x07,0x00,0x02,0x24,
+0x0C,0x00,0x62,0x10,
+0x03,0x00,0x02,0x24,
+0x25,0xB0,0x04,0x3C,
+0x43,0x00,0x85,0x34,
+0x10,0x02,0x86,0x34,
+0x10,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xA0,
+0xD8,0x00,0x84,0x34,
+0x00,0x00,0xC3,0xA0,
+0x00,0x00,0x82,0x90,
+0x80,0xFF,0x03,0x24,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA0,
+0x61,0x65,0x00,0x0C,
+0x25,0xB0,0x10,0x3C,
+0x44,0x00,0x03,0x36,
+0x00,0x00,0x62,0x94,
+0x02,0x80,0x04,0x3C,
+0x20,0xEC,0x84,0x24,
+0xC0,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA4,
+0x13,0x57,0x00,0x0C,
+0x97,0x02,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x5B,0x5F,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x60,0xEC,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x5A,0x5F,0x45,0x90,
+0x5F,0x5F,0x66,0x90,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x70,0xEC,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x5E,0x5F,0x45,0x90,
+0x49,0xFC,0x66,0x90,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x67,0x5F,0x47,0x90,
+0x4B,0xFC,0x62,0x90,
+0x02,0x80,0x04,0x3C,
+0x84,0xEC,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0xEE,0x5A,0x00,0x0C,
+0x80,0x0C,0x04,0x36,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x04,0x3C,
+0x69,0x5F,0x65,0x90,
+0x66,0x5F,0x86,0x90,
+0x02,0x80,0x04,0x3C,
+0x21,0x38,0x40,0x00,
+0x13,0x57,0x00,0x0C,
+0xA0,0xEC,0x84,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x6B,0x5F,0x66,0x90,
+0x6A,0x5F,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0xBC,0xEC,0x84,0x24,
+0x60,0x1B,0x26,0x8E,
+0x02,0x80,0x02,0x3C,
+0x4A,0xFC,0x45,0x90,
+0x82,0x31,0x06,0x00,
+0x02,0x80,0x04,0x3C,
+0xD0,0xEC,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0x01,0x00,0xC6,0x30,
+0x02,0x80,0x02,0x3C,
+0x34,0x64,0x46,0x94,
+0x02,0x80,0x03,0x3C,
+0x6C,0x5F,0x65,0x90,
+0x02,0x80,0x04,0x3C,
+0xF8,0xEC,0x84,0x24,
+0x13,0x57,0x00,0x0C,
+0xFF,0xFF,0xC6,0x30,
+0x60,0x1B,0x23,0x26,
+0x02,0x80,0x02,0x3C,
+0x48,0xFC,0x45,0x90,
+0xEC,0x3D,0x66,0x90,
+0x02,0x80,0x04,0x3C,
+0x13,0x57,0x00,0x0C,
+0x24,0xED,0x84,0x24,
+0x02,0x80,0x04,0x3C,
+0x08,0x00,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x1B,0x3E,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x77,0x65,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD8,0x00,0x04,0x36,
+0x00,0x00,0x40,0xA0,
+0x5C,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB8,0xFF,0xBD,0x27,
+0x24,0x00,0xB1,0xAF,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x5A,0x5F,0x42,0x90,
+0x25,0xB0,0x11,0x3C,
+0x58,0x00,0x25,0x36,
+0x10,0x00,0xA2,0xAF,
+0x4C,0x81,0x02,0x3C,
+0x00,0xE0,0x42,0x34,
+0x00,0x00,0xA2,0xAC,
+0xFF,0xFF,0x04,0x24,
+0x96,0x01,0x03,0x24,
+0x28,0x28,0x02,0x24,
+0x5C,0x00,0x26,0x36,
+0x60,0x00,0x27,0x36,
+0x64,0x00,0x28,0x36,
+0x8A,0x00,0x29,0x36,
+0x00,0x00,0xC3,0xAC,
+0x89,0x00,0x2A,0x36,
+0x00,0x00,0xE4,0xAC,
+0x09,0x00,0x03,0x24,
+0x00,0x00,0x04,0xAD,
+0x00,0x00,0x22,0xA5,
+0x0E,0x0E,0x02,0x3C,
+0x00,0x00,0x43,0xA1,
+0x0A,0x0A,0x42,0x34,
+0x13,0x00,0x03,0x24,
+0x8C,0x00,0x2B,0x36,
+0x90,0x00,0x2C,0x36,
+0x00,0x00,0x62,0xAD,
+0x91,0x00,0x2D,0x36,
+0x00,0x00,0x83,0xA1,
+0x40,0x00,0x02,0x24,
+0x3A,0x01,0x03,0x24,
+0x92,0x00,0x2E,0x36,
+0x00,0x00,0xA2,0xA1,
+0x00,0x00,0xC3,0xA5,
+0x25,0xB0,0x03,0x3C,
+0x21,0x00,0x02,0x24,
+0xB5,0x00,0x63,0x34,
+0x00,0x00,0x62,0xA0,
+0x10,0x00,0xA2,0x8F,
+0x12,0x00,0x03,0x24,
+0x7C,0x01,0x43,0x10,
+0x07,0x07,0x02,0x3C,
+0x07,0x07,0x42,0x34,
+0xA0,0x00,0x24,0x36,
+0x02,0x00,0x03,0x3C,
+0x00,0x00,0x82,0xAC,
+0xA4,0x00,0x25,0x36,
+0x00,0x07,0x63,0x34,
+0x00,0xC0,0x02,0x3C,
+0xA8,0x00,0x26,0x36,
+0x00,0x00,0xA3,0xAC,
+0x00,0xC2,0x42,0x34,
+0x02,0x80,0x03,0x3C,
+0x00,0x00,0xC2,0xAC,
+0x60,0x1B,0x62,0x24,
+0xAC,0x1B,0x45,0x94,
+0xAE,0x1B,0x46,0x94,
+0xAA,0x1B,0x42,0x90,
+0x02,0x80,0x03,0x3C,
+0x21,0xB0,0x07,0x3C,
+0x14,0x00,0xA2,0xA3,
+0x69,0x5F,0x63,0x90,
+0x20,0xB0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x18,0x00,0xA3,0xAF,
+0x23,0xB0,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x24,0xB0,0x08,0x3C,
+0xFF,0x1F,0x04,0x3C,
+0x25,0xB0,0x1E,0x3C,
+0xFF,0xFF,0x84,0x34,
+0x21,0x38,0xA7,0x00,
+0x21,0x40,0xC8,0x00,
+0x21,0x28,0xA2,0x00,
+0x21,0x30,0xC3,0x00,
+0x24,0x40,0x04,0x01,
+0x24,0x28,0xA4,0x00,
+0x24,0x38,0xE4,0x00,
+0x24,0x30,0xC4,0x00,
+0x35,0x00,0x02,0x24,
+0x20,0x00,0xC4,0x37,
+0x00,0x00,0x82,0xA0,
+0x22,0x00,0x03,0x24,
+0x09,0x00,0x02,0x24,
+0x03,0x05,0xC9,0x37,
+0x60,0x05,0xCA,0x37,
+0x00,0x00,0x23,0xA1,
+0x00,0x00,0x42,0xA1,
+0x25,0xB0,0x02,0x3C,
+0xD8,0x00,0x42,0x34,
+0xAC,0x00,0xCB,0x37,
+0xF8,0x00,0xCC,0x37,
+0xB0,0x00,0xCD,0x37,
+0x08,0x01,0xCE,0x37,
+0x00,0x00,0x65,0xAD,
+0x00,0x00,0x87,0xAD,
+0x00,0x00,0xA6,0xAD,
+0x00,0x00,0xC8,0xAD,
+0x00,0x00,0x40,0xA0,
+0x14,0x00,0xA2,0x93,
+0x25,0xB0,0x03,0x3C,
+0xB4,0x00,0x63,0x34,
+0x00,0x00,0x62,0xA0,
+0xB6,0x00,0xD1,0x37,
+0x04,0x00,0x03,0x24,
+0xFF,0xFF,0x02,0x24,
+0xB9,0x00,0xD2,0x37,
+0x00,0x00,0x23,0xA2,
+0xBA,0x00,0xD3,0x37,
+0x00,0x00,0x42,0xA2,
+0x0F,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA6,
+0xFF,0xCF,0x03,0x24,
+0x3F,0x3F,0x02,0x24,
+0xDC,0x00,0xD4,0x37,
+0x16,0x01,0xD5,0x37,
+0x00,0x00,0x83,0xAE,
+0x00,0x00,0xA2,0xA6,
+0x2F,0x00,0x02,0x3C,
+0x00,0x10,0x03,0x24,
+0x17,0x32,0x42,0x34,
+0x18,0x01,0xD6,0x37,
+0x1A,0x01,0xD7,0x37,
+0xD0,0x01,0xD8,0x37,
+0x00,0x00,0xC0,0xA6,
+0x00,0x00,0xE3,0xA6,
+0x00,0x00,0x02,0xAF,
+0x5E,0x00,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x17,0x43,0x63,0x34,
+0xD4,0x01,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x10,0x00,0x02,0x3C,
+0x20,0x53,0x42,0x34,
+0xD8,0x01,0xDF,0x37,
+0x00,0x00,0xE2,0xAF,
+0x25,0xB0,0x02,0x3C,
+0x44,0xA4,0x03,0x34,
+0xDC,0x01,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x25,0xB0,0x03,0x3C,
+0x1A,0x06,0x02,0x24,
+0xE0,0x01,0x63,0x34,
+0x00,0x00,0x62,0xA4,
+0x25,0xB0,0x02,0x3C,
+0x30,0x30,0x03,0x24,
+0xF4,0x01,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0xC2,0x00,0x02,0x3C,
+0x51,0x10,0x42,0x34,
+0x26,0x00,0x03,0x24,
+0xF8,0x01,0xD0,0x37,
+0x00,0x02,0xCF,0x37,
+0x00,0x00,0x02,0xAE,
+0x03,0x02,0xD9,0x37,
+0x00,0x00,0xE3,0xA5,
+0x04,0x00,0x03,0x24,
+0x00,0x00,0x23,0xA3,
+0x18,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0xD4,0x00,0x40,0x14,
+0x36,0x02,0xC2,0x37,
+0x00,0x00,0x43,0xA0,
+0x02,0x80,0x0B,0x3C,
+0x5E,0x5F,0x66,0x91,
+0x25,0xB0,0x09,0x3C,
+0x34,0x02,0x23,0x35,
+0x80,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA4,
+0x38,0x02,0x24,0x35,
+0x37,0x02,0x25,0x35,
+0x07,0x00,0x02,0x24,
+0x22,0x00,0x03,0x24,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0xA2,0xA0,
+0xD6,0x00,0xC3,0x10,
+0x1B,0x1B,0x02,0x3C,
+0x13,0x13,0x02,0x3C,
+0x13,0x13,0x42,0x34,
+0x60,0x01,0x23,0x35,
+0x64,0x01,0x24,0x35,
+0x68,0x01,0x25,0x35,
+0x7C,0x01,0x2A,0x35,
+0x6C,0x01,0x26,0x35,
+0x70,0x01,0x27,0x35,
+0x74,0x01,0x28,0x35,
+0x78,0x01,0x29,0x35,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0xA2,0xAC,
+0x00,0x00,0xC2,0xAC,
+0x00,0x00,0xE2,0xAC,
+0x00,0x00,0x02,0xAD,
+0x00,0x00,0x22,0xAD,
+0x00,0x00,0x42,0xAD,
+0x5E,0x5F,0x65,0x91,
+0x25,0xB0,0x0C,0x3C,
+0x01,0x00,0x03,0x3C,
+0x80,0x01,0x82,0x35,
+0x08,0x5F,0x63,0x34,
+0x22,0x00,0x04,0x24,
+0x00,0x00,0x43,0xAC,
+0xD5,0x00,0xA4,0x10,
+0x0F,0x1F,0x02,0x3C,
+0x92,0x00,0x02,0x24,
+0xD2,0x00,0xA2,0x10,
+0x0F,0x1F,0x02,0x3C,
+0x0F,0x10,0x02,0x3C,
+0x00,0xF0,0x51,0x34,
+0xF7,0x01,0x92,0x35,
+0x15,0xF0,0x4D,0x34,
+0x77,0x00,0x0E,0x24,
+0x84,0x01,0x87,0x35,
+0x88,0x01,0x88,0x35,
+0x10,0xF0,0x44,0x34,
+0x8C,0x01,0x85,0x35,
+0x05,0xF0,0x42,0x34,
+0x00,0x00,0xED,0xAC,
+0x90,0x01,0x83,0x35,
+0x00,0x00,0x04,0xAD,
+0x94,0x01,0x86,0x35,
+0x00,0x00,0xA2,0xAC,
+0xF5,0x0F,0x02,0x24,
+0x00,0x00,0x71,0xAC,
+0x98,0x01,0x89,0x35,
+0x00,0x00,0xC2,0xAC,
+0x9C,0x01,0x8A,0x35,
+0xA0,0x01,0x8B,0x35,
+0xF0,0x0F,0x03,0x24,
+0xF6,0x01,0x8C,0x35,
+0x0D,0x00,0x02,0x24,
+0x00,0x00,0x23,0xAD,
+0x00,0x00,0x42,0xAD,
+0x00,0x00,0x6D,0xAD,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x8E,0xA1,
+0x00,0x00,0x4E,0xA2,
+0x7B,0x5F,0x42,0x90,
+0x25,0xB0,0x1F,0x3C,
+0x05,0x06,0x03,0x3C,
+0x1C,0x00,0xA2,0xAF,
+0xA7,0x01,0xE7,0x37,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0xE2,0xA0,
+0x03,0x04,0x63,0x34,
+0xFF,0xFF,0x05,0x24,
+0x01,0x02,0x06,0x3C,
+0xA8,0x01,0xE8,0x37,
+0xAC,0x01,0xE9,0x37,
+0xB0,0x01,0xEA,0x37,
+0xB4,0x01,0xEB,0x37,
+0xB8,0x01,0xEC,0x37,
+0xBC,0x01,0xED,0x37,
+0x25,0xB0,0x02,0x3C,
+0x00,0x00,0x05,0xAD,
+0x0C,0x00,0x04,0x24,
+0x00,0x00,0x25,0xAD,
+0xC1,0x01,0x42,0x34,
+0x00,0x00,0x46,0xAD,
+0xC0,0x01,0xEE,0x37,
+0x00,0x00,0x63,0xAD,
+0x00,0x00,0x86,0xAD,
+0x00,0x00,0xA3,0xAD,
+0x25,0xB0,0x03,0x3C,
+0x00,0x00,0xC4,0xA1,
+0x0D,0x00,0x17,0x24,
+0x00,0x00,0x44,0xA0,
+0x0E,0x00,0x18,0x24,
+0x0F,0x00,0x02,0x24,
+0xC3,0x01,0xF1,0x37,
+0xC4,0x01,0xF2,0x37,
+0xC5,0x01,0xF3,0x37,
+0xC6,0x01,0xF4,0x37,
+0xC7,0x01,0xF5,0x37,
+0xC2,0x01,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x00,0x00,0x37,0xA2,
+0x00,0x00,0x57,0xA2,
+0x00,0x00,0x78,0xA2,
+0x00,0x00,0x98,0xA2,
+0x00,0x00,0xA2,0xA2,
+0x53,0x01,0x02,0x3C,
+0x0E,0xF0,0x42,0x34,
+0x46,0x00,0xF6,0x37,
+0x48,0x00,0xFE,0x37,
+0x00,0x00,0xC0,0xA6,
+0x00,0x00,0xC2,0xAF,
+0x1C,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x40,0x10,
+0x44,0x00,0xF7,0x37,
+0x00,0x00,0xE2,0x8E,
+0x00,0x02,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xAE,
+0x00,0x00,0xC3,0x8F,
+0x00,0x04,0x02,0x3C,
+0x25,0x18,0x62,0x00,
+0x00,0x00,0xC3,0xAF,
+0x4C,0x00,0xE3,0x37,
+0x00,0x00,0x60,0xA0,
+0x40,0x00,0xE6,0x37,
+0x2A,0xB0,0x04,0x3C,
+0xBC,0x00,0x02,0x24,
+0xFC,0x37,0x03,0x24,
+0x00,0x00,0xC2,0xA4,
+0x26,0xB0,0x05,0x3C,
+0x00,0x00,0xC3,0xA4,
+0x30,0x00,0x8A,0x34,
+0x20,0x20,0x02,0x24,
+0x38,0x00,0x84,0x34,
+0x40,0x00,0x03,0x24,
+0x00,0x00,0x82,0xA4,
+0x79,0x00,0xA7,0x34,
+0x00,0x00,0x43,0xA1,
+0x94,0x00,0xE8,0x37,
+0x16,0x00,0x02,0x24,
+0x64,0x00,0x03,0x24,
+0x00,0x00,0xE2,0xA0,
+0x7C,0x00,0xB1,0x34,
+0x00,0x00,0x03,0xA5,
+0x98,0x00,0xE9,0x37,
+0x7A,0x00,0xA5,0x34,
+0x22,0x00,0x02,0x24,
+0x04,0x00,0x03,0x24,
+0x00,0x00,0x22,0xA5,
+0x9C,0x00,0xEB,0x37,
+0x00,0x00,0xA3,0xA0,
+0x20,0x0C,0x02,0x24,
+0x0A,0x00,0x03,0x24,
+0x00,0x00,0x22,0xA6,
+0x9A,0x00,0xEC,0x37,
+0x00,0x00,0x63,0xA1,
+0x96,0x00,0xED,0x37,
+0xFF,0x03,0x02,0x24,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x82,0xA5,
+0x89,0x00,0xF2,0x37,
+0x00,0x00,0xA3,0xA5,
+0xB7,0x00,0xEE,0x37,
+0x20,0x00,0x02,0x24,
+0x09,0x00,0x03,0x24,
+0x00,0x00,0xC2,0xA1,
+0x00,0x00,0x43,0xA2,
+0x00,0x00,0xE4,0x96,
+0xFF,0xFD,0x02,0x24,
+0x02,0x80,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0x00,0x00,0xE4,0xA6,
+0x00,0x00,0xE2,0x96,
+0x60,0x1B,0x65,0x24,
+0x04,0x02,0x03,0x24,
+0x00,0x02,0x42,0x34,
+0x00,0x00,0xE2,0xA6,
+0xAA,0x1B,0xA4,0x90,
+0x29,0xB0,0x02,0x3C,
+0x40,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x91,0x26,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xFF,0xFF,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0x02,0x80,0x0B,0x3C,
+0x5E,0x5F,0x66,0x91,
+0x25,0xB0,0x09,0x3C,
+0x34,0x02,0x23,0x35,
+0x80,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA4,
+0x38,0x02,0x24,0x35,
+0x37,0x02,0x25,0x35,
+0x07,0x00,0x02,0x24,
+0x22,0x00,0x03,0x24,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0xA2,0xA0,
+0x2E,0xFF,0xC3,0x14,
+0x13,0x13,0x02,0x3C,
+0x1B,0x1B,0x02,0x3C,
+0x1B,0x1B,0x42,0x34,
+0x60,0x01,0x23,0x35,
+0x64,0x01,0x24,0x35,
+0x68,0x01,0x25,0x35,
+0x7C,0x01,0x2A,0x35,
+0x6C,0x01,0x26,0x35,
+0x70,0x01,0x27,0x35,
+0x74,0x01,0x28,0x35,
+0x78,0x01,0x29,0x35,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0xA2,0xAC,
+0x00,0x00,0xC2,0xAC,
+0x00,0x00,0xE2,0xAC,
+0x00,0x00,0x02,0xAD,
+0x00,0x00,0x22,0xAD,
+0x00,0x00,0x42,0xAD,
+0x5E,0x5F,0x65,0x91,
+0x25,0xB0,0x0C,0x3C,
+0x01,0x00,0x03,0x3C,
+0x80,0x01,0x82,0x35,
+0x08,0x5F,0x63,0x34,
+0x22,0x00,0x04,0x24,
+0x00,0x00,0x43,0xAC,
+0x2D,0xFF,0xA4,0x14,
+0x0F,0x1F,0x02,0x3C,
+0x00,0xF0,0x51,0x34,
+0xF7,0x01,0x92,0x35,
+0x15,0xF0,0x4D,0x34,
+0x9C,0x69,0x00,0x08,
+0xFF,0xFF,0x0E,0x24,
+0x02,0x80,0x02,0x3C,
+0x5F,0x5F,0x44,0x90,
+0x06,0x00,0x03,0x24,
+0x0D,0x00,0x83,0x10,
+0xA0,0x00,0x24,0x36,
+0x00,0x15,0x02,0x3C,
+0x00,0x07,0x42,0x34,
+0x00,0x00,0x82,0xAC,
+0x02,0x00,0x03,0x3C,
+0x04,0xE0,0x02,0x3C,
+0xA4,0x00,0x25,0x36,
+0x00,0x22,0x63,0x34,
+0xA8,0x00,0x26,0x36,
+0x00,0xAC,0x42,0x34,
+0x00,0x00,0xA3,0xAC,
+0xFD,0x68,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x00,0x15,0x02,0x3C,
+0x00,0x07,0x42,0x34,
+0x00,0x00,0x82,0xAC,
+0x02,0x00,0x03,0x3C,
+0x04,0xC0,0x02,0x3C,
+0xA4,0x00,0x25,0x36,
+0x00,0x22,0x63,0x34,
+0xA8,0x00,0x26,0x36,
+0x00,0xAE,0x42,0x34,
+0x00,0x00,0xA3,0xAC,
+0xFD,0x68,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x01,0x00,0x06,0x24,
+0xE8,0x0E,0x04,0x24,
+0x10,0x00,0xBF,0xAF,
+0x50,0x44,0x00,0x0C,
+0x00,0x10,0x05,0x3C,
+0x60,0x08,0x04,0x24,
+0x72,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x20,0x04,0x06,0x3C,
+0x20,0x04,0xC6,0x34,
+0x25,0x30,0x46,0x00,
+0x60,0x08,0x04,0x24,
+0x50,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x70,0x08,0x04,0x24,
+0x00,0x04,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x20,0x06,0x3C,
+0x80,0x00,0xC6,0x34,
+0x80,0x0C,0x04,0x24,
+0x50,0x44,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x00,0x40,0x06,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x00,0x01,0xC6,0x34,
+0x88,0x0C,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0x50,0x44,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x90,0xA0,0x00,
+0x0A,0x00,0xA0,0x10,
+0x21,0x88,0x00,0x00,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x04,0x8E,
+0x04,0x00,0x05,0x8E,
+0x02,0x00,0x31,0x26,
+0xF7,0x5A,0x00,0x0C,
+0x08,0x00,0x10,0x26,
+0x2B,0x10,0x32,0x02,
+0xF9,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x90,0xA0,0x00,
+0x0B,0x00,0xA0,0x10,
+0x21,0x88,0x00,0x00,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x04,0x8E,
+0x04,0x00,0x05,0x8E,
+0x08,0x00,0x06,0x8E,
+0x03,0x00,0x31,0x26,
+0x50,0x44,0x00,0x0C,
+0x0C,0x00,0x10,0x26,
+0x2B,0x10,0x32,0x02,
+0xF8,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x21,0x40,0x80,0x00,
+0x21,0x48,0x00,0x00,
+0x1E,0x00,0xA0,0x10,
+0x21,0x38,0x00,0x00,
+0x80,0x30,0x07,0x00,
+0x21,0x10,0xC8,0x00,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0xF2,0x63,0x24,
+0x1D,0x00,0x62,0x2C,
+0x12,0x00,0x40,0x10,
+0x80,0x10,0x03,0x00,
+0x02,0x80,0x03,0x3C,
+0x44,0xED,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x23,0x18,0x69,0x00,
+0x08,0x00,0x44,0x8C,
+0x02,0x80,0x02,0x3C,
+0x80,0x18,0x03,0x00,
+0x60,0x1B,0x42,0x24,
+0x21,0x18,0x62,0x00,
+0x04,0x1D,0x64,0xAC,
+0x01,0x00,0x29,0x25,
+0x03,0x00,0xE7,0x24,
+0x2B,0x10,0xE5,0x00,
+0xE5,0xFF,0x40,0x14,
+0x80,0x30,0x07,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xD6,0xFF,0x40,0x14,
+0x00,0x1D,0x64,0xAC,
+0xF9,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xC8,0xFF,0x40,0x14,
+0xFC,0x1C,0x64,0xAC,
+0xF9,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xBA,0xFF,0x40,0x14,
+0xF8,0x1C,0x64,0xAC,
+0xF9,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xAC,0xFF,0x40,0x14,
+0x08,0x1D,0x64,0xAC,
+0xF9,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0x9E,0xFF,0x40,0x14,
+0xF4,0x1C,0x64,0xAC,
+0xF9,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0x90,0xFF,0x40,0x14,
+0xF0,0x1C,0x64,0xAC,
+0xF9,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0xFC,0x37,0x03,0x24,
+0x40,0x00,0x42,0x34,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x43,0xA4,
+0xE8,0xFF,0xBD,0x27,
+0xE4,0xD5,0x84,0x24,
+0x10,0x00,0xBF,0xAF,
+0xA9,0x6A,0x00,0x0C,
+0x74,0x01,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x5E,0x5F,0x44,0x90,
+0x12,0x00,0x03,0x24,
+0x34,0x00,0x83,0x10,
+0x13,0x00,0x82,0x28,
+0x17,0x00,0x40,0x14,
+0x11,0x00,0x02,0x24,
+0x22,0x00,0x02,0x24,
+0x36,0x00,0x82,0x10,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x04,0x3C,
+0x6C,0xD2,0x84,0x24,
+0xD8,0x6A,0x00,0x0C,
+0x54,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x4B,0xFC,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x1A,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x6C,0xCD,0x84,0x24,
+0xA9,0x6A,0x00,0x0C,
+0x40,0x01,0x05,0x24,
+0x10,0x00,0xBF,0x8F,
+0x84,0x08,0x04,0x24,
+0xFF,0x00,0x05,0x24,
+0x58,0x00,0x06,0x24,
+0x50,0x44,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xED,0xFF,0x82,0x14,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x04,0x3C,
+0x24,0xD5,0x84,0x24,
+0xC0,0x6A,0x00,0x0C,
+0x30,0x00,0x05,0x24,
+0x02,0x80,0x04,0x3C,
+0x6C,0xD2,0x84,0x24,
+0xD8,0x6A,0x00,0x0C,
+0x54,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x4B,0xFC,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0xE8,0xFF,0x83,0x14,
+0x00,0x00,0x00,0x00,
+0x8A,0x6A,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x6C,0xCD,0x84,0x24,
+0xA9,0x6A,0x00,0x0C,
+0x40,0x01,0x05,0x24,
+0x10,0x00,0xBF,0x8F,
+0x84,0x08,0x04,0x24,
+0xFF,0x00,0x05,0x24,
+0x58,0x00,0x06,0x24,
+0x50,0x44,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x70,0xD4,0x84,0x24,
+0x2D,0x00,0x05,0x24,
+0xC0,0x6A,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x7D,0x6B,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0xBC,0xD3,0x84,0x24,
+0x94,0x6B,0x00,0x08,
+0x2D,0x00,0x05,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x50,0x0C,0x04,0x24,
+0xFF,0x00,0x05,0x24,
+0x02,0x80,0x10,0x3C,
+0x14,0x00,0xBF,0xAF,
+0xB3,0x45,0x00,0x0C,
+0x60,0x1B,0x10,0x26,
+0x60,0x1D,0x02,0xA2,
+0x58,0x0C,0x04,0x24,
+0xB3,0x45,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x61,0x1D,0x02,0xA2,
+0x60,0x0C,0x04,0x24,
+0xB3,0x45,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x62,0x1D,0x02,0xA2,
+0x68,0x0C,0x04,0x24,
+0xB3,0x45,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x63,0x1D,0x02,0xA2,
+0x38,0x0C,0x04,0x24,
+0xB3,0x45,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0xE8,0x1C,0x02,0xA2,
+0x34,0x0C,0x04,0x24,
+0xB3,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0xEC,0x1C,0x02,0xAE,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x05,0x3C,
+0xF0,0xAF,0x42,0x24,
+0x02,0x80,0x03,0x3C,
+0xA8,0x5F,0xA2,0xAC,
+0x00,0x80,0x02,0x3C,
+0x48,0x60,0x60,0xAC,
+0xA8,0x5F,0xA4,0x24,
+0x02,0x80,0x03,0x3C,
+0xD0,0x10,0x42,0x24,
+0x4C,0x60,0x60,0xA4,
+0x08,0x00,0x82,0xAC,
+0x02,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x4E,0x60,0x60,0xA4,
+0x02,0x80,0x06,0x3C,
+0x78,0x13,0x42,0x24,
+0x00,0x80,0x03,0x3C,
+0x50,0x60,0xC7,0x24,
+0x14,0x00,0x82,0xAC,
+0xEC,0x10,0x63,0x24,
+0x02,0x80,0x02,0x3C,
+0x50,0x60,0xC0,0xAC,
+0x10,0x00,0x83,0xAC,
+0x04,0x00,0xE0,0xAC,
+0x02,0x80,0x03,0x3C,
+0x58,0x60,0x40,0xA0,
+0x02,0x80,0x02,0x3C,
+0x5C,0x60,0x60,0xAC,
+0x60,0x60,0x40,0xAC,
+0x01,0x80,0x02,0x3C,
+0x30,0xDC,0x42,0x24,
+0x7C,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x94,0x13,0x63,0x24,
+0xDC,0x15,0x42,0x24,
+0x20,0x00,0x83,0xAC,
+0x24,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x1C,0x18,0x63,0x24,
+0x5C,0x1A,0x42,0x24,
+0x28,0x00,0x83,0xAC,
+0x2C,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x01,0x80,0x02,0x3C,
+0x84,0x2B,0x63,0x24,
+0x50,0x02,0x42,0x24,
+0x30,0x00,0x83,0xAC,
+0x54,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0xFC,0x1C,0x63,0x24,
+0x0C,0x20,0x42,0x24,
+0x0C,0x00,0x83,0xAC,
+0x3C,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x03,0x63,0x24,
+0x9C,0x1C,0x42,0x24,
+0x50,0x00,0x83,0xAC,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0x82,0xAC,
+0x25,0xB0,0x02,0x3C,
+0x08,0x00,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x0E,0x3C,
+0x02,0x80,0x08,0x3C,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF8,0x03,0x4D,0x24,
+0x00,0x18,0x6C,0x24,
+0x01,0x00,0x07,0x24,
+0x00,0x00,0xCB,0x25,
+0xFF,0xFF,0x0A,0x24,
+0x00,0x04,0x09,0x25,
+0x80,0x1A,0x07,0x00,
+0x21,0x10,0x6B,0x00,
+0x00,0x00,0x42,0xAC,
+0x90,0x00,0x4A,0xAC,
+0x00,0x04,0x04,0x8D,
+0x01,0x00,0xE7,0x24,
+0x08,0x00,0x45,0x24,
+0x21,0x18,0x6D,0x00,
+0x06,0x00,0xE6,0x28,
+0x04,0x00,0x82,0xAC,
+0x00,0x00,0x44,0xAC,
+0x04,0x00,0x49,0xAC,
+0x00,0x04,0x02,0xAD,
+0x8C,0x00,0x40,0xAC,
+0x6C,0x00,0xA3,0xAC,
+0xF0,0xFF,0xC0,0x14,
+0x68,0x00,0xAC,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0xC9,0xAD,
+0x06,0x00,0xA2,0x2C,
+0x13,0x00,0x40,0x10,
+0xFF,0xFF,0x07,0x24,
+0x02,0x80,0x02,0x3C,
+0x80,0x1A,0x05,0x00,
+0x00,0x00,0x42,0x24,
+0x0E,0x00,0xA0,0x10,
+0x21,0x30,0x62,0x00,
+0x90,0x00,0xC3,0x8C,
+0xFF,0xFF,0x02,0x24,
+0x0A,0x00,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x8C,0x00,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x88,0x00,0xC4,0xAC,
+0x8C,0x00,0xC2,0xAC,
+0x90,0x00,0xC5,0xAC,
+0x21,0x38,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xE0,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x5B,0x5F,0x46,0x90,
+0x25,0xB0,0x07,0x3C,
+0x02,0x80,0x02,0x3C,
+0xDB,0xFF,0x03,0x24,
+0x18,0x03,0xE4,0x34,
+0x27,0x00,0xE5,0x34,
+0xD4,0xB0,0x42,0x24,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0xA3,0xA0,
+0x02,0x00,0xC0,0x10,
+0x1B,0x00,0xE3,0x34,
+0x1F,0x00,0xE3,0x34,
+0x07,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x7F,0x43,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x50,0x24,
+0x34,0x1C,0x04,0x8E,
+0x72,0x44,0x00,0x0C,
+0x10,0x00,0x05,0x24,
+0x40,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x3C,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x58,0x1C,0x04,0x8E,
+0x00,0x04,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x58,0x1C,0x04,0x8E,
+0x00,0x08,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x30,0xDF,0xA5,0x24,
+0x21,0x20,0x00,0x00,
+0x50,0x46,0x00,0x0C,
+0xCA,0x00,0x06,0x24,
+0x31,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x67,0x5F,0x43,0x90,
+0x01,0x00,0x11,0x24,
+0x53,0x00,0x71,0x10,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x4B,0xFC,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x54,0x00,0x71,0x10,
+0x02,0x80,0x05,0x3C,
+0x34,0x1C,0x04,0x8E,
+0x21,0x30,0x40,0x02,
+0x10,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x02,0x80,0x11,0x3C,
+0x5E,0x5F,0x23,0x92,
+0x11,0x00,0x02,0x24,
+0x2A,0x00,0x62,0x10,
+0x00,0x08,0x04,0x24,
+0x7F,0x43,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x34,0x1C,0x04,0x8E,
+0x72,0x44,0x00,0x0C,
+0x10,0x00,0x05,0x3C,
+0x40,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x3C,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x58,0x1C,0x04,0x8E,
+0x00,0x04,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x58,0x1C,0x04,0x8E,
+0x00,0x08,0x05,0x24,
+0x50,0x44,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0xD8,0xDE,0xA5,0x24,
+0x01,0x00,0x04,0x24,
+0x50,0x46,0x00,0x0C,
+0x16,0x00,0x06,0x24,
+0x08,0x00,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x34,0x1C,0x04,0x8E,
+0x21,0x30,0x40,0x02,
+0x50,0x44,0x00,0x0C,
+0x10,0x00,0x05,0x3C,
+0x00,0x08,0x04,0x24,
+0x00,0x01,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x5E,0x5F,0x23,0x92,
+0x11,0x00,0x02,0x24,
+0x1D,0x00,0x62,0x10,
+0x00,0x08,0x04,0x24,
+0x7F,0x43,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x0F,0x00,0x05,0x3C,
+0x0C,0x00,0x06,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x00,0xB4,0xC6,0x34,
+0x12,0x46,0x00,0x0C,
+0x08,0x00,0x04,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x03,0x24,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC8,0xDD,0xA5,0x24,
+0x21,0x20,0x00,0x00,
+0x50,0x46,0x00,0x0C,
+0x16,0x00,0x06,0x24,
+0x6E,0x6C,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x20,0xDE,0xA5,0x24,
+0x21,0x20,0x00,0x00,
+0x50,0x46,0x00,0x0C,
+0x16,0x00,0x06,0x24,
+0x72,0x6C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x05,0x3C,
+0x50,0x44,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0xAF,0x6C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x40,0x00,0x00,
+0x08,0x84,0x09,0x24,
+0x21,0x28,0x00,0x01,
+0x21,0x38,0x00,0x00,
+0x42,0x10,0x05,0x00,
+0x26,0x30,0x49,0x00,
+0x21,0x18,0x40,0x00,
+0x01,0x00,0xA2,0x30,
+0x02,0x00,0x40,0x14,
+0xFF,0xFF,0xC5,0x30,
+0xFF,0xFF,0x65,0x30,
+0x01,0x00,0xE2,0x24,
+0xFF,0x00,0x47,0x30,
+0x08,0x00,0xE3,0x2C,
+0xF6,0xFF,0x60,0x14,
+0x42,0x10,0x05,0x00,
+0x01,0x00,0x02,0x25,
+0x40,0x18,0x08,0x00,
+0xFF,0xFF,0x48,0x30,
+0x21,0x18,0x64,0x00,
+0x00,0x01,0x02,0x2D,
+0xEC,0xFF,0x40,0x14,
+0x00,0x00,0x65,0xA4,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x6C,0xEF,0x43,0x8C,
+0x02,0x80,0x07,0x3C,
+0xBC,0x61,0xE7,0x24,
+0x02,0x00,0x02,0x24,
+0x00,0x80,0x06,0x3C,
+0x21,0x20,0xE0,0x00,
+0x14,0x00,0xE2,0xA0,
+0x54,0x39,0xC6,0x24,
+0x10,0x00,0xA5,0x27,
+0x6F,0x27,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x08,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x64,0x60,0x43,0xA0,
+0x32,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x58,0x61,0x45,0xA4,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x48,0x61,0x60,0xA0,
+0x52,0x61,0x40,0xA4,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xD8,0x61,0x84,0x24,
+0x57,0x61,0x60,0xA0,
+0xD0,0x6C,0x00,0x0C,
+0x57,0x61,0x40,0xA0,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x48,0x37,0x52,0x24,
+0x5C,0x61,0x71,0x24,
+0x0F,0x00,0x10,0x24,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x40,0x02,
+0x06,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x0C,
+0xFF,0xFF,0x10,0x26,
+0xFA,0xFF,0x01,0x06,
+0x06,0x00,0x31,0x26,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x02,0x80,0x02,0x3C,
+0x41,0x59,0x47,0x90,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x03,0x00,0x03,0x24,
+0x4E,0x37,0x84,0x24,
+0xBC,0xE6,0xA5,0x24,
+0x0F,0x00,0xE3,0x10,
+0x0D,0x00,0x06,0x24,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x4E,0x37,0x84,0x24,
+0x6C,0xE6,0xA5,0x24,
+0xCE,0x53,0x00,0x0C,
+0x0D,0x00,0x06,0x24,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x5B,0x37,0x84,0x24,
+0x7C,0xE6,0xA5,0x24,
+0x0D,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xCE,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x5B,0x37,0x84,0x24,
+0xAC,0xE6,0xA5,0x24,
+0x0D,0x00,0x06,0x24,
+0xCE,0x53,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x11,0x3C,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x10,0x3C,
+0x60,0x1B,0x10,0x26,
+0x48,0x59,0x24,0x26,
+0x58,0xE2,0xA5,0x24,
+0x6C,0x00,0x06,0x24,
+0x18,0x00,0xBF,0xAF,
+0xCE,0x53,0x00,0x0C,
+0x48,0x59,0x31,0x26,
+0x1F,0x6D,0x00,0x0C,
+0x54,0x3E,0x11,0xAE,
+0x02,0x00,0x11,0x24,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0x9C,0x39,0x11,0xA2,
+0xE8,0x54,0x84,0x24,
+0xC0,0x75,0xC6,0x24,
+0x6F,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0xB8,0x39,0x11,0xA2,
+0x04,0x55,0x84,0x24,
+0x18,0x6D,0xC6,0x24,
+0x6F,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0xD4,0x39,0x11,0xA2,
+0x20,0x55,0x84,0x24,
+0x88,0x5C,0xC6,0x24,
+0x6F,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0xF0,0x39,0x11,0xA2,
+0x3C,0x55,0x84,0x24,
+0xB8,0x72,0xC6,0x24,
+0x6F,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0x0C,0x3A,0x11,0xA2,
+0x58,0x55,0x84,0x24,
+0xEC,0x71,0xC6,0x24,
+0x6F,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0x28,0x3A,0x11,0xA2,
+0x74,0x55,0x84,0x24,
+0xC8,0x45,0xC6,0x24,
+0x6F,0x27,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x09,0x00,0x02,0x24,
+0x2C,0x43,0x02,0xA2,
+0x01,0x00,0x03,0x24,
+0xE8,0x03,0x02,0x24,
+0x84,0x42,0x03,0xA2,
+0x88,0x42,0x02,0xAE,
+0x64,0x42,0x00,0xAE,
+0xD7,0x43,0x00,0xA2,
+0xE4,0x3D,0x00,0xA6,
+0xE3,0x3D,0x00,0xA2,
+0x7C,0x42,0x00,0xA2,
+0x60,0x42,0x00,0xAE,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x03,0x80,0x05,0x3C,
+0x00,0x80,0xA5,0x24,
+0xD8,0xFF,0xBD,0x27,
+0x40,0x10,0x0D,0x3C,
+0xFF,0xFF,0xA5,0x30,
+0x02,0x80,0x02,0x3C,
+0x60,0x1B,0x42,0x24,
+0x20,0x00,0xBE,0xAF,
+0x25,0xF0,0xAD,0x00,
+0x2C,0x38,0x5E,0xAC,
+0x00,0x01,0xDE,0x27,
+0x38,0x38,0x5E,0xAC,
+0x00,0x01,0xDE,0x27,
+0x1C,0x00,0xB7,0xAF,
+0x18,0x00,0xB6,0xAF,
+0x14,0x00,0xB5,0xAF,
+0x10,0x00,0xB4,0xAF,
+0x0C,0x00,0xB3,0xAF,
+0x08,0x00,0xB2,0xAF,
+0x04,0x00,0xB1,0xAF,
+0x00,0x00,0xB0,0xAF,
+0x44,0x38,0x5E,0xAC,
+0x00,0x01,0xDE,0x27,
+0x50,0x38,0x5E,0xAC,
+0xAA,0x1B,0x44,0x90,
+0x00,0x01,0xDE,0x27,
+0x5C,0x38,0x5E,0xAC,
+0x00,0x01,0xDE,0x27,
+0x68,0x38,0x5E,0xAC,
+0x20,0xB0,0x06,0x3C,
+0x38,0x38,0x48,0x8C,
+0x44,0x38,0x49,0x8C,
+0x50,0x38,0x4A,0x8C,
+0x5C,0x38,0x4B,0x8C,
+0x68,0x38,0x4C,0x8C,
+0x00,0x22,0x04,0x00,
+0x00,0x01,0xC7,0x34,
+0xFF,0x1F,0x03,0x3C,
+0x00,0x01,0xDE,0x27,
+0xFF,0xFF,0x63,0x34,
+0x21,0x38,0x87,0x00,
+0x21,0x20,0x86,0x00,
+0x24,0x38,0xE3,0x00,
+0x20,0x10,0x06,0x3C,
+0x24,0x20,0x83,0x00,
+0x74,0x38,0x5E,0xAC,
+0x21,0x70,0xC0,0x03,
+0x25,0x28,0xAD,0x00,
+0x25,0xB0,0x0F,0x3C,
+0x00,0x01,0xDE,0x27,
+0x28,0x38,0x45,0xAC,
+0x34,0x38,0x48,0xAC,
+0x40,0x38,0x49,0xAC,
+0x4C,0x38,0x4A,0xAC,
+0xEC,0x37,0x44,0xAC,
+0x58,0x38,0x4B,0xAC,
+0xF8,0x37,0x47,0xAC,
+0x64,0x38,0x4C,0xAC,
+0xAC,0x00,0xE3,0x35,
+0xC0,0x37,0x46,0xAC,
+0xBC,0x37,0x46,0xAC,
+0xCC,0x37,0x46,0xAC,
+0xC8,0x37,0x46,0xAC,
+0x80,0x38,0x5E,0xAC,
+0xF0,0x37,0x44,0xAC,
+0xFC,0x37,0x47,0xAC,
+0x70,0x38,0x4E,0xAC,
+0xD8,0x37,0x46,0xAC,
+0xD4,0x37,0x46,0xAC,
+0xE4,0x37,0x46,0xAC,
+0xE0,0x37,0x46,0xAC,
+0x08,0x38,0x46,0xAC,
+0x04,0x38,0x46,0xAC,
+0xAC,0x1B,0x47,0x94,
+0x00,0x02,0xDE,0x27,
+0x00,0x00,0x69,0x8C,
+0x21,0x10,0x05,0x3C,
+0x98,0x38,0x5E,0xAC,
+0xB0,0x00,0xE3,0x35,
+0x00,0x00,0x79,0x8C,
+0x80,0x38,0x54,0x8C,
+0x00,0x80,0xA4,0x34,
+0x23,0x10,0x0D,0x3C,
+0x22,0x10,0x10,0x3C,
+0x02,0x80,0x16,0x3C,
+0x02,0x80,0x17,0x3C,
+0x02,0x80,0x18,0x3C,
+0x02,0x80,0x13,0x3C,
+0x23,0x20,0x87,0x00,
+0x02,0x80,0x03,0x3C,
+0x24,0x10,0x07,0x3C,
+0xC0,0x54,0x68,0x24,
+0xCC,0x38,0x44,0xAC,
+0x21,0xA8,0xC0,0x03,
+0xC8,0x54,0xCE,0x26,
+0x00,0x04,0xDE,0x27,
+0xD0,0x54,0xEA,0x26,
+0xD8,0x54,0x0B,0x27,
+0xE0,0x54,0x6C,0x26,
+0x00,0x04,0xB1,0x35,
+0x01,0x00,0x29,0x25,
+0x00,0x40,0x12,0x36,
+0x00,0x01,0xEF,0x35,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x04,0x3C,
+0x7C,0x38,0x54,0xAC,
+0x85,0x38,0x43,0xA0,
+0x94,0x38,0x55,0xAC,
+0xFC,0x38,0x51,0xAC,
+0xC0,0x38,0x49,0xAC,
+0xF0,0x38,0x52,0xAC,
+0xE4,0x38,0x59,0xAC,
+0x00,0x00,0xE7,0xAD,
+0xE0,0x38,0x47,0xAC,
+0x00,0x39,0x46,0xAC,
+0x14,0x38,0x46,0xAC,
+0x10,0x38,0x46,0xAC,
+0x9E,0x38,0x40,0xA4,
+0x9D,0x38,0x40,0xA0,
+0x9C,0x38,0x40,0xA0,
+0xF4,0x38,0x4D,0xAC,
+0xF8,0x38,0x4D,0xAC,
+0xB8,0x38,0x45,0xAC,
+0xBC,0x38,0x45,0xAC,
+0xC4,0x38,0x45,0xAC,
+0xC8,0x38,0x45,0xAC,
+0xE8,0x38,0x50,0xAC,
+0xEC,0x38,0x50,0xAC,
+0xDC,0x38,0x47,0xAC,
+0x04,0x39,0x46,0xAC,
+0x10,0x39,0x5E,0xAC,
+0x0C,0x39,0x5E,0xAC,
+0x04,0x00,0x4A,0xAD,
+0xC8,0x54,0xCE,0xAE,
+0x04,0x00,0x6B,0xAD,
+0xD0,0x54,0xEA,0xAE,
+0x04,0x00,0x8C,0xAD,
+0xD8,0x54,0x0B,0xAF,
+0x04,0x00,0x08,0xAD,
+0xE0,0x54,0x6C,0xAE,
+0xC0,0x54,0x88,0xAC,
+0x04,0x00,0xCE,0xAD,
+0x02,0x80,0x04,0x3C,
+0x18,0x18,0x83,0x24,
+0x02,0x80,0x05,0x3C,
+0x00,0x18,0xA2,0x24,
+0x18,0x18,0x83,0xAC,
+0x02,0x80,0x04,0x3C,
+0x04,0x00,0x02,0xAD,
+0x00,0x18,0xA8,0xAC,
+0xC0,0x54,0x82,0xAC,
+0x21,0x48,0x60,0x00,
+0x08,0x00,0x5E,0xAC,
+0x01,0x00,0x07,0x24,
+0x04,0x00,0x63,0xAC,
+0x00,0x01,0xDE,0x27,
+0x04,0x00,0x48,0xAC,
+0x10,0x00,0x40,0xAC,
+0x21,0x40,0x40,0x00,
+0x21,0x18,0xC0,0x01,
+0x21,0x28,0x00,0x00,
+0x0F,0x00,0x06,0x24,
+0x21,0x20,0xA9,0x00,
+0x21,0x10,0xA8,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x20,0x00,0x5E,0xAC,
+0x28,0x00,0x47,0xAC,
+0x18,0x00,0xA5,0x24,
+0x00,0x00,0x8E,0xAC,
+0x04,0x00,0x83,0xAC,
+0x00,0x00,0x64,0xAC,
+0x00,0x01,0xDE,0x27,
+0xF5,0xFF,0xC1,0x04,
+0x21,0x18,0x80,0x00,
+0x02,0x80,0x02,0x3C,
+0xD0,0x54,0x48,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x07,0x8D,
+0x98,0x19,0x4B,0x24,
+0x04,0x00,0xC4,0xAD,
+0x00,0x18,0x6A,0x24,
+0x02,0x00,0x09,0x24,
+0x21,0x28,0x00,0x00,
+0x0F,0x00,0x06,0x24,
+0x21,0x20,0xAB,0x00,
+0x21,0x10,0xAA,0x00,
+0xFF,0xFF,0xC6,0x24,
+0xA0,0x01,0x5E,0xAC,
+0xA8,0x01,0x49,0xAC,
+0x18,0x00,0xA5,0x24,
+0x00,0x00,0x88,0xAC,
+0x04,0x00,0x87,0xAC,
+0x00,0x00,0xE4,0xAC,
+0x00,0x02,0xDE,0x27,
+0xF5,0xFF,0xC1,0x04,
+0x21,0x38,0x80,0x00,
+0x02,0x80,0x02,0x3C,
+0xD8,0x54,0x49,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x25,0x8D,
+0x18,0x1B,0x4B,0x24,
+0x04,0x00,0x04,0xAD,
+0x00,0x18,0x6A,0x24,
+0x03,0x00,0x07,0x24,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x06,0x24,
+0x21,0x40,0x8B,0x00,
+0x21,0x10,0x8A,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x20,0x03,0x5E,0xAC,
+0x28,0x03,0x47,0xAC,
+0x18,0x00,0x84,0x24,
+0x00,0x00,0x09,0xAD,
+0x04,0x00,0x05,0xAD,
+0x00,0x00,0xA8,0xAC,
+0x00,0x08,0xDE,0x27,
+0xF5,0xFF,0xC1,0x04,
+0x21,0x28,0x00,0x01,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x03,0x3C,
+0xE0,0x54,0xA5,0x24,
+0x00,0x18,0x63,0x24,
+0x04,0x00,0xA6,0x8C,
+0x1C,0x00,0xB7,0x8F,
+0x50,0x03,0x7E,0xAC,
+0x18,0x00,0xB6,0x8F,
+0x20,0x00,0xBE,0x8F,
+0x14,0x00,0xB5,0x8F,
+0x10,0x00,0xB4,0x8F,
+0x0C,0x00,0xB3,0x8F,
+0x08,0x00,0xB2,0x8F,
+0x04,0x00,0xB1,0x8F,
+0x00,0x00,0xB0,0x8F,
+0x02,0x80,0x07,0x3C,
+0x48,0x1B,0xE4,0x24,
+0x04,0x00,0x02,0x24,
+0x28,0x00,0xBD,0x27,
+0x04,0x00,0x28,0xAD,
+0x04,0x00,0xA4,0xAC,
+0x58,0x03,0x62,0xAC,
+0x48,0x1B,0xE5,0xAC,
+0x04,0x00,0x86,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0xC4,0xAC,
+0xFA,0x63,0x00,0x6A,
+0x09,0xD1,0x0A,0x62,
+0x08,0xD0,0x06,0xD2,
+0x7D,0x67,0x18,0xA3,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x63,0xF3,0x00,0x49,
+0x00,0x18,0xCF,0x5B,
+0x06,0x94,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x5D,0xF3,
+0x08,0x4A,0xDD,0xF2,
+0x14,0x4B,0x7B,0x9B,
+0x5B,0x9A,0x00,0x6D,
+0x69,0xE2,0x46,0x32,
+0xC4,0xF4,0x54,0xD9,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0xBD,0xF2,0x14,0x4A,
+0x5B,0xA2,0x01,0xF6,
+0x01,0x6B,0x6B,0xEB,
+0x50,0x32,0xE4,0xF4,
+0x5C,0xD9,0xE4,0xF4,
+0x58,0xD9,0x04,0xF5,
+0x48,0x99,0x6C,0xEA,
+0x00,0xF2,0x00,0x6B,
+0x6D,0xEA,0x04,0xF5,
+0x48,0xD9,0xA9,0xE1,
+0x01,0x4D,0x1D,0x55,
+0x04,0xF5,0x0C,0xC2,
+0x44,0xF5,0x06,0xC2,
+0x24,0xF5,0x09,0xC2,
+0xF6,0x61,0x00,0x6A,
+0x64,0xF5,0x44,0xD9,
+0x06,0x94,0x7F,0x49,
+0x15,0x49,0x01,0x4C,
+0x20,0x54,0x06,0xD4,
+0xBF,0x61,0x10,0xF0,
+0x02,0x6D,0x00,0xF4,
+0xA0,0x35,0x10,0xF0,
+0x02,0x69,0x00,0xF4,
+0x20,0x31,0x10,0xF0,
+0x02,0x68,0x00,0xF4,
+0x00,0x30,0x10,0xF0,
+0x02,0x6F,0x00,0xF4,
+0xE0,0x37,0x10,0xF0,
+0x02,0x6E,0x00,0xF4,
+0xC0,0x36,0x06,0xD2,
+0x63,0xF3,0x00,0x4D,
+0x5D,0xF3,0x08,0x49,
+0xDD,0xF2,0x14,0x48,
+0xBD,0xF2,0x14,0x4F,
+0x9D,0xF2,0x14,0x4E,
+0x06,0x93,0x68,0x32,
+0x2D,0xE2,0x60,0x9B,
+0xB1,0xE2,0x09,0xE2,
+0xC0,0xF5,0x74,0xDC,
+0x40,0x9A,0x60,0xF5,
+0x40,0xDC,0x06,0x94,
+0xE9,0xE4,0x40,0xA2,
+0xAD,0xE4,0x00,0xF5,
+0x44,0xC3,0xC9,0xE4,
+0x40,0xA2,0x01,0x4C,
+0x1D,0x54,0x20,0xF5,
+0x5E,0xC3,0x06,0xD4,
+0xE7,0x61,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0x00,0x6D,
+0x10,0xF0,0x02,0x69,
+0x00,0xF4,0x20,0x31,
+0x7D,0xF1,0x10,0x4A,
+0x1D,0xF0,0x10,0x4B,
+0x06,0xD5,0x63,0xF3,
+0x00,0x49,0x2A,0x65,
+0x0B,0x65,0x05,0x67,
+0x89,0x67,0x00,0x6D,
+0x3D,0xE0,0x99,0xE0,
+0xAD,0xE6,0x40,0xA3,
+0xB1,0xE7,0x01,0x4D,
+0xA0,0xF3,0x48,0xC4,
+0x80,0xF0,0x51,0xA3,
+0x05,0x55,0x20,0xF4,
+0x59,0xC4,0xF4,0x61,
+0x06,0x95,0x48,0x67,
+0x05,0x48,0x4D,0xE5,
+0x40,0xA3,0x31,0xE5,
+0x01,0x4D,0xC0,0xF4,
+0x4A,0xC4,0x5D,0xA3,
+0x1D,0x55,0xE0,0xF4,
+0x47,0xC4,0x06,0xD5,
+0xE1,0x61,0x9D,0x67,
+0x52,0x6A,0x50,0xC4,
+0x41,0x6A,0x51,0xC4,
+0x00,0x6B,0x4D,0x6A,
+0x52,0xC4,0x73,0xC4,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x7F,0xF4,0x04,0x4C,
+0xE0,0xF3,0x08,0x6A,
+0x43,0xDC,0xBD,0x67,
+0x01,0x6A,0x10,0xF0,
+0x01,0x6E,0x00,0xF4,
+0xC0,0x36,0x54,0xC4,
+0xB4,0xF1,0x05,0x4E,
+0x00,0x1C,0x6F,0x27,
+0x10,0x4D,0x0A,0x97,
+0x09,0x91,0x08,0x90,
+0x00,0xEF,0x06,0x63,
+0xC9,0xF7,0x1B,0x6C,
+0xF1,0x63,0x8B,0xEC,
+0x1B,0xD1,0x80,0x31,
+0x20,0x31,0xE1,0xF6,
+0x80,0x41,0x1C,0x62,
+0x00,0x1C,0xEE,0x5A,
+0x1A,0xD0,0xD1,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x07,0xD2,
+0x71,0xF6,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x08,0xD2,0x71,0xF6,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x09,0xD2,
+0x71,0xF6,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x0A,0xD2,0x71,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x0B,0xD2,
+0x81,0xF6,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x0C,0xD2,0x81,0xF6,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x0D,0xD2,
+0x81,0xF6,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x0E,0xD2,0x81,0xF6,
+0x8C,0x41,0xE7,0xF7,
+0x0E,0x68,0x00,0x1C,
+0xEE,0x5A,0x0F,0xD2,
+0xD1,0xF6,0x80,0x41,
+0x10,0xD2,0x00,0x1C,
+0xEE,0x5A,0x00,0x30,
+0xD1,0xF6,0x84,0x41,
+0x00,0x30,0x00,0x1C,
+0xEE,0x5A,0x11,0xD2,
+0xD1,0xF6,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x12,0xD2,0xB0,0x67,
+0xE1,0xF6,0x80,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x13,0xD2,0xB0,0x67,
+0xD1,0xF6,0x8C,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x71,0xF6,0x80,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x71,0xF6,0x84,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x71,0xF6,0x88,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x71,0xF6,0x8C,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x81,0xF6,0x80,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x81,0xF6,0x84,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x81,0xF6,0x88,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0x81,0xF6,0x8C,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0xD1,0xF6,0x80,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0xD1,0xF6,0x84,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xB0,0x67,
+0xD1,0xF6,0x88,0x41,
+0xF2,0xF2,0x1B,0x4D,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x6A,
+0x04,0xD2,0xFF,0x6A,
+0x01,0x4A,0x40,0x30,
+0x00,0xF5,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x15,0xD2,
+0x01,0xF0,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0x40,0x32,0x00,0x30,
+0x16,0xD2,0x21,0xF0,
+0x80,0x41,0x00,0xF1,
+0xA0,0x40,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x21,0xF0,0x88,0x41,
+0x00,0xF1,0xA0,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0xA0,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x2A,0xF4,0x10,0x4D,
+0x01,0xF4,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x01,0xF0,0x00,0x6D,
+0xA0,0x35,0x7F,0x4D,
+0x01,0xF4,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x65,0x4D,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x8F,0xF7,0x00,0x6D,
+0xAB,0xED,0xA0,0x35,
+0x21,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0xA0,0x35,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x00,0xF2,0x14,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x00,0xF1,0x02,0x4D,
+0x41,0xF6,0x80,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x0D,0xF0,0x16,0x6D,
+0xA0,0x35,0xA0,0x35,
+0xC0,0xF4,0x02,0x4D,
+0x41,0xF6,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0xC5,0xF0,0x11,0x6D,
+0x41,0xF6,0x8C,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x00,0xF2,0x14,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x00,0xF1,0x02,0x4D,
+0x61,0xF6,0x80,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x05,0xF0,0x16,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x01,0xF5,0x05,0x4D,
+0x61,0xF6,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x41,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x15,0x95,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x41,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x16,0x95,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x00,0x1C,0x43,0x26,
+0x02,0x6C,0x00,0xF2,
+0x00,0x6D,0xA0,0x35,
+0xA0,0x35,0xC5,0xF0,
+0x11,0x4D,0x61,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xD1,0x5A,0x00,0x65,
+0x00,0x1C,0x72,0x26,
+0x05,0x6C,0x41,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x15,0x95,
+0x00,0x1C,0x72,0x26,
+0x05,0x6C,0x41,0xF6,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x16,0x95,
+0x00,0x1C,0x43,0x26,
+0x02,0x6C,0xA0,0x6D,
+0xA0,0x35,0xA0,0x35,
+0x2A,0xF4,0x13,0x4D,
+0x01,0xF4,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x65,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x01,0xF4,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0xE4,0x6D,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x21,0xF6,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x00,0x6D,0x21,0xF0,
+0x80,0x41,0x00,0x1C,
+0xD1,0x5A,0xB0,0x67,
+0x21,0xF0,0x88,0x41,
+0x00,0x1C,0xD1,0x5A,
+0xB0,0x67,0xA1,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x05,0xF0,0x00,0x6B,
+0x6B,0xEB,0x60,0x33,
+0x60,0x33,0x4C,0xEB,
+0x51,0x23,0x04,0x95,
+0x01,0x4D,0x0A,0x5D,
+0x04,0xD5,0x3F,0xF7,
+0x04,0x61,0xC9,0xF7,
+0x1B,0x68,0x0B,0xE8,
+0x00,0x30,0x00,0x30,
+0xE1,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x07,0x95,0xD1,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xD1,0x5A,0x08,0x95,
+0x71,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x09,0x95,0x71,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x0A,0x95,
+0x71,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x0B,0x95,0x71,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xD1,0x5A,0x0C,0x95,
+0x81,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x0D,0x95,0x81,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x0E,0x95,
+0x81,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x0F,0x95,0x81,0xF6,
+0x8C,0x40,0x00,0x1C,
+0xD1,0x5A,0x10,0x95,
+0xD1,0xF6,0x80,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x11,0x95,0xD1,0xF6,
+0x84,0x40,0x00,0x1C,
+0xD1,0x5A,0x12,0x95,
+0x81,0xF6,0x88,0x40,
+0x00,0x1C,0xD1,0x5A,
+0x13,0x95,0x1C,0x97,
+0x1B,0x91,0x1A,0x90,
+0x00,0xEF,0x0F,0x63,
+0x81,0xF4,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0xE0,0xF3,
+0x1F,0x6B,0x4C,0xEB,
+0x91,0xF6,0x84,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x14,0xD3,0xE0,0xF3,
+0x1F,0x6C,0x80,0x34,
+0x80,0x34,0x8C,0xEA,
+0x42,0x33,0x14,0x92,
+0x62,0x33,0x10,0xF0,
+0x02,0x6D,0x00,0xF4,
+0xA0,0x35,0x58,0xEB,
+0x63,0xF3,0x00,0x4D,
+0x17,0xD5,0xE0,0xF3,
+0x1F,0x6D,0x07,0xF7,
+0x00,0x68,0x12,0xEC,
+0x82,0x33,0x17,0x94,
+0xAC,0xEB,0x00,0xF4,
+0x00,0x6D,0x43,0x9C,
+0xAB,0xED,0xAC,0xEA,
+0x6D,0xEA,0x43,0xDC,
+0x81,0xF4,0x80,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x30,0x17,0x94,
+0x00,0xF4,0x00,0x6B,
+0x6B,0xEB,0x6C,0xEA,
+0x63,0x9C,0xE0,0xF3,
+0x1F,0x6D,0x81,0xF4,
+0x80,0x41,0xAC,0xEB,
+0xA2,0x67,0x00,0x1C,
+0xD1,0x5A,0x6D,0xED,
+0x00,0x1C,0x72,0x26,
+0x05,0x6C,0x91,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF3,0x1F,0x6B,
+0x60,0x33,0x60,0x33,
+0x6C,0xEA,0x14,0x93,
+0x42,0x32,0x42,0x32,
+0x78,0xEA,0xE0,0xF3,
+0x1F,0x6C,0x80,0x33,
+0x17,0x94,0x06,0xD2,
+0x43,0x9C,0x12,0xED,
+0xAC,0xEB,0x10,0x6D,
+0xAB,0xED,0xA0,0x35,
+0xA0,0x35,0xE0,0xF3,
+0x1F,0x4D,0x68,0x33,
+0xAC,0xEA,0x6D,0xEA,
+0x43,0xDC,0x81,0xF4,
+0x80,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x3F,0x6B,0x6B,0xEB,
+0x17,0x94,0x60,0x33,
+0x60,0x33,0xFF,0x4B,
+0x6C,0xEA,0x63,0x9C,
+0xE0,0xF3,0x1F,0x6D,
+0x3F,0x6C,0x62,0x33,
+0x6A,0x33,0xAC,0xEB,
+0x8C,0xEB,0x60,0x33,
+0x60,0x33,0xA2,0x67,
+0x81,0xF4,0x80,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x6D,0xED,0x91,0xF4,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x02,0xF0,0x00,0x6D,
+0x06,0x93,0xA0,0x35,
+0xA0,0x35,0xFF,0x4D,
+0xC0,0xF3,0x00,0x6C,
+0xAC,0xEA,0x8C,0xEB,
+0xA2,0x67,0x06,0xD3,
+0x80,0xF5,0x60,0x33,
+0x91,0xF4,0x84,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x6D,0xED,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x11,0xF4,0x84,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0xA1,0xF6,
+0x84,0x41,0x00,0x1C,
+0xEE,0x5A,0x05,0xD2,
+0xE0,0xF3,0x1F,0x6D,
+0xA0,0x35,0xA0,0x35,
+0xAC,0xEA,0x42,0x33,
+0x05,0x92,0x00,0xF4,
+0x00,0x6C,0x8B,0xEC,
+0x62,0x33,0x8C,0xEA,
+0x6D,0xEA,0x11,0xF4,
+0x84,0x41,0xA2,0x67,
+0x00,0x1C,0xD1,0x5A,
+0x05,0xD2,0xA1,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x01,0x6B,0x6B,0xEB,
+0x05,0x95,0x60,0x33,
+0x60,0x33,0xE0,0xF3,
+0x1F,0x4B,0x0C,0xEA,
+0x6C,0xED,0x5A,0x32,
+0x05,0xD5,0x11,0xF4,
+0x84,0x41,0x00,0x1C,
+0xD1,0x5A,0x4D,0xED,
+0x00,0x1C,0x72,0x26,
+0x05,0x6C,0x81,0xF4,
+0x88,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF3,0x1F,0x6C,
+0x4C,0xEC,0x14,0xD4,
+0xB1,0xF6,0x84,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0xE0,0xF3,
+0x1F,0x6D,0xA0,0x35,
+0xA0,0x35,0xAC,0xEA,
+0x42,0x33,0x62,0x33,
+0x81,0xF4,0x88,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x18,0xD3,0x18,0x93,
+0x14,0x94,0x98,0xEB,
+0xE0,0xF3,0x1F,0x6B,
+0x12,0xED,0xA2,0x34,
+0x17,0x95,0x6C,0xEC,
+0x63,0x9D,0x00,0xF4,
+0x00,0x6D,0xAB,0xED,
+0xAC,0xEB,0x8D,0xEB,
+0x17,0x94,0xAC,0xEA,
+0xE0,0xF3,0x1F,0x6D,
+0x63,0xDC,0xAC,0xEB,
+0xA2,0x67,0x81,0xF4,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x6D,0xED,
+0x00,0x1C,0x72,0x26,
+0x05,0x6C,0xB1,0xF6,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xE0,0xF3,0x1F,0x6B,
+0x60,0x33,0x60,0x33,
+0x6C,0xEA,0x14,0x93,
+0x42,0x32,0x42,0x32,
+0x78,0xEA,0xE0,0xF3,
+0x1F,0x6C,0x80,0x33,
+0x17,0x94,0x06,0xD2,
+0x43,0x9C,0x12,0xED,
+0xAC,0xEB,0x10,0x6D,
+0xAB,0xED,0xA0,0x35,
+0xA0,0x35,0xE0,0xF3,
+0x1F,0x4D,0x68,0x33,
+0xAC,0xEA,0x6D,0xEA,
+0x43,0xDC,0x81,0xF4,
+0x88,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0x10,0xF0,0x02,0x6B,
+0x00,0xF4,0x60,0x33,
+0xBE,0xF6,0x10,0x4B,
+0x17,0x94,0xA0,0x9B,
+0xE0,0xF3,0x1F,0x6B,
+0x4C,0xED,0x43,0x9C,
+0x3F,0x6C,0x42,0x32,
+0x4A,0x32,0x6C,0xEA,
+0x8C,0xEA,0x40,0x32,
+0x40,0x32,0x81,0xF4,
+0x88,0x41,0x00,0x1C,
+0xD1,0x5A,0x4D,0xED,
+0x91,0xF4,0x8C,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x10,0xF0,
+0x02,0x6B,0x00,0xF4,
+0x60,0x33,0xBE,0xF6,
+0x14,0x4B,0xA0,0x9B,
+0x06,0x94,0x4C,0xED,
+0xC0,0xF3,0x00,0x6A,
+0x4C,0xEC,0x80,0xF5,
+0x80,0x32,0x91,0xF4,
+0x8C,0x41,0x00,0x1C,
+0xD1,0x5A,0x4D,0xED,
+0x00,0x1C,0x72,0x26,
+0x05,0x6C,0x11,0xF4,
+0x8C,0x41,0x00,0x1C,
+0xEE,0x5A,0x00,0x65,
+0xC1,0xF6,0x84,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x05,0xD2,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0xBE,0xF6,
+0x18,0x4C,0x60,0x9C,
+0x05,0x95,0x11,0xF4,
+0x8C,0x41,0x4C,0xEB,
+0x00,0xF4,0x00,0x6A,
+0x4B,0xEA,0x62,0x33,
+0x62,0x33,0x4C,0xED,
+0x6D,0xED,0x00,0x1C,
+0xD1,0x5A,0x05,0xD5,
+0xC1,0xF6,0x8C,0x41,
+0x00,0x1C,0xEE,0x5A,
+0x00,0x65,0x01,0x6C,
+0x8B,0xEC,0x05,0x93,
+0x80,0x34,0x80,0x34,
+0xE0,0xF3,0x1F,0x4C,
+0x8C,0xEB,0x4C,0xE8,
+0xA3,0x67,0x1A,0x30,
+0x11,0xF4,0x8C,0x41,
+0x00,0x1C,0xD1,0x5A,
+0x0D,0xED,0x00,0x1C,
+0x72,0x26,0x05,0x6C,
+0x1E,0x16,0x00,0x00,
+0xFC,0x63,0x00,0x6B,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x9D,0x67,0x26,0xF7,
+0x61,0xC2,0x42,0x6A,
+0x50,0xC4,0x43,0x6A,
+0x51,0xC4,0x4E,0x6A,
+0x52,0xC4,0x73,0xC4,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x9F,0xF4,0x1C,0x4C,
+0xC0,0xF7,0x10,0x6A,
+0x43,0xDC,0xBD,0x67,
+0x01,0x6A,0x10,0xF0,
+0x01,0x6E,0x00,0xF4,
+0xC0,0x36,0x54,0xC4,
+0x97,0xF0,0x15,0x4E,
+0x06,0x62,0x00,0x1C,
+0x6F,0x27,0x10,0x4D,
+0x06,0x97,0x00,0xEF,
+0x04,0x63,0x00,0x00,
+0xE0,0x63,0x3E,0x62,
+0x3C,0xD0,0x3D,0xD1,
+0x10,0xF0,0x02,0x6D,
+0x00,0xF4,0xA0,0x35,
+0xC7,0x63,0x04,0x04,
+0xBE,0xF6,0x1C,0x4D,
+0x00,0x1C,0xCE,0x53,
+0x94,0x6E,0x9D,0x67,
+0x7F,0x4C,0x10,0xF0,
+0x02,0x6D,0x00,0xF4,
+0xA0,0x35,0xFF,0x6E,
+0x29,0x4C,0x5E,0xF7,
+0x10,0x4D,0x00,0x1C,
+0xCE,0x53,0x09,0x4E,
+0x9D,0x67,0x10,0xF0,
+0x02,0x6D,0x00,0xF4,
+0xA0,0x35,0xFF,0x6E,
+0xA0,0xF1,0x10,0x4C,
+0x5F,0xF0,0x18,0x4D,
+0x00,0x1C,0xCE,0x53,
+0x09,0x4E,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x00,0x6B,
+0x63,0xC2,0x00,0x68,
+0xA2,0x67,0xFF,0x6C,
+0x08,0x32,0x04,0x06,
+0xAD,0xE2,0xC9,0xE2,
+0x40,0x9A,0x01,0x48,
+0x8C,0xE8,0x25,0x58,
+0x46,0xDB,0xF6,0x61,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0x63,0xF3,0x00,0x4A,
+0x00,0x68,0x0A,0x65,
+0xFF,0x69,0x0C,0x32,
+0x68,0x67,0x04,0x04,
+0x00,0x6D,0x7D,0xE2,
+0x99,0xE2,0xAD,0xE6,
+0x80,0xF0,0x58,0xA3,
+0xB1,0xE7,0x01,0x4D,
+0xA0,0xF0,0x4C,0xC4,
+0xA0,0xF1,0x40,0xA3,
+0x2C,0xED,0x08,0x5D,
+0xA0,0xF1,0x54,0xC4,
+0xF2,0x61,0x01,0x48,
+0x2C,0xE8,0x21,0x58,
+0xE8,0x61,0xC8,0x67,
+0x1F,0x6A,0xA0,0xF2,
+0x5E,0xC6,0x00,0x6F,
+0x01,0x6A,0x62,0x9E,
+0xA0,0xF2,0xFF,0xC6,
+0xC0,0xF2,0x40,0xC6,
+0x10,0xF0,0x00,0x6E,
+0xC0,0x36,0xC0,0x36,
+0xFF,0x4E,0x40,0x6A,
+0xCC,0xEB,0x4B,0xEA,
+0x4C,0xEB,0x0C,0x6A,
+0x4D,0xEB,0x07,0xF7,
+0x01,0x6A,0x4B,0xEA,
+0x4C,0xEB,0x03,0xF0,
+0x00,0x6A,0x4D,0xEB,
+0x07,0xF7,0x00,0x6A,
+0x4B,0xEA,0x08,0xF0,
+0x00,0x6C,0x40,0x32,
+0x8B,0xEC,0xFF,0x4A,
+0x80,0x34,0x4C,0xEB,
+0x4F,0x44,0x4C,0xEB,
+0x10,0xF0,0x00,0x6A,
+0x4B,0xEA,0x40,0x32,
+0xFF,0x4A,0x4C,0xEB,
+0x40,0x6A,0x4D,0xEB,
+0x08,0xF0,0x00,0x6D,
+0x81,0x6A,0xAD,0xEB,
+0x4B,0xEA,0x4C,0xEB,
+0xFF,0x6A,0x01,0x4A,
+0x4B,0xEA,0x40,0x32,
+0xEF,0xF7,0x1F,0x4A,
+0x4C,0xEB,0x0C,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0xFF,0x4A,0x4C,0xEB,
+0x48,0x67,0x62,0xDA,
+0xA0,0x35,0x63,0x9A,
+0x44,0x9A,0x80,0x34,
+0xA0,0x35,0xFF,0x4C,
+0xFF,0x4D,0xAC,0xEA,
+0x8C,0xEB,0x88,0x67,
+0x44,0xDC,0x01,0x6A,
+0x4B,0xEA,0xC0,0xF2,
+0x42,0xC4,0xFF,0x6A,
+0xCC,0xEB,0xC0,0xF2,
+0x44,0xCC,0x12,0x6A,
+0xC0,0xF2,0xE6,0xC4,
+0x63,0xDC,0xC0,0xF2,
+0x47,0xC4,0x00,0x1C,
+0x8A,0x49,0x00,0x65,
+0x39,0x63,0x3E,0x97,
+0x3D,0x91,0x3C,0x90,
+0x00,0xEF,0x20,0x63,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x63,0xF3,0x00,0x4C,
+0xFF,0xF7,0x1F,0x6A,
+0x66,0xF7,0x4C,0xDC,
+0x01,0x6A,0x4B,0xEA,
+0xFC,0x63,0x45,0xC4,
+0x1C,0x6A,0x06,0x62,
+0xC0,0xF2,0x4F,0xC4,
+0xC0,0xF2,0x51,0xC4,
+0x0A,0x6A,0x3E,0x6B,
+0xC0,0xF2,0x52,0xC4,
+0x40,0x9C,0xC0,0xF2,
+0x6E,0xC4,0xC0,0xF2,
+0x70,0xC4,0x02,0x6B,
+0x6B,0xEB,0x6C,0xEA,
+0x21,0x6B,0x6B,0xEB,
+0x6C,0xEA,0x00,0x6D,
+0x40,0xDC,0x06,0xF0,
+0x00,0x6A,0xE0,0xF2,
+0xA6,0xC4,0x4B,0xEA,
+0xE0,0xF2,0x64,0x9C,
+0x40,0x32,0x40,0x32,
+0xFF,0x4A,0x4C,0xEB,
+0x20,0x6A,0xC0,0xF2,
+0x57,0xC4,0x08,0xF0,
+0x00,0x6A,0x4B,0xEA,
+0x40,0x32,0x40,0x32,
+0xFF,0x4A,0x4C,0xEB,
+0x10,0xF0,0x00,0x6A,
+0x40,0x32,0x40,0x32,
+0xFF,0x4A,0x4C,0xEB,
+0x20,0x6A,0xC0,0xF2,
+0x48,0xCC,0xFF,0x6A,
+0x01,0x4A,0xE0,0xF2,
+0x64,0xDC,0xC0,0xF2,
+0x4A,0xCC,0x01,0x6B,
+0x00,0xF2,0x00,0x6A,
+0xC0,0xF2,0xB6,0xC4,
+0xC0,0xF2,0xB4,0xC4,
+0xC0,0xF2,0xB5,0xC4,
+0xC0,0xF2,0x4C,0xCC,
+0x61,0xC4,0x44,0x6A,
+0x9D,0x67,0x50,0xC4,
+0x49,0x6A,0x51,0xC4,
+0x47,0x6A,0x52,0xC4,
+0xB3,0xC4,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x9F,0xF4,
+0x00,0x4C,0xC0,0xF7,
+0x10,0x6A,0xBD,0x67,
+0x10,0xF0,0x01,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x43,0xDC,0x74,0xC4,
+0x17,0xF1,0x1D,0x4E,
+0x00,0x1C,0x6F,0x27,
+0x10,0x4D,0x06,0x97,
+0x00,0xEF,0x04,0x63,
+0xFA,0x63,0x08,0xD0,
+0x10,0xF0,0x02,0x68,
+0x00,0xF4,0x00,0x30,
+0x63,0xF3,0x00,0x48,
+0x40,0x98,0x11,0x6B,
+0x6B,0xEB,0x6C,0xEA,
+0x09,0x6B,0x6B,0xEB,
+0x6C,0xEA,0x40,0xD8,
+0x7D,0x67,0x44,0x6A,
+0x50,0xC3,0x49,0x6A,
+0x09,0xD1,0x51,0xC3,
+0x00,0x69,0x47,0x6A,
+0x10,0xF0,0x02,0x6C,
+0x00,0xF4,0x80,0x34,
+0x1F,0xF5,0x0C,0x4C,
+0x52,0xC3,0x33,0xC3,
+0x14,0x6A,0x01,0x6B,
+0xBD,0x67,0x10,0xF0,
+0x01,0x6E,0x00,0xF4,
+0xC0,0x36,0x43,0xDC,
+0x74,0xC4,0x10,0x4D,
+0xF8,0xF2,0x05,0x4E,
+0x0A,0x62,0x00,0x1C,
+0x6F,0x27,0x23,0xC8,
+0x5D,0x67,0x47,0x6B,
+0x78,0xC2,0x7D,0x67,
+0x3B,0x6A,0x59,0xC3,
+0x43,0x6A,0x5A,0xC3,
+0x01,0x6A,0x4B,0xEA,
+0x00,0xF3,0x44,0xC0,
+0xFF,0x6A,0x01,0x4A,
+0x3B,0xC3,0x4B,0xEA,
+0x00,0xF3,0x64,0x98,
+0x40,0x32,0x40,0x32,
+0xE0,0xF0,0x1F,0x4A,
+0x4C,0xEB,0x00,0xF2,
+0x00,0x6A,0x40,0x32,
+0xF3,0xF0,0x14,0x4A,
+0x00,0xF3,0x4C,0xD8,
+0xFF,0x6A,0x01,0x4A,
+0x40,0x32,0x46,0xF0,
+0x16,0x4A,0x00,0xF3,
+0x64,0xD8,0x00,0xF3,
+0x50,0xD8,0x60,0x98,
+0x02,0x6A,0x00,0xF3,
+0x47,0xC0,0x05,0x6A,
+0x4B,0xEA,0x00,0x6C,
+0x4C,0xEB,0x81,0x6A,
+0x00,0xF3,0x88,0xD8,
+0x00,0xF3,0x94,0xD8,
+0x00,0xF3,0x98,0xD8,
+0x4B,0xEA,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x4C,0xEB,
+0xBF,0xF4,0x18,0x4C,
+0xC0,0xF7,0x10,0x6A,
+0x60,0xD8,0xBD,0x67,
+0x43,0xDC,0x10,0xF0,
+0x01,0x6E,0x00,0xF4,
+0xC0,0x36,0x01,0x6A,
+0x54,0xC4,0x78,0xF3,
+0x1D,0x4E,0x00,0x1C,
+0x6F,0x27,0x18,0x4D,
+0x4A,0x6A,0x00,0xF3,
+0x5C,0xC0,0x45,0x6A,
+0x00,0xF3,0x5D,0xC0,
+0x46,0x6A,0x00,0xF3,
+0x5E,0xC0,0x40,0x6A,
+0x00,0xF3,0x5F,0xC0,
+0x23,0x6A,0x20,0xF3,
+0x40,0xC0,0x1E,0x6A,
+0x20,0xF3,0x41,0xC0,
+0x0A,0x97,0x09,0x91,
+0x08,0x90,0x00,0xEF,
+0x06,0x63,0x00,0x00,
+0xFC,0x63,0x7D,0x67,
+0x3B,0x6A,0x50,0xC3,
+0x43,0x6A,0x51,0xC3,
+0x36,0x6A,0x52,0xC3,
+0x00,0x6B,0x5D,0x67,
+0x73,0xC2,0x10,0xF0,
+0x02,0x6A,0x00,0xF4,
+0x40,0x32,0x63,0xF3,
+0x00,0x4A,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0xDF,0xF4,
+0x14,0x4C,0xC0,0xF2,
+0x73,0xC2,0xC0,0xF7,
+0x10,0x6A,0x43,0xDC,
+0xBD,0x67,0x01,0x6A,
+0x10,0xF0,0x01,0x6E,
+0x00,0xF4,0xC0,0x36,
+0x54,0xC4,0x98,0xF6,
+0x15,0x4E,0x06,0x62,
+0x00,0x1C,0x6F,0x27,
+0x10,0x4D,0x06,0x97,
+0x00,0xEF,0x04,0x63,
+0x10,0xF0,0x02,0x6A,
+0x00,0xF4,0x40,0x32,
+0xFC,0x63,0x63,0xF3,
+0x00,0x4A,0x01,0x6D,
+0x00,0x6B,0x9D,0x67,
+0x66,0xF7,0xB6,0xCA,
+0x66,0xF7,0x74,0xCA,
+0x52,0x6A,0x50,0xC4,
+0x53,0x6A,0x51,0xC4,
+0x54,0x6A,0x52,0xC4,
+0x73,0xC4,0x10,0xF0,
+0x02,0x6C,0x00,0xF4,
+0x80,0x34,0x3F,0xF5,
+0x08,0x4C,0xE0,0xF1,
+0x14,0x6A,0xB4,0xC4,
+0x10,0xF0,0x02,0x6E,
+0x00,0xF4,0xC0,0x36,
+0xBD,0x67,0x43,0xDC,
+0xB0,0xF0,0x05,0x4E,
+0x06,0x62,0x00,0x1C,
+0x6F,0x27,0x10,0x4D,
+0x06,0x97,0x00,0xEF,
+0x04,0x63,0x00,0x65,
+0xD8,0xFF,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x80,0xF9,0x62,0x24,
+0x02,0x00,0x48,0x90,
+0x80,0xF9,0x67,0x94,
+0x02,0x80,0x02,0x3C,
+0xE0,0x63,0x42,0x24,
+0x02,0x00,0x11,0x24,
+0x01,0x80,0x06,0x3C,
+0x21,0x20,0x40,0x00,
+0x14,0x00,0x51,0xA0,
+0x10,0x00,0xA5,0x27,
+0x84,0xDB,0xC6,0x24,
+0x02,0x80,0x10,0x3C,
+0x10,0x00,0xA7,0xA7,
+0x12,0x00,0xA8,0xA3,
+0x58,0x64,0x10,0x26,
+0x6F,0x27,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x02,0x80,0x06,0x3C,
+0x21,0x20,0x00,0x02,
+0x10,0x00,0xA5,0x27,
+0x14,0x00,0x11,0xA2,
+0x6F,0x27,0x00,0x0C,
+0x0C,0x83,0xC6,0x24,
+0x02,0x80,0x03,0x3C,
+0xFC,0x63,0x63,0x24,
+0xE8,0x03,0x02,0x24,
+0x02,0x80,0x06,0x3C,
+0x21,0x20,0x60,0x00,
+0x10,0x00,0xA5,0x27,
+0x0C,0x00,0x02,0xAE,
+0x14,0x00,0x71,0xA0,
+0x6F,0x27,0x00,0x0C,
+0x08,0x82,0xC6,0x24,
+0x02,0x80,0x02,0x3C,
+0x18,0x64,0x40,0xA0,
+0x0C,0x00,0x09,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x19,0x64,0x69,0xA0,
+0x1A,0x64,0x49,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x36,0x64,0x60,0xA0,
+0x38,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x3E,0x64,0x60,0xA0,
+0x01,0x00,0x08,0x24,
+0x3F,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x1C,0x64,0x68,0xA0,
+0x02,0x80,0x06,0x3C,
+0x40,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x64,0x00,0x04,0x24,
+0x1B,0x64,0x68,0xA0,
+0x28,0x64,0x40,0xA0,
+0x2A,0x64,0xC4,0xA4,
+0x2A,0x64,0xC3,0x94,
+0x02,0x80,0x04,0x3C,
+0xB8,0x88,0x05,0x34,
+0xFF,0xFF,0x63,0x30,
+0x80,0x1A,0x03,0x00,
+0x2C,0x64,0x83,0xAC,
+0x2A,0x64,0xC2,0x94,
+0x02,0x80,0x03,0x3C,
+0x5E,0x5F,0x64,0x90,
+0xFF,0xFF,0x42,0x30,
+0x1A,0x00,0xA2,0x00,
+0x02,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x02,0x00,0x84,0x30,
+0x01,0x00,0x84,0x2C,
+0x02,0x00,0x06,0x24,
+0x23,0x30,0xC4,0x00,
+0x02,0x80,0x0A,0x3C,
+0x21,0x20,0x00,0x00,
+0x20,0x64,0x47,0x25,
+0x12,0x28,0x00,0x00,
+0x34,0x64,0x45,0xA4,
+0x02,0x80,0x02,0x3C,
+0x30,0x64,0x60,0xAC,
+0x37,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x39,0x64,0x60,0xA0,
+0x41,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x74,0x64,0x66,0xA0,
+0x3A,0x64,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x3B,0x64,0x68,0xA0,
+0x3C,0x64,0x48,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x3D,0x64,0x60,0xA0,
+0x21,0x28,0x00,0x00,
+0x44,0x64,0x40,0xAC,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x48,0x64,0x60,0xAC,
+0x50,0x64,0x44,0xAC,
+0xD0,0x07,0x03,0x24,
+0x54,0x64,0x45,0xAC,
+0x03,0x00,0x02,0x24,
+0x20,0x64,0x40,0xA1,
+0x01,0x00,0xE8,0xA0,
+0x04,0x00,0xE2,0xA0,
+0x02,0x00,0xE3,0xA4,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x12,0x00,0x02,0x24,
+0x28,0x00,0xBD,0x27,
+0x05,0x00,0xE9,0xA0,
+0x06,0x00,0xE2,0xA0,
+0x07,0x00,0xE0,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x21,0x98,0xA0,0x00,
+0x21,0x88,0xC0,0x00,
+0x21,0x90,0x00,0x00,
+0x00,0x00,0x04,0x82,
+0x53,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0xFF,0xFF,0x10,0x26,
+0x00,0x00,0x04,0x92,
+0x2B,0x00,0x02,0x24,
+0x00,0x1E,0x04,0x00,
+0x03,0x1E,0x03,0x00,
+0x41,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x02,0x24,
+0x30,0x00,0x22,0x12,
+0x00,0x1E,0x04,0x00,
+0x07,0x00,0x20,0x16,
+0x21,0x18,0x80,0x00,
+0x00,0x1E,0x04,0x00,
+0x03,0x1E,0x03,0x00,
+0x30,0x00,0x02,0x24,
+0x3B,0x00,0x62,0x10,
+0x0A,0x00,0x11,0x24,
+0x21,0x18,0x80,0x00,
+0x00,0x16,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x1A,0x00,0x40,0x10,
+0xFF,0x00,0x64,0x30,
+0xA9,0xFF,0x82,0x24,
+0x61,0x00,0x83,0x2C,
+0xFF,0x00,0x45,0x30,
+0x09,0x00,0x60,0x10,
+0x41,0x00,0x86,0x2C,
+0xC9,0xFF,0x82,0x24,
+0xFF,0x00,0x45,0x30,
+0x05,0x00,0xC0,0x10,
+0x3A,0x00,0x87,0x2C,
+0xD0,0xFF,0x82,0x24,
+0x02,0x00,0xE0,0x10,
+0xFF,0x00,0x05,0x24,
+0xFF,0x00,0x45,0x30,
+0x2A,0x10,0xB1,0x00,
+0x0A,0x00,0x40,0x10,
+0x18,0x00,0x51,0x02,
+0x01,0x00,0x10,0x26,
+0x12,0x10,0x00,0x00,
+0x2B,0x18,0x52,0x00,
+0x23,0x00,0x60,0x14,
+0x21,0x90,0xA2,0x00,
+0x00,0x00,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0x60,0x14,
+0xFF,0x00,0x64,0x30,
+0x02,0x00,0x60,0x12,
+0x21,0x10,0x40,0x02,
+0x00,0x00,0x70,0xAE,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x03,0x1E,0x03,0x00,
+0x30,0x00,0x02,0x24,
+0xCE,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x82,
+0x78,0x00,0x02,0x24,
+0x03,0x00,0x62,0x10,
+0x58,0x00,0x02,0x24,
+0xD0,0xFF,0x62,0x14,
+0x21,0x18,0x80,0x00,
+0x02,0x00,0x10,0x26,
+0x00,0x00,0x04,0x92,
+0x84,0x72,0x00,0x08,
+0x10,0x00,0x11,0x24,
+0x01,0x00,0x10,0x26,
+0x00,0x00,0x04,0x92,
+0x7B,0x72,0x00,0x08,
+0x10,0x00,0x02,0x24,
+0xB0,0x72,0x00,0x08,
+0x08,0x00,0x11,0x24,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0xFF,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x21,0x48,0x80,0x00,
+0x31,0x00,0xC0,0x14,
+0x21,0x50,0x00,0x00,
+0x00,0x00,0x87,0x90,
+0x30,0x00,0x02,0x24,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0x2E,0x00,0x62,0x10,
+0x0A,0x00,0x06,0x24,
+0x02,0x80,0x02,0x3C,
+0x40,0xFB,0x4B,0x24,
+0xFF,0x00,0xE8,0x30,
+0x21,0x10,0x0B,0x01,
+0x00,0x00,0x44,0x90,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0x44,0x00,0x82,0x30,
+0x02,0x00,0x87,0x30,
+0xD0,0xFF,0x63,0x24,
+0x1A,0x00,0x40,0x10,
+0x04,0x00,0x84,0x30,
+0x07,0x00,0x80,0x14,
+0x2B,0x10,0x66,0x00,
+0x21,0x10,0x00,0x01,
+0x02,0x00,0xE0,0x10,
+0xE0,0xFF,0x03,0x25,
+0xFF,0x00,0x62,0x30,
+0xC9,0xFF,0x43,0x24,
+0x2B,0x10,0x66,0x00,
+0x10,0x00,0x40,0x10,
+0x18,0x00,0x46,0x01,
+0x01,0x00,0x29,0x25,
+0x00,0x00,0x27,0x91,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xE8,0x30,
+0x12,0x10,0x00,0x00,
+0x21,0x50,0x43,0x00,
+0x21,0x10,0x0B,0x01,
+0x00,0x00,0x44,0x90,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0x44,0x00,0x82,0x30,
+0x02,0x00,0x87,0x30,
+0xD0,0xFF,0x63,0x24,
+0xE8,0xFF,0x40,0x14,
+0x04,0x00,0x84,0x30,
+0x02,0x00,0xA0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA9,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x40,0x01,
+0x00,0x00,0x87,0x90,
+0xD2,0x72,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x89,0x24,
+0x00,0x00,0x27,0x91,
+0x78,0x00,0x02,0x24,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0xCD,0xFF,0x62,0x14,
+0x08,0x00,0x06,0x24,
+0x01,0x00,0x22,0x91,
+0x02,0x80,0x03,0x3C,
+0x40,0xFB,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x84,0x30,
+0xC5,0xFF,0x80,0x10,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x29,0x25,
+0x00,0x00,0x27,0x91,
+0xD2,0x72,0x00,0x08,
+0x10,0x00,0x06,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x00,0x00,0x83,0x80,
+0x2D,0x00,0x02,0x24,
+0x04,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0xC8,0x72,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xC8,0x72,0x00,0x0C,
+0x01,0x00,0x84,0x24,
+0x10,0x00,0xBF,0x8F,
+0x23,0x10,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x21,0x90,0xA0,0x00,
+0x21,0x98,0xC0,0x00,
+0x21,0x88,0x00,0x00,
+0x00,0x00,0x04,0x82,
+0x53,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0xFF,0xFF,0x10,0x26,
+0x00,0x00,0x03,0x82,
+0x2D,0x00,0x02,0x24,
+0x0F,0x00,0x62,0x10,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x40,0x02,
+0x64,0x72,0x00,0x0C,
+0x21,0x30,0x60,0x02,
+0x12,0x00,0x40,0x04,
+0x21,0x18,0x40,0x00,
+0x23,0x10,0x02,0x00,
+0x0A,0x10,0x71,0x00,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x01,0x00,0x10,0x26,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x40,0x02,
+0x64,0x72,0x00,0x0C,
+0x21,0x30,0x60,0x02,
+0xFF,0xFF,0x11,0x24,
+0xF0,0xFF,0x41,0x04,
+0x21,0x18,0x40,0x00,
+0xF0,0xFF,0x20,0x16,
+0x00,0x80,0x02,0x3C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0x7F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x00,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x01,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x02,0x7E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x03,0x7D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x04,0x7C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x05,0x7B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x06,0x7A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x07,0x79,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x08,0x78,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x09,0x77,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0A,0x76,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0B,0x75,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0C,0x74,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0D,0x73,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0E,0x72,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0F,0x71,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x10,0x70,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x11,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x12,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x13,0x6E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x14,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x15,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x16,0x6C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x17,0x6B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x18,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x19,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1A,0x69,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1B,0x68,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1C,0x67,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1D,0x66,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1E,0x65,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1F,0x64,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x20,0x63,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x21,0x4C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x22,0x4B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x23,0x4A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x24,0x49,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x25,0x48,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x26,0x47,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x27,0x46,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x28,0x45,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x29,0x44,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2A,0x2C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2B,0x2B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2C,0x2A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2D,0x29,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2E,0x28,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2F,0x27,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x30,0x26,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x31,0x25,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x32,0x24,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x33,0x23,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x34,0x22,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x35,0x09,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x36,0x08,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x37,0x07,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x38,0x06,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x39,0x05,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3A,0x04,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3B,0x03,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3C,0x02,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3D,0x01,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3E,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3F,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x40,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x41,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x42,0x7E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x43,0x7D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x44,0x7C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x45,0x7B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x46,0x7A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x47,0x79,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x48,0x78,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x49,0x77,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4A,0x76,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4B,0x75,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4C,0x74,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4D,0x73,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4E,0x72,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4F,0x71,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x50,0x70,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x51,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x52,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x53,0x6E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x54,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x55,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x56,0x6C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x57,0x6B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x58,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x59,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5A,0x69,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5B,0x68,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5C,0x67,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5D,0x66,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5E,0x65,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5F,0x64,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x60,0x63,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x61,0x4C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x62,0x4B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x63,0x4A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x64,0x49,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x65,0x48,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x66,0x47,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x67,0x46,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x68,0x45,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x69,0x44,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6A,0x2C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6B,0x2B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6C,0x2A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6D,0x29,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6E,0x28,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6F,0x27,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x70,0x26,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x71,0x25,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x72,0x24,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x73,0x23,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x74,0x22,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x75,0x09,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x76,0x08,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x77,0x07,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x78,0x06,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x79,0x05,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7A,0x04,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7B,0x03,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7C,0x02,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7D,0x01,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7E,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7F,0x00,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x00,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x01,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x02,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x03,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x04,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x05,0x34,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x06,0x38,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x07,0x3E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x08,0x3E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x09,0x44,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0A,0x46,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0B,0x48,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0C,0x48,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0D,0x4E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0E,0x56,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0F,0x5A,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x10,0x5E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x11,0x62,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x12,0x6C,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x13,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x14,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x15,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x16,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x17,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x18,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x19,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1A,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1B,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1C,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1D,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1E,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1F,0x72,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x06,0x06,0x06,0x04,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x04,0x02,0x02,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x0A,0x08,0x08,0x04,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x04,0x02,0x02,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x0A,0x08,0x08,0x04,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x04,0x02,0x02,0x00,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x08,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x24,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x2C,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x70,0x08,0x00,0x00,
+0x00,0x00,0x00,0x04,
+0x01,0x00,0x00,0x00,
+0x64,0x08,0x00,0x00,
+0x00,0x04,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x78,0x08,0x00,0x00,
+0x0F,0x00,0x0F,0x00,
+0x02,0x00,0x02,0x00,
+0x74,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x78,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x7C,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x80,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x04,0x0C,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0xF4,0x01,0x00,0x00,
+0x00,0x00,0xFF,0xFF,
+0xFF,0xFF,0x00,0x00,
+0x34,0x02,0x00,0x00,
+0x00,0x00,0x00,0xF8,
+0x13,0x00,0x00,0x00,
+0x04,0x08,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x24,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x2C,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x02,0x00,0x30,0x00,
+0x70,0x08,0x00,0x00,
+0x00,0x00,0x00,0x04,
+0x01,0x00,0x00,0x00,
+0x64,0x08,0x00,0x00,
+0x00,0x04,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x78,0x08,0x00,0x00,
+0x0F,0x00,0x0F,0x00,
+0x02,0x00,0x00,0x00,
+0x74,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x78,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x7C,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x80,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x11,0x00,0x00,0x00,
+0x04,0x0C,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0xF4,0x01,0x00,0x00,
+0x00,0x00,0xFF,0xFF,
+0x77,0x77,0x00,0x00,
+0x34,0x02,0x00,0x00,
+0x00,0x00,0x00,0xF8,
+0x0A,0x00,0x00,0x00,
+0x44,0x08,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x01,0x00,
+0x04,0x08,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x24,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x2C,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x02,0x00,0x10,0x00,
+0x70,0x08,0x00,0x00,
+0x00,0x00,0x00,0x04,
+0x01,0x00,0x00,0x00,
+0x64,0x08,0x00,0x00,
+0x00,0x04,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x78,0x08,0x00,0x00,
+0x0F,0x00,0x0F,0x00,
+0x02,0x00,0x00,0x00,
+0x74,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x78,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x7C,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x80,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x11,0x00,0x00,0x00,
+0x04,0x0C,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x11,0x00,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0xF4,0x01,0x00,0x00,
+0x00,0x00,0xFF,0xFF,
+0x77,0x77,0x00,0x00,
+0x34,0x02,0x00,0x00,
+0x00,0x00,0x00,0xF8,
+0x0A,0x00,0x00,0x00,
+0x1C,0x00,0x00,0x00,
+0x00,0x00,0x00,0x07,
+0x00,0x08,0x00,0x00,
+0x00,0x00,0x04,0x00,
+0x04,0x08,0x00,0x00,
+0x03,0x80,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x00,0xFC,0x00,0x00,
+0x0C,0x08,0x00,0x00,
+0x0A,0x00,0x00,0x00,
+0x10,0x08,0x00,0x00,
+0x88,0x50,0x00,0x10,
+0x14,0x08,0x00,0x00,
+0x10,0x3D,0x0C,0x02,
+0x18,0x08,0x00,0x00,
+0x85,0x01,0x20,0x00,
+0x1C,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x20,0x08,0x00,0x00,
+0x00,0x00,0x00,0x01,
+0x24,0x08,0x00,0x00,
+0x04,0x00,0x39,0x00,
+0x28,0x08,0x00,0x00,
+0x00,0x00,0x00,0x01,
+0x2C,0x08,0x00,0x00,
+0x04,0x00,0x39,0x00,
+0x30,0x08,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x34,0x08,0x00,0x00,
+0x00,0x02,0x69,0x00,
+0x38,0x08,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x3C,0x08,0x00,0x00,
+0x00,0x02,0x69,0x00,
+0x40,0x08,0x00,0x00,
+0x00,0x00,0x01,0x00,
+0x44,0x08,0x00,0x00,
+0x00,0x00,0x01,0x00,
+0x48,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x4C,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x50,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x54,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x58,0x08,0x00,0x00,
+0x48,0x48,0x48,0x48,
+0x5C,0x08,0x00,0x00,
+0xA9,0x65,0xA9,0x65,
+0x60,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x64,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x68,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x6C,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x70,0x08,0x00,0x00,
+0x00,0x07,0x00,0x03,
+0x74,0x08,0x00,0x00,
+0x00,0x03,0x00,0x03,
+0x78,0x08,0x00,0x00,
+0x02,0x00,0x02,0x00,
+0x7C,0x08,0x00,0x00,
+0x01,0x02,0x4F,0x00,
+0x80,0x08,0x00,0x00,
+0xC1,0x0A,0x30,0xA8,
+0x84,0x08,0x00,0x00,
+0x58,0x00,0x00,0x00,
+0x88,0x08,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x8C,0x08,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x90,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x94,0x08,0x00,0x00,
+0xFE,0xFF,0xFF,0xFF,
+0x98,0x08,0x00,0x00,
+0x10,0x20,0x30,0x40,
+0x9C,0x08,0x00,0x00,
+0x50,0x60,0x70,0x00,
+0xB0,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xE0,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xE4,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x0E,0x00,0x00,
+0x33,0x33,0x33,0x30,
+0x04,0x0E,0x00,0x00,
+0x2F,0x2E,0x2D,0x2A,
+0x08,0x0E,0x00,0x00,
+0x32,0x32,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0x33,0x33,0x33,0x30,
+0x14,0x0E,0x00,0x00,
+0x2F,0x2E,0x2D,0x2A,
+0x18,0x0E,0x00,0x00,
+0x33,0x33,0x33,0x30,
+0x1C,0x0E,0x00,0x00,
+0x2F,0x2E,0x2D,0x2A,
+0x30,0x0E,0x00,0x00,
+0x00,0x7C,0x00,0x01,
+0x34,0x0E,0x00,0x00,
+0x00,0x48,0x00,0x01,
+0x38,0x0E,0x00,0x00,
+0x1F,0xDC,0x00,0x10,
+0x3C,0x0E,0x00,0x00,
+0x1F,0x8C,0x00,0x10,
+0x40,0x0E,0x00,0x00,
+0xA0,0x00,0x14,0x02,
+0x44,0x0E,0x00,0x00,
+0xA0,0x00,0x16,0x28,
+0x48,0x0E,0x00,0x00,
+0x01,0x00,0x00,0xF8,
+0x4C,0x0E,0x00,0x00,
+0x10,0x29,0x00,0x00,
+0x50,0x0E,0x00,0x00,
+0x00,0x7C,0x00,0x01,
+0x54,0x0E,0x00,0x00,
+0x00,0x48,0x00,0x01,
+0x58,0x0E,0x00,0x00,
+0x1F,0xDC,0x00,0x10,
+0x5C,0x0E,0x00,0x00,
+0x1F,0x8C,0x00,0x10,
+0x60,0x0E,0x00,0x00,
+0xA0,0x00,0x14,0x02,
+0x64,0x0E,0x00,0x00,
+0xA0,0x00,0x16,0x28,
+0x6C,0x0E,0x00,0x00,
+0x10,0x29,0x00,0x00,
+0x70,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0x74,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x78,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x7C,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x80,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x84,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0x88,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0x8C,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0xD0,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0xD4,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0xD8,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0xDC,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0xE0,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0xE4,0x0E,0x00,0x00,
+0x48,0x54,0x5E,0x01,
+0xE8,0x0E,0x00,0x00,
+0x48,0x54,0x55,0x21,
+0x00,0x09,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x04,0x09,0x00,0x00,
+0x23,0x00,0x00,0x00,
+0x08,0x09,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0x13,0x13,0x12,0x01,
+0x00,0x0A,0x00,0x00,
+0xC8,0x47,0xD0,0x00,
+0x04,0x0A,0x00,0x00,
+0x08,0x00,0xFF,0x80,
+0x08,0x0A,0x00,0x00,
+0x00,0x83,0xCD,0x88,
+0x0C,0x0A,0x00,0x00,
+0x0F,0x12,0x62,0x2E,
+0x10,0x0A,0x00,0x00,
+0x78,0xBB,0x00,0x95,
+0x14,0x0A,0x00,0x00,
+0x28,0x40,0x14,0x11,
+0x18,0x0A,0x00,0x00,
+0x17,0x11,0x88,0x00,
+0x1C,0x0A,0x00,0x00,
+0x00,0x0F,0x14,0x89,
+0x20,0x0A,0x00,0x00,
+0x00,0x00,0x1B,0x1A,
+0x24,0x0A,0x00,0x00,
+0x17,0x13,0x0E,0x09,
+0x28,0x0A,0x00,0x00,
+0x04,0x02,0x00,0x00,
+0x2C,0x0A,0x00,0x00,
+0x00,0x00,0xD3,0x10,
+0x00,0x0C,0x00,0x00,
+0x40,0x1D,0x07,0x40,
+0x04,0x0C,0x00,0x00,
+0x33,0x56,0xA0,0x00,
+0x08,0x0C,0x00,0x00,
+0xE4,0x00,0x00,0x00,
+0x0C,0x0C,0x00,0x00,
+0x6C,0x6C,0x6C,0x6C,
+0x10,0x0C,0x00,0x00,
+0x00,0x00,0x80,0x08,
+0x14,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x18,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x08,
+0x1C,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x20,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x08,
+0x24,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x28,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x08,
+0x2C,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x30,0x0C,0x00,0x00,
+0x44,0xAC,0xE9,0x6D,
+0x34,0x0C,0x00,0x00,
+0xCF,0x52,0x96,0x46,
+0x38,0x0C,0x00,0x00,
+0x94,0x59,0x79,0x49,
+0x3C,0x0C,0x00,0x00,
+0x64,0x97,0x97,0x0A,
+0x40,0x0C,0x00,0x00,
+0x3F,0x40,0x7C,0x1F,
+0x44,0x0C,0x00,0x00,
+0xB7,0x00,0x01,0x00,
+0x48,0x0C,0x00,0x00,
+0x00,0x00,0x02,0xEC,
+0x4C,0x0C,0x00,0x00,
+0x7F,0x03,0x7F,0x00,
+0x50,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x54,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x58,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x5C,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x60,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x64,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x68,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x6C,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x70,0x0C,0x00,0x00,
+0x0D,0x00,0x7F,0x2C,
+0x74,0x0C,0x00,0x00,
+0x5B,0x17,0x86,0x01,
+0x78,0x0C,0x00,0x00,
+0x1F,0x00,0x00,0x00,
+0x7C,0x0C,0x00,0x00,
+0x12,0x16,0xB9,0x00,
+0x80,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x84,0x0C,0x00,0x00,
+0x00,0x00,0xF6,0x20,
+0x88,0x0C,0x00,0x00,
+0x80,0x00,0x00,0x20,
+0x8C,0x0C,0x00,0x00,
+0x00,0x00,0x20,0x20,
+0x90,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x94,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x98,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x9C,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA0,0x0C,0x00,0x00,
+0x92,0x24,0x49,0x00,
+0xA4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA8,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xAC,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB0,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB8,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xBC,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x28,
+0xC0,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xC4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xC8,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xCC,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD0,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD8,0x0C,0x00,0x00,
+0x27,0x24,0xB2,0x64,
+0xDC,0x0C,0x00,0x00,
+0x32,0x69,0x76,0x00,
+0xE0,0x0C,0x00,0x00,
+0x22,0x22,0x22,0x00,
+0xE4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xE8,0x0C,0x00,0x00,
+0x02,0x43,0x64,0x37,
+0xEC,0x0C,0x00,0x00,
+0x0C,0xD4,0x97,0x2F,
+0x00,0x0D,0x00,0x00,
+0x50,0x07,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x03,0x04,0x00,0x00,
+0x08,0x0D,0x00,0x00,
+0x7F,0x90,0x00,0x00,
+0x0C,0x0D,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x10,0x0D,0x00,0x00,
+0x33,0x33,0x63,0xA0,
+0x14,0x0D,0x00,0x00,
+0x63,0x3C,0x33,0x33,
+0x18,0x0D,0x00,0x00,
+0x6B,0x5B,0x8F,0x6A,
+0x1C,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x20,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x24,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x28,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x2C,0x0D,0x00,0x00,
+0x75,0x99,0x97,0xCC,
+0x30,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x34,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x38,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x3C,0x0D,0x00,0x00,
+0x93,0x72,0x02,0x00,
+0x40,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x44,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x48,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x50,0x0D,0x00,0x00,
+0x0A,0x14,0x37,0x64,
+0x54,0x0D,0x00,0x00,
+0x02,0xBD,0x4D,0x02,
+0x58,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x5C,0x0D,0x00,0x00,
+0x64,0x20,0x03,0x30,
+0x60,0x0D,0x00,0x00,
+0x68,0xDE,0x53,0x46,
+0x64,0x0D,0x00,0x00,
+0x3C,0x8A,0x51,0x00,
+0x68,0x0D,0x00,0x00,
+0x01,0x21,0x00,0x00,
+0x14,0x0F,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x4C,0x0F,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x0F,0x00,0x00,
+0x00,0x03,0x00,0x00,
+0x40,0x01,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x10,0x00,0x00,0x00,
+0xC0,0x03,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0xF0,0x03,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x38,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x40,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x48,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x50,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x28,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x30,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x88,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x90,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x94,0x05,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x8C,0x05,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x98,0x0A,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0xA0,0x0A,0x01,0x80,
+0x74,0x03,0x00,0x00,
+0xC0,0x27,0x00,0x80,
+0x04,0x00,0x00,0x00,
+0xC0,0x07,0x01,0x80,
+0x74,0x03,0x00,0x00,
+0xC0,0x27,0x00,0x80,
+0x04,0x00,0x00,0x00,
+0x5C,0x2A,0x00,0x80,
+0x3C,0x00,0x00,0x00,
+0x0C,0x32,0x00,0x80,
+0x04,0x00,0x00,0x00,
+0x20,0x2B,0x00,0x80,
+0x13,0x00,0x00,0x00,
+0xF4,0x08,0x01,0x80,
+0x17,0x00,0x00,0x00,
+0x48,0x09,0x01,0x80,
+0x06,0x00,0x00,0x00,
+0xD0,0x09,0x01,0x80,
+0x06,0x00,0x00,0x00,
+0xD8,0x09,0x01,0x80,
+0x08,0x00,0x00,0x00,
+0xE0,0x09,0x01,0x80,
+0x0C,0x00,0x00,0x00,
+0xE8,0x09,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xF0,0x09,0x01,0x80,
+0x0E,0x00,0x00,0x00,
+0xF8,0x09,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0x00,0x0A,0x01,0x80,
+0x70,0x00,0x00,0x00,
+0x08,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x10,0x0A,0x01,0x80,
+0x02,0x00,0x00,0x00,
+0x18,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x20,0x0A,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0x60,0x0A,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0x68,0x0A,0x01,0x80,
+0x0C,0x00,0x00,0x00,
+0x9C,0x05,0x01,0x80,
+0x0E,0x00,0x00,0x00,
+0xA4,0x05,0x01,0x80,
+0x0C,0x00,0x00,0x00,
+0xB8,0x07,0x01,0x80,
+0x34,0x00,0x00,0x00,
+0x70,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x78,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xA8,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xB0,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xB8,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x80,0x0A,0x01,0x80,
+0x08,0x00,0x00,0x00,
+0xF4,0x04,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xC0,0x0A,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x38,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x44,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x4C,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x54,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x5C,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x64,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x6C,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x74,0x0B,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x7C,0x0B,0x01,0x80,
+0x74,0x03,0x00,0x00,
+0x84,0x0B,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0x64,0x0C,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x88,0x34,0x00,0x80,
+0x06,0x00,0x00,0x00,
+0xA0,0x0C,0x01,0x80,
+0x08,0x00,0x00,0x00,
+0xF4,0x0C,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xE8,0x2E,0x00,0x80,
+0x08,0x00,0x00,0x00,
+0x18,0x0D,0x01,0x80,
+0x1C,0x00,0x00,0x00,
+0x28,0x2F,0x00,0x80,
+0x08,0x00,0x00,0x00,
+0x48,0x0D,0x01,0x80,
+0x08,0x00,0x00,0x00,
+0xDC,0x0D,0x01,0x80,
+0x13,0x00,0x00,0x00,
+0xF8,0x9E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xC8,0x5E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xF8,0x0E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xC8,0xCE,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xD4,0x8E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xA4,0x4E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xD0,0x0E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0xCE,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xD0,0x86,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0x46,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0x06,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xA4,0x9E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0x74,0x5E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xA4,0x0E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xD0,0xCE,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x40,0x9F,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0x4E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0x06,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0xC6,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0x82,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0x42,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x40,0x02,0x00,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x03,0x00,
+0x01,0x00,0x00,0x00,
+0x41,0x10,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x00,0x10,0x01,0x00,
+0x05,0x00,0x00,0x00,
+0xC0,0x0F,0x08,0x00,
+0x07,0x00,0x00,0x00,
+0x03,0xC8,0x0F,0x00,
+0x13,0x00,0x00,0x00,
+0xB0,0x7C,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xC0,0x1C,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x60,0xDC,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x60,0x8C,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x50,0x44,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x20,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x03,0x00,
+0x01,0x00,0x00,0x00,
+0x50,0x02,0x03,0x00,
+0x02,0x00,0x00,0x00,
+0x00,0x00,0x01,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x08,0x00,
+0x11,0x00,0x00,0x00,
+0xFC,0x31,0x02,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x0C,0x00,
+0x11,0x00,0x00,0x00,
+0xF8,0xF9,0x03,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x02,0x00,
+0x11,0x00,0x00,0x00,
+0x01,0x01,0x02,0x00,
+0x14,0x00,0x00,0x00,
+0x3E,0x09,0x01,0x00,
+0x14,0x00,0x00,0x00,
+0x3E,0x09,0x09,0x00,
+0x15,0x00,0x00,0x00,
+0xF4,0x98,0x01,0x00,
+0x17,0x00,0x00,0x00,
+0x00,0x65,0x0F,0x00,
+0x1A,0x00,0x00,0x00,
+0x56,0x30,0x01,0x00,
+0x1B,0x00,0x00,0x00,
+0x00,0x00,0x06,0x00,
+0x1C,0x00,0x00,0x00,
+0x00,0x03,0x00,0x00,
+0x1E,0x00,0x00,0x00,
+0x59,0x10,0x03,0x00,
+0x21,0x00,0x00,0x00,
+0x00,0x40,0x05,0x00,
+0x22,0x00,0x00,0x00,
+0x3C,0x08,0x00,0x00,
+0x23,0x00,0x00,0x00,
+0x58,0x15,0x00,0x00,
+0x24,0x00,0x00,0x00,
+0x60,0x00,0x00,0x00,
+0x25,0x00,0x00,0x00,
+0x83,0x25,0x02,0x00,
+0x26,0x00,0x00,0x00,
+0x00,0xF2,0x00,0x00,
+0x27,0x00,0x00,0x00,
+0xF1,0xAC,0x0E,0x00,
+0x28,0x00,0x00,0x00,
+0x54,0xBD,0x09,0x00,
+0x29,0x00,0x00,0x00,
+0x82,0x45,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x34,0x13,0x02,0x00,
+0x2A,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0C,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x05,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x06,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x07,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x09,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0A,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0B,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0C,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0B,0x05,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0E,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0B,0x05,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x23,0x66,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x1A,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x00,0x40,0x0E,0x00,
+0x30,0x00,0x00,0x00,
+0x00,0x00,0x02,0x00,
+0x31,0x00,0x00,0x00,
+0x31,0x96,0x0B,0x00,
+0x32,0x00,0x00,0x00,
+0x0D,0x13,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x87,0x01,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x6C,0x9E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x94,0x5E,0x01,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x01,0x00,
+0x18,0x00,0x00,0x00,
+0x01,0xF4,0x00,0x00,
+0xFE,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x1E,0x00,0x00,0x00,
+0x5B,0x10,0x03,0x00,
+0xFE,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x03,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x04,0x00,
+0x11,0x00,0x00,0x00,
+0xF9,0x03,0x02,0x00,
+0x6C,0x09,0x00,0x00,
+0x0B,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0x0C,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x0D,0x12,0x12,
+0x12,0x12,0x12,0x12,
+0x12,0x12,0x12,0x12,
+0x12,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x0F,0x0F,
+0x0F,0x0F,0x0F,0x0F,
+0x0F,0x0F,0x0F,0x0F,
+0x0F,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x17,0x05,
+0x03,0x00,0x00,0x00,
+0x22,0x43,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x00,0x00,
+0x22,0x43,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x22,0x43,0x5E,0x00,
+0x4F,0xA4,0x3E,0x00,
+0x30,0xA6,0x00,0x00,
+0x4F,0xA4,0x3E,0x00,
+0x2B,0xA4,0x5E,0x00,
+0x2B,0xA4,0x00,0x00,
+0x2B,0xA4,0x5E,0x00,
+0x22,0xA4,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x1C,0x42,0x2F,0x00,
+0x4F,0x64,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x00,0xE0,0x4C,0x02,
+0x01,0x20,0x00,0x00,
+0x00,0xE0,0x4C,0x00,
+0x00,0x0C,0x43,0x00,
+0x00,0x50,0x43,0x00,
+0x00,0x40,0x96,0x00,
+0x00,0x05,0xB5,0x00,
+0x00,0x0A,0xF7,0x00,
+0x00,0x10,0x18,0x00,
+0x00,0x21,0x91,0x00,
+0x00,0x1C,0xF0,0x00,
+0x00,0x13,0x74,0x00,
+0x00,0x03,0x7F,0x00,
+0x00,0x50,0xF2,0x02,
+0x01,0x01,0x00,0x00,
+0x00,0x50,0xF2,0x02,
+0x00,0x01,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0xFF,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xC4,0xEE,0x01,0x80,
+0x98,0x26,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0xD0,0xEE,0x01,0x80,
+0xA0,0x26,0x01,0x80,
+0x20,0x00,0x00,0x00,
+0xDC,0xEE,0x01,0x80,
+0x98,0x26,0x01,0x80,
+0x30,0x00,0x00,0x00,
+0xEC,0xEE,0x01,0x80,
+0xA0,0x26,0x01,0x80,
+0x40,0x00,0x00,0x00,
+0xFC,0xEE,0x01,0x80,
+0xB4,0x4E,0x00,0x80,
+0x50,0x00,0x00,0x00,
+0x08,0xEF,0x01,0x80,
+0xD0,0x56,0x00,0x80,
+0x80,0x00,0x00,0x00,
+0x14,0xEF,0x01,0x80,
+0x10,0x65,0x00,0x80,
+0x90,0x00,0x00,0x00,
+0x20,0xEF,0x01,0x80,
+0x3C,0x33,0x01,0x80,
+0xA0,0x00,0x00,0x00,
+0x28,0xEF,0x01,0x80,
+0x44,0x33,0x01,0x80,
+0xB0,0x00,0x00,0x00,
+0x34,0xEF,0x01,0x80,
+0x78,0x3C,0x01,0x80,
+0xC0,0x00,0x00,0x00,
+0x3C,0xEF,0x01,0x80,
+0xAC,0x33,0x01,0x80,
+0xD0,0x00,0x00,0x00,
+0x48,0xEF,0x01,0x80,
+0x0C,0x61,0x00,0x80,
+0xC8,0x00,0x00,0x00,
+0x54,0xEF,0x01,0x80,
+0x50,0x57,0x00,0x80,
+0x0D,0x00,0x00,0x00,
+0x60,0xEF,0x01,0x80,
+0xDC,0x5B,0x00,0x80,
+0x01,0x02,0x03,0x04,
+0x05,0x06,0x07,0x08,
+0x09,0x0A,0x0B,0x24,
+0x28,0x2C,0x30,0x34,
+0x38,0x3C,0x40,0x95,
+0x99,0x9D,0xA1,0xA5,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x18,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x0B,0x01,0x02,
+0x03,0x04,0x05,0x06,
+0x07,0x08,0x09,0x0A,
+0x0B,0x0C,0x0D,0x24,
+0x28,0x2C,0x30,0x34,
+0x38,0x3C,0x40,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x15,0x01,
+0x02,0x03,0x04,0x05,
+0x06,0x07,0x08,0x09,
+0x0A,0x0B,0x0C,0x0D,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x0D,
+0x01,0x02,0x03,0x04,
+0x05,0x06,0x07,0x08,
+0x09,0x0A,0x0B,0x0C,
+0x0D,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x0D,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0x0C,0x0D,0x0E,0x24,
+0x28,0x2C,0x30,0x34,
+0x38,0x3C,0x40,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x01,0x02,
+0x03,0x04,0x05,0x06,
+0x07,0x08,0x09,0x0A,
+0x0B,0x0C,0x0D,0x0E,
+0x24,0x28,0x2C,0x30,
+0x34,0x38,0x3C,0x40,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x16,0x01,
+0x02,0x03,0x04,0x05,
+0x06,0x07,0x08,0x09,
+0x0A,0x0B,0x0C,0x0D,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x0D,
+0x01,0x02,0x03,0x04,
+0x05,0x06,0x07,0x08,
+0x09,0x0A,0x0B,0x0C,
+0x0D,0x0E,0x24,0x28,
+0x2C,0x30,0x34,0x38,
+0x3C,0x40,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x16,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0x0C,0x0D,0x24,0x28,
+0x2C,0x30,0x34,0x38,
+0x3C,0x40,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x15,0x01,0x02,
+0x03,0x04,0x05,0x06,
+0x07,0x08,0x09,0x0A,
+0x0B,0x0C,0x0D,0x0E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x0E,0x01,
+0x02,0x03,0x04,0x05,
+0x06,0x07,0x08,0x09,
+0x0A,0x0B,0x0C,0x0D,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x0D,
+0x01,0x02,0x03,0x04,
+0x05,0x06,0x07,0x08,
+0x09,0x0A,0x0B,0x0C,
+0x0D,0x24,0x28,0x2C,
+0x30,0x34,0x38,0x3C,
+0x40,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x15,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0x24,0x28,0x2C,0x30,
+0x34,0x38,0x3C,0x40,
+0x95,0x99,0x9D,0xA1,
+0xA5,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x18,0x24,0x28,
+0x2C,0x30,0x34,0x38,
+0x3C,0x40,0x64,0x68,
+0x6C,0x70,0x74,0x78,
+0x7C,0x80,0x84,0x88,
+0x8C,0x95,0x99,0x9D,
+0xA1,0xA5,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x18,0x26,
+0x2A,0x2E,0x32,0x36,
+0x3A,0x3E,0x66,0x6A,
+0x6E,0x72,0x76,0x7A,
+0x7E,0x82,0x86,0x8A,
+0x97,0x9B,0x9F,0xA3,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x15,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0xFF,0x00,0x00,0x00,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x04,0x05,0x06,0x07,
+0x08,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD8,0xE6,0x01,0x80,
+0xD8,0xE6,0x01,0x80,
+0x31,0x10,0x10,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x20,0x10,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x28,0x10,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x2C,0x10,0x10,
+0x00,0x30,0x00,0x00,
+0x31,0x2F,0x10,0x10,
+0x00,0x30,0x00,0x00,
+0x31,0x30,0x18,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x30,0x20,0x10,
+0x00,0x30,0x00,0x00,
+0x22,0x20,0x18,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x14,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x1C,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x20,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x20,0x10,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x20,0x00,0x00,
+0x1A,0x19,0x18,0x10,
+0x00,0x18,0x00,0x00,
+0x12,0x11,0x10,0x08,
+0x00,0x10,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x02,
+0x00,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x06,
+0x00,0x08,0x00,0x00,
+0x08,0x07,0x06,0x04,
+0x00,0x06,0x00,0x00,
+0x06,0x05,0x04,0x02,
+0x00,0x04,0x00,0x00,
+0x06,0x05,0x04,0x03,
+0x00,0x04,0x00,0x00,
+0x05,0x04,0x03,0x02,
+0x00,0x03,0x00,0x00,
+0x09,0x08,0x07,0x06,
+0x07,0x06,0x06,0x05,
+0x05,0x04,0x04,0x03,
+0x06,0x05,0x05,0x04,
+0x04,0x03,0x03,0x03,
+0x05,0x04,0x04,0x03,
+0x03,0x02,0x02,0x02,
+0x00,0x09,0x08,0x07,
+0x06,0x07,0x06,0x06,
+0x05,0x05,0x04,0x04,
+0x03,0x05,0x04,0x04,
+0x03,0x03,0x02,0x02,
+0x02,0x04,0x03,0x03,
+0x02,0x02,0x01,0x01,
+0x01,0x00,0x00,0x00,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x10,0x10,0x20,
+0x08,0x08,0x08,0x08,
+0x20,0x20,0x20,0x20,
+0x08,0x08,0x08,0x08,
+0x08,0x20,0x20,0x20,
+0x30,0x08,0x08,0x08,
+0x08,0x18,0x18,0x18,
+0x18,0x18,0x20,0x30,
+0x30,0x10,0x20,0x20,
+0x20,0x20,0x20,0x30,
+0x30,0x08,0x10,0x20,
+0x30,0x30,0x30,0x30,
+0x30,0x30,0x00,0x00,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x10,0x10,0x20,
+0x08,0x08,0x08,0x08,
+0x08,0x20,0x20,0x20,
+0x08,0x08,0x08,0x08,
+0x08,0x20,0x20,0x20,
+0x20,0x08,0x08,0x08,
+0x08,0x18,0x18,0x18,
+0x18,0x18,0x20,0x30,
+0x30,0x10,0x20,0x20,
+0x20,0x20,0x20,0x30,
+0x30,0x08,0x10,0x20,
+0x30,0x30,0x30,0x30,
+0x30,0x30,0x00,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x0A,0x09,
+0x08,0x00,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x0A,0x09,
+0x08,0x00,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x22,0x21,0x20,
+0x18,0x00,0x22,0x21,
+0x1C,0x08,0x00,0x22,
+0x20,0x18,0x08,0x00,
+0x0A,0x09,0x08,0x02,
+0x00,0x0A,0x09,0x08,
+0x02,0x00,0x0A,0x09,
+0x08,0x02,0x00,0x0A,
+0x09,0x08,0x02,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x22,0x21,0x20,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x22,
+0x21,0x1C,0x08,0x00,
+0x31,0x30,0x18,0x00,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x1A,0x19,
+0x18,0x10,0x00,0x1A,
+0x19,0x18,0x10,0x00,
+0x1A,0x19,0x18,0x10,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x31,
+0x2C,0x10,0x10,0x00,
+0x31,0x28,0x10,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x22,0x21,
+0x20,0x18,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x08,
+0x00,0x22,0x21,0x14,
+0x08,0x00,0x22,0x20,
+0x18,0x08,0x00,0x31,
+0x30,0x20,0x10,0x00,
+0x31,0x2C,0x10,0x10,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x31,0x30,0x20,
+0x10,0x00,0x31,0x2F,
+0x10,0x10,0x00,0x31,
+0x2F,0x10,0x10,0x00,
+0x31,0x10,0x10,0x00,
+0x00,0x31,0x2C,0x10,
+0x10,0x00,0x00,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x0A,0x09,
+0x08,0x00,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x02,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x22,0x21,0x20,
+0x18,0x00,0x22,0x21,
+0x1C,0x08,0x00,0x22,
+0x21,0x14,0x08,0x00,
+0x0A,0x09,0x08,0x02,
+0x00,0x0A,0x09,0x08,
+0x02,0x00,0x0A,0x09,
+0x08,0x02,0x00,0x0A,
+0x09,0x08,0x02,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x22,0x21,0x20,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x22,
+0x21,0x14,0x08,0x00,
+0x22,0x21,0x14,0x08,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x1A,0x19,
+0x18,0x10,0x00,0x1A,
+0x19,0x18,0x10,0x00,
+0x1A,0x19,0x18,0x10,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x31,
+0x2C,0x10,0x10,0x00,
+0x31,0x28,0x10,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x22,0x21,
+0x20,0x18,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x08,
+0x00,0x22,0x21,0x14,
+0x08,0x00,0x22,0x20,
+0x18,0x08,0x00,0x31,
+0x30,0x20,0x10,0x00,
+0x31,0x2C,0x10,0x10,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x31,0x30,0x20,
+0x10,0x00,0x31,0x2F,
+0x10,0x10,0x00,0x31,
+0x2F,0x10,0x10,0x00,
+0x31,0x10,0x10,0x00,
+0x00,0x31,0x2C,0x10,
+0x10,0x00,0x00,0x00,
+0x01,0x02,0x04,0x08,
+0x02,0x04,0x08,0x0C,
+0x10,0x18,0x20,0x30,
+0x02,0x04,0x08,0x0C,
+0x10,0x18,0x20,0x30,
+0x06,0x0C,0x10,0x18,
+0x24,0x30,0x3C,0x48,
+0x48,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x25,0x27,0x2C,
+0x19,0x1B,0x1E,0x20,
+0x23,0x29,0x2A,0x2B,
+0x00,0x00,0x00,0x00,
+0x25,0x29,0x2B,0x2E,
+0x2E,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x10,0x00,0x00,0x00,
+0x18,0x00,0x00,0x00,
+0x24,0x00,0x00,0x00,
+0x30,0x00,0x00,0x00,
+0x48,0x00,0x00,0x00,
+0x60,0x00,0x00,0x00,
+0x90,0x00,0x00,0x00,
+0xC0,0x00,0x00,0x00,
+0xD8,0x00,0x00,0x00,
+0x50,0x00,0x00,0x00,
+0x78,0x00,0x00,0x00,
+0xA0,0x00,0x00,0x00,
+0xC8,0x00,0x00,0x00,
+0x40,0x01,0x00,0x00,
+0x90,0x01,0x00,0x00,
+0xE0,0x01,0x00,0x00,
+0x30,0x02,0x00,0x00,
+0x2C,0x01,0x00,0x00,
+0x40,0x01,0x00,0x00,
+0xE0,0x01,0x00,0x00,
+0xD0,0x02,0x00,0x00,
+0x80,0x0C,0x00,0x00,
+0x80,0x0C,0x00,0x00,
+0x80,0x0C,0x00,0x00,
+0xA0,0x0F,0x00,0x00,
+0xA0,0x0F,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x0C,0x00,0x00,0x00,
+0x12,0x00,0x00,0x00,
+0x18,0x00,0x00,0x00,
+0x24,0x00,0x00,0x00,
+0x30,0x00,0x00,0x00,
+0x48,0x00,0x00,0x00,
+0x60,0x00,0x00,0x00,
+0x6C,0x00,0x00,0x00,
+0x28,0x00,0x00,0x00,
+0x3C,0x00,0x00,0x00,
+0x50,0x00,0x00,0x00,
+0x64,0x00,0x00,0x00,
+0xA0,0x00,0x00,0x00,
+0xC8,0x00,0x00,0x00,
+0xF0,0x00,0x00,0x00,
+0x18,0x01,0x00,0x00,
+0x64,0x00,0x00,0x00,
+0xA0,0x00,0x00,0x00,
+0xF0,0x00,0x00,0x00,
+0x68,0x01,0x00,0x00,
+0x40,0x06,0x00,0x00,
+0x40,0x06,0x00,0x00,
+0x40,0x06,0x00,0x00,
+0xD0,0x07,0x00,0x00,
+0xD0,0x07,0x00,0x00,
+0x38,0x84,0x01,0x80,
+0x2C,0x8A,0x01,0x80,
+0x2C,0x8A,0x01,0x80,
+0x2C,0x8A,0x01,0x80,
+0x2C,0x8A,0x01,0x80,
+0x60,0x88,0x01,0x80,
+0x40,0x84,0x01,0x80,
+0x38,0x84,0x01,0x80,
+0x38,0x84,0x01,0x80,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x2C,0x8D,0x01,0x80,
+0x2C,0x8D,0x01,0x80,
+0x2C,0x8D,0x01,0x80,
+0x2C,0x8D,0x01,0x80,
+0x38,0x83,0x01,0x80,
+0xAC,0x8B,0x01,0x80,
+0x40,0x83,0x01,0x80,
+0x48,0x83,0x01,0x80,
+0x50,0x83,0x01,0x80,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x08,0x04,0x04,0x08,
+0x02,0x02,0x01,0x01,
+0x80,0x00,0x00,0x00,
+0x52,0x54,0x4C,0x38,
+0x37,0x31,0x32,0x20,
+0x46,0x57,0x20,0x76,
+0x65,0x72,0x73,0x69,
+0x6F,0x6E,0x20,0x30,
+0x2E,0x30,0x2E,0x31,
+0x23,0x20,0x4D,0x6F,
+0x6E,0x20,0x41,0x70,
+0x72,0x20,0x32,0x20,
+0x31,0x39,0x3A,0x35,
+0x34,0x3A,0x35,0x37,
+0x20,0x43,0x53,0x54,
+0x20,0x32,0x30,0x31,
+0x32,0x20,0x20,0x53,
+0x56,0x4E,0x3A,0x20,
+0x25,0x64,0x00,0x00,
+0x43,0x68,0x69,0x70,
+0x20,0x56,0x65,0x72,
+0x73,0x69,0x6F,0x6E,
+0x3A,0x25,0x78,0x00,
+0x48,0x43,0x49,0x20,
+0x74,0x79,0x70,0x65,
+0x3A,0x20,0x25,0x78,
+0x28,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x72,0x66,0x5F,0x63,
+0x6F,0x66,0x69,0x67,
+0x3A,0x20,0x25,0x78,
+0x28,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x6D,0x70,0x5F,0x6D,
+0x6F,0x64,0x65,0x3A,
+0x20,0x25,0x78,0x28,
+0x25,0x78,0x29,0x2C,
+0x20,0x49,0x51,0x4B,
+0x3A,0x20,0x25,0x78,
+0x0A,0x00,0x00,0x00,
+0x76,0x63,0x73,0x20,
+0x74,0x79,0x70,0x65,
+0x3A,0x20,0x25,0x78,
+0x28,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x74,0x61,0x72,0x67,
+0x65,0x74,0x20,0x74,
+0x68,0x65,0x72,0x6D,
+0x61,0x6C,0x3A,0x20,
+0x25,0x78,0x2C,0x20,
+0x20,0x62,0x74,0x5F,
+0x63,0x6F,0x65,0x78,
+0x69,0x73,0x74,0x3A,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x67,0x64,0x5F,0x70,
+0x6F,0x77,0x65,0x72,
+0x47,0x61,0x69,0x6E,
+0x20,0x3D,0x20,0x25,
+0x64,0x2C,0x20,0x4B,
+0x65,0x65,0x70,0x41,
+0x6C,0x69,0x76,0x65,
+0x42,0x63,0x6E,0x49,
+0x74,0x76,0x43,0x6E,
+0x74,0x20,0x3D,0x20,
+0x25,0x64,0x0A,0x00,
+0x62,0x41,0x75,0x74,
+0x6F,0x6C,0x6F,0x61,
+0x64,0x4F,0x6B,0x3A,
+0x20,0x25,0x78,0x2C,
+0x20,0x43,0x68,0x6E,
+0x6C,0x50,0x6C,0x61,
+0x6E,0x3A,0x25,0x78,
+0x00,0x00,0x00,0x00,
+0x04,0xAD,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xCC,0xAC,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0x94,0xAC,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0x5C,0xAC,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0x24,0xAC,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xEC,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xD4,0xAB,0x01,0x80,
+0xAC,0xAB,0x01,0x80,
+0x40,0x05,0x00,0x80,
+0x34,0x05,0x00,0x80,
+0x28,0x05,0x00,0x80,
+0x1C,0x05,0x00,0x80,
+0x10,0x05,0x00,0x80,
+0x04,0x05,0x00,0x80,
+0xF8,0x04,0x00,0x80,
+0xEC,0x04,0x00,0x80,
+0xE0,0x04,0x00,0x80,
+0xD4,0x04,0x00,0x80,
+0x8C,0x04,0x00,0x80,
+0x43,0x4D,0x44,0x20,
+0x53,0x45,0x51,0x20,
+0x69,0x73,0x20,0x6E,
+0x6F,0x74,0x20,0x4D,
+0x61,0x74,0x63,0x68,
+0x65,0x64,0x20,0x28,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x29,0x00,
+0x67,0x65,0x74,0x20,
+0x6A,0x6F,0x69,0x6E,
+0x20,0x63,0x6D,0x64,
+0x0A,0x00,0x00,0x00,
+0x73,0x65,0x74,0x20,
+0x6F,0x70,0x6D,0x6F,
+0x64,0x65,0x3A,0x20,
+0x25,0x78,0x0A,0x00,
+0x73,0x65,0x74,0x41,
+0x75,0x74,0x68,0x3A,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x72,0x63,0x76,0x20,
+0x73,0x65,0x74,0x5F,
+0x73,0x74,0x61,0x6B,
+0x65,0x79,0x0A,0x00,
+0x55,0x70,0x64,0x61,
+0x74,0x65,0x20,0x4D,
+0x61,0x63,0x41,0x64,
+0x64,0x72,0x0A,0x00,
+0x44,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x43,0x74,
+0x72,0x6C,0x20,0x43,
+0x6D,0x64,0x20,0x69,
+0x73,0x20,0x69,0x6E,
+0x76,0x61,0x6C,0x69,
+0x64,0x20,0x66,0x6F,
+0x72,0x20,0x43,0x75,
+0x72,0x72,0x65,0x6E,
+0x74,0x20,0x46,0x57,
+0x0A,0x00,0x00,0x00,
+0x43,0x68,0x6E,0x6C,
+0x50,0x6C,0x61,0x6E,
+0x3A,0x25,0x78,0x00,
+0x67,0x65,0x74,0x20,
+0x73,0x75,0x72,0x76,
+0x65,0x79,0x20,0x63,
+0x6D,0x64,0x0A,0x00,
+0x53,0x53,0x49,0x44,
+0x3A,0x20,0x25,0x73,
+0x0A,0x00,0x00,0x00,
+0x00,0x0E,0x04,0x0E,
+0x10,0x0E,0x14,0x0E,
+0x18,0x0E,0x1C,0x0E,
+0x43,0x68,0x6E,0x6C,
+0x3A,0x20,0x25,0x78,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x41,0x73,
+0x73,0x6F,0x63,0x52,
+0x65,0x71,0x00,0x00,
+0x4F,0x6E,0x41,0x73,
+0x73,0x6F,0x63,0x52,
+0x73,0x70,0x00,0x00,
+0x4F,0x6E,0x52,0x65,
+0x41,0x73,0x73,0x6F,
+0x63,0x52,0x65,0x71,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x52,0x65,
+0x41,0x73,0x73,0x6F,
+0x63,0x52,0x73,0x70,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x50,0x72,
+0x6F,0x62,0x65,0x52,
+0x65,0x71,0x00,0x00,
+0x4F,0x6E,0x50,0x72,
+0x6F,0x62,0x65,0x52,
+0x73,0x70,0x00,0x00,
+0x4F,0x6E,0x42,0x65,
+0x61,0x63,0x6F,0x6E,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x41,0x54,
+0x49,0x4D,0x00,0x00,
+0x4F,0x6E,0x44,0x69,
+0x73,0x61,0x73,0x73,
+0x6F,0x63,0x00,0x00,
+0x4F,0x6E,0x41,0x75,
+0x74,0x68,0x00,0x00,
+0x4F,0x6E,0x44,0x65,
+0x41,0x75,0x74,0x68,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x41,0x63,
+0x74,0x69,0x6F,0x6E,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x51,0x6F,
+0x73,0x4E,0x75,0x6C,
+0x6C,0x00,0x00,0x00,
+0x4F,0x6E,0x45,0x78,
+0x63,0x65,0x70,0x74,
+0x69,0x6F,0x6E,0x00,
+0x57,0x4F,0x57,0x4C,
+0x41,0x4E,0x00,0x00,
+0x02,0x04,0x04,0x07,
+0x07,0x0D,0x0D,0x0D,
+0x02,0x07,0x07,0x0D,
+0x0D,0x0F,0x0F,0x0F,
+0x0F,0x00,0x00,0x00,
+0x01,0x01,0x02,0x03,
+0x04,0x05,0x08,0x10,
+0x42,0x57,0x5F,0x6D,
+0x6F,0x64,0x65,0x20,
+0x3D,0x20,0x25,0x64,
+0x2C,0x20,0x63,0x68,
+0x61,0x6E,0x6E,0x65,
+0x6C,0x5F,0x6F,0x66,
+0x66,0x73,0x65,0x74,
+0x20,0x3D,0x20,0x25,
+0x64,0x00,0x00,0x00,
+0x73,0x75,0x72,0x76,
+0x65,0x79,0x20,0x64,
+0x6F,0x6E,0x65,0x28,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x29,0x0A,
+0x00,0x00,0x00,0x00,
+0x38,0x37,0x31,0x32,
+0x20,0x6E,0x6F,0x74,
+0x20,0x73,0x75,0x70,
+0x70,0x6F,0x72,0x74,
+0x65,0x64,0x20,0x35,
+0x47,0x20,0x63,0x68,
+0x3A,0x20,0x25,0x64,
+0x00,0x00,0x00,0x00,
+0x6A,0x6F,0x69,0x6E,
+0x20,0x72,0x65,0x73,
+0x28,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x64,0x65,0x6C,0x20,
+0x73,0x74,0x61,0x0A,
+0x00,0x00,0x00,0x00,
+0x61,0x64,0x64,0x20,
+0x73,0x74,0x61,0x3A,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x0A,0x00,
+0x72,0x63,0x76,0x20,
+0x64,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x0A,0x00,
+0x57,0x4D,0x4D,0x28,
+0x25,0x78,0x29,0x3A,
+0x20,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x61,0x73,0x73,0x6F,
+0x63,0x20,0x72,0x65,
+0x6A,0x65,0x63,0x74,
+0x2C,0x20,0x73,0x74,
+0x61,0x74,0x75,0x73,
+0x3A,0x20,0x25,0x64,
+0x0A,0x00,0x00,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x35,0x3A,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x4F,0x42,0x53,0x53,
+0x5F,0x53,0x43,0x41,
+0x4E,0x20,0x49,0x4E,
+0x54,0x45,0x52,0x56,
+0x41,0x4C,0x3D,0x25,
+0x64,0x00,0x00,0x00,
+0x70,0x61,0x63,0x6B,
+0x65,0x74,0x20,0x74,
+0x6F,0x6F,0x20,0x6C,
+0x61,0x72,0x67,0x65,
+0x28,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x00,0x50,0xF2,0x01,
+0x44,0x72,0x6F,0x70,
+0x20,0x53,0x75,0x72,
+0x76,0x65,0x79,0x45,
+0x76,0x65,0x6E,0x74,
+0x2C,0x20,0x63,0x68,
+0x3A,0x20,0x25,0x78,
+0x00,0x00,0x00,0x00,
+0x69,0x6E,0x76,0x61,
+0x6C,0x69,0x64,0x20,
+0x63,0x61,0x70,0x3A,
+0x25,0x78,0x0A,0x00,
+0x49,0x42,0x53,0x53,
+0x20,0x6D,0x6F,0x64,
+0x65,0x2C,0x20,0x63,
+0x75,0x72,0x20,0x63,
+0x68,0x61,0x6E,0x6E,
+0x65,0x6C,0x3A,0x20,
+0x25,0x78,0x2C,0x20,
+0x62,0x63,0x6E,0x20,
+0x69,0x6E,0x74,0x65,
+0x72,0x76,0x61,0x6C,
+0x3A,0x20,0x25,0x78,
+0x0A,0x00,0x00,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x34,0x3A,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x63,0x75,0x72,0x20,
+0x63,0x68,0x61,0x6E,
+0x6E,0x65,0x6C,0x3A,
+0x20,0x25,0x78,0x2C,
+0x20,0x62,0x63,0x6E,
+0x20,0x69,0x6E,0x74,
+0x65,0x72,0x76,0x61,
+0x6C,0x3A,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x61,0x73,
+0x73,0x6F,0x63,0x72,
+0x65,0x71,0x00,0x00,
+0x00,0x50,0xF2,0x04,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x61,0x73,
+0x73,0x6F,0x63,0x72,
+0x65,0x71,0x28,0x25,
+0x78,0x29,0x0A,0x00,
+0x5B,0x57,0x41,0x50,
+0x49,0x5D,0x20,0x67,
+0x65,0x74,0x20,0x77,
+0x61,0x70,0x69,0x20,
+0x49,0x45,0x0A,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x61,0x63,
+0x74,0x69,0x6F,0x6E,
+0x3A,0x20,0x25,0x78,
+0x2C,0x20,0x25,0x78,
+0x2C,0x20,0x25,0x78,
+0x20,0x0A,0x00,0x00,
+0x44,0x45,0x4C,0x42,
+0x41,0x3A,0x20,0x25,
+0x78,0x28,0x25,0x78,
+0x29,0x0A,0x00,0x00,
+0x41,0x44,0x44,0x42,
+0x41,0x20,0x52,0x53,
+0x50,0x3A,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x61,0x75,
+0x74,0x68,0x0A,0x00,
+0x63,0x6C,0x6E,0x74,
+0x20,0x61,0x75,0x74,
+0x68,0x20,0x66,0x61,
+0x69,0x6C,0x65,0x64,
+0x20,0x64,0x75,0x65,
+0x20,0x74,0x6F,0x20,
+0x69,0x6C,0x6C,0x65,
+0x67,0x61,0x6C,0x20,
+0x73,0x65,0x71,0x3D,
+0x25,0x78,0x0A,0x00,
+0x63,0x6C,0x6E,0x74,
+0x20,0x61,0x75,0x74,
+0x68,0x20,0x66,0x61,
+0x69,0x6C,0x2C,0x20,
+0x73,0x74,0x61,0x74,
+0x75,0x73,0x3A,0x20,
+0x25,0x64,0x0A,0x00,
+0x6E,0x6F,0x20,0x63,
+0x68,0x61,0x6C,0x6C,
+0x65,0x6E,0x67,0x65,
+0x20,0x74,0x65,0x78,
+0x74,0x3F,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x75,0x6E,0x6B,0x6E,
+0x6F,0x77,0x6E,0x20,
+0x41,0x50,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x41,0x74,0x68,0x65,
+0x72,0x6F,0x73,0x20,
+0x41,0x50,0x28,0x4D,
+0x41,0x43,0x29,0x0A,
+0x00,0x00,0x00,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x25,0x78,0x3A,0x20,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x42,0x72,0x6F,0x61,
+0x64,0x63,0x6F,0x6D,
+0x20,0x41,0x50,0x0A,
+0x00,0x00,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x41,0x74,0x68,0x65,
+0x72,0x6F,0x73,0x20,
+0x41,0x50,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x52,0x61,0x6C,0x69,
+0x6E,0x6B,0x20,0x41,
+0x50,0x0A,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x4D,0x61,0x72,0x76,
+0x65,0x6C,0x6C,0x20,
+0x41,0x50,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x52,0x65,0x61,0x6C,
+0x74,0x65,0x6B,0x20,
+0x39,0x36,0x42,0x20,
+0x41,0x50,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x43,0x69,0x73,0x63,
+0x6F,0x20,0x41,0x50,
+0x0A,0x00,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x52,0x65,0x61,0x6C,
+0x74,0x65,0x6B,0x20,
+0x39,0x36,0x42,0x20,
+0x41,0x50,0x20,0x77,
+0x69,0x74,0x68,0x20,
+0x76,0x69,0x64,0x65,
+0x6F,0x20,0x6D,0x6F,
+0x64,0x65,0x0A,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x64,0x65,
+0x61,0x75,0x74,0x68,
+0x0A,0x00,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x64,0x69,
+0x73,0x61,0x73,0x73,
+0x6F,0x63,0x0A,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x6B,0x65,
+0x65,0x70,0x61,0x6C,
+0x69,0x76,0x65,0x20,
+0x6E,0x75,0x6C,0x6C,
+0x20,0x64,0x61,0x74,
+0x61,0x00,0x00,0x00,
+0x64,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x28,0x6E,
+0x6F,0x20,0x64,0x61,
+0x74,0x61,0x20,0x72,
+0x63,0x76,0x64,0x29,
+0x0A,0x00,0x00,0x00,
+0x64,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x20,0x74,
+0x69,0x6D,0x65,0x72,
+0x3A,0x20,0x6E,0x6F,
+0x20,0x62,0x65,0x61,
+0x63,0x6F,0x6E,0x0A,
+0x00,0x00,0x00,0x00,
+0x60,0x1B,0x02,0x80,
+0x4D,0x47,0x54,0x51,
+0x75,0x65,0x75,0x65,
+0x53,0x74,0x61,0x74,
+0x75,0x73,0x3A,0x20,
+0x25,0x78,0x00,0x00,
+0x06,0x00,0x2A,0xB0,
+0x18,0x03,0x25,0xB0,
+0x44,0x44,0x33,0x33,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB4,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0x38,0x46,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0x2C,0x46,0x01,0x80,
+0x20,0x46,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0x14,0x46,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0x08,0x46,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xFC,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xF0,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xE4,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xD8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xCC,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xB8,0x45,0x01,0x80,
+0xC0,0x45,0x01,0x80,
+0xF8,0x46,0x01,0x80,
+0xEC,0x46,0x01,0x80,
+0xE0,0x46,0x01,0x80,
+0xD4,0x46,0x01,0x80,
+0xC8,0x46,0x01,0x80,
+0xBC,0x46,0x01,0x80,
+0xB0,0x46,0x01,0x80,
+0xA4,0x46,0x01,0x80,
+0x98,0x46,0x01,0x80,
+0x8C,0x46,0x01,0x80,
+0x80,0x46,0x01,0x80,
+0x74,0x46,0x01,0x80,
+0x6A,0x75,0x64,0x67,
+0x65,0x5F,0x6E,0x65,
+0x74,0x77,0x6F,0x72,
+0x6B,0x5F,0x74,0x79,
+0x70,0x65,0x00,0x00,
+0x25,0x73,0x3A,0x20,
+0x45,0x72,0x72,0x28,
+0x4E,0x6F,0x20,0x41,
+0x6E,0x79,0x20,0x52,
+0x61,0x74,0x65,0x29,
+0x0A,0x00,0x00,0x00,
+0x00,0x50,0xF2,0x01,
+0x00,0x50,0xF2,0x02,
+0x00,0x50,0xF2,0x04,
+0x00,0x0F,0xAC,0x02,
+0x00,0x0F,0xAC,0x04,
+0x64,0x65,0x63,0x69,
+0x64,0x65,0x5F,0x64,
+0x69,0x73,0x63,0x6F,
+0x6E,0x6E,0x65,0x63,
+0x74,0x5F,0x74,0x69,
+0x6D,0x65,0x6F,0x75,
+0x74,0x00,0x00,0x00,
+0x25,0x73,0x3A,0x20,
+0x44,0x69,0x73,0x43,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x54,0x4F,
+0x28,0x4F,0x50,0x20,
+0x45,0x72,0x72,0x3A,
+0x20,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x30,0x31,0x32,0x33,
+0x34,0x35,0x36,0x37,
+0x38,0x39,0x41,0x42,
+0x43,0x44,0x45,0x46,
+0x00,0x00,0x00,0x00,
+0x25,0x64,0x2E,0x00,
+0x25,0x68,0x68,0x58,
+0x3A,0x00,0x00,0x00,
+0x0C,0xF6,0x01,0x80,
+0x67,0x66,0x66,0x66,
+0x75,0x70,0x64,0x61,
+0x74,0x65,0x20,0x63,
+0x61,0x6D,0x20,0x65,
+0x6E,0x74,0x72,0x79,
+0x20,0x28,0x25,0x78,
+0x2C,0x20,0x25,0x78,
+0x29,0x0A,0x00,0x00,
+0x2D,0x3E,0x28,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x29,0x0A,0x00,
+0x70,0x03,0x25,0xB0,
+0x00,0x00,0x01,0x00,
+0x00,0x02,0x00,0x00,
+0x08,0x09,0x00,0x00,
+0x63,0xA3,0x00,0x80,
+0x69,0xA3,0x00,0x80,
+0x6F,0xA3,0x00,0x80,
+0x75,0xA3,0x00,0x80,
+0x63,0xA3,0x00,0x80,
+0x63,0xA3,0x00,0x80,
+0x63,0xA3,0x00,0x80,
+0x63,0xA3,0x00,0x80,
+0x7B,0xA3,0x00,0x80,
+0x81,0xA3,0x00,0x80,
+0x87,0xA3,0x00,0x80,
+0x8D,0xA3,0x00,0x80,
+0x60,0x1B,0x02,0x80,
+0x00,0x00,0xC0,0xFF,
+0xFF,0xFF,0xFF,0x0F,
+0xFF,0xFF,0xC0,0xFF,
+0xFF,0xFF,0xFF,0x0F,
+0x00,0x00,0xFF,0x03,
+0xFE,0x01,0x80,0x7F,
+0xE2,0x01,0x80,0x78,
+0xC7,0x01,0xC0,0x71,
+0xAE,0x01,0x80,0x6B,
+0x95,0x01,0x40,0x65,
+0x7F,0x01,0xC0,0x5F,
+0x69,0x01,0x40,0x5A,
+0x55,0x01,0x40,0x55,
+0x42,0x01,0x80,0x50,
+0x30,0x01,0x00,0x4C,
+0x1F,0x01,0xC0,0x47,
+0x0F,0x01,0xC0,0x43,
+0x00,0x01,0x00,0x40,
+0xF2,0x00,0x80,0x3C,
+0xE4,0x00,0x00,0x39,
+0xD7,0x00,0xC0,0x35,
+0xCB,0x00,0xC0,0x32,
+0xC0,0x00,0x00,0x30,
+0xB5,0x00,0x40,0x2D,
+0xAB,0x00,0xC0,0x2A,
+0xA2,0x00,0x80,0x28,
+0x98,0x00,0x00,0x26,
+0x90,0x00,0x00,0x24,
+0x88,0x00,0x00,0x22,
+0x80,0x00,0x00,0x20,
+0x79,0x00,0x40,0x1E,
+0x72,0x00,0x80,0x1C,
+0x6C,0x00,0x00,0x1B,
+0x66,0x00,0x80,0x19,
+0x60,0x00,0x00,0x18,
+0x5B,0x00,0xC0,0x16,
+0x56,0x00,0x80,0x15,
+0x51,0x00,0x40,0x14,
+0x4C,0x00,0x00,0x13,
+0x48,0x00,0x00,0x12,
+0x44,0x00,0x00,0x11,
+0x40,0x00,0x00,0x10,
+0x36,0x35,0x2E,0x25,
+0x1C,0x12,0x09,0x04,
+0x33,0x32,0x2B,0x23,
+0x1A,0x11,0x08,0x04,
+0x30,0x2F,0x29,0x21,
+0x19,0x10,0x08,0x03,
+0x2D,0x2D,0x27,0x1F,
+0x18,0x0F,0x08,0x03,
+0x2B,0x2A,0x25,0x1E,
+0x16,0x0E,0x07,0x03,
+0x28,0x28,0x22,0x1C,
+0x15,0x0D,0x07,0x03,
+0x26,0x25,0x21,0x1B,
+0x14,0x0D,0x06,0x03,
+0x24,0x23,0x1F,0x19,
+0x13,0x0C,0x06,0x03,
+0x22,0x21,0x1D,0x18,
+0x11,0x0B,0x06,0x02,
+0x20,0x20,0x1B,0x16,
+0x11,0x08,0x05,0x02,
+0x1F,0x1E,0x1A,0x15,
+0x10,0x0A,0x05,0x02,
+0x1D,0x1C,0x18,0x14,
+0x0F,0x0A,0x05,0x02,
+0x1B,0x1A,0x17,0x13,
+0x0E,0x09,0x04,0x02,
+0x1A,0x19,0x16,0x12,
+0x0D,0x09,0x04,0x02,
+0x18,0x17,0x15,0x11,
+0x0C,0x08,0x04,0x02,
+0x17,0x16,0x13,0x10,
+0x0C,0x08,0x04,0x02,
+0x16,0x15,0x12,0x0F,
+0x0B,0x07,0x04,0x01,
+0x14,0x14,0x11,0x0E,
+0x0B,0x07,0x03,0x02,
+0x13,0x13,0x10,0x0D,
+0x0A,0x06,0x03,0x01,
+0x12,0x12,0x0F,0x0C,
+0x09,0x06,0x03,0x01,
+0x11,0x11,0x0F,0x0C,
+0x09,0x06,0x03,0x01,
+0x10,0x10,0x0E,0x0B,
+0x08,0x05,0x03,0x01,
+0x0F,0x0F,0x0D,0x0B,
+0x08,0x05,0x03,0x01,
+0x0E,0x0E,0x0C,0x0A,
+0x08,0x05,0x02,0x01,
+0x0D,0x0D,0x0C,0x0A,
+0x07,0x05,0x02,0x01,
+0x0D,0x0C,0x0B,0x09,
+0x07,0x04,0x02,0x01,
+0x0C,0x0C,0x0A,0x09,
+0x06,0x04,0x02,0x01,
+0x0B,0x0B,0x0A,0x08,
+0x06,0x04,0x02,0x01,
+0x0B,0x0A,0x09,0x08,
+0x06,0x04,0x02,0x01,
+0x0A,0x0A,0x09,0x07,
+0x05,0x03,0x02,0x01,
+0x0A,0x09,0x08,0x07,
+0x05,0x03,0x02,0x01,
+0x09,0x09,0x08,0x06,
+0x05,0x03,0x01,0x01,
+0x09,0x08,0x07,0x06,
+0x04,0x03,0x01,0x01,
+0x36,0x35,0x2E,0x1B,
+0x00,0x00,0x00,0x00,
+0x33,0x32,0x2B,0x19,
+0x00,0x00,0x00,0x00,
+0x30,0x2F,0x29,0x18,
+0x00,0x00,0x00,0x00,
+0x2D,0x2D,0x17,0x17,
+0x00,0x00,0x00,0x00,
+0x2B,0x2A,0x25,0x15,
+0x00,0x00,0x00,0x00,
+0x28,0x28,0x24,0x14,
+0x00,0x00,0x00,0x00,
+0x26,0x25,0x21,0x13,
+0x00,0x00,0x00,0x00,
+0x24,0x23,0x1F,0x12,
+0x00,0x00,0x00,0x00,
+0x22,0x21,0x1D,0x11,
+0x00,0x00,0x00,0x00,
+0x20,0x20,0x1B,0x10,
+0x00,0x00,0x00,0x00,
+0x1F,0x1E,0x1A,0x0F,
+0x00,0x00,0x00,0x00,
+0x1D,0x1C,0x18,0x0E,
+0x00,0x00,0x00,0x00,
+0x1B,0x1A,0x17,0x0E,
+0x00,0x00,0x00,0x00,
+0x1A,0x19,0x16,0x0D,
+0x00,0x00,0x00,0x00,
+0x18,0x17,0x15,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x16,0x13,0x0B,
+0x00,0x00,0x00,0x00,
+0x16,0x15,0x12,0x0B,
+0x00,0x00,0x00,0x00,
+0x14,0x14,0x11,0x0A,
+0x00,0x00,0x00,0x00,
+0x13,0x13,0x10,0x0A,
+0x00,0x00,0x00,0x00,
+0x12,0x12,0x0F,0x09,
+0x00,0x00,0x00,0x00,
+0x11,0x11,0x0F,0x09,
+0x00,0x00,0x00,0x00,
+0x10,0x10,0x0E,0x08,
+0x00,0x00,0x00,0x00,
+0x0F,0x0F,0x0D,0x08,
+0x00,0x00,0x00,0x00,
+0x0E,0x0E,0x0C,0x07,
+0x00,0x00,0x00,0x00,
+0x0D,0x0D,0x0C,0x07,
+0x00,0x00,0x00,0x00,
+0x0D,0x0C,0x0B,0x06,
+0x00,0x00,0x00,0x00,
+0x0C,0x0C,0x0A,0x06,
+0x00,0x00,0x00,0x00,
+0x0B,0x0B,0x0A,0x06,
+0x00,0x00,0x00,0x00,
+0x0B,0x0A,0x09,0x05,
+0x00,0x00,0x00,0x00,
+0x0A,0x0A,0x09,0x05,
+0x00,0x00,0x00,0x00,
+0x0A,0x09,0x08,0x05,
+0x00,0x00,0x00,0x00,
+0x09,0x09,0x08,0x05,
+0x00,0x00,0x00,0x00,
+0x09,0x08,0x07,0x04,
+0x00,0x00,0x00,0x00,
+0x53,0x74,0x61,0x74,
+0x75,0x73,0x28,0x25,
+0x78,0x29,0x2C,0x20,
+0x54,0x69,0x6D,0x65,
+0x28,0x48,0x3A,0x25,
+0x78,0x2C,0x20,0x4C,
+0x3A,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x50,0x53,0x00,0x00,
+0xD0,0x84,0x01,0x80,
+0xD0,0x84,0x01,0x80,
+0xF8,0x84,0x01,0x80,
+0xD0,0x84,0x01,0x80,
+0xD0,0x84,0x01,0x80,
+0xF8,0x84,0x01,0x80,
+0xD0,0x84,0x01,0x80,
+0xAC,0x84,0x01,0x80,
+0x00,0x01,0x02,0x02,
+0x03,0x03,0x03,0x03,
+0x04,0x04,0x04,0x04,
+0x04,0x04,0x04,0x04,
+0x05,0x05,0x05,0x05,
+0x05,0x05,0x05,0x05,
+0x05,0x05,0x05,0x05,
+0x05,0x05,0x05,0x05,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x28,0x28,0x28,
+0x28,0x28,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0xA0,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x04,0x04,0x04,0x04,
+0x04,0x04,0x04,0x04,
+0x04,0x04,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x41,0x41,0x41,
+0x41,0x41,0x41,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x42,0x42,0x42,
+0x42,0x42,0x42,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x10,
+0x10,0x10,0x10,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA0,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x10,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x10,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x2D,0x5C,0x7C,0x2F,
+0x00,0x00,0x00,0x00,
+0xCA,0x61,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB0,0xC2,0xC6,0x00,
+0xB0,0xC2,0xC6,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x60,0xB5,0xC6,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x02,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB8,0x60,0xA1,0x09,
+0xFF,0xFF,0xFF,0xFF,
+};
diff --git a/drivers/net/wireless/8712u/include/h2clbk.h b/drivers/net/wireless/8712u/include/h2clbk.h
new file mode 100755
index 0000000..a087a5e
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/h2clbk.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+
+#define _H2CLBK_H_
+
+
+#include <rtl8711_spec.h>
+#include <TypeDef.h>
+
+
+void _lbk_cmd(PADAPTER Adapter);
+
+void _lbk_rsp(PADAPTER Adapter);
+
+void _lbk_evt(IN PADAPTER Adapter);
+
+void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
diff --git a/drivers/net/wireless/8712u/include/hal_init.h b/drivers/net/wireless/8712u/include/hal_init.h
new file mode 100755
index 0000000..b64ff94
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/hal_init.h
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __HAL_INIT_H__
+#define __HAL_INIT_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+uint rtl871x_hal_init(_adapter *padapter);
+uint rtl871x_hal_deinit(_adapter *padapter);
+void rtl871x_hal_stop(_adapter *padapter);
+
+#ifdef CONFIG_RTL8711
+#include "rtl8711_hal.h"
+#endif
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_hal.h"
+#endif
+
+#endif //__HAL_INIT_H__
+
diff --git a/drivers/net/wireless/8712u/include/ieee80211.h b/drivers/net/wireless/8712u/include/ieee80211.h
new file mode 100755
index 0000000..3d1d326
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/ieee80211.h
@@ -0,0 +1,1171 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+
+#ifndef CONFIG_RTL8711FW
+
+	#include <drv_conf.h>
+	#include <osdep_service.h>
+	#include <drv_types.h>
+	#include "wifi.h"
+
+	#if defined PLATFORM_OS_XP
+	#include <ntstrsafe.h>
+	#endif
+	#if defined PLATFORM_LINUX
+	#include <linux/wireless.h>
+	#endif
+#else
+	
+	#include <list.h>
+
+#endif
+
+#define MGMT_QUEUE_NUM 5
+
+#define ETH_ALEN	6
+
+#ifdef CONFIG_HOSTAPD_MODE
+
+#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 14)
+
+/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	RTL871X_HOSTAPD_FLUSH = 1,
+	RTL871X_HOSTAPD_ADD_STA = 2,
+	RTL871X_HOSTAPD_REMOVE_STA = 3,
+	RTL871X_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	RTL871X_SET_ENCRYPTION = 6,
+	RTL871X_GET_ENCRYPTION = 7,
+	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
+	RTL871X_HOSTAPD_GET_RID = 9,
+	RTL871X_HOSTAPD_SET_RID = 10,
+	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
+	RTL871X_HOSTAPD_MLME = 13,
+	RTL871X_HOSTAPD_SCAN_REQ = 14,
+	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
+	RTL871X_HOSTAPD_SET_BEACON=16,
+};
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_NONERP BIT(31)
+
+#endif
+
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE				2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME						4
+
+#define IEEE_PARAM_WPA_ENABLED				1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED			3
+#define IEEE_PARAM_PRIVACY_INVOKED			4
+#define IEEE_PARAM_AUTH_ALGS					5
+#define IEEE_PARAM_IEEE_802_1X				6
+#define IEEE_PARAM_WPAX_SELECT				7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH				1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE 	BIT(0)
+#define WPA_CIPHER_WEP40 	BIT(1)
+#define WPA_CIPHER_WEP104 BIT(2)
+#define WPA_CIPHER_TKIP 	BIT(3)
+#define WPA_CIPHER_CCMP 	BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN 4
+static u8 WPA_OUI_TYPE[] = { 0x00, 0x50, 0xf2, 1 };
+static u16 WPA_VERSION = 1;
+static u8 WPA_AUTH_KEY_MGMT_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+static u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x50, 0xf2, 1 };
+static u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x50, 0xf2, 2 };
+static u8 WPA_CIPHER_SUITE_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+static u8 WPA_CIPHER_SUITE_WEP40[] = { 0x00, 0x50, 0xf2, 1 };
+static u8 WPA_CIPHER_SUITE_TKIP[] = { 0x00, 0x50, 0xf2, 2 };
+//static u8 WPA_CIPHER_SUITE_WRAP[] = { 0x00, 0x50, 0xf2, 3 };
+static u8 WPA_CIPHER_SUITE_CCMP[] = { 0x00, 0x50, 0xf2, 4 };
+static u8 WPA_CIPHER_SUITE_WEP104[] = { 0x00, 0x50, 0xf2, 5 };
+
+
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+static u16 RSN_VERSION = 1;
+static u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x0f, 0xac, 1 };
+static u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x0f, 0xac, 2 };
+static u8 RSN_CIPHER_SUITE_NONE[] = { 0x00, 0x0f, 0xac, 0 };
+static u8 RSN_CIPHER_SUITE_WEP40[] = { 0x00, 0x0f, 0xac, 1 };
+static u8 RSN_CIPHER_SUITE_TKIP[] = { 0x00, 0x0f, 0xac, 2 };
+//static u8 RSN_CIPHER_SUITE_WRAP[] = { 0x00, 0x0f, 0xac, 3 };
+static u8 RSN_CIPHER_SUITE_CCMP[] = { 0x00, 0x0f, 0xac, 4 };
+static u8 RSN_CIPHER_SUITE_WEP104[] = { 0x00, 0x0f, 0xac, 5 };
+
+
+
+enum NETWORK_TYPE
+{
+	WIRELESS_INVALID	= 0,
+	WIRELESS_11B = 1,
+	WIRELESS_11G = 2,
+	WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G),
+	WIRELESS_11A = 4,
+	WIRELESS_11N = 8,
+	WIRELESS_11GN = (WIRELESS_11G|WIRELESS_11N),
+	WIRELESS_11BGN = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11N),
+};
+
+
+typedef struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+        union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+	        struct{
+			int command;
+    			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+#ifdef CONFIG_HOSTAPD_MODE
+		struct {			
+			u16 aid;
+			u16 capability;
+			int flags;
+			u8 tx_supp_rates[16];		
+			struct ieee80211_ht_cap ht_cap;
+		} add_sta;
+		struct {
+			u8	reserved[2];
+			u8	buf[0];
+		} bcn_ie;
+#endif
+
+	} u;
+}ieee_param;
+
+
+#if WIRELESS_EXT < 17
+#define IW_QUAL_QUAL_INVALID   0x10
+#define IW_QUAL_LEVEL_INVALID  0x20
+#define IW_QUAL_NOISE_INVALID  0x40
+#define IW_QUAL_QUAL_UPDATED   0x1
+#define IW_QUAL_LEVEL_UPDATED  0x2
+#define IW_QUAL_NOISE_UPDATED  0x4
+#endif
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	_list	list;
+};
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct rtw_ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+} __attribute__ ((packed));
+
+
+struct	ieee80211_hdr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	u16	qc;
+}  __attribute__ ((packed));
+
+struct  ieee80211_hdr_3addr_qos {
+        u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+       u16     qc;
+}  __attribute__ ((packed));
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __attribute__ ((packed));
+
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+};
+
+struct ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+};
+
+
+struct	ieee80211_hdr_qos {
+	struct	ieee80211_hdr wlan_hdr;
+	u16	qc;
+};
+
+struct  ieee80211_hdr_3addr_qos {
+        struct  ieee80211_hdr_3addr wlan_hdr;
+        u16     qc;
+};
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+};
+#pragma pack()
+
+#endif
+
+
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define RTW_IEEE80211_FCTL_VERS		0x0002
+#define RTW_IEEE80211_FCTL_FTYPE		0x000c
+#define RTW_IEEE80211_FCTL_STYPE		0x00f0
+#define RTW_IEEE80211_FCTL_TODS		0x0100
+#define RTW_IEEE80211_FCTL_FROMDS		0x0200
+#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
+#define RTW_IEEE80211_FCTL_RETRY		0x0800
+#define RTW_IEEE80211_FCTL_PM		0x1000
+#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
+#define RTW_IEEE80211_FCTL_WEP		0x4000
+#define RTW_IEEE80211_FCTL_ORDER		0x8000
+
+#define RTW_IEEE80211_FTYPE_MGMT		0x0000
+#define RTW_IEEE80211_FTYPE_CTL		0x0004
+#define RTW_IEEE80211_FTYPE_DATA		0x0008
+
+/* management */
+#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define RTW_IEEE80211_STYPE_ASSOC_RESP 	0x0010
+#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
+#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
+#define RTW_IEEE80211_STYPE_BEACON		0x0080
+#define RTW_IEEE80211_STYPE_ATIM		0x0090
+#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
+#define RTW_IEEE80211_STYPE_AUTH		0x00B0
+#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
+
+/* control */
+#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_RTS		0x00B0
+#define RTW_IEEE80211_STYPE_CTS		0x00C0
+#define RTW_IEEE80211_STYPE_ACK		0x00D0
+#define RTW_IEEE80211_STYPE_CFEND		0x00E0
+#define RTW_IEEE80211_STYPE_CFENDACK	0x00F0
+
+/* data */
+#define RTW_IEEE80211_STYPE_DATA		0x0000
+#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
+#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
+#define RTW_IEEE80211_STYPE_CFACK		0x0050
+#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
+#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
+#define RTW_IEEE80211_QOS_DATAGRP		0x0080
+#define RTW_IEEE80211_QoS_DATAGRP		RTW_IEEE80211_QOS_DATAGRP	
+
+#define RTW_IEEE80211_SCTL_FRAG		0x000F
+#define RTW_IEEE80211_SCTL_SEQ		0xFFF0
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+};
+#pragma pack()
+
+#endif
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+#define WLAN_EID_RSN 48
+#define WLAN_EID_GENERIC 221
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN  		4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN 		8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
+        IEEE80211_CCK_RATE_5MB_MASK | \
+        IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
+	IEEE80211_OFDM_RATE_9MB_MASK  | \
+	IEEE80211_OFDM_RATE_18MB_MASK | \
+	IEEE80211_OFDM_RATE_36MB_MASK | \
+	IEEE80211_OFDM_RATE_48MB_MASK | \
+	IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	//u32 mac_time[2];
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	//u8 control;
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   //jackson
+	uint tid;	//jackson
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+
+struct ieee80211_softmac_stats{
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} ;
+#pragma pack()
+
+#endif
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__ ((packed));
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __attribute__ ((packed));
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} ;
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} ;
+#pragma pack()
+
+#endif
+
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	//struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_request_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	//u8 current_ap[ETH_ALEN];
+	struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_response_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+//	struct ieee80211_info_element info_element; /* supported rates */
+} __attribute__ ((packed));
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	//struct ieee80211_info_element_hdr info_element;
+} ;
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} ;
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} ;
+
+struct ieee80211_assoc_request_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	//u8 current_ap[ETH_ALEN];
+	struct ieee80211_info_element_hdr info_element;
+} ;
+
+struct ieee80211_assoc_response_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+//	struct ieee80211_info_element info_element; /* supported rates */
+};
+
+#pragma pack()
+
+#endif
+
+
+
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+//(HZ / 2)
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN 128
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+#if 0
+struct ieee80211_network {
+	/* These entries are used to identify a unique network */
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	/* Ensure null-terminated for any debug msgs */
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
+	u8	rssi;	//relative signal strength
+	u8	sq;		//signal quality
+
+	/* These are network statistics */
+	//struct ieee80211_rx_stats stats;
+	u16 capability;
+	u16	aid;
+	u8 rates[MAX_RATES_LENGTH];
+	u8 rates_len;
+	u8 rates_ex[MAX_RATES_EX_LENGTH];
+	u8 rates_ex_len;
+	
+	u8 edca_parmsets[18];
+		
+	u8 mode;
+	u8 flags;
+	u8 time_stamp[8];
+	u16 beacon_interval;
+	u16 listen_interval;
+	u16 atim_window;
+	u8 wpa_ie[MAX_WPA_IE_LEN];
+	size_t wpa_ie_len;
+	u8 rsn_ie[MAX_WPA_IE_LEN];
+	size_t rsn_ie_len;
+	u8 country[6];
+	u8 dtim_period;
+	u8 dtim_data;
+	u8 power_constraint;
+	u8 qosinfo;
+	u8 qbssload[5];
+	u8 network_type;
+	int join_res;
+	unsigned long	last_scanned;	
+};
+#endif
+/*
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+*/
+
+enum ieee80211_state {
+
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+	
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+	
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+	
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+	
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+	
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+	
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+	
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
+
+#ifdef PLATFORM_OS_XP
+extern __inline int is_multicast_ether_addr(const u8 *addr)
+{
+        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+extern __inline int is_broadcast_ether_addr(const u8 *addr)
+{
+	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
+		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
+}
+#endif
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+typedef struct tx_pending_t{
+	int frag;
+	struct ieee80211_txb *txb;
+}tx_pending_t;
+
+
+
+#define MAXTID	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+extern __inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+{
+	/* Single white space is for Linksys APs */
+	if (essid_len == 1 && essid[0] == ' ')
+		return 1;
+
+	/* Otherwise, if the entire essid is 0, we assume it is hidden */
+	while (essid_len) {
+		essid_len--;
+		if (essid[essid_len] != '\0')
+			return 0;
+	}
+
+	return 1;
+}
+
+extern __inline int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case RTW_IEEE80211_FTYPE_DATA:
+		if (fc & RTW_IEEE80211_QOS_DATAGRP)
+			hdrlen += 2;
+		if ((fc & RTW_IEEE80211_FCTL_FROMDS) && (fc & RTW_IEEE80211_FCTL_TODS))
+			hdrlen += 6; /* Addr4 */
+		break;
+	case RTW_IEEE80211_FTYPE_CTL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case RTW_IEEE80211_STYPE_CTS:
+		case RTW_IEEE80211_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+
+	return hdrlen;
+}
+
+
+u8 *set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
+u8 *set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
+u8 *get_ie(u8*pbuf, sint index, sint *len, sint limit);
+void set_supported_rate(u8* SupportedRates, uint mode) ;
+
+unsigned char *get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
+unsigned char *get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+int get_wpa_cipher_suite(u8 *s);
+int get_wpa2_cipher_suite(u8 *s);
+int parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher);
+int parse_wpa2_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher);
+
+int get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len);
+
+u8 *get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+
+uint	get_rateset_len(u8	*rateset);
+
+struct registry_priv;
+int generate_ie(struct registry_priv *pregistrypriv);
+
+
+int get_bit_value_from_ieee_value(u8 val);
+
+uint	is_cckrates_included(u8 *rate);
+
+uint	is_cckratesonly_included(u8 *rate);
+
+int check_network_type(unsigned char *rate, int ratelen, int channel);
+
+
+#endif /* IEEE80211_H */
+
diff --git a/drivers/net/wireless/8712u/include/ieee80211_ext.h b/drivers/net/wireless/8712u/include/ieee80211_ext.h
new file mode 100755
index 0000000..6e95f0f
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/ieee80211_ext.h
@@ -0,0 +1,477 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __IEEE80211_EXT_H
+#define __IEEE80211_EXT_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WPA_PROTO_WPA BIT(0)
+#define WPA_PROTO_RSN BIT(1)
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+
+
+#define WPA_CAPABILITY_PREAUTH BIT(0)
+#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
+#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)
+
+
+#define PMKID_LEN 16
+
+
+#ifdef PLATFORM_LINUX
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct wme_ac_parameter {
+#if defined(CONFIG_LITTLE_ENDIAN)
+	/* byte 1 */
+	u8 	aifsn:4,
+		acm:1,
+	 	aci:2,
+	 	reserved:1;
+
+	/* byte 2 */
+	u8 	eCWmin:4,
+	 	eCWmax:4;
+#elif defined(CONFIG_BIG_ENDIAN)
+	/* byte 1 */
+	u8 	reserved:1,
+	 	aci:2,
+	 	acm:1,
+	 	aifsn:4;
+
+	/* byte 2 */
+	u8 	eCWmax:4,
+	 	eCWmin:4;
+#else
+#error	"Please fix <endian.h>"
+#endif
+
+	/* bytes 3 & 4 */
+	u16 txopLimit;
+} __attribute__ ((packed));
+
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
+	u8 reserved;
+	struct wme_ac_parameter ac[4];
+
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+};
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+};
+
+#pragma pack()
+
+#endif
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((u8 *) (a), (val))
+//#define RSN_SELECTOR_PUT(a, val) WPA_PUT_LE32((u8 *) (a), (val))
+
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       WLAN_ACTION_SM_PS = 1,
+       WLAN_ACTION_PSPM = 2,
+       WLAN_ACTION_PCO_PHASE = 3,
+       WLAN_ACTION_MIMO_CSI_MX = 4,
+       WLAN_ACTION_MIMO_NONCP_BF = 5,
+       WLAN_ACTION_MIMP_CP_BF = 6,
+       WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+#ifdef PLATFORM_LINUX
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  __attribute__ ((packed)) auth;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) reassoc_req;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) disassoc;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  __attribute__ ((packed)) beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_req;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) wme_action;
+#if 0
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  __attribute__ ((packed)) chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  __attribute__ ((packed)) measurement;
+#endif
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  __attribute__ ((packed)) addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  __attribute__ ((packed)) addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  __attribute__ ((packed)) delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  __attribute__ ((packed)) plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) mesh_action;
+			} __attribute__ ((packed)) u;
+		}  __attribute__ ((packed)) action;
+	} __attribute__ ((packed)) u;
+}__attribute__ ((packed));
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  auth;
+		struct {
+			u16 reason_code;
+		}  deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  reassoc_req;
+		struct {
+			u16 reason_code;
+		}  disassoc;
+#if 0		
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  probe_req;
+		
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  probe_resp;
+#endif	
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  wme_action;
+/*				
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  measurement;
+*/				
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  mesh_action;
+			} u;
+		}  action;
+	} u;
+} ;
+
+#pragma pack()
+
+#endif
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/if_ether.h b/drivers/net/wireless/8712u/include/if_ether.h
new file mode 100755
index 0000000..5f79132
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/if_ether.h
@@ -0,0 +1,131 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence). 
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+ 
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+ 
+struct ethhdr 
+{
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+};
+
+struct _vlan {
+   unsigned short       h_vlan_TCI;                // Encapsulates priority and VLAN ID
+   unsigned short       h_vlan_encapsulated_proto;
+};
+
+
+
+#define get_vlan_id(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI))>>13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short )pvlan->h_vlan_encapsulated_proto))
+
+
+#endif	/* _LINUX_IF_ETHER_H */
diff --git a/drivers/net/wireless/8712u/include/ioctl_cfg80211.h b/drivers/net/wireless/8712u/include/ioctl_cfg80211.h
new file mode 100755
index 0000000..46f55df
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/ioctl_cfg80211.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_CFG80211_H__
+#define __IOCTL_CFG80211_H__ 
+
+
+struct rtw_wdev_priv
+{	
+	struct wireless_dev *rtw_wdev;
+	
+	_adapter *padapter;
+
+	struct cfg80211_scan_request *scan_request;
+	_lock scan_req_lock;
+
+	struct net_device *pmon_ndev;//for monitor interface
+	char ifname_mon[IFNAMSIZ + 1]; //interface name for monitor interface
+
+};
+
+#define wdev_to_priv(w) (struct rtw_wdev_priv *)(wdev_priv(w))
+
+#define wiphy_to_adapter(x) (_adapter *)(((struct rtw_wdev_priv*)wiphy_priv(x))->padapter)
+
+#define wiphy_to_wdev(x) (struct wireless_dev *)(((struct rtw_wdev_priv*)wiphy_priv(x))->rtw_wdev)
+
+
+
+int rtw_wdev_alloc(_adapter *padapter, struct device *dev);
+void rtw_wdev_free(struct wireless_dev *wdev);
+
+void rtw_cfg80211_init_wiphy(_adapter *padapter);
+
+void rtw_cfg80211_surveydone_event_callback(_adapter *padapter);
+
+void rtw_cfg80211_indicate_connect(_adapter *padapter);
+void rtw_cfg80211_indicate_disconnect(_adapter *padapter);
+void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted);
+
+int rtw_cfg80211_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+#endif //__IOCTL_CFG80211_H__
+
diff --git a/drivers/net/wireless/8712u/include/ip.h b/drivers/net/wireless/8712u/include/ip.h
new file mode 100755
index 0000000..8f1fd8c
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/ip.h
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP protocol.
+ *
+ * Version:	@(#)ip.h	1.0.2	04/28/93
+ *
+ * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+#include <rtl871x_byteorder.h>
+
+/* SOL_IP socket options */
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 |IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
+#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 |IPOPT_CONTROL)
+#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+
+   REASONS: it is clear that nobody used them because:
+   - MAX_ROUTES value was wrong.
+   - "struct route" was wrong.
+   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+#ifdef PLATFORM_LINUX
+
+struct ip_options {
+  __u32		faddr;				/* Saved first hop address */
+  unsigned char	optlen;
+  unsigned char srr;
+  unsigned char rr;
+  unsigned char ts;
+  unsigned char is_setbyuser:1,			/* Set by setsockopt?			*/
+                is_data:1,			/* Options in __data, rather than skb	*/
+                is_strictroute:1,		/* Strict source route			*/
+                srr_is_hit:1,			/* Packet destination addr was our one	*/
+                is_changed:1,			/* IP checksum more not valid		*/	
+                rr_needaddr:1,			/* Need to record addr of outgoing dev	*/
+                ts_needtime:1,			/* Need to record timestamp		*/
+                ts_needaddr:1;			/* Need to record addr of outgoing dev  */
+  unsigned char router_alert;
+  unsigned char __pad1;
+  unsigned char __pad2;
+  unsigned char __data[0];
+};
+
+#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
+#endif
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+#endif	/* _LINUX_IP_H */
diff --git a/drivers/net/wireless/8712u/include/mlme_osdep.h b/drivers/net/wireless/8712u/include/mlme_osdep.h
new file mode 100755
index 0000000..dbd3250
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/mlme_osdep.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+
+#if defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL)
+extern int time_after(u32 now, u32 old);
+#endif
+
+
+extern void init_mlme_timer(_adapter *padapter);
+extern void os_indicate_disconnect( _adapter *adapter );
+extern void os_indicate_connect( _adapter *adapter );
+void rtw_os_indicate_scan_done( _adapter *padapter, bool aborted);
+extern void report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie);
+
+
+
+#endif	//_MLME_OSDEP_H_
diff --git a/drivers/net/wireless/8712u/include/mp_custom_oid.h b/drivers/net/wireless/8712u/include/mp_custom_oid.h
new file mode 100755
index 0000000..e9f4cc0
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/mp_custom_oid.h
@@ -0,0 +1,353 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+// by Owen
+// 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
+// 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
+// 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility
+
+//
+
+// by Owen for Production Kit
+// For Production Kit with Agilent Equipments
+// in order to make our custom oids hopefully somewhat unique
+// we will use 0xFF (indicating implementation specific OID)
+//               81(first byte of non zero Realtek unique identifier)
+//               80 (second byte of non zero Realtek unique identifier)
+//               XX (the custom OID number - providing 255 possible custom oids)
+
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST    			0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025 
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+// added by Owen on 04/08/03 for Cameo's request
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+//
+
+//Sean		
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+
+//========================================================================
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+//========================================================================
+
+
+// by Owen for RTL8185 Phy Status Report Utility
+#define OID_RT_UTILITY_FALSE_ALARM_COUNTERS				0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE				0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER				0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS					0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS			0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS	0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS			0xFF818586
+//
+
+// by Owen on 03/09/19-03/09/22 for RTL8185
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+//
+
+#define OID_RT_GET_CONNECT_STATE                	0xFF030001
+#define OID_RT_RESCAN	                        	0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE                 	0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY               	0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185		
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A//S
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B//S
+
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+
+// by Owen on 03/31/03 for Cameo's request
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+//
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+
+// For Netgear request. 2005.01.13, by rcnjko.
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+// For Netgear request. 2005.02.17, by rcnjko.
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+// For AZ project. 2005.06.27, by rcnjko.
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+
+// Vincent 8185MP
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+
+//Andy TEST
+//#define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1
+//#define OID_RT_PRO_READ_REGISTRY			0xFF0111C2
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+
+
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+
+// AP OID
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304	// Determine if driver supports AP mode. 2004.08.27, by rcnjko.
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	// Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko.
+
+// 8187MP. 2004.09.06, by rcnjko.
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+
+// Meeting House. added by Annie, 2005-07-20.
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+
+//8711 MP OID added 20051230.
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100//S
+
+#define OID_RT_PRO_READ_REGISTER			0xFF871101 //Q
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 //S
+
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 //Q		
+#define OID_RT_PRO_BURST_WRITE_REGISTER 		0xFF871104 //S
+
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 //S
+
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106 //Q
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 //S
+
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 //S
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 //Q
+
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A //Q
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B //Q
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C//Q
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D//S
+
+
+//Method 2 for H2C/C2H
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 //S
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 //Q
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 //S
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 //Q
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114//Q
+
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 //Q, S
+
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 //S
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 //Q,S
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 //Q
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 //Q
+
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A //S
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B //Q
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C //S
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D //Q
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E //S
+#define OID_RT_POLL_RX_STATUS				0xFF87111F //Q
+
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 //Q,S
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121//S
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122//S
+#define OID_RT_PRO_READ_TSSI				0xFF871123//S
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124//S
+
+ 
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 //Q
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 //S 
+
+//Method 2 , using workitem
+#define OID_RT_SET_READ_REG				0xFF871181 //S
+#define OID_RT_SET_WRITE_REG				0xFF871182 //S
+#define OID_RT_SET_BURST_READ_REG			0xFF871183 //S
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 //S
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185 //S
+#define OID_RT_SET_READ16_EEPROM			0xFF871186 //S
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 //S
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188 //Q
+
+//For SDIO INTERFACE only
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 //Q, S
+#define OID_RT_PRO_871X_DRV_EXT 			0xFF8711A1
+
+//For USB INTERFACE only
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 //Q, S
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 //S
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 //S
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 //Q
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 //Q
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB //S
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC //S
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 //Q, S
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 //S
+#define OID_RT_PRO_DELE_STA_INFO    			0xFF871202 //S
+#define OID_RT_PRO_QUERY_DR_VARIABLE   			0xFF871203 //Q
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 //Q, S
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205 //Q
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 //S
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 //Q, S
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 //Q
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209 //S
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A //S
+
+#define OID_RT_SET_RX_PACKET_TYPE    			0xFF87120B //S
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C //Q
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D //S
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E //S
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F //S
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 //Q
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 //S
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 //Q
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 //Q
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214 //S
+
+#define OID_RT_GET_POWER_MODE				0xFF871215 //Q
+
+#define OID_RT_PRO_EFUSE				0xFF871216 //Q, S
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217 //Q, S
+
+#endif //#ifndef	__CUSTOM_OID_H
diff --git a/drivers/net/wireless/8712u/include/nic_spec.h b/drivers/net/wireless/8712u/include/nic_spec.h
new file mode 100755
index 0000000..4ae0199
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/nic_spec.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+
+
+#ifndef __NIC_SPEC_H__
+#define __NIC_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8711_MCTRL_		(0x20000)
+#define RTL8711_UART_		(0x30000)
+#define RTL8711_TIMER_		(0x40000)
+#define RTL8711_FINT_		(0x50000)
+#define RTL8711_HINT_		(0x50000)
+#define RTL8711_GPIO_		(0x60000)
+#define RTL8711_WLANCTRL_	(0x200000)
+#define RTL8711_WLANFF_		(0xe00000)
+#define RTL8711_HCICTRL_	(0x600000)
+#define RTL8711_SYSCFG_		(0x620000)
+#define RTL8711_SYSCTRL_	(0x620000)
+#define RTL8711_MCCTRL_		(0x020000)
+
+
+#include <rtl8711_regdef.h>
+
+#include <rtl8711_bitdef.h>
+
+
+#endif // __RTL8711_SPEC_H__
+
diff --git a/drivers/net/wireless/8712u/include/osdep_ce_service.h b/drivers/net/wireless/8712u/include/osdep_ce_service.h
new file mode 100755
index 0000000..370448f
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/osdep_ce_service.h
@@ -0,0 +1,151 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#ifndef __OSDEP_CE_SERVICE_H_
+#define __OSDEP_CE_SERVICE_H_
+
+
+#include <ndis.h>
+#include <ntddndis.h>
+
+#ifdef CONFIG_SDIO_HCI
+#include "SDCardDDK.h"
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usbdi.h>
+#endif
+
+typedef HANDLE 	_sema;
+typedef	LIST_ENTRY	_list;
+typedef NDIS_STATUS _OS_STATUS;
+
+typedef NDIS_SPIN_LOCK	_lock;
+
+typedef HANDLE 		_rwlock; //Mutex
+
+typedef u32	_irqL;
+
+typedef NDIS_HANDLE  _nic_hdl;
+
+
+typedef NDIS_MINIPORT_TIMER    _timer;
+
+struct	__queue	{
+	LIST_ENTRY	queue;
+	_lock	lock;
+};
+
+typedef	NDIS_PACKET	_pkt;
+typedef NDIS_BUFFER	_buffer;
+typedef struct	__queue	_queue;
+
+typedef HANDLE 	_thread_hdl_;
+typedef DWORD thread_return;
+typedef void*	thread_context;
+typedef NDIS_WORK_ITEM _workitem;
+
+#define thread_exit() ExitThread(STATUS_SUCCESS); return 0;
+
+
+#define SEMA_UPBND	(0x7FFFFFFF)   //8192
+
+static __inline _list *get_prev(_list	*list)
+{
+	return list->Blink;
+}
+	
+static __inline _list *get_next(_list	*list)
+{
+	return list->Flink;
+}
+
+static __inline _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
+
+static void __inline _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisAcquireSpinLock(plock);
+}
+
+static void __inline _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisReleaseSpinLock(plock);
+}
+
+static __inline _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);	
+}
+
+static __inline _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);	
+}
+
+
+static void __inline _enter_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+	WaitForSingleObject(*prwlock, INFINITE );
+
+}
+
+static void __inline _exit_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+	ReleaseMutex(*prwlock);
+}
+
+static __inline void list_delete(_list *plist)
+{
+	RemoveEntryList(plist);
+	InitializeListHead(plist);
+}
+
+static __inline void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,PVOID cntx)
+{
+	NdisMInitializeTimer(ptimer, padapter, pfunc, cntx);
+}
+
+static __inline void _set_timer(_timer *ptimer,u32 delay_time)
+{
+ 	NdisMSetTimer(ptimer,delay_time);
+}
+
+static __inline void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	NdisMCancelTimer(ptimer,bcancelled);
+}
+
+static __inline void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+
+	NdisInitializeWorkItem(pwork, pfunc, cntx);
+}
+
+static __inline void _set_workitem(_workitem *pwork)
+{
+	NdisScheduleWorkItem(pwork);
+}
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/osdep_intf.h b/drivers/net/wireless/8712u/include/osdep_intf.h
new file mode 100755
index 0000000..e9b89c3
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/osdep_intf.h
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifdef PLATFORM_LINUX
+
+#ifdef CONFIG_USB_HCI
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#endif
+
+#endif
+
+#ifdef PLATFORM_OS_XP
+
+#ifdef CONFIG_SDIO_HCI
+#include <ntddsd.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb.h>
+#include <usbioctl.h>
+#include <usbdlib.h>
+#endif
+
+#endif
+
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0: 1)) << 2)
+
+
+struct intf_priv {
+	
+	u8 *intf_dev;
+	//u32	max_iosz; 	//USB2.0: 128, USB1.1: 64, SDIO:64
+#ifdef CONFIG_SDIO_HCI
+	u32	max_xmitsz; //USB2.0: unlimited, SDIO:512
+	u32	max_recvsz; //USB2.0: unlimited, SDIO:512
+
+	volatile u8 *io_rwmem;
+	volatile u8 *allocated_io_rwmem;
+	//u8 intf_status;	
+	
+	//void (*_bus_io)(u8 *priv);	
+
+/*
+Under Sync. IRP (SDIO/USB)
+A protection mechanism is necessary for the io_rwmem(read/write protocol)
+
+Under Async. IRP (SDIO/USB)
+The protection mechanism is through the pending queue.
+*/
+
+	_rwlock rwlock;	
+#endif
+	
+#ifdef PLATFORM_LINUX	
+	#ifdef CONFIG_USB_HCI	
+	// when in USB, IO is through interrupt in/out endpoints
+	struct usb_device 	*udev;
+	PURB	piorw_urb;
+	_sema	io_retevt;
+	//_timer	io_timer;
+	//u8	bio_irp_timeout;
+	//u8	bio_timer_cancel;
+	#endif
+#endif
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		// below is for io_rwmem...	
+		PMDL pmdl;
+		PSDBUS_REQUEST_PACKET  sdrp;
+		PSDBUS_REQUEST_PACKET  recv_sdrp;
+		PSDBUS_REQUEST_PACKET  xmit_sdrp;
+
+			PIRP		piorw_irp;
+
+	#endif
+	#ifdef CONFIG_USB_HCI
+		PURB	piorw_urb;
+		PIRP		piorw_irp;
+		u8 io_irp_cnt;
+		u8 bio_irp_pending;
+		_sema io_retevt;	
+	#endif	
+#endif
+
+};	
+
+
+struct intf_hdl;
+
+extern uint _init_intf_hdl(_adapter *padapter, struct intf_hdl *pintf_hdl);
+extern void _unload_intf_hdl(struct intf_priv *pintfpriv);
+
+u32 rtl871x_open_fw(_adapter * padapter, void **pphfwfile_hdl, u8 **ppmappedfw);
+void rtl871x_close_fw(_adapter *padapter, void *phfwfile_hdl);
+
+
+#ifdef PLATFORM_LINUX
+int r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+#endif
+
+
+#endif	//_OSDEP_INTF_H_
+
diff --git a/drivers/net/wireless/8712u/include/osdep_service.h b/drivers/net/wireless/8712u/include/osdep_service.h
new file mode 100755
index 0000000..e72304a
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/osdep_service.h
@@ -0,0 +1,484 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+#include <drv_conf.h>
+#include <basic_types.h>
+//#include <rtl871x_byteorder.h>
+
+#define _SUCCESS	1
+#define _FAIL		0
+
+#undef _TRUE
+#define _TRUE		1
+
+#undef _FALSE
+#define _FALSE		0
+
+
+#ifdef PLATFORM_LINUX
+	#include <linux/version.h>
+	#include <linux/spinlock.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+	#include <asm/semaphore.h>
+#else
+	#include <linux/semaphore.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+	#include <linux/sched.h>
+#endif
+	#include <linux/sem.h>
+	#include <linux/netdevice.h>
+	#include <linux/etherdevice.h>
+	#include <net/iw_handler.h>
+	#include <linux/proc_fs.h>	// Necessary because we use the proc fs
+	
+#ifdef CONFIG_USB_HCI
+	typedef struct urb *  PURB;
+#endif
+
+	typedef struct 	semaphore _sema;
+	typedef	spinlock_t	_lock;
+        typedef struct semaphore	_rwlock;
+	typedef struct timer_list _timer;
+
+	struct	__queue	{
+		struct	list_head	queue;	
+		_lock	lock;
+	};
+
+	typedef	struct sk_buff	_pkt;
+	typedef unsigned char	_buffer;
+	
+	typedef struct	__queue	_queue;
+	typedef struct	list_head	_list;
+	typedef	int	_OS_STATUS;
+	//typedef u32	_irqL;
+	typedef unsigned long _irqL;
+	typedef	struct	net_device * _nic_hdl;
+	
+	typedef pid_t		_thread_hdl_;
+	typedef int		thread_return;
+	typedef void*	thread_context;
+
+	#define thread_exit() complete_and_exit(NULL, 0)
+
+	typedef void timer_hdl_return;
+	typedef void* timer_hdl_context;
+	typedef struct work_struct _workitem;
+	
+
+static __inline _list *get_next(_list	*list)
+{
+	return list->next;
+}	
+
+static __inline _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+	
+#define LIST_CONTAINOR(ptr, type, member) \
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))	
+
+        
+static void __inline _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+static void __inline _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+static void __inline _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+static void __inline _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+static void __inline _enter_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+		down(prwlock);
+}
+
+
+static void __inline _exit_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+		up(prwlock);
+}
+
+static __inline void list_delete(_list *plist)
+{
+	
+
+
+	list_del_init(plist);
+	
+
+	
+}
+
+static __inline void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,void* cntx)
+{
+	//setup_timer(ptimer, pfunc,(u32)cntx);	
+	ptimer->function = pfunc;
+	ptimer->data = (u32)cntx;
+	init_timer(ptimer);
+}
+
+static __inline void _set_timer(_timer *ptimer,u32 delay_time)
+{	
+	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));	
+}
+
+static __inline void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	del_timer_sync(ptimer); 	
+	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
+}
+
+static __inline void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	INIT_WORK(pwork, pfunc);
+#else
+	INIT_WORK(pwork, pfunc,pwork);
+#endif
+}
+
+static __inline void _set_workitem(_workitem *pwork)
+{
+	schedule_work(pwork);
+}
+
+#endif	
+
+
+#ifdef PLATFORM_OS_XP
+
+	#include <ndis.h>
+	#include <ntddk.h>
+	#include <ntddsd.h>
+	#include <ntddndis.h>
+	#include <ntdef.h>
+	
+
+	typedef KSEMAPHORE 	_sema;
+	typedef	LIST_ENTRY	_list;
+	typedef NDIS_STATUS _OS_STATUS;
+	
+
+	typedef NDIS_SPIN_LOCK	_lock;
+
+	typedef KMUTEX 			_rwlock;
+
+	typedef KIRQL	_irqL;
+
+	// USB_PIPE for WINCE , but handle can be use just integer under windows
+	typedef NDIS_HANDLE  _nic_hdl;
+
+
+	typedef NDIS_MINIPORT_TIMER    _timer;
+
+	struct	__queue	{
+		LIST_ENTRY	queue;	
+		_lock	lock;
+	};
+
+	typedef	NDIS_PACKET	_pkt;
+	typedef NDIS_BUFFER	_buffer;
+	typedef struct	__queue	_queue;
+	
+	typedef PKTHREAD _thread_hdl_;
+	typedef void	thread_return;
+	typedef void* thread_context;
+
+	typedef NDIS_WORK_ITEM _workitem;
+
+	#define thread_exit() PsTerminateSystemThread(STATUS_SUCCESS);
+
+	
+	#define SEMA_UPBND	(0x7FFFFFFF)   //8192
+	
+static __inline _list *get_next(_list	*list)
+{
+	return list->Flink;
+}	
+
+static __inline _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+	
+
+#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
+     
+
+static __inline _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisAcquireSpinLock(plock);	
+}
+
+static __inline _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisReleaseSpinLock(plock);	
+}
+
+
+static __inline _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);	
+}
+
+static __inline _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);	
+}
+
+
+static __inline _enter_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+	KeWaitForSingleObject(prwlock, Executive, KernelMode, FALSE, NULL);
+}
+
+
+static __inline _exit_hwio_critical(_rwlock *prwlock, _irqL *pirqL)
+{
+	KeReleaseMutex(prwlock, FALSE);
+}
+
+
+static __inline void list_delete(_list *plist)
+{
+	RemoveEntryList(plist);
+	InitializeListHead(plist);	
+}
+
+static __inline void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,PVOID cntx)
+{
+	NdisMInitializeTimer(ptimer, padapter, pfunc, cntx);
+}
+
+static __inline void _set_timer(_timer *ptimer,u32 delay_time)
+{	
+ 	NdisMSetTimer(ptimer,delay_time);	
+}
+
+static __inline void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	NdisMCancelTimer(ptimer,bcancelled);
+}
+
+static __inline void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+
+	NdisInitializeWorkItem(pwork, pfunc, cntx);
+}
+
+static __inline void _set_workitem(_workitem *pwork)
+{
+	NdisScheduleWorkItem(pwork);
+}
+
+#endif
+
+
+#ifdef PLATFORM_OS_CE
+#include <osdep_ce_service.h>
+#endif
+
+#include <rtl871x_byteorder.h>
+
+#ifdef CONFIG_IOCTL_CFG80211	
+//	#include <linux/ieee80211.h>        
+        #include <net/ieee80211_radiotap.h>
+	#include <net/cfg80211.h>	
+#endif //CONFIG_IOCTL_CFG80211
+
+#ifndef BIT
+	#define BIT(x)	( 1 << (x))
+#endif
+
+extern u8*	_malloc(u32 sz);
+extern void	_mfree(u8 *pbuf, u32 sz);
+extern void	_memcpy(void* dec, void* sour, u32 sz);
+extern int	_memcmp(void *dst, void *src, u32 sz);
+extern void	_memset(void *pbuf, int c, u32 sz);
+
+extern void	_init_listhead(_list *list);
+extern u32	is_list_empty(_list *phead);
+extern void	list_insert_tail(_list *plist, _list *phead);
+extern void	list_delete(_list *plist);
+extern void	_init_sema(_sema *sema, int init_val);
+extern void	_free_sema(_sema	*sema);
+extern void	_up_sema(_sema	*sema);
+extern u32	_down_sema(_sema *sema);
+extern void	_rtl_rwlock_init(_rwlock *prwlock);
+extern void	_spinlock_init(_lock *plock);
+extern void	_spinlock_free(_lock *plock);
+extern void	_spinlock(_lock	*plock);
+extern void	_spinunlock(_lock	*plock);
+extern void	_spinlock_ex(_lock	*plock);
+extern void	_spinunlock_ex(_lock	*plock);
+extern void	_init_queue(_queue	*pqueue);
+extern u32	_queue_empty(_queue	*pqueue);
+extern u32	end_of_queue_search(_list *queue, _list *pelement);
+extern u32	get_current_time(void);
+
+extern void	sleep_schedulable(int ms);
+
+extern void	msleep_os(int ms);
+extern void	usleep_os(int us);
+extern void	mdelay_os(int ms);
+extern void	udelay_os(int us);
+extern u8*	_zmalloc(u32 sz);
+extern u8	*	_vmalloc(u32 sz);
+extern u8	*	_zvmalloc(u32 sz);
+extern void	_vmfree(u8 * pbuf, u32 sz);
+
+struct rtw_netdev_priv_indicator {
+	void *priv;
+	u32 sizeof_priv;
+};
+extern struct net_device * rtw_alloc_etherdev(int sizeof_priv);
+#define rtw_netdev_priv(netdev) ( ((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv )
+extern void rtw_free_netdev(struct net_device * netdev);
+
+static __inline unsigned char _cancel_timer_ex(_timer *ptimer)
+{	
+#ifdef PLATFORM_LINUX
+	return del_timer_sync(ptimer);
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	u8 bool;
+	
+	_cancel_timer(ptimer, &bool);
+	
+	return bool;
+#endif
+}
+
+static __inline void thread_enter(void *context)
+{
+#ifdef PLATFORM_LINUX
+	//struct net_device *pnetdev = (struct net_device *)context;
+	//daemonize("%s", pnetdev->name);
+	daemonize("%s", "RTKTHREAD");
+	allow_signal(SIGTERM);
+#endif
+}
+
+static __inline void flush_signals_thread(void) 
+{
+#ifdef PLATFORM_LINUX
+	if (signal_pending (current)) 
+	{
+		flush_signals(current);
+	}
+#endif
+}
+
+static __inline _OS_STATUS res_to_status(sint res)
+{
+
+
+#if defined (PLATFORM_LINUX) || defined (PLATFORM_MPIXEL)
+	return res;
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+	if (res == _SUCCESS)
+		return NDIS_STATUS_SUCCESS;
+	else
+		return NDIS_STATUS_FAILURE;
+
+#endif	
+	
+}
+
+
+static __inline u32 _RND8(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
+	
+	return val;
+
+}
+
+static __inline u32 _RND128(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
+	
+	return val;
+
+}
+
+static __inline u32 _RND256(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
+	
+	return val;
+
+}
+
+static __inline u32 _RND512(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
+	
+	return val;
+
+}
+
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+
+//#ifdef __GNUC__
+#ifdef PLATFORM_LINUX
+#define STRUCT_PACKED __attribute__ ((packed))
+#else
+#define STRUCT_PACKED
+#endif
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/recv_osdep.h b/drivers/net/wireless/8712u/include/recv_osdep.h
new file mode 100755
index 0000000..7b37faa
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/recv_osdep.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+extern sint _init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+extern void _free_recv_priv (struct recv_priv *precvpriv);
+extern  sint update_rxstatus(_adapter *adapter, union recv_frame *precv_frame, struct recv_stat *rxstatus );
+
+
+extern s32  recv_entry(union recv_frame *precv_frame);	
+extern void recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
+extern void recv_returnpacket(IN _nic_hdl cnxt, IN _pkt *preturnedpkt);
+
+
+extern void handle_tkip_mic_err(_adapter *padapter,u8 bgroup);
+		
+
+int	init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+void free_recv_priv (struct recv_priv *precvpriv);
+
+
+int os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter);
+int os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe);
+void os_recv_resource_free(struct recv_priv *precvpriv);
+
+
+int os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf);
+int os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf);
+
+void os_read_port(_adapter *padapter, struct recv_buf *precvbuf);
+
+void init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+#endif //
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_bitdef.h
new file mode 100755
index 0000000..5f40bf4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_bitdef.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+
+
+#ifndef __RTL8712_BITDEF_H__
+#define __RTL8712_BITDEF_H__
+
+
+#include "rtl8712_spec/ioreg_def/rtl8712_cmdctrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_macsetting_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_timectrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_fifoctrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_ratectrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_edcasetting_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_security_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_powersave_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_interrupt_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_debugctrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_offload_bitdef.h"
+#include "rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h"
+#include "rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h"
+
+#endif // __RTL8712_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_cmd.h b/drivers/net/wireless/8712u/include/rtl8712_cmd.h
new file mode 100755
index 0000000..38069e0
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_cmd.h
@@ -0,0 +1,338 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_CMD_H_
+#define __RTL8712_CMD_H_
+
+#define CMD_HDR_SZ	8
+
+u8 fw_cmd(PADAPTER pAdapter, u32 cmd);
+void fw_cmd_data(PADAPTER pAdapter, u32 *value, u8 flag);
+
+struct cmd_hdr {
+	u32 cmd_dw0;
+	u32 cmd_dw1;
+};
+
+
+enum rtl8712_h2c_cmd
+{
+	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
+ 	GEN_CMD_CODE(_Write_MACREG) ,    
+ 	GEN_CMD_CODE(_Read_BBREG) ,  
+ 	GEN_CMD_CODE(_Write_BBREG) ,  
+ 	GEN_CMD_CODE(_Read_RFREG) ,  
+ 	GEN_CMD_CODE(_Write_RFREG) , /*5*/
+ 	GEN_CMD_CODE(_Read_EEPROM) ,  
+ 	GEN_CMD_CODE(_Write_EEPROM) ,  
+ 	GEN_CMD_CODE(_Read_EFUSE) ,  
+ 	GEN_CMD_CODE(_Write_EFUSE) , 
+ 	
+ 	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
+ 	GEN_CMD_CODE(_Write_CAM) ,   
+ 	GEN_CMD_CODE(_setBCNITV),
+ 	GEN_CMD_CODE(_setMBIDCFG),
+ 	GEN_CMD_CODE(_JoinBss),   /*14*/
+ 	GEN_CMD_CODE(_DisConnect) , /*15*/
+ 	GEN_CMD_CODE(_CreateBss) ,
+	GEN_CMD_CODE(_SetOpMode) , 
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+ 	GEN_CMD_CODE(_SetAuth) ,
+ 	
+ 	GEN_CMD_CODE(_SetKey) ,	/*20*/
+ 	GEN_CMD_CODE(_SetStaKey) ,
+ 	GEN_CMD_CODE(_SetAssocSta) ,
+ 	GEN_CMD_CODE(_DelAssocSta) ,
+ 	GEN_CMD_CODE(_SetStaPwrState) , 
+ 	GEN_CMD_CODE(_SetBasicRate) , /*25*/
+ 	GEN_CMD_CODE(_GetBasicRate) ,
+ 	GEN_CMD_CODE(_SetDataRate) ,
+ 	GEN_CMD_CODE(_GetDataRate) ,
+	GEN_CMD_CODE(_SetPhyInfo) ,
+	
+ 	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
+	GEN_CMD_CODE(_SetPhy) ,
+ 	GEN_CMD_CODE(_GetPhy) ,
+ 	GEN_CMD_CODE(_readRssi) ,
+ 	GEN_CMD_CODE(_readGain) ,
+ 	GEN_CMD_CODE(_SetAtim) , /*35*/
+ 	GEN_CMD_CODE(_SetPwrMode) , 
+ 	GEN_CMD_CODE(_JoinbssRpt),
+ 	GEN_CMD_CODE(_SetRaTable) ,
+ 	GEN_CMD_CODE(_GetRaTable) ,  	
+ 	
+ 	GEN_CMD_CODE(_GetCCXReport), /*40*/
+ 	GEN_CMD_CODE(_GetDTMReport),
+ 	GEN_CMD_CODE(_GetTXRateStatistics),
+ 	GEN_CMD_CODE(_SetUsbSuspend),
+ 	GEN_CMD_CODE(_SetH2cLbk),
+ 	GEN_CMD_CODE(_AddBAReq) , /*45*/
+
+	GEN_CMD_CODE(_SetChannel), /*46*/
+
+// MP_OFFLOAD Start (47~54)
+	GEN_CMD_CODE(_SetTxPower), 
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+	GEN_CMD_CODE(_SetSingleToneTx),
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+// MP_OFFLOAD End
+
+	GEN_CMD_CODE(_TX_Beacon),        /*55*/
+	GEN_CMD_CODE(_SetPowerTracking),
+	GEN_CMD_CODE(_AMSDU_TO_AMPDU), /*57*/ 
+	GEN_CMD_CODE(_SetMacAddress), /*58*/
+
+	GEN_CMD_CODE(_DisconnectCtrl), /*59*/
+	GEN_CMD_CODE(_SetChannelPlan), /*60*/
+	GEN_CMD_CODE(_DisconnectCtrlEx), /*61*/
+	GEN_CMD_CODE(_WWlanCtrl), /*62*/
+	GEN_CMD_CODE(_SetPwrParam),	/*63*/
+	
+	
+#if 1//To do, modify these h2c cmd, add or delete
+	GEN_CMD_CODE(_GetH2cLbk) ,
+
+	// WPS extra IE
+	GEN_CMD_CODE(_SetProbeReqExtraIE) ,
+	GEN_CMD_CODE(_SetAssocReqExtraIE) ,
+	GEN_CMD_CODE(_SetProbeRspExtraIE) ,
+	GEN_CMD_CODE(_SetAssocRspExtraIE) ,
+	
+	// the following is driver will do
+	GEN_CMD_CODE(_GetCurDataRate) , 
+
+	GEN_CMD_CODE(_GetTxRetrycnt),  // to record times that Tx retry to transmmit packet after association
+	GEN_CMD_CODE(_GetRxRetrycnt), // to record total number of the received frame with ReTry bit set in the WLAN header
+
+	GEN_CMD_CODE(_GetBCNOKcnt),
+	GEN_CMD_CODE(_GetBCNERRcnt),
+	GEN_CMD_CODE(_GetCurTxPwrLevel),
+
+	GEN_CMD_CODE(_SetDIG),
+	GEN_CMD_CODE(_SetRA),
+	GEN_CMD_CODE(_SetPT),
+	GEN_CMD_CODE(_ReadTSSI),	
+ #endif
+	MAX_H2CCMD
+};
+
+
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_ 		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_ 		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_ 		_Write_RFREG_CMD_
+#define _DRV_INT_CMD_		(MAX_H2CCMD+1)
+#define _SetRFIntFs_CMD_	(MAX_H2CCMD+2)
+
+#ifdef _RTL8712_CMD_C_
+struct _cmd_callback 	cmd_callback[] = 
+{
+	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL}, 
+	{GEN_CMD_CODE(_Read_BBREG), &getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+	
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},	
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+ 	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), &createbss_cmd_callback},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+	
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},	
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},	
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+	
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},	
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable) , NULL},
+ 	
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+ 	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+ 	{GEN_CMD_CODE(_GetTXRateStatistics), NULL}, 
+ 	{GEN_CMD_CODE(_SetUsbSuspend), NULL}, 
+ 	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+ 	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+
+// MP_OFFLOAD Start (47~54)
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL},
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+// MP_OFFLOAD End
+
+	{GEN_CMD_CODE(_TX_Beacon), NULL},        /*55*/
+	{GEN_CMD_CODE(_SetPowerTracking), NULL},
+	{GEN_CMD_CODE(_AMSDU_TO_AMPDU), NULL}, /*57*/ 
+	{GEN_CMD_CODE(_SetMacAddress), NULL}, /*58*/	
+
+	{GEN_CMD_CODE(_DisconnectCtrl),NULL}, /*59*/ 
+	{GEN_CMD_CODE(_SetChannelPlan),NULL}, /*60*/
+	{GEN_CMD_CODE(_DisconnectCtrlEx),NULL}, /*61*/
+	{GEN_CMD_CODE(_WWlanCtrl), NULL}, /*62*/
+	{GEN_CMD_CODE(_SetPwrParam), NULL}, /*63*/
+	
+#if 1//To do, modify these h2c cmd, add or delete
+	{GEN_CMD_CODE(_GetH2cLbk), NULL},
+
+	{_SetProbeReqExtraIE_CMD_, NULL},
+	{_SetAssocReqExtraIE_CMD_, NULL},
+	{_SetProbeRspExtraIE_CMD_, NULL},
+	{_SetAssocRspExtraIE_CMD_, NULL},	
+	{_GetCurDataRate_CMD_, NULL},
+	{_GetTxRetrycnt_CMD_, NULL},
+	{_GetRxRetrycnt_CMD_, NULL},	
+	{_GetBCNOKcnt_CMD_, NULL},	
+	{_GetBCNERRcnt_CMD_, NULL},	
+	{_GetCurTxPwrLevel_CMD_, NULL},	
+	{_SetDIG_CMD_, NULL},	
+	{_SetRA_CMD_, NULL},		
+	{_SetPT_CMD_,NULL},
+	{GEN_CMD_CODE(_ReadTSSI), &readtssi_cmdrsp_callback}
+#endif
+};
+#endif
+
+
+#ifdef CONFIG_MLME_EXT
+
+struct cmd_hdl {
+	uint	parmsize;
+	u8 (*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);	
+};
+
+
+u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
+
+extern u8 r871x_NULL_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_joinbss_hdl(_adapter *padapter, u8 *pbuf);	
+extern u8 r871x_disconnect_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_createbss_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_setopmode_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_sitesurvey_hdl(_adapter *padapter, u8 *pbuf);	
+extern u8 r871x_setauth_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_setkey_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_set_stakey_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_set_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_del_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+
+#define GEN_MLME_CMD_HANDLER(size, cmd)	{size, &r871x_ ## cmd ## _hdl},
+
+#ifdef _RTL8712_CMD_C_
+struct cmd_hdl	wlancmds[] = 
+{
+	GEN_DRV_CMD_HANDLER(0, read_macreg) /*0*/
+	GEN_DRV_CMD_HANDLER(0, write_macreg)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	
+	GEN_MLME_CMD_HANDLER(0, NULL) /*10*/
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)		
+	GEN_MLME_CMD_HANDLER(sizeof (struct joinbss_parm), joinbss) /*14*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct disconnect_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct createbss_parm), createbss)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setopmode_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct sitesurvey_parm), sitesurvey) /*18*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct setauth_parm), setauth)
+	
+	GEN_MLME_CMD_HANDLER(sizeof (struct setkey_parm), setkey) /*20*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct set_stakey_parm), set_stakey)
+	GEN_MLME_CMD_HANDLER(sizeof (struct set_assocsta_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct del_assocsta_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setstapwrstate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setbasicrate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct getbasicrate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setdatarate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct getdatarate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setphyinfo_parm), NULL)
+	
+	GEN_MLME_CMD_HANDLER(sizeof (struct getphyinfo_parm), NULL)  /*30*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct setphy_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct getphy_parm), NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	
+	GEN_MLME_CMD_HANDLER(0, NULL)	/*40*/
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	
+};
+#endif
+
+#endif//end of CONFIG_MLME_EXT
+
+u8 read_macreg_cmd(_adapter  *padapter, u32 offset, u8 *pval);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_efuse.h b/drivers/net/wireless/8712u/include/rtl8712_efuse.h
new file mode 100755
index 0000000..339e3aa
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_efuse.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_EFUSE_H__
+#define __RTL8712_EFUSE_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+#define _REPEAT_THRESHOLD_	3
+
+#define EFUSE_MAX_SIZE		512
+#define EFUSE_MAP_MAX_SIZE	128
+
+#define PGPKG_MAX_WORDS		4
+#define PGPKT_DATA_SIZE		8	// PGPKG_MAX_WORDS*2; BYTES sizeof(u8)*8
+#define MAX_PGPKT_SIZE		9	// 1 + PGPKT_DATA_SIZE; header + 2 * 4 words (BYTES)
+
+#define GET_EFUSE_OFFSET(header)	((header & 0xF0) >> 4)
+#define GET_EFUSE_WORD_EN(header)	(header & 0x0F)
+#define MAKE_EFUSE_HEADER(offset, word_en)	(((offset & 0x0F) << 4) | (word_en & 0x0F))
+//------------------------------------------------------------------------------
+typedef struct PG_PKT_STRUCT {
+	u8 offset;
+	u8 word_en;
+	u8 data[PGPKT_DATA_SIZE];
+} PGPKT_STRUCT,*PPGPKT_STRUCT;
+//------------------------------------------------------------------------------
+extern u8 	efuse_reg_init(_adapter *padapter);
+extern void 	efuse_reg_uninit(_adapter *padapter);
+extern u16 	efuse_get_current_size(_adapter *padapter);
+extern int 	efuse_get_max_size(_adapter *padapter);
+extern void 	efuse_change_max_size(_adapter *padapter);
+extern u8 	efuse_pg_packet_read(_adapter *padapter, u8 offset, u8 *data);
+extern u8 	efuse_pg_packet_write(_adapter *padapter, const u8 offset, const u8 word_en, const u8 *data);
+extern u8 	efuse_access(_adapter *padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
+extern u8	efuse_map_read(_adapter *padapter, u16 addr, u16 cnts, u8 *data);
+extern u8	efuse_map_write(_adapter *padapter, u16 addr, u16 cnts, u8 *data);
+#endif
diff --git a/drivers/net/wireless/8712u/include/rtl8712_event.h b/drivers/net/wireless/8712u/include/rtl8712_event.h
new file mode 100755
index 0000000..5bc78ce
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_event.h
@@ -0,0 +1,109 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL8712_EVENT_H_
+#define _RTL8712_EVENT_H_
+
+void event_handle(_adapter *padapter, uint *peventbuf);
+
+
+void dummy_event_callback(_adapter *adapter , u8 *pbuf);
+void fwdbg_event_callback(_adapter *adapter , u8 *pbuf);
+extern void got_addbareq_event_callback(_adapter *adapter , u8 *pbuf);
+
+enum rtl8712_c2h_event
+{
+	GEN_EVT_CODE(_Read_MACREG)=0, /*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+ 	GEN_EVT_CODE(_Read_RFREG),
+ 	GEN_EVT_CODE(_Read_EEPROM),
+ 	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),			/*5*/
+ 	GEN_EVT_CODE(_Get_BasicRate),  
+ 	GEN_EVT_CODE(_Get_DataRate),   
+ 	GEN_EVT_CODE(_Survey),	 /*8*/
+ 	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+ 	
+ 	GEN_EVT_CODE(_JoinBss) , /*10*/
+ 	GEN_EVT_CODE(_AddSTA),
+ 	GEN_EVT_CODE(_DelSTA),
+ 	GEN_EVT_CODE(_AtimDone) ,
+ 	GEN_EVT_CODE(_TX_Report),  
+	GEN_EVT_CODE(_CCX_Report),			/*15*/
+ 	GEN_EVT_CODE(_DTM_Report),
+ 	GEN_EVT_CODE(_TX_Rate_Statistics),
+ 	GEN_EVT_CODE(_C2HLBK), 
+ 	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB	
+	GEN_EVT_CODE(_WPS_PBC),			/*24*/
+	GEN_EVT_CODE(_ADDBAReq_Report),	/*25*/
+	GEN_EVT_CODE(_Survey_timer),	/*26*///for softap mode, need been modified
+	GEN_EVT_CODE(_OBSS_scan_timer),	/*27*/
+ 	MAX_C2HEVT
+};
+
+
+#ifdef _RTL8712_CMD_C_		
+
+struct fwevent wlanevents[] = 
+{
+	{0, dummy_event_callback}, 	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &survey_event_callback},		/*8*/
+	{sizeof (struct surveydone_event), &surveydone_event_callback},	/*9*/
+		
+	{0, &joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &stassoc_event_callback},
+	{sizeof(struct stadel_event), &stadel_event_callback},	
+	{0, &atimdone_event_callback},
+	{0, dummy_event_callback},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, fwdbg_event_callback},
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},	
+	{0, &cpwm_event_callback},
+	{0, &wpspbc_event_callback},
+	{0, &got_addbareq_event_callback},
+	{0, fwdbg_event_callback},//for softap mode, need been modified
+	{sizeof(struct survey_timer_event), &survey_timer_event_callback},
+};
+
+#endif//_RTL8712_CMD_C_
+
+void recv_event_bh(void *priv);
+
+#ifdef CONFIG_MLME_EXT
+int event_queuing (_adapter *padapter, struct event_node *evtnode);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_hal.h b/drivers/net/wireless/8712u/include/rtl8712_hal.h
new file mode 100755
index 0000000..9546a11
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_hal.h
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_HAL_H__
+#define __RTL8712_HAL_H__
+
+
+
+enum _HW_VERSION {
+
+	RTL8712_FPGA,
+	RTL8712_1stCUT,//A Cut (RTL8712_ASIC)
+	RTL8712_2ndCUT,//B Cut
+	RTL8712_3rdCUT,//C Cut
+};
+
+
+enum _LOOPBACK_TYPE {
+
+ RTL8712_AIR_TRX = 0,
+ RTL8712_MAC_LBK,
+ RTL8712_BB_LBK,
+ RTL8712_MAC_FW_LBK = 4,
+ RTL8712_BB_FW_LBK = 8,
+
+};
+
+enum RTL871X_HCI_TYPE {
+
+	RTL8712_SDIO,	
+	RTL8712_USB,
+};
+
+enum RTL8712_RF_CONFIG{
+	RTL8712_RF_1T1R,
+	RTL8712_RF_1T2R,
+	RTL8712_RF_2T2R
+};
+
+
+enum _RTL8712_HCI_TYPE_{
+ RTL8712_HCI_TYPE_PCIE=0x01,
+ RTL8712_HCI_TYPE_AP_PCIE=0x81,  
+ RTL8712_HCI_TYPE_USB=0x02,
+ RTL8712_HCI_TYPE_92USB=0x02,
+ RTL8712_HCI_TYPE_AP_USB=0x82,   
+ RTL8712_HCI_TYPE_72USB=0x12,
+ RTL8712_HCI_TYPE_SDIO=0x04,
+ RTL8712_HCI_TYPE_72SDIO=0x14
+};
+
+
+struct fw_priv {   //8-bytes alignment required
+
+	//--- long word 0 ----
+ unsigned char  signature_0;  //0x12: CE product, 0x92: IT product
+ unsigned char  signature_1;  //0x87: CE product, 0x81: IT product
+ unsigned char  hci_sel;   //0x81: PCI-AP, 01:PCIe, 02: 92S-U, 0x82: USB-AP, 0x12: 72S-U, 03:SDIO
+ unsigned char  chip_version; //the same value as reigster value 
+ unsigned char  customer_ID_0; //customer  ID low byte
+ unsigned char  customer_ID_1; //customer  ID high byte
+ unsigned char  rf_config;  //0x11:  1T1R, 0x12: 1T2R, 0x92: 1T2R turbo, 0x22: 2T2R
+ unsigned char  usb_ep_num;  // 4: 4EP, 6: 6EP, 11: 11EP
+	
+	//--- long word 1 ----
+ unsigned char  regulatory_class_0; //regulatory class bit map 0
+ unsigned char  regulatory_class_1; //regulatory class bit map 1
+ unsigned char  regulatory_class_2; //regulatory class bit map 2
+ unsigned char  regulatory_class_3; //regulatory class bit map 3 
+ unsigned char  rfintfs;    // 0:SWSI, 1:HWSI, 2:HWPI
+ unsigned char  def_nettype;  //
+ unsigned char  turboMode;
+ unsigned char  lowPowerMode;// 0: noral mode, 1: low power mode
+	
+	//--- long word 2 ----
+ unsigned char  lbk_mode; //0x00: normal, 0x03: MACLBK, 0x01: PHYLBK
+ unsigned char  mp_mode; // 1: for MP use, 0: for normal driver (to be discussed)
+ unsigned char  vcsType; /* 0:off 1:on 2:auto */
+ unsigned char  vcsMode; /* 1:RTS/CTS 2:CTS to self */
+ unsigned char  rsvd022;
+ unsigned char  rsvd023;
+ unsigned char  rsvd024;
+ unsigned char  rsvd025;
+	
+	//--- long word 3 ----
+ unsigned char  qos_en;    //1: QoS enable
+ unsigned char  bw_40MHz_en;   //1: 40MHz BW enable
+ unsigned char  AMSDU2AMPDU_en;   //1: 4181 convert AMSDU to AMPDU, 0: disable
+ unsigned char  AMPDU_en;   //1: 11n AMPDU enable
+ unsigned char  rate_control_offload;  //1: FW offloads, 0: driver handles
+ unsigned char  aggregation_offload;  //1: FW offloads, 0: driver handles
+ unsigned char  rsvd030;
+ unsigned char  rsvd031;
+
+	//--- long word 4 ----
+ unsigned char  beacon_offload;   // 1. FW offloads, 0: driver handles
+ unsigned char  MLME_offload;   // 2. FW offloads, 0: driver handles
+ unsigned char  hwpc_offload;   // 3. FW offloads, 0: driver handles
+ unsigned char  tcp_checksum_offload; // 4. FW offloads, 0: driver handles
+ unsigned char  tcp_offload;    // 5. FW offloads, 0: driver handles
+ unsigned char  ps_control_offload;  // 6. FW offloads, 0: driver handles
+ unsigned char  WWLAN_offload;   // 7. FW offloads, 0: driver handles
+ unsigned char  rsvd040;
+
+	//--- long word 5 ----
+ unsigned char  tcp_tx_frame_len_L;  //tcp tx packet length low byte
+ unsigned char  tcp_tx_frame_len_H;  //tcp tx packet length high byte
+ unsigned char  tcp_rx_frame_len_L;  //tcp rx packet length low byte
+ unsigned char  tcp_rx_frame_len_H;  //tcp rx packet length high byte
+ unsigned char  rsvd050;
+ unsigned char  rsvd051;
+ unsigned char  rsvd052;
+ unsigned char  rsvd053;
+	
+};
+
+
+struct fw_hdr{//8-byte alinment required
+
+	unsigned short	signature;//
+	unsigned short	version;//0x8000 ~ 0x8FFF for FPGA version,	//0x0000 ~ 0x7FFF for ASIC version,
+	
+	unsigned int		dmem_size;    //define the size of boot loader
+
+	unsigned int		img_IMEM_size;    //define the size of FW in IMEM
+	
+	unsigned int		img_SRAM_size;    //define the size of FW in SRAM
+
+	unsigned int		fw_priv_sz;       //define the size of DMEM variable 
+	
+	unsigned short	efuse_addr;
+	unsigned short 	h2ccnd_resp_addr;
+	
+#if 0
+	unsigned short	debug_dump_addr;
+	unsigned short	rsvd1;
+#else
+	unsigned int		SVNRevision;
+#endif
+	
+	unsigned int  		release_time; //Mon:Day:Hr:Min
+
+	struct fw_priv 	fwpriv;	
+	
+};
+
+struct hal_priv{
+
+	//Endpoint handles
+	_nic_hdl	pipehdls_r8712[10];
+	
+	u8 (*hal_bus_init)(_adapter *adapter);
+	u8  (*hal_bus_deinit)(_adapter *adapter);
+	
+};
+
+uint	 rtl8712_hal_init(_adapter *padapter);
+
+#endif
diff --git a/drivers/net/wireless/8712u/include/rtl8712_recv.h b/drivers/net/wireless/8712u/include/rtl8712_recv.h
new file mode 100755
index 0000000..15c0442
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_recv.h
@@ -0,0 +1,301 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL8712_RECV_H_
+#define _RTL8712_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF 1024//512//128
+	#else
+		#define NR_RECVBUFF (16)
+	#endif
+#elif defined(PLATFORM_OS_CE)
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF (128)
+	#else
+		#define NR_RECVBUFF (4)
+	#endif
+#else
+
+#ifdef CONFIG_PLATFORM_MT53XX
+	#define NR_RECVBUFF (1)
+#else
+	#define NR_RECVBUFF (4)
+#endif
+
+	#define NR_PREALLOC_RECV_SKB (8)
+#endif
+
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+//#define MAX_RECVBUF_SZ 2048 // 2k
+//#define MAX_RECVBUF_SZ (8192) // 8K
+//#define MAX_RECVBUF_SZ (16384) //16K
+//#define MAX_RECVBUF_SZ (16384 + 1024) //16K + 1k
+//#define MAX_RECVBUF_SZ (30720) //30k
+//#define MAX_RECVBUF_SZ (30720 + 1024) //30k+1k
+//#define MAX_RECVBUF_SZ (32768) // 32k
+
+#if defined(CONFIG_SDIO_HCI)
+
+#define MAX_RECVBUF_SZ (50000) //30k //(2048)//(30720) //30k
+
+#elif defined(CONFIG_USB_HCI)
+
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+//#define MAX_RECVBUF_SZ (32768) // 32k
+//#define MAX_RECVBUF_SZ (16384) //16K
+//#define MAX_RECVBUF_SZ 0x3800
+#ifdef CONFIG_USB_RX_AGGREGATION
+#ifdef CONFIG_PLATFORM_MSTAR389
+#define MAX_RECVBUF_SZ (15360) // 15K
+#else
+#define MAX_RECVBUF_SZ (30720) // 30K
+#endif
+#else
+#define MAX_RECVBUF_SZ (7168) // 7K
+#endif //CONFIG_USB_RX_AGGREGATION
+#endif
+
+#endif
+
+#define RECVBUFF_ALIGN_SZ 512
+
+#define RSVD_ROOM_SZ (0)
+
+
+//These definition is used for Rx packet reordering.
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+#define SN_EQUAL(a, b)	(a == b)
+//#define REORDER_WIN_SIZE	128
+//#define REORDER_ENTRY_NUM	128
+#define REORDER_WAIT_TIME	30 // (ms)
+
+
+struct recv_stat
+{	
+	unsigned int rxdw0;
+
+	unsigned int rxdw1;
+
+	unsigned int rxdw2;
+
+	unsigned int rxdw3;
+
+	unsigned int rxdw4;
+
+	unsigned int rxdw5;	
+};
+
+struct phy_cck_rx_status
+{
+	/* For CCK rate descriptor. This is a unsigned 8:1 variable. LSB bit presend
+	   0.5. And MSB 7 bts presend a signed value. Range from -64~+63.5. */
+	u8	adc_pwdb_X[4];
+	u8	sq_rpt;	
+	u8	cck_agc_rpt;
+};
+
+struct phy_stat
+{
+	unsigned int phydw0;
+
+	unsigned int phydw1;
+
+	unsigned int phydw2;
+
+	unsigned int phydw3;
+
+	unsigned int phydw4;
+
+	unsigned int phydw5;	
+	
+	unsigned int phydw6;
+
+	unsigned int phydw7;	
+};
+#define PHY_STAT_GAIN_TRSW_SHT 0
+#define PHY_STAT_PWDB_ALL_SHT 4
+#define PHY_STAT_CFOSHO_SHT 5
+#define PHY_STAT_CCK_AGC_RPT_SHT 5
+#define PHY_STAT_CFOTAIL_SHT 9
+#define PHY_STAT_RXEVM_SHT 13
+#define PHY_STAT_RXSNR_SHT 15
+#define PHY_STAT_PDSNR_SHT 19
+#define PHY_STAT_CSI_CURRENT_SHT 21
+#define PHY_STAT_CSI_TARGET_SHT 23
+#define PHY_STAT_SIGEVM_SHT 25
+#define PHY_STAT_MAX_EX_PWR_SHT 26
+
+
+union recvstat {
+	struct recv_stat recv_stat;
+	unsigned int value[RXDESC_SIZE>>2];	
+};
+
+
+struct recv_buf{
+
+	_list list;
+	
+	_lock recvbuf_lock;
+	
+	u32	ref_cnt;
+
+	_adapter  *adapter;
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef PLATFORM_LINUX
+		_pkt *pskb;		
+		u8 reuse;
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PMDL mdl_ptr;	
+#endif	
+	u8	cmd_fail;
+#endif
+
+#ifdef CONFIG_USB_HCI
+
+	#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	purb;
+
+	#endif
+
+	#ifdef PLATFORM_OS_XP
+		PIRP		pirp;
+	#endif
+
+	#ifdef PLATFORM_OS_CE
+		USB_TRANSFER	usb_transfer_read_port;
+	#endif
+
+	#ifdef PLATFORM_LINUX
+		_pkt *pskb;		
+		u8 reuse;
+	#endif
+	
+	u8  irp_pending;
+	u32  transfer_len;	
+	
+#endif	
+
+	uint  len;	
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	
+	u8 *pbuf;	
+	u8 *pallocated_buf;
+
+
+};
+
+
+/*
+	head  ----->
+
+		data  ----->
+	
+			payload
+	
+		tail  ----->
+	
+	
+	end   ----->
+
+	len = (unsigned int )(tail - data);
+
+*/
+struct recv_frame_hdr{
+
+	_list	list;
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+
+	_adapter  *adapter;
+	u8 fragcnt;
+
+	struct rx_pkt_attrib attrib;
+
+	uint  len;	
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+
+	void *precvbuf;		
+
+
+	//
+	struct sta_info *psta;
+		
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl *preorder_ctrl;	
+
+};
+
+
+union recv_frame{
+
+	union{	
+		_list list;
+		struct recv_frame_hdr hdr;
+		uint mem[RECVFRAME_HDR_ALIGN>>2];
+	}u;
+
+	//uint mem[MAX_RXSZ>>2];
+
+};
+
+
+int init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf);
+void rxcmd_event_hdl(_adapter *padapter, void *prxcmdbuf);
+s32 signal_scale_mapping(s32 cur_sig );
+
+void reordering_ctrl_timeout_handler(void *pcontext);
+#ifdef PLATFORM_LINUX
+//#if defined (CONFIG_USB_HCI) && defined(PLATFORM_LINUX)
+#ifdef CONFIG_RECV_TASKLET
+void recv_tasklet(void *priv);
+#else
+void recv_bh(void *priv);
+#endif
+
+#endif
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_regdef.h
new file mode 100755
index 0000000..d103954
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_regdef.h
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+
+#ifndef __RTL8712_REGDEF_H__
+#define __RTL8712_REGDEF_H__
+
+
+#include "rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_cmdctrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_macsetting_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_timectrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_fifoctrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_ratectrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_edcasetting_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_security_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_powersave_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_interrupt_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_debugctrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_offload_regdef.h"
+
+
+#endif // __RTL8712_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_rf.h b/drivers/net/wireless/8712u/include/rtl8712_rf.h
new file mode 100755
index 0000000..a6e2fdc
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_rf.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef	__RTL8712_RF_H_ 
+#define __RTL8712_RF_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <rtl871x_mp_phy_regdef.h>
+
+#define WIFI_20MHZ_MODE			0x0000
+#define WIFI_40MHZ_MODE			0x8000
+
+// Bandwidth Offset
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER		1
+#define HAL_PRIME_CHNL_OFFSET_UPPER		2
+
+/*
+u32 get_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask);
+u8 set_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask, u32 value);
+u32 get_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask);
+u8 set_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask,u32 value);
+*/
+
+u32 get_efuse_content(_adapter *padapter, u16 offset);
+void dump_efuse_content(_adapter *padapter, unsigned int *pbuf, int sz);
+
+
+
+void set_channel_and_txpower(_adapter *padapter, u8 level, u8 ch);
+void switchBWOPMODE(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
+
+
+//int set_init_ra_tbl(PADAPTER pAdapter, unsigned short param, unsigned int bitmap);
+
+//u8 get_rf_mimo_mode(_adapter *padapter);
+
+#endif //_RTL8712_RF_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec.h b/drivers/net/wireless/8712u/include/rtl8712_spec.h
new file mode 100755
index 0000000..a340e0c
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_SPEC_H__
+#define __RTL8712_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8712_IOBASE_TXPKT			0x10200000	//IOBASE_TXPKT
+#define RTL8712_IOBASE_RXPKT			0x10210000	//IOBASE_RXPKT
+#define RTL8712_IOBASE_RXCMD			0x10220000	//IOBASE_RXCMD
+#define RTL8712_IOBASE_TXSTATUS		0x10230000	//IOBASE_TXSTATUS
+#define RTL8712_IOBASE_RXSTATUS		0x10240000	//IOBASE_RXSTATUS
+#define RTL8712_IOBASE_IOREG			0x10250000	//IOBASE_IOREG ADDR
+#define RTL8712_IOBASE_SCHEDULER		0x10260000	//IOBASE_SCHEDULER
+#define RTL8712_IOBASE_TRXDMA			0x10270000	//IOBASE_TRXDMA
+#define RTL8712_IOBASE_TXLLT			0x10280000	//IOBASE_TXLLT
+#define RTL8712_IOBASE_WMAC			0x10290000	//IOBASE_WMAC
+#define RTL8712_IOBASE_FW2HW			0x102A0000	//IOBASE_FW2HW
+#define RTL8712_IOBASE_ACCESS_PHYREG	0x102B0000	//IOBASE_ACCESS_PHYREG
+
+#define RTL8712_IOBASE_FF	0x10300000	//IOBASE_FIFO 0x1031000~0x103AFFFF 
+
+
+//IOREG Offset for 8712
+#define RTL8712_SYSCFG_		RTL8712_IOBASE_IOREG
+#define RTL8712_CMDCTRL_		(RTL8712_IOBASE_IOREG + 0x40)
+#define RTL8712_MACIDSETTING_	(RTL8712_IOBASE_IOREG + 0x50)
+#define RTL8712_TIMECTRL_		(RTL8712_IOBASE_IOREG + 0x80)
+#define RTL8712_FIFOCTRL_		(RTL8712_IOBASE_IOREG + 0xA0)
+#define RTL8712_RATECTRL_		(RTL8712_IOBASE_IOREG + 0x160)
+#define RTL8712_EDCASETTING_	(RTL8712_IOBASE_IOREG + 0x1D0)
+#define RTL8712_WMAC_			(RTL8712_IOBASE_IOREG + 0x200)
+#define RTL8712_SECURITY_		(RTL8712_IOBASE_IOREG + 0x240)
+#define RTL8712_POWERSAVE_	(RTL8712_IOBASE_IOREG + 0x260)
+#define RTL8712_GP_				(RTL8712_IOBASE_IOREG + 0x2E0)
+#define RTL8712_INTERRUPT_		(RTL8712_IOBASE_IOREG + 0x300)
+#define RTL8712_DEBUGCTRL_		(RTL8712_IOBASE_IOREG + 0x310)
+#define RTL8712_OFFLOAD_		(RTL8712_IOBASE_IOREG + 0x2D0)
+
+
+//FIFO for 8712
+#define RTL8712_DMA_BCNQ		(RTL8712_IOBASE_FF + 0x10000)
+#define RTL8712_DMA_MGTQ		(RTL8712_IOBASE_FF + 0x20000)
+#define RTL8712_DMA_BMCQ		(RTL8712_IOBASE_FF + 0x30000)
+#define RTL8712_DMA_VOQ		(RTL8712_IOBASE_FF + 0x40000)
+#define RTL8712_DMA_VIQ		(RTL8712_IOBASE_FF + 0x50000)
+#define RTL8712_DMA_BEQ		(RTL8712_IOBASE_FF + 0x60000)
+#define RTL8712_DMA_BKQ		(RTL8712_IOBASE_FF + 0x70000)
+#define RTL8712_DMA_RX0FF		(RTL8712_IOBASE_FF + 0x80000)
+#define RTL8712_DMA_H2CCMD	(RTL8712_IOBASE_FF + 0x90000)
+#define RTL8712_DMA_C2HCMD	(RTL8712_IOBASE_FF + 0xA0000)
+
+
+//------------------------------
+
+//BIT 16 15
+#define	DID_SDIO_LOCAL			0	// 0 0
+#define	DID_WLAN_IOREG			1	// 0 1
+#define	DID_WLAN_FIFO			3	// 1 1
+#define   DID_UNDEFINE				(-1)
+
+#define CMD_ADDR_MAPPING_SHIFT			2	//SDIO CMD ADDR MAPPING ,shift 2 bit for match offset[14:2]
+
+//Offset for SDIO LOCAL
+#define	OFFSET_SDIO_LOCAL				0x0FFF
+
+//Offset for WLAN IOREG
+#define OFFSET_WLAN_IOREG				0x0FFF
+
+//Offset for WLAN FIFO
+#define	OFFSET_TX_BCNQ				0x0300
+#define	OFFSET_TX_HIQ					0x0310
+#define	OFFSET_TX_CMDQ				0x0320
+#define	OFFSET_TX_MGTQ				0x0330
+#define	OFFSET_TX_HCCAQ				0x0340
+#define	OFFSET_TX_VOQ					0x0350
+#define	OFFSET_TX_VIQ					0x0360
+#define	OFFSET_TX_BEQ					0x0370
+#define	OFFSET_TX_BKQ					0x0380
+#define	OFFSET_RX_RX0FFQ				0x0390
+#define	OFFSET_RX_C2HFFQ				0x03A0
+
+#define	BK_QID_01	1
+#define	BK_QID_02	2
+#define	BE_QID_01	0
+#define	BE_QID_02	3
+#define	VI_QID_01	4
+#define	VI_QID_02	5
+#define	VO_QID_01	6
+#define	VO_QID_02	7
+#define	HCCA_QID_01	8
+#define	HCCA_QID_02	9
+#define	HCCA_QID_03	10
+#define	HCCA_QID_04	11
+#define	HCCA_QID_05	12
+#define	HCCA_QID_06	13
+#define	HCCA_QID_07	14
+#define	HCCA_QID_08	15
+#define	HI_QID		17
+#define	CMD_QID	19
+#define	MGT_QID	18
+#define	BCN_QID	16
+
+#include "rtl8712_regdef.h"
+
+#include "rtl8712_bitdef.h"
+
+#include "basic_types.h"
+
+#endif // __RTL8712_SPEC_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_bitdef.h
new file mode 100755
index 0000000..b231ff3
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_bitdef.h
@@ -0,0 +1,130 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_CMDCTRL_BITDEF_H__
+#define __RTL8712_CMDCTRL_BITDEF_H__
+
+//
+// 2. Command Control Registers	 (Offset: 0x0040 - 0x004F)
+//
+//----------------------------------------------------------------------------
+//       8192S (CMD) command register bits		(Offset 0x40, 16 bits)
+//----------------------------------------------------------------------------
+#define		_APSDOFF_STATUS		BIT(15)	//
+#define		_APSDOFF				BIT(14)   //
+#define		_BBRSTn				BIT(13)  //Enable OFDM/CCK
+#define		_BB_GLB_RSTn			BIT(12)   //Enable BB
+#define		_SCHEDULE_EN			BIT(10)  //Enable MAC scheduler
+#define		_MACRXEN				BIT(9)   //
+#define		_MACTXEN				BIT(8)   //
+#define		_DDMA_EN				BIT(7)    //FW off load function enable
+#define		_FW2HW_EN			BIT(6)   //MAC every module reset as below
+#define		_RXDMA_EN			BIT(5)   //
+#define		_TXDMA_EN			BIT(4)   //
+#define		_HCI_RXDMA_EN		BIT(3)    //
+#define		_HCI_TXDMA_EN		BIT(2)    //
+
+
+//CR
+/*
+#define _TCP_OFLD_EN			BIT(11)
+#define _HWPC_EN				BIT(10)
+#define _TSF_RST				BIT(8)
+#define _TSF_EN					BIT(7)
+#define _APSDOFF_STATUS			BIT(6)
+#define _APSDOFF				BIT(5)
+#define _RST					BIT(4)
+#define _RE						BIT(3)
+#define _TE						BIT(2)
+#define _RXEN					BIT(1)
+#define _TXEN					BIT(0)
+*/
+
+//TXPAUSE
+#define	_STOPHCCA				BIT(6)
+#define	_STOPHIGH				BIT(5)
+#define	_STOPMGT				BIT(4)
+#define	_STOPVO					BIT(3)
+#define	_STOPVI					BIT(2)
+#define	_STOPBE					BIT(1)
+#define	_STOPBK					BIT(0)
+
+//TCR
+#define	_DISCW					BIT(20)
+#define	_ICV					BIT(19)
+//#define	_DIS_RQSZ				BIT(18)
+#define	_CFEND_FMT				BIT(17)
+#define	_CRC					BIT(16)
+#define	_FWRDY					BIT(7)
+#define _BASECHG				BIT(6)
+#define	_IMEM_RDY				BIT(5)
+#define _DMEM_CODE_DONE			BIT(4)
+#define _EMEM_CHK_RPT			BIT(3)
+#define _EMEM_CODE_DONE			BIT(2)
+#define _IMEM_CHK_RPT			BIT(1)
+#define _IMEM_CODE_DONE			BIT(0)
+
+#define	_TXDMA_INIT_VALUE	(_IMEM_CHK_RPT|_EMEM_CHK_RPT)
+
+//RCR
+//#define	_ONLYERLPKT				BIT(31)
+//#define	_ENCS2					BIT(30)
+//#define	_ENCS1					BIT(29)
+//#define	_HTCBMFC				BIT(28)
+#define	_ENMBID					BIT(27)
+#define	_APP_PHYST_RXFF			BIT(25)
+#define	_APP_PHYST_STAFF		BIT(24)
+#define	_CBSSID					BIT(23)
+#define	_APWRMGT				BIT(22)
+#define	_ADD3					BIT(21)
+#define	_AMF					BIT(20)
+#define	_ACF					BIT(19)
+#define	_ADF					BIT(18)
+#define	_APP_MIC				BIT(17)
+#define	_APP_ICV				BIT(16)
+#define	_RXFTH_MSK				0x0000E000
+#define	_RXFTH_SHT				13
+#define	_AICV					BIT(12)
+#define	_RXPKTLMT_MSK			0x00000FC0
+#define	_RXPKTLMT_SHT			6
+#define	_ACRC32					BIT(5)
+#define	_AB						BIT(3)
+#define	_AM						BIT(2)
+#define	_APM					BIT(1)
+#define	_AAP					BIT(0)
+
+//MSR
+#define	_NETTYPE_MSK			0x03
+#define	_NETTYPE_SHT			0
+
+//BT
+#define _BTMODE_MSK				0x06
+#define _BTMODE_SHT				1
+#define _ENBT					BIT(0)
+
+//MBIDCTRL
+#define	_ENMBID_MODE			BIT(15)
+#define	_BCNNO_MSK				0x7000
+#define	_BCNNO_SHT				12
+#define	_BCNSPACE_MSK			0x0FFF
+#define	_BCNSPACE_SHT			0
+
+
+#endif // __RTL8712_CMDCTRL_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_regdef.h
new file mode 100755
index 0000000..fb04c76
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_cmdctrl_regdef.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_CMDCTRL_REGDEF_H__
+#define __RTL8712_CMDCTRL_REGDEF_H__
+
+
+#define CR				(RTL8712_CMDCTRL_ + 0x0000)
+#define TXPAUSE			(RTL8712_CMDCTRL_ + 0x0002)
+#define TCR				(RTL8712_CMDCTRL_ + 0x0004)
+#define RCR				(RTL8712_CMDCTRL_ + 0x0008)
+#define MSR				(RTL8712_CMDCTRL_ + 0x000C)
+#define SYSF_CFG		(RTL8712_CMDCTRL_ + 0x000D)
+#define MBIDCTRL		(RTL8712_CMDCTRL_ + 0x000E)
+	
+	
+#endif // __RTL8712_CMDCTRL_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_bitdef.h
new file mode 100755
index 0000000..dcb9f4a
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_bitdef.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_DEBUGCTRL_BITDEF_H__
+#define __RTL8712_DEBUGCTRL_BITDEF_H__
+
+//BIST
+#define	_BIST_RST			BIT(0)
+
+//LMS
+#define	_LMS_MSK			0x03
+
+//WDG_CTRL
+#define	_OVSEL_MSK			0x0600
+#define	_OVSEL_SHT			9
+#define	_WDGCLR				BIT(8)
+#define	_WDGEN_MSK			0x00FF
+#define	_WDGEN_SHT			0
+
+//INTM
+#define	_TXTIMER_MSK		0xF000
+#define	_TXTIMER_SHT		12
+#define	_TXNUM_MSK			0x0F00
+#define	_TXNUM_SHT			8
+#define	_RXTIMER_MSK		0x00F0
+#define	_RXTIMER_SHT		4
+#define	_RXNUM_MSK			0x000F
+#define	_RXNUM_SHT			0
+
+//FDLOCKTURN0
+//FDLOCKTURN1
+#define	_TURN1				BIT(0)
+
+//FDLOCKFLAG0
+//FDLOCKFLAG1
+#define	_LOCKFLAG1_MSK		0x03
+
+
+#endif // __RTL8712_DEBUGCTRL_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_regdef.h
new file mode 100755
index 0000000..7faeff7
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_debugctrl_regdef.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_DEBUGCTRL_REGDEF_H__
+#define __RTL8712_DEBUGCTRL_REGDEF_H__
+
+#define BIST				( RTL8712_DEBUGCTRL_ + 0x00)
+#define DBS					( RTL8712_DEBUGCTRL_ + 0x04)
+#define LMS					( RTL8712_DEBUGCTRL_ + 0x05)
+#define CPUINST				( RTL8712_DEBUGCTRL_ + 0x08)
+#define CPUCAUSE			( RTL8712_DEBUGCTRL_ + 0x0C)
+#define LBUS_ERR_ADDR		( RTL8712_DEBUGCTRL_ + 0x10)
+#define LBUS_ERR_CMD		( RTL8712_DEBUGCTRL_ + 0x14)
+#define LBUS_ERR_DATA_L		( RTL8712_DEBUGCTRL_ + 0x18)
+#define LBUS_ERR_DATA_H		( RTL8712_DEBUGCTRL_ + 0x1C)
+#define LBUS_EXCEPTION_ADDR	( RTL8712_DEBUGCTRL_ + 0x20)
+#define WDG_CTRL			( RTL8712_DEBUGCTRL_ + 0x24)
+#define INTMTU				( RTL8712_DEBUGCTRL_ + 0x28)
+#define INTM				( RTL8712_DEBUGCTRL_ + 0x2A)
+#define FDLOCKTURN0			( RTL8712_DEBUGCTRL_ + 0x2C)
+#define FDLOCKTURN1			( RTL8712_DEBUGCTRL_ + 0x2D)
+#define FDLOCKFLAG0			( RTL8712_DEBUGCTRL_ + 0x2E)
+#define FDLOCKFLAG1			( RTL8712_DEBUGCTRL_ + 0x2F)
+#define TRXPKTBUF_DBG_DATA	( RTL8712_DEBUGCTRL_ + 0x30)
+#define TRXPKTBUF_DBG_CTRL	( RTL8712_DEBUGCTRL_ + 0x38)
+#define DPLL_MON			( RTL8712_DEBUGCTRL_ + 0x3A)
+
+
+
+#endif // __RTL8712_DEBUGCTRL_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_bitdef.h
new file mode 100755
index 0000000..d63567d
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_bitdef.h
@@ -0,0 +1,72 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_EDCASETTING_BITDEF_H__
+#define __RTL8712_EDCASETTING_BITDEF_H__
+
+//EDCAPARAM
+#define	_TXOPLIMIT_MSK		0xFFFF0000
+#define	_TXOPLIMIT_SHT		16
+#define	_ECWIN_MSK			0x0000FF00
+#define	_ECWIN_SHT			8
+#define	_AIFS_MSK			0x000000FF
+#define	_AIFS_SHT			0
+
+//BCNTCFG
+#define	_BCNECW_MSK			0xFF00
+#define	_BCNECW_SHT			8
+#define	_BCNIFS_MSK			0x00FF
+#define	_BCNIFS_SHT			0
+
+//CWRR
+#define	_CWRR_MSK			0x03FF
+
+//ACMAVG
+#define	_AVG_TIME_UP		BIT(3)
+#define	_AVGPERIOD_MSK		0x03
+
+//ACMHWCTRL
+#define	_VOQ_ACM_STATUS		BIT(6)
+#define	_VIQ_ACM_STATUS		BIT(5)
+#define	_BEQ_ACM_STATUS		BIT(4)
+#define	_VOQ_ACM_EN			BIT(3)
+#define	_VIQ_ACM_EN			BIT(2)
+#define	_BEQ_ACM_EN			BIT(1)
+#define	_ACMHWEN			BIT(0)
+
+//VO_ADMTIME
+#define	_VO_ACM_RUT			BIT(18)
+#define	_VO_ADMTIME_MSK		0x0003FFF
+
+//VI_ADMTIME
+#define	_VI_ACM_RUT			BIT(18)
+#define	_VI_ADMTIME_MSK		0x0003FFF
+
+//BE_ADMTIME
+#define	_BE_ACM_RUT			BIT(18)
+#define	_BE_ADMTIME_MSK		0x0003FFF
+
+//Retry limit reg
+#define	_SRL_MSK			0xFF00
+#define	_SRL_SHT			8
+#define	_LRL_MSK			0x00FF
+#define	_LRL_SHT			0
+
+#endif // __RTL8712_EDCASETTING_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_regdef.h
new file mode 100755
index 0000000..c36c473
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_edcasetting_regdef.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+#ifndef __RTL8712_EDCASETTING_REGDEF_H__
+#define __RTL8712_EDCASETTING_REGDEF_H__
+
+#define EDCA_VO_PARAM		( RTL8712_EDCASETTING_ + 0x00 )
+#define EDCA_VI_PARAM		( RTL8712_EDCASETTING_ + 0x04 )
+#define EDCA_BE_PARAM		( RTL8712_EDCASETTING_ + 0x08 )
+#define EDCA_BK_PARAM		( RTL8712_EDCASETTING_ + 0x0C )
+#define BCNTCFG				( RTL8712_EDCASETTING_ + 0x10 )
+#define CWRR				( RTL8712_EDCASETTING_ + 0x12 )
+#define ACMAVG				( RTL8712_EDCASETTING_ + 0x16 )
+#define ACMHWCTRL			( RTL8712_EDCASETTING_ + 0x17 )
+#define VO_ADMTIME			( RTL8712_EDCASETTING_ + 0x18 )
+#define VI_ADMTIME			( RTL8712_EDCASETTING_ + 0x1C )
+#define BE_ADMTIME			( RTL8712_EDCASETTING_ + 0x20 )
+//#define BK_ADMTIME			( RTL8712_EDCASETTING_ + 0x24 )
+#define RL					( RTL8712_EDCASETTING_ + 0x24 )
+
+
+#endif // __RTL8712_EDCASETTING_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_bitdef.h
new file mode 100755
index 0000000..c67eaaa
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_bitdef.h
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_FIFOCTRL_BITDEF_H__
+#define __RTL8712_FIFOCTRL_BITDEF_H__
+
+
+//PBP
+#define	_PSTX_MSK			0xF0
+#define	_PSTX_SHT			4
+#define	_PSRX_MSK			0x0F
+#define	_PSRX_SHT			0
+
+//TXFF_STATUS
+#define	_TXSTATUS_OVF		BIT(15)
+
+//RXFF_STATUS
+#define	_STATUSFF1_OVF		BIT(7)
+#define	_STATUSFF1_EMPTY	BIT(6)
+#define	_STATUSFF0_OVF		BIT(5)
+#define	_STATUSFF0_EMPTY	BIT(4)
+#define	_RXFF1_OVF			BIT(3)
+#define	_RXFF1_EMPTY		BIT(2)
+#define	_RXFF0_OVF			BIT(1)
+#define	_RXFF0_EMPTY		BIT(0)
+
+//TXFF_EMPTY_TH
+#define	_BKQ_EMPTY_TH_MSK	0x0F0000
+#define	_BKQ_EMPTY_TH_SHT	16
+#define	_BEQ_EMPTY_TH_MSK	0x00F000
+#define	_BEQ_EMPTY_TH_SHT	12
+#define	_VIQ_EMPTY_TH_MSK	0x000F00
+#define	_VIQ_EMPTY_TH_SHT	8
+#define	_VOQ_EMPTY_TH_MSK	0x0000F0
+#define	_VOQ_EMPTY_TH_SHT	4
+#define	_BMCQ_EMPTY_TH_MSK	0x00000F
+#define	_BMCQ_EMPTY_TH_SHT	0
+
+//SDIO_RX_BLKSZ
+#define	_SDIO_RX_BLKSZ_MSK	0x07
+
+//RXDMA_CTRL
+#define	_C2HFF_POLL		BIT(4)
+#define	_RXPKT_POLL		BIT(0)
+
+//RXPKT_NUM
+#define	_RXCMD_NUM_MSK		0xFF00
+#define	_RXCMD_NUM_SHT		8
+#define	_RXFF0_NUM_MSK		0x00FF
+#define	_RXFF0_NUM_SHT		0
+
+//FIFOPAGE2
+#define	_PUB_AVAL_PG_MSK	0xFFFF0000
+#define	_PUB_AVAL_PG_SHT	16
+#define	_BCN_AVAL_PG_MSK	0x0000FFFF
+#define	_BCN_AVAL_PG_SHT	0
+
+//RX0PKTNUM
+#define	_RXFF0_DEC_POLL				BIT(15)
+#define	_RXFF0_PKT_DEC_NUM_MSK		0x3F00
+#define	_RXFF0_PKT_DEC_NUM_SHT		8
+#define	_RXFF0_PKTNUM_RPT_MSK		0x00FF
+#define	_RXFF0_PKTNUM_RPT_SHT		0
+
+//RX1PKTNUM
+#define	_RXFF1_DEC_POLL				BIT(15)
+#define	_RXFF1_PKT_DEC_NUM_MSK		0x3F00
+#define	_RXFF1_PKT_DEC_NUM_SHT		8
+#define	_RXFF1_PKTNUM_RPT_MSK		0x00FF
+#define	_RXFF1_PKTNUM_RPT_SHT		0
+
+//RXFLTMAP0
+#define	_MGTFLT13EN		BIT(13)
+#define	_MGTFLT12EN		BIT(12)
+#define	_MGTFLT11EN		BIT(11)
+#define	_MGTFLT10EN		BIT(10)
+#define	_MGTFLT9EN		BIT(9)
+#define	_MGTFLT8EN		BIT(8)
+#define	_MGTFLT5EN		BIT(5)
+#define	_MGTFLT4EN		BIT(4)
+#define	_MGTFLT3EN		BIT(3)
+#define	_MGTFLT2EN		BIT(2)
+#define	_MGTFLT1EN		BIT(1)
+#define	_MGTFLT0EN		BIT(0)
+
+//RXFLTMAP1
+#define	_CTRLFLT15EN	BIT(15)
+#define	_CTRLFLT14EN	BIT(14)
+#define	_CTRLFLT13EN	BIT(13)
+#define	_CTRLFLT12EN	BIT(12)
+#define	_CTRLFLT11EN	BIT(11)
+#define	_CTRLFLT10EN	BIT(10)
+#define	_CTRLFLT9EN		BIT(9)
+#define	_CTRLFLT8EN		BIT(8)
+#define	_CTRLFLT7EN		BIT(7)
+#define	_CTRLFLT6EN		BIT(6)
+
+//RXFLTMAP2
+#define	_DATAFLT15EN	BIT(15)
+#define	_DATAFLT14EN	BIT(14)
+#define	_DATAFLT13EN	BIT(13)
+#define	_DATAFLT12EN	BIT(12)
+#define	_DATAFLT11EN	BIT(11)
+#define	_DATAFLT10EN	BIT(10)
+#define	_DATAFLT9EN		BIT(9)
+#define	_DATAFLT8EN		BIT(8)
+#define	_DATAFLT7EN		BIT(7)
+#define	_DATAFLT6EN		BIT(6)
+#define	_DATAFLT5EN		BIT(5)
+#define	_DATAFLT4EN		BIT(4)
+#define	_DATAFLT3EN		BIT(3)
+#define	_DATAFLT2EN		BIT(2)
+#define	_DATAFLT1EN		BIT(1)
+#define	_DATAFLT0EN		BIT(0)
+
+//RXFLTMAP3
+#define	_MESHAFLT1EN		BIT(1)
+#define	_MESHAFLT0EN		BIT(0)
+
+//TXPKT_NUM_CTRL
+#define	_TXPKTNUM_DEC		BIT(8)
+#define	_TXPKTNUM_MSK		0x00FF
+#define	_TXPKTNUM_SHT		0
+
+//TXFF_PG_NUM
+#define	_TXFF_PG_NUM_MSK	0x0FFF
+
+
+#endif	//	__RTL8712_FIFOCTRL_BITDEF_H__
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_regdef.h
new file mode 100755
index 0000000..47c0ac4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_fifoctrl_regdef.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_FIFOCTRL_REGDEF_H__
+#define __RTL8712_FIFOCTRL_REGDEF_H__
+
+#define RQPN				( RTL8712_FIFOCTRL_ + 0x00 )
+#define RXFF_BNDY			( RTL8712_FIFOCTRL_ + 0x0C )
+#define RXRPT_BNDY		( RTL8712_FIFOCTRL_ + 0x10 )
+#define TXPKTBUF_PGBNDY		( RTL8712_FIFOCTRL_ + 0x14 )
+#define PBP					( RTL8712_FIFOCTRL_ + 0x15 )
+#define RX_DRVINFO_SZ		( RTL8712_FIFOCTRL_ + 0x16 )
+#define TXFF_STATUS			( RTL8712_FIFOCTRL_ + 0x17 )
+#define RXFF_STATUS			( RTL8712_FIFOCTRL_ + 0x18 )
+#define TXFF_EMPTY_TH		( RTL8712_FIFOCTRL_ + 0x19 )
+#define SDIO_RX_BLKSZ		( RTL8712_FIFOCTRL_ + 0x1C )
+#define RXDMA_RXCTRL			( RTL8712_FIFOCTRL_ + 0x1D )
+#define RXPKT_NUM			( RTL8712_FIFOCTRL_ + 0x1E )
+#define RXPKT_NUM_C2H			( RTL8712_FIFOCTRL_ + 0x1F )
+#define C2HCMD_UDT_SIZE		( RTL8712_FIFOCTRL_ + 0x20 )
+#define C2HCMD_UDT_ADDR		( RTL8712_FIFOCTRL_ + 0x22 )
+#define FIFOPAGE2			( RTL8712_FIFOCTRL_ + 0x24 )
+#define FIFOPAGE1			( RTL8712_FIFOCTRL_ + 0x28 )
+#define FW_RSVD_PG_CTRL	( RTL8712_FIFOCTRL_ + 0x30 )
+#define TXRPTFF_RDPTR		( RTL8712_FIFOCTRL_ + 0x40 )
+#define TXRPTFF_WTPTR		( RTL8712_FIFOCTRL_ + 0x44 )
+#define C2HFF_RDPTR			( RTL8712_FIFOCTRL_ + 0x48 )
+#define C2HFF_WTPTR			( RTL8712_FIFOCTRL_ + 0x4C )
+#define RXFF0_RDPTR			( RTL8712_FIFOCTRL_ + 0x50 )
+#define RXFF0_WTPTR			( RTL8712_FIFOCTRL_ + 0x54 )
+#define RXFF1_RDPTR			( RTL8712_FIFOCTRL_ + 0x58 )
+#define RXFF1_WTPTR			( RTL8712_FIFOCTRL_ + 0x5C )
+#define RXRPT0FF_RDPTR		( RTL8712_FIFOCTRL_ + 0x60 )
+#define RXRPT0FF_WTPTR		( RTL8712_FIFOCTRL_ + 0x64 )
+#define RXRPT1FF_RDPTR		( RTL8712_FIFOCTRL_ + 0x68 )
+#define RXRPT1FF_WTPTR		( RTL8712_FIFOCTRL_ + 0x6C )
+#define RX0PKTNUM			( RTL8712_FIFOCTRL_ + 0x72 )
+#define RX1PKTNUM			( RTL8712_FIFOCTRL_ + 0x74 )
+#define RXFLTMAP0			( RTL8712_FIFOCTRL_ + 0x76 )
+#define RXFLTMAP1			( RTL8712_FIFOCTRL_ + 0x78 )
+#define RXFLTMAP2			( RTL8712_FIFOCTRL_ + 0x7A )
+#define RXFLTMAP3			( RTL8712_FIFOCTRL_ + 0x7c )
+#define TBDA				( RTL8712_FIFOCTRL_ + 0x84 )
+#define THPDA				( RTL8712_FIFOCTRL_ + 0x88 )
+#define TCDA				( RTL8712_FIFOCTRL_ + 0x8C )
+#define TMDA				( RTL8712_FIFOCTRL_ + 0x90 )
+#define HDA					( RTL8712_FIFOCTRL_ + 0x94 )
+#define TVODA				( RTL8712_FIFOCTRL_ + 0x98 )
+#define TVIDA				( RTL8712_FIFOCTRL_ + 0x9C )
+#define TBEDA				( RTL8712_FIFOCTRL_ + 0xA0 )
+#define TBKDA				( RTL8712_FIFOCTRL_ + 0xA4 )
+#define RCDA				( RTL8712_FIFOCTRL_ + 0xA8 )
+#define RDSA				( RTL8712_FIFOCTRL_ + 0xAC )
+#define TXPKT_NUM_CTRL		( RTL8712_FIFOCTRL_ + 0xB0 )
+#define TXQ_PGADD			( RTL8712_FIFOCTRL_ + 0xB3 )
+#define TXFF_PG_NUM			( RTL8712_FIFOCTRL_ + 0xB4 )
+
+
+
+#endif	// __RTL8712_FIFOCTRL_REGDEF_H__
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h
new file mode 100755
index 0000000..ab72167
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_GP_BITDEF_H__
+#define __RTL8712_GP_BITDEF_H__
+
+//GPIO_CTRL
+#define	_GPIO_MOD_MSK			0xFF000000
+#define	_GPIO_MOD_SHT			24
+#define	_GPIO_IO_SEL_MSK		0x00FF0000
+#define	_GPIO_IO_SEL_SHT		16
+#define	_GPIO_OUT_MSK			0x0000FF00
+#define	_GPIO_OUT_SHT			8
+#define	_GPIO_IN_MSK			0x000000FF
+#define	_GPIO_IN_SHT			0
+
+#endif	//__RTL8712_GP_BITDEF_H__
+
+
+
+//SYS_PINMUX_CFG
+#define	_GPIOSEL_MSK			0x0003
+#define	_GPIOSEL_SHT			0
+
+//LED_CFG
+#define _LED1SV				BIT(7)
+#define _LED1CM_MSK			0x0070
+#define _LED1CM_SHT			4
+#define _LED0SV				BIT(3)
+#define _LED0CM_MSK			0x0007
+#define _LED0CM_SHT			0
+
+//PHY_REG
+#define _HST_RDRDY_SHT			0
+#define _HST_RDRDY_MSK			0xFF
+#define _HST_RDRDY			BIT(_HST_RDRDY_SHT)
+#define _CPU_WTBUSY_SHT			1
+#define _CPU_WTBUSY_MSK			0xFF
+#define _CPU_WTBUSY			BIT(_CPU_WTBUSY_SHT)
+
+//
+
+// 11. General Purpose Registers   (Offset: 0x02E0 - 0x02FF)
+
+//       8192S GPIO Config Setting (offset 0x2F1, 1 byte)
+
+//----------------------------------------------------------------------------
+
+#define            GPIOMUX_EN                 BIT(3) // When this bit is set to "1", GPIO PINs will switch to MAC GPIO Function
+
+#define            GPIOSEL_GPIO                0      // UART or JTAG or pure GPIO
+
+#define            GPIOSEL_PHYDBG           1      // PHYDBG
+
+#define            GPIOSEL_BT                    2      // BT_coex
+
+#define            GPIOSEL_WLANDBG		 3      // WLANDBG
+
+#define            GPIOSEL_GPIO_MASK     ~(BIT(0)|BIT(1))
+
+
+// HW Readio OFF switch (GPIO BIT)
+
+#define            HAL_8192S_HW_GPIO_OFF_BIT    BIT(3)
+
+#define            HAL_8192S_HW_GPIO_OFF_MASK        0xF7
+
+#define            HAL_8192S_HW_GPIO_WPS_BIT   BIT(4)
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h
new file mode 100755
index 0000000..e1e4410
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_GP_REGDEF_H__
+#define __RTL8712_GP_REGDEF_H__
+
+#define PSTIMER			( RTL8712_GP_ + 0x00 )
+#define TIMER1			( RTL8712_GP_ + 0x04 )
+#define TIMER2			( RTL8712_GP_ + 0x08 )
+#define GPIO_CTRL			( RTL8712_GP_ + 0x0C )
+#define GPIO_IO_SEL			( RTL8712_GP_ + 0x0E )
+#define GPIO_INTCTRL			( RTL8712_GP_ + 0x10 )
+#define MAC_PINMUX_CTRL		( RTL8712_GP_ + 0x11 )
+#define LEDCFG			( RTL8712_GP_ + 0x12 )
+#define PHY_REG_RPT		( RTL8712_GP_ + 0x13 )
+#define PHY_REG_DATA		( RTL8712_GP_ + 0x14 )
+
+
+#endif	//__RTL8712_GP_REGDEF_H__
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_bitdef.h
new file mode 100755
index 0000000..1dada60
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_bitdef.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_INTERRUPT_BITDEF_H__
+#define __RTL8712_INTERRUPT_BITDEF_H__
+
+//HIMR
+//HISR
+#define	_CPUERR					BIT(29)
+#define	_ATIMEND				BIT(28)
+#define	_TXBCNOK				BIT(27)
+#define	_TXBCNERR				BIT(26)
+#define	_BCNDMAINT4				BIT(25)
+#define	_BCNDMAINT3				BIT(24)
+#define	_BCNDMAINT2				BIT(23)
+#define	_BCNDMAINT1				BIT(22)
+#define	_BCNDOK4				BIT(21)
+#define	_BCNDOK3				BIT(20)
+#define	_BCNDOK2				BIT(19)
+#define	_BCNDOK1				BIT(18)
+#define	_TIMEOUT2				BIT(17)
+#define	_TIMEOUT1				BIT(16)
+#define	_TXFOVW					BIT(15)
+#define	_PSTIMEOUT				BIT(14)
+#define	_BCNDMAINT0				BIT(13)
+#define	_FOVW					BIT(12)
+#define	_RDU					BIT(11)
+#define	_RXCMDOK				BIT(10)
+#define	_BCNDOK0				BIT(9)
+#define	_HIGHDOK				BIT(8)
+#define	_COMDOK					BIT(7)
+#define	_MGTDOK					BIT(6)
+#define	_HCCADOK				BIT(5)
+#define	_BKDOK					BIT(4)
+#define	_BEDOK					BIT(3)
+#define	_VIDOK					BIT(2)
+#define	_VODOK					BIT(1)
+#define	_RXOK					BIT(0)
+
+
+#endif	//__RTL8712_INTERRUPT_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_regdef.h
new file mode 100755
index 0000000..05a40f2
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_interrupt_regdef.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_INTERRUPT_REGDEF_H__
+#define __RTL8712_INTERRUPT_REGDEF_H__
+
+#define CPUIMR				( RTL8712_INTERRUPT_ + 0x00)
+#define CPUISR				( RTL8712_INTERRUPT_ + 0x04)
+#define HIMR				( RTL8712_INTERRUPT_ + 0x08)
+#define HISR				( RTL8712_INTERRUPT_ + 0x0C)
+
+#endif //__RTL8712_INTERRUPT_REGDEF_H__
+
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_bitdef.h
new file mode 100755
index 0000000..4612873
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_bitdef.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+
+
+#ifndef __RTL8712_MACSETTING_BITDEF_H__
+#define __RTL8712_MACSETTING_BITDEF_H__
+
+
+//MACID
+//BSSID
+
+//HWVID
+#define	_HWVID_MSK				0x0F
+
+//MAR
+//MBIDCANCONTENT
+
+//MBIDCANCFG
+#define	_POOLING				BIT(31)
+#define	_WRITE_EN				BIT(16)
+#define	_CAM_ADDR_MSK			0x001F
+#define	_CAM_ADDR_SHT			0
+
+//BUILDTIME
+#define _BUILDTIME_MSK			0x3FFFFFFF
+
+//BUILDUSER
+
+
+
+#endif // __RTL8712_MACSETTING_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_regdef.h
new file mode 100755
index 0000000..5177bf6
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_macsetting_regdef.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#ifndef __RTL8712_MACSETTING_REGDEF_H__
+#define __RTL8712_MACSETTING_REGDEF_H__
+
+
+
+#define MACID				(RTL8712_MACIDSETTING_ + 0x0000)
+#define BSSIDR				(RTL8712_MACIDSETTING_ + 0x0008)
+#define HWVID				(RTL8712_MACIDSETTING_ + 0x000E)
+#define MAR					(RTL8712_MACIDSETTING_ + 0x0010)
+#define MBIDCANCONTENT		(RTL8712_MACIDSETTING_ + 0x0018)
+#define MBIDCANCFG			(RTL8712_MACIDSETTING_ + 0x0020)
+#define BUILDTIME			(RTL8712_MACIDSETTING_ + 0x0024)
+#define BUILDUSER			(RTL8712_MACIDSETTING_ + 0x0028)
+
+
+
+#endif //__RTL8712_MACSETTING_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_bitdef.h
new file mode 100755
index 0000000..f185ed5
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_bitdef.h
@@ -0,0 +1,26 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_OFFLOAD_BITDEF_H__
+#define __RTL8712_OFFLOAD_BITDEF_H__
+
+
+
+#endif // __RTL8712_DEBUGCTRL_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_regdef.h
new file mode 100755
index 0000000..947133d
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_offload_regdef.h
@@ -0,0 +1,29 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_OFFLOAD_REGDEF_H__
+#define __RTL8712_OFFLOAD_REGDEF_H__
+
+#define TXPOLL				( RTL8712_OFFLOAD_ + 0x00)
+#define TPPOLL				( RTL8712_OFFLOAD_ + 0x04)
+
+
+
+#endif // __RTL8712_OFFLOAD_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_bitdef.h
new file mode 100755
index 0000000..21ccbb0
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_bitdef.h
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+#ifndef __RTL8712_POWERSAVE_BITDEF_H__
+#define __RTL8712_POWERSAVE_BITDEF_H__
+
+//WOWCTRL
+#define	_UWF			BIT(3)
+#define	_MAGIC			BIT(2)
+#define	_WOW_EN			BIT(1)
+#define	_PMEN			BIT(0)
+
+//PSSTATUS
+#define	_PSSTATUS_SEL_MSK		0x0F
+
+//PSSWITCH
+#define	_PSSWITCH_ACT			BIT(7)
+#define	_PSSWITCH_SEL_MSK		0x0F
+#define	_PSSWITCH_SEL_SHT		0
+
+//LPNAV_CTRL
+#define	_LPNAV_EN				BIT(31)
+#define	_LPNAV_EARLY_MSK		0x7FFF0000
+#define	_LPNAV_EARLY_SHT		16
+#define	_LPNAV_TH_MSK			0x0000FFFF
+#define	_LPNAV_TH_SHT			0
+
+//RPWM
+//CPWM
+#define	_TOGGLING				BIT(7)
+#define	_WWLAN					BIT(3)
+#define	_RPS_ST					BIT(2)
+#define	_WLAN_TRX				BIT(1)
+#define	_SYS_CLK				BIT(0)
+
+#endif // __RTL8712_POWERSAVE_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_regdef.h
new file mode 100755
index 0000000..ab13ec8
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_powersave_regdef.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+#ifndef __RTL8712_POWERSAVE_REGDEF_H__
+#define __RTL8712_POWERSAVE_REGDEF_H__
+
+#define WOWCTRL				( RTL8712_POWERSAVE_ + 0x00 )
+#define PSSTATUS			( RTL8712_POWERSAVE_ + 0x01 )
+#define PSSWITCH			( RTL8712_POWERSAVE_ + 0x02 )
+#define MIMOPS_WAITPERIOD	( RTL8712_POWERSAVE_ + 0x03 )
+#define LPNAV_CTRL			( RTL8712_POWERSAVE_ + 0x04 )
+#define WFM0				( RTL8712_POWERSAVE_ + 0x10 )
+#define WFM1				( RTL8712_POWERSAVE_ + 0x20 )
+#define WFM2				( RTL8712_POWERSAVE_ + 0x30 )
+#define WFM3				( RTL8712_POWERSAVE_ + 0x40 )
+#define WFM4				( RTL8712_POWERSAVE_ + 0x50 )
+#define WFM5				( RTL8712_POWERSAVE_ + 0x60 )
+#define WFCRC				( RTL8712_POWERSAVE_ + 0x70 )
+#define RPWM				( RTL8712_POWERSAVE_ + 0x7C )
+#define CPWM				( RTL8712_POWERSAVE_ + 0x7D )
+
+#endif // __RTL8712_POWERSAVE_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_bitdef.h
new file mode 100755
index 0000000..eced629
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_bitdef.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_RATECTRL_BITDEF_H__
+#define __RTL8712_RATECTRL_BITDEF_H__
+
+//INIRTSMCS_SEL
+#define	_INIRTSMCS_SEL_MSK		0x3F
+
+// RRSR
+#define	_RRSR_SHORT			BIT(23)
+#define	_RRSR_RSC_MSK		0x600000
+#define	_RRSR_RSC_SHT		21
+#define	_RRSR_BITMAP_MSK	0x0FFFFF
+#define	_RRSR_BITMAP_SHT	0
+
+// AGGLEN_LMT_H
+#define	_AGGLMT_MCS32_MSK			0xF0
+#define	_AGGLMT_MCS32_SHT			4
+#define	_AGGLMT_MCS15_SGI_MSK		0x0F
+#define	_AGGLMT_MCS15_SGI_SHT		0
+
+// DARFRC
+// RARFRC
+// MCS_TXAGC
+// CCK_TXAGC
+#define	_CCK_MSK			0xFF00
+#define	_CCK_SHT			8
+#define	_BARKER_MSK			0x00FF
+#define	_BARKER_SHT			0
+
+#endif	//	__RTL8712_RATECTRL_BITDEF_H__
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_regdef.h
new file mode 100755
index 0000000..d58ad2f
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_ratectrl_regdef.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_RATECTRL_REGDEF_H__
+#define __RTL8712_RATECTRL_REGDEF_H__
+
+#define INIMCS_SEL			( RTL8712_RATECTRL_ + 0x00 )
+#define INIRTSMCS_SEL		( RTL8712_RATECTRL_ + 0x20 )
+#define RRSR				( RTL8712_RATECTRL_ + 0x21 )
+#define ARFR0				( RTL8712_RATECTRL_ + 0x24 )
+#define ARFR1				( RTL8712_RATECTRL_ + 0x28 )
+#define ARFR2				( RTL8712_RATECTRL_ + 0x2C )
+#define ARFR3				( RTL8712_RATECTRL_ + 0x30 )
+#define ARFR4				( RTL8712_RATECTRL_ + 0x34 )
+#define ARFR5				( RTL8712_RATECTRL_ + 0x38 )
+#define ARFR6				( RTL8712_RATECTRL_ + 0x3C )
+#define ARFR7				( RTL8712_RATECTRL_ + 0x40 )
+#define AGGLEN_LMT_H		( RTL8712_RATECTRL_ + 0x47 )
+#define AGGLEN_LMT_L		( RTL8712_RATECTRL_ + 0x48 )
+#define DARFRC				( RTL8712_RATECTRL_ + 0x50 )
+#define RARFRC				( RTL8712_RATECTRL_ + 0x58 )
+#define MCS_TXAGC0			( RTL8712_RATECTRL_ + 0x60 )
+#define MCS_TXAGC1			( RTL8712_RATECTRL_ + 0x61 )
+#define MCS_TXAGC2			( RTL8712_RATECTRL_ + 0x62 )
+#define MCS_TXAGC3			( RTL8712_RATECTRL_ + 0x63 )
+#define MCS_TXAGC4			( RTL8712_RATECTRL_ + 0x64 )
+#define MCS_TXAGC5			( RTL8712_RATECTRL_ + 0x65 )
+#define MCS_TXAGC6			( RTL8712_RATECTRL_ + 0x66 )
+#define MCS_TXAGC7			( RTL8712_RATECTRL_ + 0x67 )
+#define CCK_TXAGC			( RTL8712_RATECTRL_ + 0x68 )
+
+
+#endif	//	__RTL8712_RATECTRL_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_bitdef.h
new file mode 100755
index 0000000..c5ccc3d
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_bitdef.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_SECURITY_BITDEF_H__
+#define __RTL8712_SECURITY_BITDEF_H__
+
+//CAMCMD
+#define	_SECCAM_POLLING				BIT(31)
+#define	_SECCAM_CLR					BIT(30)
+#define	_SECCAM_WE					BIT(16)
+#define	_SECCAM_ADR_MSK				0x000000FF
+#define	_SECCAM_ADR_SHT				0
+
+//CAMDBG
+#define	_SECCAM_INFO				BIT(31)
+#define	_SEC_KEYFOUND				BIT(30)
+#define	_SEC_CONFIG_MSK				0x3F000000
+#define	_SEC_CONFIG_SHT				24
+#define	_SEC_KEYCONTENT_MSK			0x00FFFFFF
+#define	_SEC_KEYCONTENT_SHT			0
+
+//SECCFG
+#define	_NOSKMC						BIT(5)
+#define	_SKBYA2						BIT(4)
+#define	_RXDEC						BIT(3)
+#define	_TXENC						BIT(2)
+#define	_RXUSEDK					BIT(1)
+#define	_TXUSEDK					BIT(0)
+
+
+#endif	//__RTL8712_SECURITY_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_regdef.h
new file mode 100755
index 0000000..269da8f
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_security_regdef.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_SECURITY_REGDEF_H__
+#define __RTL8712_SECURITY_REGDEF_H__
+
+#define	CAMCMD			( RTL8712_SECURITY_ + 0x00 )
+#define	CAMWRITE		( RTL8712_SECURITY_ + 0x04 )
+#define	CAMREAD		( RTL8712_SECURITY_ + 0x08 )
+#define	CAMDBG			( RTL8712_SECURITY_ + 0x0C )
+#define	SECCFG			( RTL8712_SECURITY_ + 0x10 )
+
+#endif	//__RTL8712_SECURITY_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h
new file mode 100755
index 0000000..770d4e5
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h
@@ -0,0 +1,163 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_SYSCFG_BITDEF_H__
+#define __RTL8712_SYSCFG_BITDEF_H__
+
+
+//SYS_PWR_CTRL
+//SRCTRL0
+//SRCTRL1
+//SYS_CLKR
+
+//SYS_IOS_CTRL
+#define iso_LDR2RP_SHT				8 // EE Loader to Retention Path
+#define iso_LDR2RP				BIT(iso_LDR2RP_SHT) // 1:isolation, 0:attach
+
+//SYS_CTRL
+#define FEN_DIO_SDIO_SHT			0
+#define FEN_DIO_SDIO				BIT(FEN_DIO_SDIO_SHT)
+#define FEN_SDIO_SHT				1
+#define FEN_SDIO				BIT(FEN_SDIO_SHT)
+#define FEN_USBA_SHT				2
+#define FEN_USBA				BIT(FEN_USBA_SHT)
+#define FEN_UPLL_SHT				3
+#define FEN_UPLL				BIT(FEN_UPLL_SHT)
+#define FEN_USBD_SHT				4
+#define FEN_USBD				BIT(FEN_USBD_SHT)
+#define FEN_DIO_PCIE_SHT			5
+#define FEN_DIO_PCIE				BIT(FEN_DIO_PCIE_SHT)
+#define FEN_PCIEA_SHT				6
+#define FEN_PCIEA				BIT(FEN_PCIEA_SHT)
+#define FEN_PPLL_SHT				7
+#define FEN_PPLL				BIT(FEN_PPLL_SHT)
+#define FEN_PCIED_SHT				8
+#define FEN_PCIED				BIT(FEN_PCIED_SHT)
+//#define FEN_AUTOLOAD_DONE_SHT			9
+//#define FEN_AUTOLOAD_DONE			BIT(FEN_AUTOLOAD_DONE_SHT)
+//#define PSW_RM_SHT				10
+//#define PSW_RM				BIT(PSW_RM_SHT)
+#define FEN_CPUEN_SHT				10
+#define FEN_CPUEN				BIT(FEN_CPUEN_SHT)
+#define FEN_DCORE_SHT				11
+#define FEN_DCORE				BIT(FEN_DCORE_SHT)
+#define FEN_ELDR_SHT				12
+#define FEN_ELDR				BIT(FEN_ELDR_SHT)
+#define PWC_DV2LDR_SHT				13
+#define PWC_DV2LDR				BIT(PWC_DV2LDR_SHT) // Loader Power Enable
+//#define FEN_WOW_SHT				14
+//#define FEN_WOW				BIT(FEN_WOW_SHT)
+//#define FEN_DPSM_SHT				15
+//#define FEN_DPSM				BIT(FEN_DPSM_SHT)
+
+//=== SYS_CLKR ===
+#define SYS_CLKSEL_SHT		0
+#define SYS_CLKSEL		BIT(SYS_CLKSEL_SHT) // System Clock 80MHz
+#define PS_CLKSEL_SHT		1
+#define PS_CLKSEL		BIT(PS_CLKSEL_SHT) //System power save clock select.
+#define CPU_CLKSEL_SHT		2
+#define CPU_CLKSEL		BIT(CPU_CLKSEL_SHT) // System Clock select, 1: AFE source, 0: System clock(L-Bus)
+#define INT32K_EN_SHT		3
+#define INT32K_EN		BIT(INT32K_EN_SHT)
+#define MACSLP_SHT		4
+#define MACSLP			BIT(MACSLP_SHT)
+#define MAC_CLK_EN_SHT		11
+#define MAC_CLK_EN		BIT(MAC_CLK_EN_SHT) // MAC Clock Enable.
+#define SYS_CLK_EN_SHT		12
+#define SYS_CLK_EN		BIT(SYS_CLK_EN_SHT)
+#define RING_CLK_EN_SHT		13
+#define RING_CLK_EN		BIT(RING_CLK_EN_SHT)
+#define SWHW_SEL_SHT		14		
+#define SWHW_SEL		BIT(SWHW_SEL_SHT) // Load done, control path seitch.
+#define FWHW_SEL_SHT		15
+#define FWHW_SEL		BIT(FWHW_SEL_SHT) // Sleep exit, control path swith. 
+
+//9346CR
+#define	_VPDIDX_MSK			0xFF00
+#define	_VPDIDX_SHT			8
+#define	_EEM_MSK			0x00C0
+#define	_EEM_SHT			6
+#define	_EEM0				BIT(6)
+#define	_EEM1				BIT(7)
+#define	_EEPROM_EN			BIT(5)
+#define	_9356SEL			BIT(4)
+#define	_EECS				BIT(3)
+#define	_EESK				BIT(2)
+#define	_EEDI				BIT(1)
+#define	_EEDO				BIT(0)
+
+//AFE_MISC
+#define	AFE_MISC_USB_MBEN_SHT		7
+#define	AFE_MISC_USB_MBEN		BIT(AFE_MISC_USB_MBEN_SHT)
+#define	AFE_MISC_USB_BGEN_SHT		6
+#define	AFE_MISC_USB_BGEN		BIT(AFE_MISC_USB_BGEN_SHT)
+#define	AFE_MISC_LD12_VDAJ_SHT		4
+#define	AFE_MISC_LD12_VDAJ_MSK		0X0030
+#define	AFE_MISC_LD12_VDAJ		BIT(AFE_MISC_LD12_VDAJ_SHT)
+#define	AFE_MISC_I32_EN_SHT		3
+#define	AFE_MISC_I32_EN			BIT(AFE_MISC_I32_EN_SHT)
+#define	AFE_MISC_E32_EN_SHT		2
+#define	AFE_MISC_E32_EN			BIT(AFE_MISC_E32_EN_SHT)
+#define	AFE_MISC_MBEN_SHT		1 
+#define	AFE_MISC_MBEN			BIT(AFE_MISC_MBEN_SHT)// Enable AFE Macro Block's Mbias.
+#define	AFE_MISC_BGEN_SHT		0 
+#define	AFE_MISC_BGEN			BIT(AFE_MISC_BGEN_SHT)// Enable AFE Macro Block's Bandgap.
+
+
+//----------------------------------------------------------------------------
+//       SPS1_CTRL bits					(Offset 0x18-1E, 56bits)
+//----------------------------------------------------------------------------
+#define	SPS1_SWEN			BIT(1)	// Enable vsps18 SW Macro Block.
+#define	SPS1_LDEN			BIT(0)	// Enable VSPS12 LDO Macro block. 
+
+
+//----------------------------------------------------------------------------
+//       LDOA15_CTRL bits				(Offset 0x20, 8bits)
+//----------------------------------------------------------------------------
+#define	LDA15_EN			BIT(0)	// Enable LDOA15 Macro Block
+
+
+//----------------------------------------------------------------------------
+//       8192S LDOV12D_CTRL bits			(Offset 0x21, 8bits)
+//----------------------------------------------------------------------------
+#define	LDV12_EN			BIT(0)	// Enable LDOVD12 Macro Block
+#define	LDV12_SDBY			BIT(1)	// LDOVD12 standby mode
+
+//CLK_PS_CTRL
+#define	_CLK_GATE_EN		BIT(0)
+
+
+// EFUSE_CTRL
+#define EF_FLAG			BIT(31)		// Access Flag, Write:1; Read:0
+#define EF_PGPD			0x70000000	// E-fuse Program time
+#define EF_RDT			0x0F000000	// E-fuse read time: in the unit of cycle time
+#define EF_PDN_EN		BIT(19)		// EFuse Power down enable
+#define ALD_EN			BIT(18)		// Autoload Enable
+#define EF_ADDR			0x0003FF00	// Access Address
+#define EF_DATA			0x000000FF	// Access Data
+
+// EFUSE_TEST
+#define LDOE25_EN		BIT(31)		// Enable LDOE25 Macro Block
+
+// EFUSE_CLK_CTRL
+#define EFUSE_CLK_EN		BIT(1)		// E-Fuse Clock Enable
+#define EFUSE_CLK_SEL		BIT(0)		// E-Fuse Clock Select, 0:500K, 1:40M
+
+#endif	//__RTL8712_SYSCFG_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h
new file mode 100755
index 0000000..6021b14
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_SYSCFG_REGDEF_H__
+#define __RTL8712_SYSCFG_REGDEF_H__
+
+
+#define SYS_ISO_CTRL		(RTL8712_SYSCFG_ + 0x0000)
+#define SYS_FUNC_EN		(RTL8712_SYSCFG_ + 0x0002)
+#define PMC_FSM			(RTL8712_SYSCFG_ + 0x0004)
+#define SYS_CLKR		(RTL8712_SYSCFG_ + 0x0008)
+#define EE_9346CR		(RTL8712_SYSCFG_ + 0x000A)
+#define EE_VPD			(RTL8712_SYSCFG_ + 0x000C)
+#define AFE_MISC		(RTL8712_SYSCFG_ + 0x0010)
+#define SPS0_CTRL		(RTL8712_SYSCFG_ + 0x0011)
+#define SPS1_CTRL		(RTL8712_SYSCFG_ + 0x0018)
+#define RF_CTRL			(RTL8712_SYSCFG_ + 0x001F)
+#define LDOA15_CTRL		(RTL8712_SYSCFG_ + 0x0020)
+#define LDOV12D_CTRL		(RTL8712_SYSCFG_ + 0x0021)
+#define LDOHCI12_CTRL		(RTL8712_SYSCFG_ + 0x0022)
+#define LDO_USB_CTRL		(RTL8712_SYSCFG_ + 0x0023)
+#define LPLDO_CTRL		(RTL8712_SYSCFG_ + 0x0024)
+#define AFE_XTAL_CTRL		(RTL8712_SYSCFG_ + 0x0026)
+#define AFE_PLL_CTRL		(RTL8712_SYSCFG_ + 0x0028)
+#define EFUSE_CTRL		(RTL8712_SYSCFG_ + 0x0030)
+#define EFUSE_TEST		(RTL8712_SYSCFG_ + 0x0034)
+#define PWR_DATA		(RTL8712_SYSCFG_ + 0x0038)
+#define DPS_TIMER		(RTL8712_SYSCFG_ + 0x003C)
+#define RCLK_MON		(RTL8712_SYSCFG_ + 0x003E)
+#define EFUSE_CLK_CTRL		(RTL8712_SYSCFG_ + 0x02F8)
+
+
+#endif //__RTL8712_SYSCFG_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_bitdef.h
new file mode 100755
index 0000000..769ab21
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_bitdef.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+#ifndef __RTL8712_TIMECTRL_BITDEF_H__
+#define __RTL8712_TIMECTRL_BITDEF_H__
+
+//TSFTR
+//SLOT
+//USTIME
+
+//TUBASE
+#define	_TUBASE_MSK			0x07FF
+
+//SIFS_CCK
+#define	_SIFS_CCK_TRX_MSK		0xFF00
+#define	_SIFS_CCK_TRX_SHT		0x8
+#define	_SIFS_CCK_CTX_MSK		0x00FF
+#define	_SIFS_CCK_CTX_SHT		0
+
+//SIFS_OFDM
+#define	_SIFS_OFDM_TRX_MSK		0xFF00
+#define	_SIFS_OFDM_TRX_SHT		0x8
+#define	_SIFS_OFDM_CTX_MSK		0x00FF
+#define	_SIFS_OFDM_CTX_SHT		0
+
+//PIFS
+//ACKTO
+//EIFS
+//BCNITV
+//ATIMWND
+
+//DRVERLYINT
+#define	_ENSWBCN				BIT(15)
+#define	_DRVERLY_TU_MSK			0x0FF0
+#define	_DRVERLY_TU_SHT			4
+#define	_DRVERLY_US_MSK			0x000F
+#define	_DRVERLY_US_SHT			0
+
+//BCNDMATIM
+#define	_BCNDMATIM_MSK			0x03FF
+
+//BCNERRTH
+//MLT
+
+
+#endif // __RTL8712_TIMECTRL_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_regdef.h
new file mode 100755
index 0000000..a6c091d
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_timectrl_regdef.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 	
+#ifndef __RTL8712_TIMECTRL_REGDEF_H__
+#define __RTL8712_TIMECTRL_REGDEF_H__
+
+#define TSFTR			( RTL8712_TIMECTRL_ + 0x00 )
+#define USTIME			( RTL8712_TIMECTRL_ + 0x08 )
+#define SLOT			( RTL8712_TIMECTRL_ + 0x09 )
+#define TUBASE			( RTL8712_TIMECTRL_ + 0x0A )
+#define SIFS_CCK		( RTL8712_TIMECTRL_ + 0x0C )
+#define SIFS_OFDM		( RTL8712_TIMECTRL_ + 0x0E )
+#define PIFS			( RTL8712_TIMECTRL_ + 0x10 )
+#define ACKTO			( RTL8712_TIMECTRL_ + 0x11 )
+#define EIFS			( RTL8712_TIMECTRL_ + 0x12 )
+#define BCNITV			( RTL8712_TIMECTRL_ + 0x14 )
+#define ATIMWND			( RTL8712_TIMECTRL_ + 0x16 )
+#define DRVERLYINT		( RTL8712_TIMECTRL_ + 0x18 )
+#define BCNDMATIM		( RTL8712_TIMECTRL_ + 0x1A )
+#define BCNERRTH		( RTL8712_TIMECTRL_ + 0x1C )
+#define MLT				( RTL8712_TIMECTRL_ + 0x1D )
+
+
+#endif // __RTL8712_TIMECTRL_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h
new file mode 100755
index 0000000..7f2e8a4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_WMAC_BITDEF_H__
+#define __RTL8712_WMAC_BITDEF_H__
+
+//NAVCTRL
+#define	_NAV_UPPER_EN			BIT(18)
+#define	_NAV_MTO_EN				BIT(17)
+#define	_NAV_UPPER				BIT(16)
+#define	_NAV_MTO_MSK			0xFF00
+#define	_NAV_MTO_SHT			8
+#define	_RTSRST_MSK				0x00FF
+#define	_RTSRST_SHT				0
+
+//BWOPMODE
+#define	_20MHZBW				BIT(2)
+
+//BACAMCMD
+#define	_BACAM_POLL				BIT(31)
+#define	_BACAM_RST				BIT(17)
+#define	_BACAM_RW				BIT(16)
+#define	_BACAM_ADDR_MSK			0x0000007F
+#define	_BACAM_ADDR_SHT			0
+
+//LBDLY
+#define	_LBDLY_MSK				0x1F
+
+//FWDLY
+#define	_FWDLY_MSK				0x0F
+
+//RXERR_RPT
+#define	_RXERR_RPT_SEL_MSK		0xF0000000
+#define	_RXERR_RPT_SEL_SHT		28
+#define	_RPT_CNT_MSK			0x000FFFFF
+#define	_RPT_CNT_SHT			0
+
+
+#endif	//__RTL8712_WMAC_BITDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h
new file mode 100755
index 0000000..f1561d0
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_WMAC_REGDEF_H__
+#define __RTL8712_WMAC_REGDEF_H__
+
+#define NAVCTRL				( RTL8712_WMAC_ + 0x00 )
+#define BWOPMODE			( RTL8712_WMAC_ + 0x03 )
+#define BACAMCMD			( RTL8712_WMAC_ + 0x04 )
+#define BACAMCONTENT		( RTL8712_WMAC_ + 0x08 )
+#define LBDLY				( RTL8712_WMAC_ + 0x10 )
+#define FWDLY				( RTL8712_WMAC_ + 0x11 )
+#define HWPC_RX_CTRL		( RTL8712_WMAC_ + 0x18 )
+#define MQ					( RTL8712_WMAC_ + 0x20 )
+#define MA					( RTL8712_WMAC_ + 0x22 )
+#define MS					( RTL8712_WMAC_ + 0x24 )
+#define CLM_RESULT			( RTL8712_WMAC_ + 0x27 )
+#define NHM_RPI_CNT		( RTL8712_WMAC_ + 0x28 )
+#define RXERR_RPT			( RTL8712_WMAC_ + 0x30 )
+#define NAV_PROT_LEN		( RTL8712_WMAC_ + 0x34 )
+#define CFEND_TH			( RTL8712_WMAC_ + 0x36 )
+#define AMPDU_MIN_SPACE	( RTL8712_WMAC_ + 0x37 )
+#define	TXOP_STALL_CTRL		( RTL8712_WMAC_ + 0x38 )
+
+
+#endif //__RTL8712_WMAC_REGDEF_H__
+
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/vssver.scc b/drivers/net/wireless/8712u/include/rtl8712_spec/ioreg_def/vssver.scc
new file mode 100755
index 0000000000000000000000000000000000000000..a69adfd57d6718783576c82689fecc0ec05dafa2
GIT binary patch
literal 448
zcmXpJVq|zUp=5FS{u%zu^O@w1uxw&Xj#<f*A;JI#nLxT~<%dfCWu;pffg)KzzKnYN
zcmByr+d=$nAm6iR<4G7l2gv^`$<_<w=K}fvvNjvQ_<2D7k(|2`Fn&Iee@!pu1dLw*
z<nQwFtAOzff&3}g*p9;ZML@o`_`(brzZl3@xG;?u#xDW#e|_Bc6UHwE@=fR8yawZ!
z0r~EtWjA2_av=YSnCyKRzXHf-Vi0PB@hgG+u5~h}VEif||J}!bVcDUl<Uszf2J)ry
z%gtc&H9)@Z<tY<j{8}KtVd3LG7{3n4kNK*W1>@HP`R~-kw!-)gK)&qZ#B3P95y(I2
Rq>}>UHv#zx>23WmJ^;TKa~S{t

literal 0
HcmV?d00001

diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h
new file mode 100755
index 0000000..cde2dd4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#include "rtl8712_sdio_regdef.h"
+
+#ifndef __RTL8712_SDIO_BITDEF_H__
+#define __RTL8712_SDIO_BITDEF_H__
+
+#define _TX_CRC_RPT_EN_SHT			0
+#define _TX_CRC_RPT_EN				BIT(_TX_CRC_RPT_EN_SHT)
+#define _TX_CRC_RPT_EN_MSK			0xFE
+#define _CMD_ERR_STOP_INT_EN_SHT	1
+#define _CMD_ERR_STOP_INT_EN		BIT(_CMD_ERR_STOP_INT_EN_SHT)
+#define _CMD_ERR_STOP_INT_EN_MSK	0xFD
+
+#define	_RX0_BLK_NUM	0x0040
+#define	_C2H_BLK_NUM	0x0041
+
+//SDIO_HISR
+#define	_RXDONE_SHT			0
+#define	_RXDONE				BIT(_RXDONE_SHT)
+#define _C2HCMD_SHT			1
+#define	_C2HCMD				BIT(_C2HCMD_SHT)
+#define _BMCQ_AVAL_IND_SHT	2
+#define	_BMCQ_AVAL_IND		BIT(_BMCQ_AVAL_IND_SHT)
+#define _VOQ_AVAL_IND_SHT	3
+#define	_VOQ_AVAL_IND		BIT(_VOQ_AVAL_IND_SHT)
+#define _VIQ_AVAL_IND_SHT	4
+#define	_VIQ_AVAL_IND		BIT(_VIQ_AVAL_IND_SHT)
+#define _BEQ_AVAL_IND_SHT	5
+#define	_BEQ_AVAL_IND		BIT(_BEQ_AVAL_IND_SHT)
+#define _BKQ_AVAL_IND_SHT	6
+#define	_BKQ_AVAL_IND		BIT(_BKQ_AVAL_IND_SHT)
+#define _CPWM_INT_SHT		7
+#define _CPWM_INT			BIT(_CPWM_INT_SHT)
+#define _RXOVF_SHT			8
+#define	_RXOVF				BIT(_RXOVF_SHT)
+#define _TXOVF_SHT			9
+#define	_TXOVF				BIT(_TXOVF_SHT)
+#define _CPUERR_SHT			10
+#define	_CPUERR_			BIT(_CPUERR_SHT)
+
+#endif // __RTL8712_TIMECTRL_BITDEF_H__
+
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h b/drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h
new file mode 100755
index 0000000..ed533ac
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h
@@ -0,0 +1,71 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+
+#ifndef __RTL8712_SDIO_REGDEF_H__
+#define __RTL8712_SDIO_REGDEF_H__
+
+
+#define	RTL8712_SDIO_LOCAL_BASE		0X10100000
+#define	RTL8712_SDIO_LOCAL_MSK		0x10101FFF
+
+#define	SDIO_TX_CTRL			(RTL8712_SDIO_LOCAL_BASE + 0x0000)
+
+#define	SDIO_BKQ_FREEPG			(RTL8712_SDIO_LOCAL_BASE + 0x0008)
+#define	SDIO_BEQ_FREEPG			(RTL8712_SDIO_LOCAL_BASE + 0x0007)
+#define	SDIO_VIQ_FREEPG			(RTL8712_SDIO_LOCAL_BASE + 0x0006)
+#define	SDIO_VOQ_FREEPG			(RTL8712_SDIO_LOCAL_BASE + 0x0005)
+#define	SDIO_HIQ_FREEPG			(RTL8712_SDIO_LOCAL_BASE + 0X0004)
+#define	SDIO_CMDQ_FREEPG		(RTL8712_SDIO_LOCAL_BASE + 0x0003)
+#define	SDIO_MGTQ_FREEPG		(RTL8712_SDIO_LOCAL_BASE + 0x0002)
+#define	SDIO_BCNQ_FREEPG		(RTL8712_SDIO_LOCAL_BASE + 0x0001)
+
+#define   SDIO_FREE_TXPG 		(RTL8712_SDIO_LOCAL_BASE + 0x0001)
+// don't change the following define
+#define BKQ_FREEPG_INX 7
+#define BEQ_FREEPG_INX 6
+#define VIQ_FREEPG_INX 5
+#define VOQ_FREEPG_INX 4
+#define HIQ_FREEPG_INX 3
+#define CMDQ_FREEPG_INX 2
+#define MGTQ_FREEPG_INX 1
+#define BCNQ_FREEPG_INX 0
+
+
+#define	SDIO_HIMR				(RTL8712_SDIO_LOCAL_BASE + 0x0009)
+#define	SDIO_HISR				(RTL8712_SDIO_LOCAL_BASE + 0x0010)
+
+#define	SDIO_RX0_RDYBLK_NUM		(RTL8712_SDIO_LOCAL_BASE + 0x0040)
+#define	SDIO_C2H_RDYBLK_NUM		(RTL8712_SDIO_LOCAL_BASE + 0x0048)
+#define	SDIO_RXDMA_OK_TIMER		(RTL8712_SDIO_LOCAL_BASE + 0x0042)
+
+#define	SDIO_HRPWM				(RTL8712_SDIO_LOCAL_BASE + 0x0080)
+#define	SDIO_HCPWM				(RTL8712_SDIO_LOCAL_BASE + 0x0081)
+
+#define	SDIOERR_RPT				(RTL8712_SDIO_LOCAL_BASE + 0x00C0)
+#define	SDIO_CMD_ERRCNT			(RTL8712_SDIO_LOCAL_BASE + 0x00C1)
+#define	SDIO_DARA_ERRCNT		(RTL8712_SDIO_LOCAL_BASE + 0x00C2)
+#define	SDIO_DATA_CRCERR_CTRL	(RTL8712_SDIO_LOCAL_BASE + 0x00FC)
+
+#define	SDIO_DBG_SEL			(RTL8712_SDIO_LOCAL_BASE + 0x00FF)
+
+
+#endif // __RTL8712_SDIO_REGDEF_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl8712_xmit.h b/drivers/net/wireless/8712u/include/rtl8712_xmit.h
new file mode 100755
index 0000000..23a22f4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl8712_xmit.h
@@ -0,0 +1,312 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL8712_XMIT_H_
+#define _RTL8712_XMIT_H_
+
+#define HWXMIT_ENTRY	4
+
+#define VO_QUEUE_INX	0
+#define VI_QUEUE_INX	1
+#define BE_QUEUE_INX	2
+#define BK_QUEUE_INX	3
+#define TS_QUEUE_INX	4
+#define MGT_QUEUE_INX	5
+#define BMC_QUEUE_INX	6
+#define BCN_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#define TXDESC_SIZE 32
+#define TXDESC_OFFSET TXDESC_SIZE
+
+#define NR_AMSDU_XMITFRAME 8
+#define NR_TXAGG_XMITFRAME 8
+
+#define MAX_AMSDU_XMITBUF_SZ 8704
+#define MAX_TXAGG_XMITBUF_SZ 16384 //16k
+
+
+#define tx_cmd tx_desc
+
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ (0)
+#define OFFSET_SHT (16)
+#define OWN 	BIT(31)
+#define FSG	BIT(27)
+#define LSG	BIT(26)
+#define TYPE_SHT (24)
+#define TYPE_MSK (0x03000000)
+
+//OFFSET 4
+#define PKT_OFFSET_SZ (0)
+#define QSEL_SHT (8)
+#define HWPC BIT(31)
+
+//OFFSET 8
+#define BMC BIT(7)
+#define BK BIT(30)
+#define AGG_EN BIT(29)
+#define RTS_RC_SHT (16)
+
+//OFFSET 12
+#define SEQ_SHT (16)
+
+//OFFSET 16
+#define TXBW BIT(18)
+
+//OFFSET 20
+#define DISFB BIT(15)
+#define RSVD6_MSK (0x00E00000)
+#define RSVD6_SHT (21)
+
+struct tx_desc{
+
+	//DWORD 0
+	unsigned int txdw0;
+
+	unsigned int txdw1;
+
+	unsigned int txdw2;
+
+	unsigned int txdw3;
+
+	unsigned int txdw4;
+
+	unsigned int txdw5;
+
+	unsigned int txdw6;
+
+	unsigned int txdw7;	
+
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];	
+};
+
+
+#if 0
+#define tx_desc tx_cmd
+
+struct tx_cmd {
+
+#ifdef CONFIG_LITTLE_ENDIAN
+	// DWORD 1
+	unsigned int	txpktsize:16;
+	unsigned int	offset:8;
+	unsigned int	frame_type:2;
+	unsigned int	ls:1;
+	unsigned int	fs:1;
+	unsigned int	linip:1;
+	unsigned int	amsdu:1;
+	unsigned int	gf:1;
+	unsigned int	own:1;	
+	// DWORD 2
+	unsigned int	macid:5;			
+	unsigned int	moredata:1;
+	unsigned int	morefrag:1;
+	unsigned int	pifs:1;
+	unsigned int	qsel:5;
+	unsigned int	ack_policy:2;
+	unsigned int	noacm:1;
+	unsigned int	non_qos:1;
+	unsigned int	key_id:2;
+	unsigned int	oui:1;
+	unsigned int	pkt_type:1;
+	unsigned int	en_desc_id:1;
+	unsigned int	sectype:2;
+	unsigned int	wds:1;//padding0
+	unsigned int	htc:1;//padding1
+	unsigned int	pkt_offset:5;//padding_len (hw)	
+	unsigned int	hwpc:1;		
+	// DWORD 3
+	unsigned int	data_retry_lmt:6;
+	unsigned int	rty_lmt_en:1;
+	unsigned int	tsfl:5;
+	unsigned int	rts_rc:6;
+	unsigned int	data_rc:6;
+	unsigned int	rsvd2:5;
+	unsigned int	agg_en:1;
+	unsigned int	bk:1;
+	unsigned int	own_mac:1;
+	// DWORD 4
+	unsigned int	nextheadpage:8;
+	unsigned int	tailpage:8;
+	unsigned int	seq:12;
+	unsigned int	frag:4;	
+	// DWORD 5
+	unsigned int	rtsrate:6;
+	unsigned int	disrtsfb:1;
+	unsigned int	rts_ratefb_lmt:4;
+	unsigned int	cts2self:1;
+	unsigned int	rtsen:1;
+	unsigned int	ra_brsr_id:3;
+	unsigned int	txht:1;
+	unsigned int	txshort:1;//for data
+	unsigned int	txbw:1;
+	unsigned int	txsc:2;
+	unsigned int	stbc:2;
+	unsigned int	rd:1;
+	unsigned int	rtsht:1;
+	unsigned int	rtsshort:1;
+	unsigned int	rtsbw:1;
+	unsigned int	rts_sc:2;
+	unsigned int	rts_stbc:2;
+	unsigned int	userate:1;	
+	// DWORD 6
+	unsigned int	packet_id:9;
+	unsigned int	txrate:6;
+	unsigned int	disfb:1;
+	unsigned int	data_ratefb_lmt:5;
+	unsigned int	txagc:11;	
+	// DWORD 7
+	unsigned int	ip_chksum:16;
+	unsigned int	tcp_chksum:16;
+	// DWORD 8
+	unsigned int	txbuffsize:16;//pcie
+	unsigned int	ip_hdr_offset:8;
+	unsigned int	rsvd3:7;
+	unsigned int	tcp_en:1;
+/*	
+	// DWORD 9
+	unsigned int	tx_buffer_address:32;	//pcie
+	// DWORD 10
+	unsigned int	next_tx_desc_address:32;	//pcie
+*/	
+
+#else
+
+#endif
+
+} ;
+
+
+union txcmd {
+	struct tx_cmd cmd;
+	uint value[8];	
+};
+
+
+
+struct amsdu_xmit_frame {
+	
+	_list	list;
+	struct	pkt_attrib	attrib;
+	_pkt *pkt;
+	
+	int frame_tag;
+	 _adapter *	padapter;
+	
+#ifdef CONFIG_USB_HCI
+	//insert urb, irp, and irpcnt info below...      
+       u8 *mem_addr;      
+       u32 sz[8];	   
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+	
+#ifdef PLATFORM_WINDOWS
+	PIRP		pxmit_irp[8];
+#endif
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+       uint irpcnt;         
+       uint fragcnt;
+		   
+#endif
+
+	uint	mem[(MAX_AMSDU_XMITBUF_SZ>>2)];	
+
+};
+
+struct agg_xmit_frame {
+	
+	_list	list;
+	struct	pkt_attrib	attrib;
+	_pkt *pkt;
+	
+	int frame_tag;
+	_adapter *padapter;
+	
+#ifdef CONFIG_USB_HCI
+	//insert urb, irp, and irpcnt info below...       
+       u8 *mem_addr;      
+       u32 sz[8];	   
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	PIRP		pxmit_irp[8];
+#endif
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+       uint irpcnt;         
+       uint fragcnt;
+	   
+#endif
+
+	uint	mem[(MAX_TXAGG_XMITBUF_SZ>>2)];
+
+};
+
+
+
+struct amsdu_xmit_frame *alloc_amsdu_xmitframe(struct xmit_priv *pxmitpriv);
+int free_amsdu_xmitframe(struct xmit_priv *pxmitpriv, struct amsdu_xmit_frame *pxmitframe);
+struct agg_xmit_frame *alloc_txagg_xmitframe(struct xmit_priv *pxmitpriv);
+int free_txagg_xmitframe(struct xmit_priv *pxmitpriv, struct agg_xmit_frame *pxmitframe);
+#endif
+void update_txdesc(struct xmit_frame *pxmitframe, uint *ptxdesc, int sz);
+void dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe);
+
+int xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+int pframe_coalesce(_adapter *padapter, struct xmit_frame	*pxmitframe, u8 *pframe);
+
+
+struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue);
+struct xmit_frame *dequeue_amsdu_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue);
+struct xmit_frame *dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, sint entry);
+
+void do_queue_select(_adapter *padapter, struct pkt_attrib *pattrib);
+u32 get_ff_hwaddr(struct xmit_frame	*pxmitframe);
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+u8 xmitframe_aggr_1st(struct xmit_buf * pxmitbuf, struct xmit_frame * pxmitframe);
+u8 dump_aggr_xframe(struct xmit_buf * pxmitbuf, struct xmit_frame * pxmitframe);
+#endif //CONFIG_USB_TX_AGGREGATION
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_byteorder.h b/drivers/net/wireless/8712u/include/rtl871x_byteorder.h
new file mode 100755
index 0000000..e8e4ef3
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_byteorder.h
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_BYTEORDER_H_
+#define _RTL871X_BYTEORDER_H_
+
+#include <drv_conf.h>
+
+#if defined (CONFIG_LITTLE_ENDIAN) && defined (CONFIG_BIG_ENDIAN)
+#error "Shall be CONFIG_LITTLE_ENDIAN or CONFIG_BIG_ENDIAN, but not both!\n"
+#endif
+
+#if defined (CONFIG_LITTLE_ENDIAN)
+#ifndef CONFIG_PLATFORM_MSTAR389
+#  include <byteorder/little_endian.h>
+#endif
+#elif defined (CONFIG_BIG_ENDIAN)
+#  include <byteorder/big_endian.h>
+#else
+#  error "Must be LITTLE/BIG Endian Host"
+#endif
+
+#endif /* _RTL871X_BYTEORDER_H_ */
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_cmd.h b/drivers/net/wireless/8712u/include/rtl871x_cmd.h
new file mode 100755
index 0000000..eaebf42
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_cmd.h
@@ -0,0 +1,1148 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_CMD_H_
+#define __RTL871X_CMD_H_
+
+#include <drv_conf.h>
+#include <wlan_bssdef.h>
+#include <rtl871x_rf.h>
+#define C2H_MEM_SZ (16*1024)
+
+#ifndef CONFIG_RTL8711FW
+
+	#include <osdep_service.h>
+	#include <ieee80211.h> // <ieee80211/ieee80211.h>
+
+
+	#define FREE_CMDOBJ_SZ	128
+	
+	#define MAX_CMDSZ	512
+	#define MAX_RSPSZ	512
+	#define MAX_EVTSZ	1024
+
+#ifdef PLATFORM_OS_CE
+	#define CMDBUFF_ALIGN_SZ 4
+#else
+	#define CMDBUFF_ALIGN_SZ 512
+#endif
+
+	struct cmd_obj {
+		u16	cmdcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	cmdsz;
+		u8	*rsp;
+		u32	rspsz;
+		//_sema 	cmd_sem;
+		_list	list;
+	};
+
+	struct cmd_priv {
+		_sema	cmd_queue_sema;
+		//_sema	cmd_done_sema;
+		_sema	terminate_cmdthread_sema;		
+		_queue	cmd_queue;
+		u8	cmd_seq;
+		u8	*cmd_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*cmd_allocated_buf;
+		u8	*rsp_buf;	//shall be non-paged, and 4 bytes aligned		
+		u8	*rsp_allocated_buf;
+		u32	cmd_issued_cnt;
+		u32	cmd_done_cnt;
+		u32	rsp_cnt;
+		_adapter *padapter;
+	};
+
+	struct evt_obj {
+		u16	evtcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	evtsz;		
+		_list	list;
+	};
+
+	struct	evt_priv {
+#ifdef CONFIG_EVENT_THREAD_MODE
+		_sema	evt_notify;
+		_sema	terminate_evtthread_sema;	
+#endif
+		_queue	evt_queue;
+		
+#ifdef CONFIG_H2CLBK
+		_sema	lbkevt_done;
+		u8	lbkevt_limit;
+		u8	lbkevt_num;
+		u8	*cmdevt_parm;		
+#endif		
+		u8	event_seq;
+		u8	*evt_buf;	//shall be non-paged, and 4 bytes aligned		
+		u8	*evt_allocated_buf;
+		u32	evt_done_cnt;
+#ifdef CONFIG_SDIO_HCI
+		u8	*c2h_mem;
+		u8	*allocated_c2h_mem;
+#ifdef PLATFORM_OS_XP
+		PMDL	pc2h_mdl;
+#endif
+#endif
+
+#ifdef PLATFORM_LINUX
+		struct tasklet_struct event_tasklet;
+#endif
+	};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (u8 *)(pparm);\
+	pcmd->cmdsz = sizeof (*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while(0)
+
+extern u32 enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern u32 enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern struct cmd_obj *dequeue_cmd(_queue *queue);
+extern void free_cmd_obj(struct cmd_obj *pcmd);
+
+extern u32 enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj);
+extern struct evt_obj *dequeue_evt(_queue *queue);
+extern void free_evt_obj(struct evt_obj *pcmd);
+
+thread_return cmd_thread(thread_context context);
+
+extern u32 cmd_enqueue(_queue *cmdq,struct cmd_obj	*pcmd);
+
+extern u32 init_cmd_priv (struct cmd_priv *pcmdpriv);
+extern void free_cmd_priv (struct cmd_priv *pcmdpriv);
+
+extern u32 init_evt_priv (struct evt_priv *pevtpriv);
+extern void free_evt_priv (struct evt_priv *pevtpriv);
+extern void cmd_clr_isr(struct cmd_priv *pcmdpriv);
+extern void evt_notify_isr(struct evt_priv *pevtpriv);
+
+#else
+	#include <ieee80211.h>
+#endif	/* CONFIG_RTL8711FW */
+
+
+enum rtl871x_drvint_cid
+{	
+	NONE_WK_CID,
+	WDG_WK_CID,
+	MAX_WK_CID
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To enter USB suspend mode
+
+Command Mode
+
+*/
+struct usb_suspend_parm {
+	u32 action;// 1: sleep, 0:resume
+};
+
+/*
+Caller Mode: Infra, Ad-HoC
+
+Notes: To join a known BSS.
+
+Command-Event Mode
+
+*/
+
+/*
+Caller Mode: Infra, Ad-Hoc
+
+Notes: To join the specified bss
+
+Command Event Mode
+
+*/
+struct joinbss_parm {
+	NDIS_WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To disconnect the current associated BSS
+
+Command Mode
+
+*/
+struct disconnect_parm {
+	u32 rsvd;
+};
+
+/*
+Caller Mode: AP, Ad-HoC(M)
+
+Notes: To create a BSS
+
+Command Mode
+*/
+struct createbss_parm {
+	NDIS_WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To set the NIC mode of RTL8711
+
+Command Mode
+
+The definition of mode:
+
+#define IW_MODE_AUTO	0	// Let the driver decides which AP to join
+#define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
+#define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
+#define IW_MODE_MASTER	3	// Synchronisation master or Access Point
+#define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
+#define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
+#define IW_MODE_MONITOR	6	// Passive monitor (listen only)
+
+*/
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To ask RTL8711 performing site-survey
+
+Command-Event Mode 
+
+*/
+typedef struct _RT_CHANNEL_PLAN
+{
+	u8	Channel[NUM_CHANNELS];
+	u8	Len;
+}RT_CHANNEL_PLAN, *PRT_CHANNEL_PLAN;
+
+typedef struct _SS_DrvCtrl_
+{
+	u8	EnableDrvCtrlForSurveyTO; // 1: Driver Control, 0: Firmware Default
+	u8	rsvd;
+	u16	SurveyTO; //Unit: ms
+
+	u8	EnableDrvCtrlForChnlList; // 1: Driver Control, 0: Firmware Default
+	RT_CHANNEL_PLAN	ChnlList;
+}SS_DrvCtrl, *PSS_DrvCtrl;
+
+#define RTW_SSID_SCAN_AMOUNT 9 // for WEXT_CSCAN_AMOUNT 9
+struct sitesurvey_parm
+{
+	s32	passive_mode; //active: 1, passive: 0
+	s32	bsslimit; // 1 ~ 48
+	s32	ss_ssidlen;
+	u8	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+
+	// Driver Control:
+	// 1.) Survey TimeOut for each Channel (Channel Idle Time = SurveyTO * 2)
+	// 2.) Survey Channel List
+	SS_DrvCtrl	DrvCtrl;
+};
+
+
+/*
+Caller Mode: Any
+
+Notes: To set the auth type of RTL8711. open/shared/802.1x
+
+Command Mode
+
+*/
+struct setauth_parm {
+	u8 mode;  //0: legacy open, 1: legacy shared 2: 802.1x
+	u8 _1x;   //0: PSK, 1: TLS
+	u8 rsvd[2];
+};
+
+/*
+Caller Mode: Infra
+
+a. algorithm: wep40, wep104, tkip & aes
+b. keytype: grp key/unicast key
+c. key contents
+
+when shared key ==> keyid is the camid
+when 802.1x ==> keyid [0:1] ==> grp key
+when 802.1x ==> keyid > 2 ==> unicast key
+
+*/
+struct setkey_parm {
+	u8	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
+	u8	keyid;		
+	u8 	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
+	u8	key[16];	// this could be 40 or 104
+};
+
+/*
+When in AP or Ad-Hoc mode, this is used to 
+allocate an sw/hw entry for a newly associated sta.
+
+Command
+
+when shared key ==> algorithm/keyid 
+
+*/
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+	
+	Command mode
+	
+	This is to force fw to del an sta_data entry per driver's request
+	
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	u8  	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+#ifdef MP_FIRMWARE_OFFLOAD
+	u32	curr_rateidx;
+#else
+	u8	mac_id;
+	u8	datarates[NumRates];
+#endif
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+	
+};
+struct getdatarate_rsp {
+	u8 datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+struct	setphyinfo_parm {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+struct	getphyinfo_parm {
+	u32 rsvd;
+};
+
+struct	getphyinfo_rsp {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+struct	setphy_parm {
+	u8	rfchannel;
+	u8	modem;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_parm {
+	u32 rsvd;
+
+};
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct writePTM_parm {
+	u8	type;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct setrfintfs_parm {
+	u8	rfintfs;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0 
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+	
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+	
+	The rsp layout shall be:
+	rsp: 			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=  	swap32(w1);
+		b0		= 	b1
+		s2		= 	s0 + s1
+		b1		= 	b0
+		w1		=	w0
+		
+	mac[0] == 	2
+	==> CMD_EVENT mode, return 	H2C_SUCCESS
+	The event layout shall be:
+	event:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   swap16(s0) - event.mac[2];
+		s1		=   s1 + event.mac[2];
+		w0		=  	swap32(w0);
+		b0		= 	b1
+		s2		= 	s0 + event.mac[2]
+		b1		= 	b0 
+		w1		=	swap32(w1) - event.mac[2];	
+	
+		parm->mac[3] is the total event counts that host requested.
+		
+	
+	event will be the same with the cmd's param.
+		
+*/
+
+#ifdef CONFIG_H2CLBK
+
+struct seth2clbk_parm {
+	u8 mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16  s2;
+	u8	b1;
+	u32	w1;
+};
+
+struct geth2clbk_parm {
+	u32 rsv;	
+};
+
+struct geth2clbk_rsp {
+	u8	mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16	s2;
+	u8	b1;
+	u32	w1;
+};
+
+#endif	/* CONFIG_H2CLBK */
+
+// CMD param Formart for DRV INTERNAL CMD HDL
+struct drvint_cmd_parm {
+	int i_cid; //internal cmd id
+	int sz; // buf sz
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;		
+	u8	rx_antset;
+	u8	tx_antenna;		
+	u8	rx_antenna;		
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;		// 0: pure hw, 1: fw
+};
+
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+#ifdef CONFIG_PWRCTRL
+struct setpwrmode_parm  {
+	u8	mode;
+	u8	flag_low_traffic_en;
+	u8	flag_lpnav_en;
+	u8	flag_rf_low_snr_en;
+	
+	u8	flag_dps_en; // 1: dps, 0: 32k
+	u8	bcn_rx_en;
+	u8	bcn_pass_cnt;	  // fw report one beacon information to driver  when it receives bcn_pass_cnt  beacons.
+	u8	bcn_to; 	  // beacon TO (ms). =0 no limit.
+	
+	u16	bcn_itv;
+	u8	app_itv; // only for VOIP mode.
+	u8	awake_bcn_itv;
+	
+	u8	smart_ps;
+	u8	bcn_pass_time;	// unit: 100ms
+};
+
+struct setatim_parm {
+	u8 op;   // 0: add, 1:del
+	u8 txid; // id of dest station.
+};
+#endif /*CONFIG_PWRCTRL*/
+
+struct setratable_parm {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+struct getratable_parm {
+                uint rsvd;
+};
+struct getratable_rsp {
+        u8 ss_ForceUp[NumRates];
+        u8 ss_ULevel[NumRates];
+        u8 ss_DLevel[NumRates];
+        u8 count_judge[NumRates];
+};
+
+
+//to get TX,RX retry count
+struct gettxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct gettxretrycnt_rsp{
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct getrxretrycnt_rsp{
+	unsigned long rx_retrycnt;
+};
+
+//to get BCNOK,BCNERR count
+struct getbcnokcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnokcnt_rsp{
+	unsigned long  bcnokcnt;
+};
+
+struct getbcnerrcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp{
+	unsigned long bcnerrcnt;
+};
+
+// to get current TX power level
+struct getcurtxpwrlevel_parm{
+	unsigned int rsvd;
+};
+struct getcurtxpwrlevel_rsp{
+	unsigned short tx_power;
+};
+
+//dynamic on/off DIG
+struct setdig_parm{
+	unsigned char dig_on;		// 1:on , 0:off
+};
+
+//dynamic on/off RA
+struct setra_parm{
+	unsigned char ra_on;		// 1:on , 0:off
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+
+struct addBaReq_parm
+{
+ 	unsigned int tid;
+};
+
+/*H2C Handler index: 46 */
+struct SetChannel_parm
+{
+	u32 curr_ch;	
+};
+
+#ifdef MP_FIRMWARE_OFFLOAD
+/*H2C Handler index: 47 */
+struct SetTxPower_parm
+{
+	u8 TxPower;
+};
+
+/*H2C Handler index: 48 */
+struct SwitchAntenna_parm
+{
+	u16 antenna_tx;
+	u16 antenna_rx;
+//	R_ANTENNA_SELECT_CCK cck_txrx;
+	u8 cck_txrx;
+};
+
+/*H2C Handler index: 49 */
+struct SetCrystalCap_parm
+{
+	u32 curr_crystalcap;
+};
+
+/*H2C Handler index: 50 */
+struct SetSingleCarrierTx_parm
+{
+	u8 bStart;
+};
+
+/*H2C Handler index: 51 */
+struct SetSingleToneTx_parm
+{
+	u8 bStart;
+	u8 curr_rfpath;
+};
+
+/*H2C Handler index: 52 */
+struct SetCarrierSuppressionTx_parm
+{
+	u8 bStart;
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 53 */
+struct SetContinuousTx_parm
+{
+	u8 bStart;
+	u8 CCK_flag; /*1:CCK 2:OFDM*/
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 54 */
+struct SwitchBandwidth_parm
+{
+	u8 curr_bandwidth;
+};
+
+#endif	/* MP_FIRMWARE_OFFLOAD */
+
+
+/*H2C Handler index: 55 */
+struct Tx_Beacon_param
+{
+	NDIS_WLAN_BSSID_EX network;
+};
+
+/*H2C Handler index: 56 */
+struct PT_param
+{
+	u8 PT_En;
+};
+
+/*H2C Handler index: 58 */
+struct SetMacAddr_param
+{
+	u8 MacAddr[ETH_ALEN];
+};
+
+/*H2C Handler index: 59 */
+struct disconnectCtrl_param
+{
+	 u8  enableDrvCtrl;
+	 u8  rsvd1;
+	 u8  rsvd2;
+	 u8  rsvd3;
+	 u32  disconnectTO; // Unit: ms
+};
+
+/*H2C Handler index: 60 */
+//
+// Channel Plan Type.
+// Note: 
+//	We just add new channel plan when the new channel plan is different from any of the following 
+//	channel plan. 
+//	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
+//	customize them in RT_CHANNEL_INFO in the RT_CHANNEL_LIST.
+// 
+typedef enum _RT_CHANNEL_DOMAIN
+{
+	RT_CHANNEL_DOMAIN_FCC = 0,
+	RT_CHANNEL_DOMAIN_IC = 1,
+	RT_CHANNEL_DOMAIN_ETSI = 2,
+	RT_CHANNEL_DOMAIN_SPAIN = 3,
+	RT_CHANNEL_DOMAIN_FRANCE = 4,
+	RT_CHANNEL_DOMAIN_MKK = 5,
+	RT_CHANNEL_DOMAIN_MKK1 = 6,
+	RT_CHANNEL_DOMAIN_ISRAEL = 7,
+	RT_CHANNEL_DOMAIN_TELEC = 8,
+	RT_CHANNEL_DOMAIN_MIC = 9,				// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN = 10,		// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_13 = 11,		// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_TELEC_NETGEAR = 12,		// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_NCC = 13,
+	RT_CHANNEL_DOMAIN_5G = 14,
+	RT_CHANNEL_DOMAIN_5G_40M = 15,
+	//===== Add new channel plan above this line===============//
+	RT_CHANNEL_DOMAIN_MAX,
+}RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
+
+#define rtw_is_channel_plan_valid(chplan) (chplan<RT_CHANNEL_DOMAIN_MAX)
+
+struct SetChannelPlan_param
+{
+	RT_CHANNEL_DOMAIN	ChannelPlan;
+};
+
+#if 0
+/*H2C Handler index: 61 */
+struct DisconnectCtrlEx_param
+{
+	//MAXTIME = (2 * FirstStageTO) + (TryPktCnt * TryPktInterval)
+	u8	EnableDrvCtrl;
+	u8	TryPktCnt;
+	u8	TryPktInterval;	//Unit: ms
+	u8	rsvd;
+	u32	FirstStageTO;	//Unit: ms
+};
+#endif
+
+/*H2C Handler index: 62 */
+typedef struct _bitMask_type
+{
+	u8 bitMask[16];
+	u16 crc_result;
+	u16 rsvd2;
+}bitMask_type;
+
+typedef struct _WWlanCtrl_param
+{
+	u8 fun_en;
+	u8 magicpkt_en;
+	u8 pattern_en;
+	u8 GPIO_ACTIVE;		//0:HIGH ACTIVE 1:LOW ACTIVE
+	u16 GPIO_DURATION;	//DEFAULT
+	u8 bitMask_num;		//max=13
+	u8 rsvd1;
+	bitMask_type data[1];
+}WWlanCtrl_param;
+
+/*H2C Handler index: 63 */
+typedef enum _PS_SCHEME_ORIENTED_
+{
+	PSO_TP			= 0,
+	PSO_BATTERY 	= 1
+}PS_SCHEME_ORIENTED, *PPS_SCHEME_ORIENTED;
+
+typedef struct _PS_CTRL_PARAM {
+	u8	bDrvCtrlEnable;
+	u8	BCNToMaxLimit;	
+	u16	TRX_RFKeepOnTime;	//Unit: ms
+	
+	u8	RxBMCFrameTO;		//Unit: ms
+	u8 	BCNEarlyTime;		//Unit: ms	
+	u8	RxBCNTimeOut;		//Unit: ms
+	u8	SchemeOriented;		//PS_SCHEME_ORIENTED
+}PS_CTRL_PARAM, *PPS_CTRL_PARAM;
+
+typedef	struct	_SetPwr_Param_
+{
+	PS_CTRL_PARAM	PSPram;
+
+}SetPwr_Param, *PSetPwr_Param;
+
+
+/*H2C Handler index: 61 */
+struct DisconnectCtrlEx_param
+{
+	//MAXTIME = (2 * FirstStageTO) + (TryPktCnt * TryPktInterval)
+	unsigned char 	EnableDrvCtrl;
+	unsigned char		TryPktCnt;
+	unsigned char		TryPktInterval;	//Unit: ms
+	unsigned char		rsvd;
+	unsigned int		FirstStageTO;	//Unit: ms
+};
+
+#ifndef CONFIG_RTL8711FW
+#else
+struct cmdobj {
+	uint	parmsize;
+	u8 (*h2cfuns)(u8 *pbuf);	
+};
+extern u8 joinbss_hdl(u8 *pbuf);	
+extern u8 disconnect_hdl(u8 *pbuf);
+extern u8 createbss_hdl(u8 *pbuf);
+extern u8 setopmode_hdl(u8 *pbuf);
+extern u8 sitesurvey_hdl(u8 *pbuf);	
+extern u8 setauth_hdl(u8 *pbuf);
+extern u8 setkey_hdl(u8 *pbuf);
+extern u8 set_stakey_hdl(u8 *pbuf);
+extern u8 set_assocsta_hdl(u8 *pbuf);
+extern u8 del_assocsta_hdl(u8 *pbuf);
+extern u8 setstapwrstate_hdl(u8 *pbuf);
+extern u8 setbasicrate_hdl(u8 *pbuf);	
+extern u8 getbasicrate_hdl(un8 *pbuf);
+extern u8 setdatarate_hdl(u8 *pbuf);
+extern u8 getdatarate_hdl(u8 *pbuf);
+extern u8 setphyinfo_hdl(u8 *pbuf);	
+extern u8 getphyinfo_hdl(u8 *pbuf);
+extern u8 setphy_hdl(u8 *pbuf);
+extern u8 getphy_hdl(u8 *pbuf);
+#ifdef CONFIG_H2CLBK
+extern u8 seth2clbk_hdl(u8 *pbuf);
+extern u8 geth2clbk_hdl(u8 *pbuf);
+#endif	/* CONFIG_H2CLBK */
+#endif  /* CONFIG_RTL8711FW */
+
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+
+/*
+
+Result: 
+0x00: success
+0x01: sucess, and check Response.
+0x02: cmd ignored due to duplicated sequcne number
+0x03: cmd dropped due to invalid cmd code
+0x04: reserved.
+
+*/
+
+#define H2C_RSP_OFFSET			512
+
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+
+extern u8 setMacAddr_cmd(_adapter *padapter, u8 *mac_addr);
+extern u8 setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
+extern u8 setstandby_cmd(_adapter *padapter, uint action);
+extern u8 sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *pssid);
+extern u8 createbss_cmd(_adapter  *padapter);
+extern u8 createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz);
+extern u8 setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
+extern u8 setstakey_cmd(_adapter  *padapter, u8 *psta, u8 unicast_key);
+extern u8 joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork);
+extern u8 disassoc_cmd(_adapter  *padapter);
+extern u8 setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+extern u8 setdatarate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 set_chplan_cmd(_adapter  *padapter, int chplan);
+extern u8 setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 setbbreg_cmd(_adapter * padapter, u8 offset, u8 val);
+extern u8 setrfreg_cmd(_adapter * padapter, u8 offset, u32 val);
+extern u8 getbbreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
+extern u8 getrfreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
+extern u8 setrfintfs_cmd(_adapter  *padapter, u8 mode);
+extern u8 setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
+extern u8 getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);
+
+extern u8 gettssi_cmd(_adapter  *padapter, u8 offset,u8 *pval);
+extern u8 setptm_cmd(_adapter*padapter, u8 type);
+extern u8 setfwdig_cmd(_adapter*padapter, u8 type);
+extern u8 setfwra_cmd(_adapter*padapter, u8 type);
+
+extern u8 addbareq_cmd(_adapter*padapter, u8 tid);
+
+extern u8 wdg_wk_cmd(_adapter*padapter);
+
+extern void survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);	
+extern void createbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
+
+extern void setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void getrttbl_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+
+#ifdef CONFIG_PWRCTRL
+extern u8 setpwrmode_cmd(_adapter* adapter, u32 ps_mode, u32 smart_ps);
+extern u8  setatim_cmd(_adapter* adapter, u8 add, u8 txid);
+#endif	/* CONFIG_PWRCTRL */
+
+extern u8 disconnectCtrlEx_cmd(_adapter* adapter, u32 enableDrvCtrl, u32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO);
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(_adapter  *padapter, struct cmd_obj *cmd);
+};
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_cmd.h"
+#endif
+
+#endif // _CMD_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_debug.h b/drivers/net/wireless/8712u/include/rtl871x_debug.h
new file mode 100755
index 0000000..3528139
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_debug.h
@@ -0,0 +1,262 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_DEBUG_H__
+#define __RTL871X_DEBUG_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#define _drv_emerg_			1
+#define _drv_alert_			2
+#define _drv_crit_			3
+#define _drv_err_			4
+#define	_drv_warning_			5
+#define _drv_notice_			6
+#define _drv_info_			7
+#define _drv_dump_			8
+#define	_drv_debug_			9
+
+
+#define _module_rtl871x_xmit_c_		BIT(0)
+#define _module_xmit_osdep_c_		BIT(1)
+#define _module_rtl871x_recv_c_		BIT(2)
+#define _module_recv_osdep_c_		BIT(3)
+#define _module_rtl871x_mlme_c_		BIT(4)
+#define	_module_mlme_osdep_c_		BIT(5)
+#define _module_rtl871x_sta_mgt_c_	BIT(6)
+#define _module_rtl871x_cmd_c_		BIT(7)
+#define	_module_cmd_osdep_c_		BIT(8)
+#define _module_rtl871x_io_c_		BIT(9)
+#define	_module_io_osdep_c_		BIT(10)
+#define _module_os_intfs_c_		BIT(11)
+#define _module_rtl871x_security_c_	BIT(12)
+#define _module_rtl871x_eeprom_c_	BIT(13)
+#define _module_hal_init_c_		BIT(14)
+#define _module_hci_hal_init_c_		BIT(15)
+#define _module_rtl871x_ioctl_c_	BIT(16)
+#define _module_rtl871x_ioctl_set_c_	BIT(17)
+#define _module_rtl871x_ioctl_query_c_	BIT(18)
+#define _module_rtl871x_pwrctrl_c_	BIT(19)
+#define _module_hci_intfs_c_		BIT(20)
+#define _module_hci_ops_c_		BIT(21)
+#define _module_osdep_service_c_	BIT(22)
+#define _module_rtl871x_mp_ioctl_c_	BIT(23)
+#define _module_hci_ops_os_c_		BIT(24)
+#define _module_rtl871x_ioctl_os_c	BIT(25)
+#define _module_rtl8712_cmd_c_		BIT(26)
+#define _module_rtl871x_mp_c_		BIT(27)
+#define _module_rtl8712_xmit_c_		BIT(28)
+#define _module_rtl8712_efuse_c_	BIT(29)
+#define _module_rtl8712_recv_c_		BIT(30)
+#define _module_rtl8712_led_c_		BIT(31)
+
+#undef _MODULE_DEFINE_
+
+#if defined _RTL871X_XMIT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_xmit_c_
+#elif defined _XMIT_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_xmit_osdep_c_
+#elif defined _RTL871X_RECV_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_recv_c_
+#elif defined _RECV_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_recv_osdep_c_
+#elif defined _RTL871X_MLME_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_mlme_c_
+#elif defined _MLME_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTL871X_STA_MGT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_sta_mgt_c_
+#elif defined _RTL871X_CMD_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_cmd_c_
+#elif defined _CMD_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_cmd_osdep_c_
+#elif defined _RTL871X_IO_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_io_c_
+#elif defined _IO_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_io_osdep_c_
+#elif defined _OS_INTFS_C_
+	#define	_MODULE_DEFINE_	_module_os_intfs_c_
+#elif defined _RTL871X_SECURITY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_security_c_
+#elif defined _RTL871X_EEPROM_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_
+#elif defined _HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hal_init_c_
+#elif defined _HCI_HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
+#elif defined _RTL871X_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_
+#elif defined _RTL871X_IOCTL_SET_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_set_c_
+#elif defined _RTL871X_IOCTL_QUERY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_query_c_
+#elif defined _RTL871X_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_pwrctrl_c_
+#elif defined _HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _HCI_OPS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_c_
+#elif defined _OSDEP_HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _OSDEP_SERVICE_C_
+	#define	_MODULE_DEFINE_	_module_osdep_service_c_
+#elif defined _RTL871X_MP_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_ioctl_c_
+#elif defined _HCI_OPS_OS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_os_c_
+#elif defined _RTL871X_IOCTL_LINUX_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_os_c
+#elif defined _RTL871X_MP_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_c_
+#elif defined _RTL8712_CMD_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_cmd_c_
+#elif defined _RTL8712_XMIT_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_xmit_c_
+#elif  defined _RTL8712_EFUSE_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_efuse_c_
+#elif defined _RTL8712_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#else	
+	#undef	_MODULE_DEFINE_	
+#endif
+
+#ifdef PLATFORM_OS_CE
+extern void rtl871x_cedbg(const char *fmt, ...);
+#endif
+
+#define RT_TRACE(_Comp, _Level, Fmt) do{}while(0)
+#define _func_enter_ {}
+#define _func_exit_ {}
+
+#undef	_dbgdump
+
+#ifdef CONFIG_DEBUG_RTL871X
+
+#ifndef _RTL871X_DEBUG_C_
+extern u32 GlobalDebugLevel;
+extern u64 GlobalDebugComponents;
+#endif
+
+#if defined PLATFORM_WINDOWS
+
+	#ifdef PLATFORM_OS_XP
+
+	#define _dbgdump	DbgPrint
+
+	#elif defined PLATFORM_OS_CE
+
+	#define _dbgdump	rtl871x_cedbg
+
+	#endif
+
+#elif defined PLATFORM_LINUX
+
+	#define _dbgdump	printk
+
+#endif
+
+#endif /* CONFIG_DEBUG_RTL871X */
+
+
+#if defined(_dbgdump) && defined(_MODULE_DEFINE_)
+
+	#undef RT_TRACE
+	#define RT_TRACE(_Comp, _Level, Fmt)\
+	do {\
+		if ((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
+			_dbgdump("%s [0x%08x,%d]", RTL871X_MODULE_NAME, (unsigned int)_Comp, _Level);\
+			_dbgdump Fmt;\
+		}\
+	} while(0)
+
+#endif
+
+#if defined(_dbgdump)
+
+	#undef  _func_enter_
+	#define _func_enter_ \
+	do {\
+		if (GlobalDebugLevel >= _drv_debug_) \
+		{\
+			_dbgdump("\n %s : %s enters at %d\n", RTL871X_MODULE_NAME, __FUNCTION__, __LINE__);\
+		}\
+	} while(0)
+
+	#undef  _func_exit_
+	#define _func_exit_ \
+	do {\
+		if (GlobalDebugLevel >= _drv_debug_) \
+		{\
+			_dbgdump("\n %s : %s exits at %d\n", RTL871X_MODULE_NAME, __FUNCTION__, __LINE__);\
+		}\
+	} while(0)
+
+#endif
+
+// Added by Albert 2010/07/01
+// If the customer doesn't want any debug message, we can remark the following define.
+//#define printk(x, ...) {}
+
+#ifdef CONFIG_DEBUG_RTL8712
+
+	#ifdef PLATFORM_WINDOWS
+
+	#define _dbgdump	DbgPrint
+
+	#define MSG_8712 {}
+
+	#define DBG_8712 {}
+
+	#define WRN_8712 {}
+
+	#define ERR_8712 {}
+	#endif
+
+	#ifdef PLATFORM_LINUX
+
+	#define _dbgdump	printk
+
+	#define MSG_8712(x, ...) {}
+
+	#define DBG_8712(x,...)  {}
+
+	#define WRN_8712(x,...)  {}
+
+	#define ERR_8712(x,...)  {}
+	#endif
+
+	#undef MSG_8712
+	#define MSG_8712 _dbgdump
+
+	#undef DBG_8712
+	#define DBG_8712 _dbgdump
+
+	#undef WRN_8712
+	#define WRN_8712 _dbgdump
+
+	#undef ERR_8712
+	#define ERR_8712 _dbgdump
+
+#endif	//CONFIG_DEBUG_RTL8712
+
+#endif	//__RTL871X_DEBUG_H__
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_eeprom.h b/drivers/net/wireless/8712u/include/rtl871x_eeprom.h
new file mode 100755
index 0000000..df48f95
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_eeprom.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_EEPROM_H__
+#define __RTL871X_EEPROM_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#define	RTL8712_EEPROM_ID			0x8712
+#define	EEPROM_MAX_SIZE			256
+#define	CLOCK_RATE					50			//100us		
+
+//- EEPROM opcodes
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      // Erase/write enable
+#define EEPROM_EWDS_OPCODE		16      // Erase/write disable
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later	
+#define JAPAN						0x2 //temp, should be provided later
+
+#ifdef CONFIG_SDIO_HCI
+#define eeprom_cis0_sz	17
+#define eeprom_cis1_sz	50
+#endif
+
+#define	EEPROM_CID_DEFAULT			0x0
+#define	EEPROM_CID_ALPHA				0x1
+#define	EEPROM_CID_Senao				0x3
+#define	EEPROM_CID_NetCore				0x5
+#define	EEPROM_CID_CAMEO				0X8
+#define	EEPROM_CID_SITECOM				0x9
+#define	EEPROM_CID_COREGA				0xB
+#define	EEPROM_CID_EDIMAX_BELKIN		0xC
+#define	EEPROM_CID_SERCOMM_BELKIN		0xE
+#define	EEPROM_CID_CAMEO1				0xF
+#define	EEPROM_CID_WNC_COREGA		0x12
+#define	EEPROM_CID_CLEVO				0x13
+#define	EEPROM_CID_WHQL				0xFE // added by chiyoko for dtm, 20090108
+
+typedef enum _RT_CUSTOMER_ID
+{
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6, 
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,	// Merge by Jacken, 2008/01/31.
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_819x_ALPHA = 15,
+	RT_CID_819x_Sitecom = 16,
+	RT_CID_CCX = 17, // It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17.      
+	RT_CID_819x_Lenovo = 18,
+	RT_CID_819x_QMI = 19,
+	RT_CID_819x_Edimax_Belkin = 20,		
+	RT_CID_819x_Sercomm_Belkin = 21,			
+	RT_CID_819x_CAMEO1 = 22,
+	RT_CID_819x_MSI = 23,
+	RT_CID_819x_Acer = 24,
+	RT_CID_819x_AzWave_ASUS = 25,
+	RT_CID_819x_AzWave = 26, // For AzWave in PCIe, The ID is AzWave use and not only Asus
+	RT_CID_819x_WNC_COREGA = 27,
+	RT_CID_819x_CLEVO = 28,
+}RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;
+
+struct eeprom_priv 
+{    
+	u8		bautoload_fail_flag;
+	u8		bempty;
+	u8		sys_config;
+	u8		mac_addr[6];	
+	u8		config0;
+	u16	channel_plan;
+	u8		country_string[3];	
+	u8		tx_power_b[15];
+	u8		tx_power_g[15];
+	u8		tx_power_a[201];
+
+	u8		efuse_eeprom_data[EEPROM_MAX_SIZE];
+
+	RT_CUSTOMER_ID CustomerID;
+
+	#ifdef CONFIG_SDIO_HCI
+	u8		sdio_setting;	
+	u32		ocr;
+	u8		cis0[eeprom_cis0_sz];
+	u8		cis1[eeprom_cis1_sz];	
+	#endif
+
+};
+
+
+extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
+extern u16 eeprom_read16(_adapter *padapter, u16 reg);
+extern void read_eeprom_content(_adapter *padapter);
+extern void eeprom_read_sz(_adapter * padapter, u16 reg,u8* data, u32 sz); 
+
+extern void read_eeprom_content_by_attrib(_adapter *	padapter	);
+
+#endif  //__RTL871X_EEPROM_H__
diff --git a/drivers/net/wireless/8712u/include/rtl871x_event.h b/drivers/net/wireless/8712u/include/rtl871x_event.h
new file mode 100755
index 0000000..122b8cf
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_event.h
@@ -0,0 +1,185 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871x_EVENT_H_
+#define _RTL871x_EVENT_H_
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#ifndef CONFIG_RTL8711FW
+#ifdef PLATFORM_LINUX
+#include <wlan_bssdef.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/sem.h>
+#endif
+#else
+#include <wlan_bssdef.h>
+#endif//CONFIG_RTL8711FW
+
+
+
+#ifdef CONFIG_H2CLBK
+#include <h2clbk.h>
+#endif
+
+/*
+Used to report a bss has been scanned
+
+*/
+struct survey_event	{
+	NDIS_WLAN_BSSID_EX bss;
+};
+
+/*
+Used to report that the requested site survey has been done.
+
+bss_cnt indicates the number of bss that has been reported.
+
+
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;	
+	
+};
+
+/*
+Used to report the link result of joinning the given bss
+
+
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+Used to report a given STA has joinned the created BSS.
+It is used in AP/Ad-HoC(M) mode.
+
+
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+	
+};
+
+struct stadel_event {
+ unsigned char macaddr[6];
+ unsigned char rsvd[2]; 
+};
+
+struct addba_event
+{
+ 	unsigned int tid;
+};
+
+/*
+ * Site survey timer event
+ *
+ * When would FW send this event?
+ * 1).OnAssociation Response 
+ *	when 20/40coexistence is enable 
+ *	timeout = scan_vale;
+ * 2).OnBeacon
+ *	when AP send the obss_scan_exemption 
+ *	to tell us no need to scan
+ *	timeout = 0;
+ *
+ * Other case (FW don't send c2h cmd, driver should handle this by itself)
+ * 1).disconnect 
+ *	timeout = 0;
+ * 2).join other BSS
+ *	timeout = 0; 
+ */
+struct survey_timer_event
+{
+	unsigned short timeout;	// second, 0 for stop
+};
+
+#ifdef CONFIG_H2CLBK
+struct c2hlbk_event{
+	unsigned char mac[6];
+	unsigned short	s0;
+	unsigned short	s1;
+	unsigned int	w0;
+	unsigned char	b0;
+	unsigned short  s2;
+	unsigned char	b1;
+	unsigned int	w1;	
+};
+#endif//CONFIG_H2CLBK
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+};
+
+
+#define C2HEVENT_SZ			32	
+
+struct event_node{
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	volatile int	head;
+	volatile int	tail;
+	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];	
+};
+
+struct ADDBA_Req_Report_parm {
+ unsigned char MacAddress[ETH_ALEN];
+ unsigned short StartSeqNum;
+ unsigned char tid;
+};
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_event.h"
+#endif
+
+#endif // _WLANEVENT_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_ht.h b/drivers/net/wireless/8712u/include/rtl871x_ht.h
new file mode 100755
index 0000000..0522b98
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_ht.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_HT_H_
+#define _RTL871X_HT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include "wifi.h"
+
+struct ht_priv
+{
+	unsigned int	ht_option;	
+	unsigned int	ampdu_enable;//for enable Tx A-MPDU
+	unsigned char	baddbareq_issued[16];
+	unsigned int	tx_amsdu_enable;//for enable Tx A-MSDU
+	unsigned int	tx_amdsu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
+	unsigned int	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
+	struct rtw_ieee80211_ht_cap ht_cap;
+};
+
+#endif	//_RTL871X_HT_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_io.h b/drivers/net/wireless/8712u/include/rtl871x_io.h
new file mode 100755
index 0000000..8158244
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_io.h
@@ -0,0 +1,443 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _IO_H_
+#define _IO_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <osdep_intf.h>
+
+#ifdef PLATFORM_LINUX
+#include <asm/byteorder.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/list.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_USB_HCI
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#endif
+
+#endif
+
+
+#define NUM_IOREQ		8
+
+#ifdef PLATFORM_WINDOWS
+#define MAX_PROT_SZ	64
+#endif
+#ifdef PLATFORM_LINUX
+#define MAX_PROT_SZ	(64-16)
+#endif
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+// IO COMMAND TYPE
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+
+/* 
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+
+
+
+// IO STATUS TYPE
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+
+
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+
+/*
+
+	Only Sync. burst accessing is provided.
+
+*/
+
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+
+
+
+//below is for the intf_option bit defition...
+
+#define _INTF_ASYNC_	BIT(0)	//support async io
+
+struct intf_priv;
+struct	intf_hdl;
+struct io_queue;
+
+struct	_io_ops {
+
+
+		uint (*_sdbus_read_bytes_to_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+		uint (*_sdbus_read_blocks_to_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+		void (*_attrib_read)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+
+
+		uint (*_sdbus_write_blocks_from_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+		uint (*_sdbus_write_bytes_from_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+		u8 (*_cmd52r)(struct intf_priv *pintfpriv, u32 addr);
+		void (*_cmd52w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+		u8 (*_cmdfunc152r)(struct intf_priv *pintfpriv, u32 addr);
+		void (*_cmdfunc152w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+
+
+		void (*_attrib_write)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		
+		void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		
+		void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+
+		void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		
+		void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		
+		void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+
+		
+
+
+		u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		
+		u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		u32 (*_write_scsi)(struct intf_hdl *pintfhdl,u32 cnt, u8 *pmem);
+		
+
+
+		u8 (*_async_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u16 (*_async_read16)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u32 (*_async_read32)(struct intf_hdl *pintfhdl, u32 addr);
+				
+		void (*_async_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		
+		void (*_async_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		
+		void (*_async_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+					
+
+
+
+};
+
+struct io_req {	
+	_list	list;
+	u32	addr;	
+	volatile u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;	
+	_sema	sema;
+
+#ifdef PLATFORM_OS_CE
+#ifdef CONFIG_USB_HCI
+	// URB handler for write_mem
+	USB_TRANSFER usb_transfer_write_mem;
+#endif
+#endif
+	
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;	
+
+#ifdef PLATFORM_OS_XP	
+	PMDL pmdl;
+	PIRP  pirp; 
+
+#ifdef CONFIG_SDIO_HCI
+	PSDBUS_REQUEST_PACKET sdrp;
+#endif	
+
+#endif	
+
+
+};
+
+struct	intf_hdl {
+	u32	intf_option;
+	//u32	bus_status;
+	//u32	do_flush;
+	//u16	len;
+	//u16	done_len;
+	u8	*adapter;
+	u8	*intf_dev;	
+	struct intf_priv	*pintfpriv;
+	void (*intf_hdl_init)(u8 *priv);
+	void (*intf_hdl_unload)(u8 *priv);
+	void (*intf_hdl_open)(u8 *priv);
+	void (*intf_hdl_close)(u8 *priv);
+	struct	_io_ops	io_ops;
+};
+
+struct reg_protocol_rd {
+
+#ifdef CONFIG_LITTLE_ENDIAN	
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	//u32		Value;
+#else
+
+
+//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;	
+
+	u32 Reserved2  :24;	
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;	
+
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;	
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;	
+	u32 BurstMode :1 ;	
+	u32 FixOrContinuous : 1;	
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	//u32		Value;
+
+#endif
+	
+};
+
+
+struct reg_protocol_wt {
+	
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	u32		Value;
+
+#else
+	//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;	
+
+	u32 Reserved2  :24;	
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;	
+		
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;	
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;	
+	u32 BurstMode :1 ;	
+	u32 FixOrContinuous : 1;	
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	u32		Value;
+
+#endif
+
+};
+
+
+
+/*
+Below is the data structure used by _io_handler
+
+*/
+
+struct io_queue {	
+	_lock	lock;	
+	_list  	free_ioreqs;	
+	_list		pending;		//The io_req list that will be served in the single protocol read/write.	
+	_list		processing;
+	u8	*free_ioreqs_buf; // 4-byte aligned
+	u8	*pallocated_free_ioreqs_buf;
+	struct	intf_hdl	intf;
+};
+
+static __inline u32 _RND4(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
+	
+	return val;
+
+}
+
+extern uint ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+extern void sync_ioreq_enqueue(struct io_req *preq,struct io_queue *ioqueue);
+extern uint sync_ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+
+
+extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
+extern struct io_req *alloc_ioreq(struct io_queue *pio_q);
+
+extern uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl);
+extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);
+
+extern void attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern u8 read8(_adapter *adapter, u32 addr);
+extern u16 read16(_adapter *adapter, u32 addr);
+extern u32 read32(_adapter *adapter, u32 addr);
+extern void read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void write8(_adapter *adapter, u32 addr, u8 val);
+extern void write16(_adapter *adapter, u32 addr, u16 val);
+extern void write32(_adapter *adapter, u32 addr, u32 val);
+extern void write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void write_scsi(_adapter *adapter, u32 cnt, u8 *pmem);
+//ioreq 
+extern void ioreq_read8(_adapter *adapter, u32 addr, u8 *pval);
+extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);	
+extern void ioreq_read32(_adapter *adapter, u32 addr, u32 *pval);
+extern void ioreq_write8(_adapter *adapter, u32 addr, u8 val);
+extern void ioreq_write16(_adapter *adapter, u32 addr, u16 val);
+extern void ioreq_write32(_adapter *adapter, u32 addr, u32 val);
+
+
+extern uint async_read8(_adapter *adapter, u32 addr, u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
+extern uint async_read16(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
+extern uint async_read32(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
+
+extern void async_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern void async_write8(_adapter *adapter, u32 addr, u8 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write16(_adapter *adapter, u32 addr, u16 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write32(_adapter *adapter, u32 addr, u32 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+
+
+extern uint	alloc_io_queue(_adapter *adapter);
+extern void free_io_queue(_adapter *adapter);
+extern void async_bus_io(struct io_queue *pio_q);
+extern void bus_sync_io(struct io_queue *pio_q);
+//extern u32 _ioreq2rwmem(struct io_queue *pio_q);
+extern void dev_power_down(_adapter * Adapter, u8 bpwrup);
+
+#endif	//_RTL8711_IO_H_
diff --git a/drivers/net/wireless/8712u/include/rtl871x_ioctl.h b/drivers/net/wireless/8712u/include/rtl871x_ioctl.h
new file mode 100755
index 0000000..e416aeb
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_ioctl.h
@@ -0,0 +1,264 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __IOCTL_H
+#define __IOCTL_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+// For DDK-defined OIDs
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+
+#define SZ_OID_NDIS_SEG1		  23
+#define SZ_OID_NDIS_SEG2		    3
+#define SZ_OID_NDIS_SEG3		    6
+#define SZ_OID_NDIS_SEG4		    6
+#define SZ_OID_NDIS_SEG5		    4
+#define SZ_OID_NDIS_SEG6		    8
+#define SZ_OID_NDIS_SEG7		    7
+#define SZ_OID_NDIS_SEG8		  36
+#define SZ_OID_NDIS_SEG9		  24
+#define SZ_OID_NDIS_SEG10		  19
+
+// For Realtek-defined OIDs
+#define OID_MP_SEG1		0xFF871100
+#define OID_MP_SEG2		0xFF818000
+
+#define OID_MP_SEG3		0xFF818700
+#define OID_MP_SEG4		0xFF011100
+
+#define DEBUG_OID(dbg, str)     		\
+       if((!dbg))				    			\
+      	{					    			\
+	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __FUNCTION__, __LINE__, str));	\
+      	}			
+
+
+enum oid_type
+{
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; //the starting number for OID
+	unsigned int oid_end; //the ending number for OID
+	struct oid_obj_priv *node_array; 
+	unsigned int array_sz; //the size of node_array
+	int query_counter; //count the number of query hits for this segment  
+	int set_counter; //count the number of set hits for this segment  
+};
+
+struct oid_par_priv
+{
+	void				*adapter_context;
+	NDIS_OID		oid;
+	void*			information_buf;
+	unsigned long		information_buf_len;
+	unsigned long*	bytes_rw;
+	unsigned long*	bytes_needed;
+	enum oid_type	type_of_oid;
+	unsigned int 		dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message 
+	NDIS_STATUS (*oidfuns)(struct oid_par_priv *poid_par_priv);	
+};
+
+
+NDIS_STATUS oid_null_function(struct oid_par_priv* poid_par_priv);
+
+#ifdef PLATFORM_WINDOWS
+
+int TranslateNdisPsToRtPs(IN NDIS_802_11_POWER_MODE	ndisPsMode);
+
+//OID Handler for Segment 1
+NDIS_STATUS oid_gen_supported_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_hardware_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_in_use_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_lookahead_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_frame_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_link_speed_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_transmit_buffer_space_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_receive_buffer_space_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_transmit_block_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_receive_block_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_id_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_description_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_current_packet_filter_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_current_lookahead_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_driver_version_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_total_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_protocol_options_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_mac_options_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_connect_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_send_packets_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_driver_version_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 2
+NDIS_STATUS oid_gen_physical_medium_hdl(struct oid_par_priv* poid_par_priv);
+
+//OID Handler for Segment 3
+NDIS_STATUS oid_gen_xmit_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_xmit_error_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_error_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_no_buffer_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 4
+NDIS_STATUS oid_802_3_permanent_address_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_current_address_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_multicast_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_maximum_list_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_mac_options_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 5
+NDIS_STATUS oid_802_3_rcv_error_alignment_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_one_collision_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_more_collisions_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 6
+NDIS_STATUS oid_802_3_xmit_deferred_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_max_collisions_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_rcv_overrun_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_underrun_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_heartbeat_failure_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_times_crs_lost_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_late_collisions_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 7
+NDIS_STATUS oid_pnp_capabilities_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_set_power_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_query_power_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_add_wake_up_pattern_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_remove_wake_up_pattern_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_wake_up_pattern_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_enable_wake_up_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 8
+NDIS_STATUS oid_802_11_bssid_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_ssid_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_infrastructure_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_add_wep_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_remove_wep_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_disassociate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_authentication_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_privacy_filter_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_bssid_list_scan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_encryption_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_reload_defaults_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_add_key_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_remove_key_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_association_information_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_media_stream_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_capability_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_pmkid_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+
+//OID Handler for Segment 9
+NDIS_STATUS oid_802_11_network_types_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_network_type_in_use_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rssi_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rssi_trigger_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_fragmentation_threshold_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rts_threshold_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_number_of_antennas_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rx_antenna_selected_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_tx_antenna_selected_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_supported_rates_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_desired_rates_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_configuration_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_bssid_list_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 10
+NDIS_STATUS oid_802_11_statistics_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment ED 
+NDIS_STATUS oid_rt_mh_vender_id_hdl(struct oid_par_priv* poid_par_priv);
+
+void Set_802_3_MULTICAST_LIST(ADAPTER *pAdapter, UCHAR *MCListbuf, ULONG MCListlen, BOOLEAN bAcceptAllMulticast);
+
+#endif// end of PLATFORM_WINDOWS
+
+
+#ifdef PLATFORM_LINUX
+
+extern struct iw_handler_def  r871x_handlers_def;
+
+#endif
+
+extern	NDIS_STATUS drv_query_info(
+	IN	_nic_hdl		MiniportAdapterContext,
+	IN	NDIS_OID		Oid,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32*			BytesWritten,
+	OUT	u32*			BytesNeeded
+	);
+
+extern	NDIS_STATUS 	drv_set_info(
+	IN	_nic_hdl		MiniportAdapterContext,
+	IN	NDIS_OID		Oid,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32*			BytesRead,
+	OUT	u32*			BytesNeeded
+	);
+
+#endif // #ifndef __INC_CEINFO_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_ioctl_query.h b/drivers/net/wireless/8712u/include/rtl871x_ioctl_query.h
new file mode 100755
index 0000000..ec606b4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_ioctl_query.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __IOCTL_QUERY_H
+#define __IOCTL_QUERY_H
+
+#include <drv_conf.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_WINDOWS
+
+u8 query_802_11_capability(_adapter*	padapter,u8*	pucBuf,u32 *	pulOutLen);
+u8 query_802_11_association_information (_adapter * padapter, PNDIS_802_11_ASSOCIATION_INFORMATION pAssocInfo);
+
+#endif
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_ioctl_rtl.h b/drivers/net/wireless/8712u/include/rtl871x_ioctl_rtl.h
new file mode 100755
index 0000000..e5fdd5f
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_ioctl_rtl.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_IOCTL_RTL_H
+#define _RTL871X_IOCTL_RTL_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+//************** oid_rtl_seg_01_01 ************** 
+NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);//84
+NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv);	//8a
+NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv);	//8b
+
+NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv);//93
+NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_bcn_intvl_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_dedicate_probe_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_current_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_forced_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+//**************  oid_rtl_seg_01_03 section start ************** 
+NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv);
+
+// oid_rtl_seg_01_11 
+NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv);
+
+//**************  oid_rtl_seg_03_00 section start **************  
+NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+#endif
diff --git a/drivers/net/wireless/8712u/include/rtl871x_ioctl_set.h b/drivers/net/wireless/8712u/include/rtl871x_ioctl_set.h
new file mode 100755
index 0000000..a728d81
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_ioctl_set.h
@@ -0,0 +1,77 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __IOCTL_SET_H
+#define __IOCTL_SET_H
+
+#include <drv_conf.h>
+#include <drv_types.h>
+
+
+typedef u8 NDIS_802_11_PMKID_VALUE[16];
+
+typedef struct _BSSIDInfo {
+	NDIS_802_11_MAC_ADDRESS  BSSID;
+	NDIS_802_11_PMKID_VALUE  PMKID;
+} BSSIDInfo, *PBSSIDInfo;
+
+
+#ifdef PLATFORM_OS_XP
+typedef struct _NDIS_802_11_PMKID {
+	u32	Length;
+	u32	BSSIDInfoCount;
+	BSSIDInfo BSSIDInfo[1];
+} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+u8 set_802_11_reload_defaults(_adapter * padapter, NDIS_802_11_RELOAD_DEFAULTS reloadDefaults);
+u8 set_802_11_test(_adapter * padapter, NDIS_802_11_TEST * test);
+u8 set_802_11_pmkid(_adapter *pdapter, NDIS_802_11_PMKID *pmkid);
+
+u8 pnp_set_power_sleep(_adapter* padapter);
+u8 pnp_set_power_wakeup(_adapter* padapter);
+
+void pnp_resume_wk(void *context);
+void pnp_sleep_wk(void * context);
+
+#endif
+
+u8 set_802_11_add_key(_adapter * padapter, NDIS_802_11_KEY * key);
+u8 set_802_11_authentication_mode(_adapter *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
+u8 set_802_11_bssid(_adapter* padapter, u8 *bssid);
+u8 set_802_11_add_wep(_adapter * padapter, NDIS_802_11_WEP * wep);
+u8 set_802_11_disassociate(_adapter * padapter);
+u8 set_802_11_bssid_list_scan(_adapter* padapter);
+u8 set_802_11_infrastructure_mode(_adapter * padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 set_802_11_remove_wep(_adapter * padapter, u32 keyindex);
+u8 set_802_11_ssid(_adapter * padapter, NDIS_802_11_SSID * ssid);
+u8 set_802_11_remove_key(_adapter * padapter, NDIS_802_11_REMOVE_KEY * key);
+
+
+u8 validate_ssid(NDIS_802_11_SSID *ssid);
+
+u16 rtw_get_network_max_rate(_adapter *adapter, NDIS_WLAN_BSSID_EX *bss);
+int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode);
+int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan);
+int rtw_set_country(_adapter *adapter, const char *country_code);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_led.h b/drivers/net/wireless/8712u/include/rtl871x_led.h
new file mode 100755
index 0000000..37aeb67
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_led.h
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL8712_LED_H
+#define __RTL8712_LED_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define MSECS(t)        (HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
+
+//================================================================================
+// LED customization.
+//================================================================================
+typedef enum _LED_CTL_MODE {
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+	LED_CTL_START_WPS_BOTTON = 11, //added for runtop
+	LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA	
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, //added for BELKIN
+}LED_CTL_MODE;
+
+
+
+#define IS_LED_WPS_BLINKING(_LED_871x)	(((PLED_871x)_LED_871x)->CurrLedState==LED_BLINK_WPS \
+					|| ((PLED_871x)_LED_871x)->CurrLedState==LED_BLINK_WPS_STOP \
+					|| ((PLED_871x)_LED_871x)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_871x) 	(((PLED_871x)_LED_871x)->bLedWPSBlinkInProgress \
+					||((PLED_871x)_LED_871x)->bLedScanBlinkInProgress)
+
+typedef enum _LED_PIN_871x{
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1
+}LED_PIN_871x;
+
+//================================================================================
+// LED customization.
+//================================================================================
+typedef	enum _LED_STRATEGY_871x{
+	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
+	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
+	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
+	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
+	SW_LED_MODE4, //for Edimax / Belkin
+	SW_LED_MODE5, //for Sercomm / Belkin
+	SW_LED_MODE6, //for WNC / Corega
+	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
+}LED_STRATEGY_871x, *PLED_STRATEGY_871x;
+
+typedef struct _LED_871x{
+	_adapter		*padapter;
+	LED_PIN_871x		LedPin;	// Identify how to implement this SW led.
+	u32			CurrLedState; // Current LED state.
+	u8			bLedOn; // _TRUE if LED is ON, _FALSE if LED is OFF.
+
+	u8			bSWLedCtrl;
+
+	u8			bLedBlinkInProgress; // true if it is blinking, false o.w..
+	// ALPHA, added by chiyoko, 20090106
+	u8			bLedNoLinkBlinkInProgress;
+	u8			bLedLinkBlinkInProgress;
+	u8			bLedStartToLinkBlinkInProgress;
+	u8			bLedScanBlinkInProgress;
+	u8			bLedWPSBlinkInProgress;
+	
+	u32			BlinkTimes; // Number of times to toggle led state for blinking.
+	u32			BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
+
+	_timer			BlinkTimer; // Timer object for led blinking.
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	_workitem		BlinkWorkItem; // Workitem used by BlinkTimer to manipulate H/W to blink LED. 
+#endif
+} LED_871x, *PLED_871x;
+
+struct led_priv{
+	/* add for led controll */
+	LED_871x		SwLed0;
+	LED_871x		SwLed1;
+	LED_STRATEGY_871x	LedStrategy;
+	u8			bRegUseLed;
+	void (*LedControlHandler)(_adapter *padapter, LED_CTL_MODE LedAction);
+	/* add for led controll */
+};
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+void InitSwLeds(_adapter *padapter);
+void DeInitSwLeds(_adapter *padapter);
+void LedControl871x(_adapter *padapter,LED_CTL_MODE LedAction);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_mlme.h b/drivers/net/wireless/8712u/include/rtl871x_mlme.h
new file mode 100755
index 0000000..bf4c0d2
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_mlme.h
@@ -0,0 +1,412 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_MLME_H_
+#define __RTL871X_MLME_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+
+
+#ifndef CONFIG_RTL8711FW
+
+#define	MAX_BSS_CNT	64
+#define   MAX_JOIN_TIMEOUT	6000
+//#define   MAX_JOIN_TIMEOUT	2500
+
+//	Changed the scanning timeout from 6 seconds to 4.5 seconds because
+//	wpa_supplicant's scaning timeout is 5 seconds.
+#define 	SCANNING_TIMEOUT 	4500
+
+#ifdef PALTFORM_OS_WINCE
+#define	SCANQUEUE_LIFETIME 12000000 // unit:us
+#else
+#define	SCANQUEUE_LIFETIME 20 // unit:sec
+#endif
+
+#define 	WIFI_NULL_STATE		0x00000000
+#define	WIFI_ASOC_STATE		0x00000001		// Under Linked state...
+#define 	WIFI_REASOC_STATE	       0x00000002
+#define	WIFI_SLEEP_STATE	       0x00000004
+#define	WIFI_STATION_STATE	0x00000008
+#define	WIFI_AP_STATE				0x00000010
+#define	WIFI_ADHOC_STATE			0x00000020
+#define   WIFI_ADHOC_MASTER_STATE 0x00000040
+#define   WIFI_UNDER_LINKING		0x00000080
+#ifdef CONFIG_MLME_EXT
+#define	WIFI_AUTH_NULL		0x00000100
+#define	WIFI_AUTH_STATE1		0x00000200
+#define	WIFI_AUTH_SUCCESS	0x00000400
+#endif
+//#define WIFI_UNDER_CMD			0x00000200
+#define WIFI_SITE_MONITOR		0x00000800		//to indicate the station is under site surveying
+
+#ifdef WDS
+#define	WIFI_WDS				0x00001000
+#define	WIFI_WDS_RX_BEACON	0x00002000		// already rx WDS AP beacon
+#endif
+#ifdef AUTO_CONFIG
+#define	WIFI_AUTOCONF			0x00004000
+#define	WIFI_AUTOCONF_IND	0x00008000
+#endif
+
+//#ifdef UNDER_MPTEST
+#define	WIFI_MP_STATE						0x00010000
+#define	WIFI_MP_CTX_BACKGROUND			0x00020000	// in continous tx background
+#define	WIFI_MP_CTX_ST					0x00040000	// in continous tx with single-tone
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	// pending in continous tx background due to out of skb
+#define	WIFI_MP_CTX_CCK_HW				0x00100000	// in continous tx
+#define	WIFI_MP_CTX_CCK_CS				0x00200000	// in continous tx with carrier suppression
+#define   WIFI_MP_LPBK_STATE				0x00400000
+//#endif
+
+//#define _FW_UNDER_CMD		WIFI_UNDER_CMD
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#ifdef CONFIG_MLME_EXT
+#define _FW_LINKED			0x01000000
+#else
+#define _FW_LINKED			WIFI_ASOC_STATE
+#endif
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+enum dot11AuthAlgrthmNum {
+	dot11AuthAlgrthm_Open = 0,
+	dot11AuthAlgrthm_Shared,
+	dot11AuthAlgrthm_8021X,
+	dot11AuthAlgrthm_Auto,
+	dot11AuthAlgrthm_MaxNum
+};
+
+// Scan type including active and passive scan.
+typedef enum _RT_SCAN_TYPE
+{
+	SCAN_PASSIVE,
+	SCAN_ACTIVE,
+	SCAN_MIX,
+}RT_SCAN_TYPE, *PRT_SCAN_TYPE;
+
+/*
+
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+
+
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+
+*/
+
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	sint	traffic_busy;
+	_timer	sitesurvey_ctrl_timer;
+};
+
+struct mlme_priv {
+
+	_lock	lock;
+	sint	fw_state;	//shall we protect this variable? maybe not necessarily...
+
+	u8 to_join; //flag
+	u8 *nic_hdl;
+
+	_list		*pscanned;
+	_queue	free_bss_pool;
+	_queue	scanned_queue;
+	u8	*free_bss_buf;
+	unsigned long	num_of_scanned;
+	u8 passive_mode; //add for Andorid's SCAN-ACTIVE/SCAN-PASSIVE
+
+	NDIS_802_11_SSID	assoc_ssid;
+	u8	assoc_bssid[6];
+
+	struct wlan_network	cur_network;
+
+	struct sitesurvey_ctrl sitesurveyctrl;
+
+	//uint wireless_mode; no used, remove it
+
+
+	_timer assoc_timer;
+
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+
+	_timer scan_to_timer; // driver itself handles scan_timeout status.
+	_timer dhcp_timer; // set dhcp timeout if driver is in ps mode.
+
+	_timer survey_timer; // regular site survey timer for WiFi Certification
+	u32 survey_interval; // survey timer interval, millisecond(ms)
+
+	struct qos_priv qospriv;
+
+#ifdef CONFIG_80211N_HT
+
+	struct ht_priv	htpriv;
+
+#endif
+
+	_timer	wdg_timer; //watchdog periodic timer
+	//_workitem	hw_pbc_workitem; //use for fw wps event
+	//_timer	hw_pbc_timer; // prevent press push button frequently
+
+#ifdef RTK_DMP_PLATFORM
+	// DMP kobject_hotplug function  signal need in passive level
+	_workitem	Linkup_workitem;
+	_workitem	Linkdown_workitem;
+#endif
+};
+
+#ifdef CONFIG_HOSTAPD_MODE
+struct hostapd_priv
+{
+	struct net_device *pmgnt_netdev;
+	_adapter *padapter;
+	struct usb_anchor anchored;
+};
+
+extern int hostapd_mode_init(_adapter *padapter);
+extern void hostapd_mode_unload(_adapter *padapter);
+#endif
+
+extern void survey_event_callback(_adapter *adapter, u8 *pbuf);
+extern void surveydone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void joinbss_event_callback(_adapter *adapter, u8 *pbuf);
+extern void stassoc_event_callback(_adapter *adapter, u8 *pbuf);
+extern void stadel_event_callback(_adapter *adapter, u8 *pbuf);
+extern void atimdone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void cpwm_event_callback(_adapter *adapter, u8 *pbuf);
+extern void wpspbc_event_callback(_adapter *adapter, u8 *pbuf);
+extern void survey_timer_event_callback(PADAPTER adapter, u8 *pbuf);
+
+#ifdef PLATFORM_WINDOWS
+extern thread_return event_thread(void *context);
+extern void sitesurvey_ctrl_handler(
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+extern void join_timeout_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+
+extern void _scan_timeout_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+
+//extern void hw_pbc_workitem_callback(
+//	IN NDIS_WORK_ITEM*	pWorkItem,
+//	IN PVOID			Context
+//	);
+
+#endif
+
+#ifdef PLATFORM_LINUX
+extern int event_thread(void *context);
+extern void sitesurvey_ctrl_handler(void* FunctionContext);
+extern void join_timeout_handler(void* FunctionContext);
+extern void _scan_timeout_handler(void* FunctionContext);
+//extern void hw_pbc_workitem_callback(struct work_struct *work);
+#endif
+
+extern void free_network_queue(_adapter *adapter);
+extern int init_mlme_priv(_adapter *adapter);// (struct mlme_priv *pmlmepriv);
+
+extern void free_mlme_priv (struct mlme_priv *pmlmepriv);
+
+
+extern sint select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
+extern sint set_key(_adapter *adapter,struct security_priv *psecuritypriv,sint keyid);
+extern sint set_auth(_adapter *adapter,struct security_priv *psecuritypriv);
+
+static __inline u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{	//if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid
+	// if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+static __inline u8 check_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	if (pmlmepriv->fw_state & state)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+static __inline sint get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+ */
+static __inline void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state |= state;
+}
+
+static __inline void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state &= ~state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+static __inline void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	_irqL irqL;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+	if (check_fwstate(pmlmepriv, state) == _TRUE)
+		pmlmepriv->fw_state ^= state;
+	_exit_critical(&pmlmepriv->lock, &irqL);
+}
+
+static __inline void clr_fwstate_ex(struct mlme_priv *pmlmepriv, sint state)
+{
+	_irqL irqL;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+	_clr_fwstate_(pmlmepriv, state);
+	_exit_critical(&pmlmepriv->lock, &irqL);
+}
+
+static __inline void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned++;
+	_exit_critical(&pmlmepriv->lock, &irqL);
+}
+
+static __inline void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned--;
+	_exit_critical(&pmlmepriv->lock, &irqL);
+}
+
+static __inline void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint val)
+{
+	_irqL irqL;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned = val;
+	_exit_critical(&pmlmepriv->lock, &irqL);
+}
+
+#endif
+
+extern u16 get_capability(NDIS_WLAN_BSSID_EX *bss);
+extern uint get_NDIS_WLAN_BSSID_EX_sz(NDIS_WLAN_BSSID_EX *bss);
+extern void update_scanned_network(_adapter *adapter, NDIS_WLAN_BSSID_EX *target);
+extern void disconnect_hdl_under_linked(_adapter* adapter, struct sta_info *psta, u8 free_assoc);
+extern void generate_random_ibss(u8 *pibss);
+extern struct wlan_network* find_network(_queue *scanned_queue, u8 *addr);
+extern struct wlan_network* get_oldest_wlan_network(_queue *scanned_queue);
+
+extern void free_assoc_resources(_adapter* adapter);
+extern void indicate_disconnect(_adapter* adapter);
+extern void indicate_connect(_adapter* adapter);
+void rtw_indicate_scan_done( _adapter *padapter, bool aborted);
+
+extern int restruct_sec_ie(_adapter *adapter,u8 *in_ie,u8 *out_ie,uint in_len);
+extern int restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
+extern void init_registrypriv_dev_network(_adapter *adapter);
+
+extern void update_registrypriv_dev_network(_adapter *adapter);
+
+extern void get_encrypt_decrypt_from_registrypriv(_adapter *adapter);
+
+extern void _sitesurvey_ctrl_handler(_adapter *adapter);
+extern void _join_timeout_handler(_adapter *adapter);
+extern void scan_timeout_handler(_adapter *adapter);
+extern void _dhcp_timeout_handler(_adapter *adapter);
+extern void _regular_site_survey_handler(PADAPTER padapter);
+extern void _wdg_timeout_handler(_adapter *adapter);
+//extern void _hw_pbc_timeout_handler(_adapter *adapter);
+
+extern int _init_mlme_priv(_adapter *padapter);
+
+extern void _free_mlme_priv(struct mlme_priv *pmlmepriv);
+
+extern int _enqueue_network(_queue *queue, struct wlan_network *pnetwork);
+
+extern struct wlan_network* _dequeue_network(_queue *queue);
+
+extern struct wlan_network* _alloc_network(struct mlme_priv *pmlmepriv);
+
+
+extern void _free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+extern void _free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+
+
+extern struct wlan_network* _find_network(_queue *scanned_queue, u8 *addr);
+
+extern void _free_network_queue(_adapter* padapter);
+
+extern sint if_up(_adapter *padapter);
+
+
+u8 *get_capability_from_ie(u8 *ie);
+u8 *get_timestampe_from_ie(u8 *ie);
+u8 *get_beacon_interval_from_ie(u8 *ie);
+
+
+void joinbss_reset(_adapter *padapter);
+
+#ifdef CONFIG_80211N_HT
+unsigned int restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+void update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len);
+void issue_addbareq_cmd(_adapter *padapter, int priority);
+#endif
+
+
+int is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
+
+#endif //__RTL871X_MLME_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_mlme_ext.h b/drivers/net/wireless/8712u/include/rtl871x_mlme_ext.h
new file mode 100755
index 0000000..7dd368e
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_mlme_ext.h
@@ -0,0 +1,385 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_MLME_EXT_H_
+#define __RTL871X_MLME_EXT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+#include <wifi.h>
+
+struct mlme_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(_adapter *padapter, u8 *pframe, uint len);
+};
+
+struct	bssid_desc	{
+	unsigned char valid;
+	unsigned char 	addr[ETH_ALEN];
+};
+
+
+
+/*
+struct	ss_res	{
+	int	state;
+	int	bss_cnt;
+	int	channel_idx;//
+	int	ss_ssidlen;
+	int	passive_mode;
+	unsigned char 	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+	struct	bssid_desc	bssid[MAX_BSS_CNT];
+	
+};
+*/
+
+struct	ss_res	
+{
+	int				state;
+	int				active_mode;
+	int				ss_ssidlen;
+	unsigned char 	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+	
+	unsigned char	old_channel;
+	unsigned char	old_modem;
+	unsigned char	sur_regulatory_inx;
+	unsigned char 	ch_inx;
+	unsigned short	orig_bw_mode;
+	unsigned char	orig_channel_offset;
+	
+	unsigned char	orig_MSR;
+	unsigned int	bss_cnt;
+	unsigned int	fail_cnt;
+	
+	struct bssid_desc ma_tbl[MAX_BSS_CNT];
+	
+};
+
+struct rtl_wmm_ac_params {
+	int cwmin;
+	int cwmax;
+	int aifs;
+	int txopLimit; /* in units of 32us */
+	int admission_control_mandatory;
+};
+
+struct wpa_psk
+{	
+
+/*
+#define _NO_PRIVACY_	0x0
+#define _WEP40_			0x1
+#define _TKIP_			0x2
+#define _TKIP_WTMIC_	0x3
+#define _AES_			0x4
+#define _WEP104_		0x5
+*/
+
+	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;
+
+	unsigned char	PassPhrase[65];
+	unsigned long GKRekeyTime;//0:disable
+	
+};
+
+struct wifi_mib
+{
+	unsigned int mib_ver;
+	
+	unsigned char	dot11OperationalRateSet[32];
+	unsigned int	dot11OperationalRateSetLen;
+
+	struct Dot11nConfigEntry dot11nConfigEntry;
+
+};
+
+struct mlme_ext_priv
+{
+	_adapter *padapter;
+
+#ifdef PLATFORM_LINUX
+	struct net_device *mondev;
+#endif
+
+#ifdef CONFIG_RTL8712
+
+	/*
+	//pcur_network pointers to pmlmepriv->cur_network.network
+	//for AP_MODE,  pcur_network is available when create_bss is called.
+	//			    pcur_network defines ap's capability & related network parameter.
+	//for STA_MODE security capability refers to the security_priv.
+	//for AP_MODE, security capabilities are defined as follows;	
+	//mac/bb/rf related capabilities, basic/supported/mcs rates, channel, modulation, etc. is defined below.		
+	*/	
+	WLAN_BSSID_EX	*pcur_network;
+
+	struct wifi_mib	wmib;
+
+	//mac_ctrl
+	unsigned char	basicrate[NumRates];
+	unsigned char	basicrate_inx;
+#ifdef LOWEST_BASIC_RATE	
+	unsigned char	lowest_basicrate_inx;
+#endif	
+	unsigned char	datarate[NumRates];
+	unsigned char	dtim;
+	unsigned char	cur_channel;
+	unsigned char	cur_modem;
+	//unsigned char	old_channel;
+	//unsigned char	old_modem;
+
+        //rf_ctrl related
+	unsigned char rf_config;
+	struct mib_rf_ctrl	rf_ctrl;	
+	struct regulatory_class class_sets[1];
+
+
+	//
+	struct ss_res sitesurvey_res;	
+	WLAN_BSSID_EX	joining_network;
+	unsigned int	join_res;
+	unsigned short aid;
+	unsigned int	reauth_count;
+	unsigned int	reassoc_count;
+	unsigned int	auth_seq;
+	unsigned int	join_req_ongoing;
+	unsigned int 	authModeToggle;
+	unsigned int	authModeRetry;
+	unsigned int 	iv;
+	unsigned char	chg_txt[128];
+
+
+	//timer for associating (I)BSS
+	_timer	survey_timer;
+	_timer	reauth_timer;
+	_timer	reassoc_timer;
+	_timer	disconnect_timer;
+
+
+	//mlme_event related
+	struct	c2hevent_queue 	c2hevent;
+	struct	network_queue	networks;
+	unsigned int	c2h_res;
+	unsigned char	*c2h_buf;
+
+	
+	//xmit_mgnt_frame related
+	unsigned short mgnt_seqnum;
+	_queue	free_mgnt_queue;	
+	unsigned char *pallocated_mgnt_frame_buf;
+	unsigned char *pxmit_mgnt_frame_buf;
+	unsigned int	free_mgnt_frame_cnt;
+
+
+	
+#else	
+
+	struct 	sta_data	sta_data[MAX_STASZ];
+	struct 	stainfo			stainfos[MAX_STASZ];
+	struct 	stainfo2			stainfo2s[MAX_STASZ];
+	struct	stainfo_rxcache	rxcache[MAX_STASZ];
+	struct	stainfo_stats		stainfostats[MAX_STASZ];	
+	struct	network_queue	networks;//
+	struct	mib_rf_ctrl		rf_ctrl;
+	struct 	erp_mib 			dot11ErpInfo;
+	struct 	Dot11RsnIE		dot11RsnIE;
+	struct	Dot1180211AuthEntry 	dot1180211authentry;
+	struct	c2hevent_queue 	c2hevent;//
+	struct	del_sta_queue		del_sta_q;
+	struct	regulatory_class	class_sets[NUM_REGULATORYS];
+	struct	regulatory_class	*cur_class;
+	struct	rxbufhead_pool	rxbufheadpool;
+	struct	txbufhead_pool	txbufheadpool;
+	struct	mib_mac_ctrl		mac_ctrl;
+	struct	event_node		survey_done_event;
+	struct 	surveydone_event	survey_done;
+	struct	event_node		join_res_event;
+	struct	joinbss_event		joinbss_done;
+	struct	event_node		add_sta_event;
+	struct	stassoc_event		add_sta_done;
+	struct	event_node		del_sta_event;
+	struct	stadel_event		del_sta_done;
+	struct	ss_res			sitesurvey_res;//
+	NDIS_WLAN_BSSID_EX	cur_network;
+	_timer	survey_timer;
+	_timer	reauth_timer;
+	_timer	reassoc_timer;
+	_timer	disconnect_timer;
+
+	_list	free_rxirp_mgt;
+	_list	free_txirp_mgt;
+	_list 	assoc_entry;	
+	_list	hash_array[MAX_STASZ];
+	
+	_sema cam_sema;
+	_lock free_rxirp_mgt_lock;
+	_lock free_txirp_mgt_lock;
+
+	u8	evt_clear;
+	
+	u32	reauth_count;//
+	u32	reassoc_count;//
+	u32	auth_seq;//
+	u32	join_req_ongoing;//
+	u32	join_res;
+	u32	bcnlimit;
+	u32 h2crsp_addr[512>>2];
+	u32	c2h_res;//
+	int 	authModeToggle;
+	int	bcn_to_cnt;
+
+	u16	aid;
+	u16	ps_bcn_itv;	/* Current AP's beacon interval */
+	
+	unsigned char	cur_channel;//
+	unsigned char	dtim_period;
+	u8	change_chan;	
+	u8	cmd_proc;
+	u8	cur_modem;//
+	u8	network_type;
+	u8	vcs_mode;
+	u8 	h2cseq;
+	u8	old_channel;//
+	u8	old_modem;//
+	u8	sur_regulatory_inx;
+	u8	ch_inx;
+	u8	beacon_cnt;
+	u8	*c2h_buf;//
+	u8	*pallocated_fw_rxirp_buf;
+	u8	*pfw_rxirp_buf;
+	u8	*pallocated_fw_txirp_buf;
+	u8	*pfw_txirp_buf;
+
+	//TX rate
+	int	rate;       /* current rate */
+	int	basic_rate;
+
+	//DIG parameter
+	u8	bDynamicInitGain;
+	u8	RegBModeGainStage;
+	u8	RegDigOfdmFaUpTh;
+	u8	InitialGain;
+	u8	DIG_NumberFallbackVote;
+	u8	DIG_NumberUpgradeVote;
+	u8	StageCCKTh;
+	u16	CCKUpperTh;
+	u16	CCKLowerTh;
+	u32	FalseAlarmRegValue;
+
+	//Rate adaptive parameter
+	u8	bRateAdaptive;
+	u8	ForcedDataRate;
+	u8	TryupingCountNoData;
+	u8	TryDownCountLowData;
+	u8	bTryuping;
+	u8	LastFailTxRate;
+	u8	FailTxRateCount;
+	u16	CurrRetryCnt;
+	u16	LastRetryCnt;
+	u16	LastRetryRate;
+	u16	TryupingCount;
+	u32	LastTxThroughput;
+	s32	LastFailTxRateSS;
+	s32	RecvSignalPower;
+	u64	LastTxokCnt;
+	u64	LastRxokCnt;
+	u64	LastTxOKBytes;
+	u64	NumTxOkTotal;
+	u64	NumTxOkBytesTotal;
+	u64	NumRxOkTotal;
+	
+#endif	
+	
+};
+
+
+#define MAX_MGNTBUF_SZ 	(512)
+#define NR_MGNTFRAME 8
+
+struct mgnt_frame{
+
+	_list	list;
+
+	struct pkt_attrib attrib;
+	
+	_pkt *pkt;
+	
+	int frame_tag;
+	
+	 _adapter *padapter;
+
+	 u8 *buf_addr;
+
+	 struct xmit_buf *pxmitbuf;
+
+
+#ifdef CONFIG_SDIO_HCI
+
+	u8 pg_num;
+
+#endif
+	
+#ifdef CONFIG_USB_HCI
+
+	//insert urb, irp, and irpcnt info below...      
+	//max frag_cnt = 8 
+	
+       u8 *mem_addr;      
+       u16 sz[8];	   
+	PURB	pxmit_urb[8];
+#ifdef PLATFORM_WINDOWS
+	PIRP		pxmit_irp[8];
+#endif
+	u8 bpending[8];
+	//sint ac_tag[8];
+	u8 last[8];
+       //uint irpcnt;         
+       //uint fragcnt;
+#endif
+	
+	//uint	mem[(MAX_MGNTBUF_SZ >> 2)];
+	uint	mem[1];
+	
+};
+
+int	init_mlme_ext_priv (_adapter* padapter);
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext);
+void init_mlme_ext_timer(_adapter *padapter);
+
+unsigned char *init_mgnt_xmitframe(struct mgnt_frame *pmgntframe);
+struct mgnt_frame *alloc_mgnt_xmitframe(struct mlme_ext_priv *pmlmeext);
+int free_mgnt_xmitframe(struct mlme_ext_priv *pmlmeext, struct mgnt_frame *pmgntframe);
+
+
+void mlmeext_surveydone_event_callback(_adapter* padapter);
+void mlmeext_joinbss_event_callback(_adapter *padapter, struct wlan_network *pnetwork);
+
+void start_createbss(_adapter *padapter, char *ssid, unsigned int ssid_len);
+
+int xmitframes_filter(_adapter *padapter, _pkt *pkt);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_mp.h b/drivers/net/wireless/8712u/include/rtl871x_mp.h
new file mode 100755
index 0000000..64af1b2
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_mp.h
@@ -0,0 +1,459 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_MP_H_
+#define __RTL871X_MP_H_
+
+
+#ifndef PLATFORM_WINDOWS
+//	00 - Success
+//	11 - Error
+#define STATUS_SUCCESS				(0x00000000L)
+#define STATUS_PENDING				(0x00000103L)
+
+#define STATUS_UNSUCCESSFUL			(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
+#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
+
+#define NDIS_STATUS_SUCCESS			((NDIS_STATUS)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING			((NDIS_STATUS) STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED		((NDIS_STATUS)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED			((NDIS_STATUS)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED		((NDIS_STATUS)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE			((NDIS_STATUS)0x00010007L)
+
+#define NDIS_STATUS_FAILURE			((NDIS_STATUS) STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES			((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING			((NDIS_STATUS)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION			((NDIS_STATUS)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS		((NDIS_STATUS)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND		((NDIS_STATUS)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED			((NDIS_STATUS)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED		((NDIS_STATUS)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL		((NDIS_STATUS)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS		((NDIS_STATUS)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND		((NDIS_STATUS)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED		((NDIS_STATUS)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS		((NDIS_STATUS)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING		((NDIS_STATUS)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED		((NDIS_STATUS)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET		((NDIS_STATUS)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL		((NDIS_STATUS)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY		((NDIS_STATUS)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN		((NDIS_STATUS)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING		((NDIS_STATUS)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH		((NDIS_STATUS)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA		((NDIS_STATUS)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT		((NDIS_STATUS)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID			((NDIS_STATUS)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED		((NDIS_STATUS)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA		((NDIS_STATUS)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE	((NDIS_STATUS)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND		((NDIS_STATUS)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE		((NDIS_STATUS)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED		((NDIS_STATUS)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT		((NDIS_STATUS)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE			((NDIS_STATUS)0xC001001FL)
+
+#define NDIS_STATUS_INVALID_SAP			((NDIS_STATUS)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE			((NDIS_STATUS)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS		((NDIS_STATUS)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED		((NDIS_STATUS)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER		((NDIS_STATUS)0xC0010024L)  // cause 27
+#define NDIS_STATUS_VC_NOT_AVAILABLE		((NDIS_STATUS)0xC0010025L)  // cause 35,45
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE	((NDIS_STATUS)0xC0010026L)  // cause 37
+#define NDIS_STATUS_INCOMPATABLE_QOS		((NDIS_STATUS)0xC0010027L)  // cause 49
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED	((NDIS_STATUS)0xC0010028L)  // cause 93
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION	((NDIS_STATUS)0xC0010029L)  // cause 3
+#endif /* #ifndef PLATFORM_WINDOWS */
+
+#define MPT_NOOP			0
+#define MPT_READ_MAC_1BYTE		1
+#define MPT_READ_MAC_2BYTE		2
+#define MPT_READ_MAC_4BYTE		3
+#define MPT_WRITE_MAC_1BYTE		4
+#define MPT_WRITE_MAC_2BYTE		5
+#define MPT_WRITE_MAC_4BYTE		6
+#define MPT_READ_BB_CCK			7
+#define MPT_WRITE_BB_CCK		8
+#define MPT_READ_BB_OFDM		9
+#define MPT_WRITE_BB_OFDM		10
+#define MPT_READ_RF			11
+#define MPT_WRITE_RF			12
+#define MPT_READ_EEPROM_1BYTE		13
+#define MPT_WRITE_EEPROM_1BYTE		14
+#define MPT_READ_EEPROM_2BYTE		15
+#define MPT_WRITE_EEPROM_2BYTE		16
+#define MPT_SET_CSTHRESHOLD		21
+#define MPT_SET_INITGAIN		22
+#define MPT_SWITCH_BAND			23
+#define MPT_SWITCH_CHANNEL		24
+#define MPT_SET_DATARATE		25
+#define MPT_SWITCH_ANTENNA		26
+#define MPT_SET_TX_POWER		27
+#define MPT_SET_CONT_TX			28
+#define MPT_SET_SINGLE_CARRIER		29
+#define MPT_SET_CARRIER_SUPPRESSION	30
+#define MPT_GET_RATE_TABLE		31
+#define MPT_READ_TSSI			32
+#define MPT_GET_THERMAL_METER		33
+
+
+#define MAX_MP_XMITBUF_SZ 	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame
+{
+	_list	list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int frame_tag;
+
+	_adapter *padapter;
+
+#ifdef CONFIG_USB_HCI
+
+	//insert urb, irp, and irpcnt info below...
+	//max frag_cnt = 8
+
+	u8 *mem_addr;
+	u16 sz[8];
+
+#if defined(PLATFORM_OS_XP) || defined(PLATFORM_LINUX)
+	PURB pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PIRP pxmit_irp[8];
+#endif
+
+	u8 bpending[8];
+	//sint ac_tag[8];
+	u8 last[8];
+	//uint irpcnt;         
+	//uint fragcnt;	   
+#endif /* CONFIG_USB_HCI */
+
+	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
+};
+
+struct mp_wiparam
+{
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+typedef void(*wi_act_func)(void* padapter);
+
+#ifdef PLATFORM_WINDOWS
+struct mp_wi_cntx
+{
+	u8 bmpdrv_unload;
+
+	// Work Item
+	NDIS_WORK_ITEM mp_wi;
+	NDIS_EVENT mp_wi_evt;
+	_lock mp_wi_lock;
+	u8 bmp_wi_progress;
+	wi_act_func curractfunc;
+	// Variable needed in each implementation of CurrActFunc.
+	struct mp_wiparam param;
+};
+#endif
+
+struct mp_priv
+{
+	_adapter *papdater;
+
+	//OID cmd handler
+	struct mp_wiparam workparam;
+	u8 act_in_progress;
+
+	//Tx Section
+	u8 TID;
+	u32 tx_pktcount;
+
+	//Rx Section
+	u32 rx_pktcount;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+
+	struct recv_stat rxstat;
+
+	//RF/BB relative
+	u32 curr_ch;
+	u32 curr_rateidx;
+	u8 curr_bandwidth;
+	u8 curr_modem;
+	u8 curr_txpoweridx;
+
+	u32 curr_crystalcap;
+
+	u16 antenna_tx;
+	u16 antenna_rx;
+	u8 curr_rfpath;
+
+	u8 check_mp_pkt;
+
+	uint ForcedDataRate;
+
+	struct wlan_network mp_network;
+	NDIS_802_11_MAC_ADDRESS network_macaddr;
+
+	//Testing Flag
+	u32 mode;//0 for normal type packet, 1 for loopback packet (16bytes TXCMD)
+
+	sint prev_fw_state;
+
+#ifdef PLATFORM_WINDOWS
+	u32 rx_testcnt;
+	u32 rx_testcnt1;
+	u32 rx_testcnt2;
+	u32 tx_testcnt;
+	u32 tx_testcnt1;
+
+	struct mp_wi_cntx wi_cntx;
+
+	u8 h2c_result;
+	u8 h2c_seqnum;
+	u16 h2c_cmdcode;
+	u8 h2c_resp_parambuf[512];
+	_lock h2c_lock;
+	_lock wkitm_lock;
+	u32 h2c_cmdcnt;
+	NDIS_EVENT h2c_cmd_evt;
+	NDIS_EVENT c2h_set;
+	NDIS_EVENT h2c_clr;
+	NDIS_EVENT cpwm_int;
+
+	NDIS_EVENT scsir_full_evt;
+	NDIS_EVENT scsiw_empty_evt;
+#endif
+
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	_queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+};
+
+typedef struct _IOCMD_STRUCT_ {
+	u8	cmdclass;
+	u16	value;
+	u8	index;
+}IOCMD_STRUCT;
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+//=======================================================================
+
+#define LOWER 	_TRUE
+#define RAISE	_FALSE
+
+#if 0
+#define IOCMD_CTRL_REG			0x102502C0
+#define IOCMD_DATA_REG			0x102502C4
+#else
+#define IOCMD_CTRL_REG			0x10250370
+#define IOCMD_DATA_REG			0x10250374
+#endif
+
+#define IOCMD_GET_THERMAL_METER		0xFD000028
+
+#define IOCMD_CLASS_BB_RF		0xF0
+#define IOCMD_BB_READ_IDX		0x00
+#define IOCMD_BB_WRITE_IDX		0x01
+#define IOCMD_RF_READ_IDX		0x02
+#define IOCMD_RF_WRIT_IDX		0x03
+
+#define BB_REG_BASE_ADDR		0x800
+
+
+#define RF_PATH_A 	0
+#define RF_PATH_B 	1
+#define RF_PATH_C 	2
+#define RF_PATH_D 	3
+
+#define MAX_RF_PATH_NUMS	2
+
+
+#define _2MAC_MODE_	0
+#define _LOOPBOOK_MODE_	1
+
+static u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+
+/* MP set force data rate base on the definition. */
+typedef enum _MPT_RATE_INDEX
+{
+	/* CCK rate. */
+	MPT_RATE_1M,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_LAST
+}MPT_RATE_E, *PMPT_RATE_E;
+
+// Represent Channel Width in HT Capabilities
+typedef enum _HT_CHANNEL_WIDTH {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_40 = 1,
+}HT_CHANNEL_WIDTH, *PHT_CHANNEL_WIDTH;
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	// 0x3F
+
+typedef enum _POWER_MODE_ {
+	POWER_LOW = 0,
+	POWER_NORMAL
+}POWER_MODE;
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+#define RPTMaxCount 0x000FFFFF;
+
+// parameter 1 : BitMask
+// 	bit 0  : OFDM PPDU
+//	bit 1  : OFDM False Alarm
+//	bit 2  : OFDM MPDU OK
+//	bit 3  : OFDM MPDU Fail
+//	bit 4  : CCK PPDU
+//	bit 5  : CCK False Alarm
+//	bit 6  : CCK MPDU ok
+//	bit 7  : CCK MPDU fail
+//	bit 8  : HT PPDU counter
+//	bit 9  : HT false alarm
+//	bit 10 : HT MPDU total
+//	bit 11 : HT MPDU OK
+//	bit 12 : HT MPDU fail
+//	bit 15 : RX full drop
+typedef enum _RXPHY_BITMASK_
+{
+	OFDM_PPDU_BIT = 0,
+	OFDM_FALSE_BIT,
+	OFDM_MPDU_OK_BIT,
+	OFDM_MPDU_FAIL_BIT,
+	CCK_PPDU_BIT,
+	CCK_FALSE_BIT,
+	CCK_MPDU_OK_BIT,
+	CCK_MPDU_FAIL_BIT,
+	HT_PPDU_BIT,
+	HT_FALSE_BIT,
+	HT_MPDU_BIT,
+	HT_MPDU_OK_BIT,
+	HT_MPDU_FAIL_BIT,
+} RXPHY_BITMASK;
+
+
+typedef enum _ENCRY_CTRL_STATE_ {
+	HW_CONTROL,		//hw encryption& decryption
+	SW_CONTROL,		//sw encryption& decryption
+	HW_ENCRY_SW_DECRY,	//hw encryption & sw decryption
+	SW_ENCRY_HW_DECRY	//sw encryption & hw decryption
+}ENCRY_CTRL_STATE;
+
+// Bandwidth Offset
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+//=======================================================================
+extern struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv);
+extern int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe);
+
+extern void mp871xinit(_adapter *padapter);
+extern void mp871xdeinit(_adapter *padapter);
+
+extern void _irqlevel_changed_(_irqL *irqlevel, u8 bLower);
+//=======================================================================
+extern void	IQCalibrateBcut(PADAPTER pAdapter);
+
+extern u32	bb_reg_read(PADAPTER Adapter, u16 offset);
+extern u8	bb_reg_write(PADAPTER Adapter, u16 offset, u32 value);
+extern u32	rf_reg_read(PADAPTER Adapter, u8 path, u8 offset);
+extern u8	rf_reg_write(PADAPTER Adapter, u8 path, u8 offset, u32 value);
+
+extern u32	get_bb_reg(PADAPTER Adapter, u16 offset, u32 bitmask);
+extern u8	set_bb_reg(PADAPTER Adapter, u16 offset, u32 bitmask, u32 value);
+extern u32	get_rf_reg(PADAPTER Adapter, u8 path, u8 offset, u32 bitmask);
+extern u8	set_rf_reg(PADAPTER Adapter, u8 path, u8 offset, u32 bitmask, u32 value);
+
+extern void	SetChannel(PADAPTER pAdapter);
+extern void	SetTxPower(PADAPTER pAdapte);
+extern void	SetTxAGCOffset(PADAPTER pAdapter, u32 ulTxAGCOffset);
+extern void	SetDataRate(PADAPTER pAdapter);
+extern void	SwitchBandwidth(PADAPTER pAdapter);
+
+extern void	SwitchAntenna(PADAPTER pAdapter);
+
+extern void	SetCrystalCap(PADAPTER pAdapter);
+
+//extern void	TriggerRFThermalMeter(PADAPTER pAdapter);
+extern void	GetThermalMeter(PADAPTER pAdapter, u32 *value);
+
+extern void	SetContinuousTx(PADAPTER pAdapter, u8 bStart);
+extern void	SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
+extern void	SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
+extern void	SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
+
+extern void	ResetPhyRxPktCount(PADAPTER pAdapter);
+extern u32	GetPhyRxPktReceived(PADAPTER pAdapter);
+extern u32	GetPhyRxPktCRC32Error(PADAPTER pAdapter);
+
+#endif //__RTL871X_MP_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_mp_ioctl.h b/drivers/net/wireless/8712u/include/rtl871x_mp_ioctl.h
new file mode 100755
index 0000000..e713444
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_mp_ioctl.h
@@ -0,0 +1,572 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_MP_IOCTL_H
+#define _RTL871X_MP_IOCTL_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mp_custom_oid.h>
+#include <rtl871x_ioctl.h>
+#include <rtl871x_ioctl_rtl.h>
+#include <rtl8712_efuse.h>
+
+
+#define TESTFWCMDNUMBER			1000000
+#define TEST_H2CINT_WAIT_TIME		500
+#define TEST_C2HINT_WAIT_TIME		500
+#define HCI_TEST_SYSCFG_HWMASK		1
+#define _BUSCLK_40M			(4 << 2)
+
+//------------------------------------------------------------------------------
+typedef struct CFG_DBG_MSG_STRUCT {
+	u32 DebugLevel;
+	u32 DebugComponent_H32;
+	u32 DebugComponent_L32;
+}CFG_DBG_MSG_STRUCT,*PCFG_DBG_MSG_STRUCT;
+
+typedef struct _RW_REG {
+	uint offset;
+	uint width;
+	u32 value;
+}mp_rw_reg,RW_Reg, *pRW_Reg;
+
+//for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM
+typedef struct _EEPROM_RW_PARAM {
+	uint offset;
+	u16 value;
+}eeprom_rw_param,EEPROM_RWParam, *pEEPROM_RWParam;
+
+typedef struct _EFUSE_ACCESS_STRUCT_ {
+	u16	start_addr;
+	u16	cnts;
+	u8	data[0];
+}EFUSE_ACCESS_STRUCT, *PEFUSE_ACCESS_STRUCT;
+
+typedef struct _BURST_RW_REG {
+	uint offset;
+	uint len;
+	u8 Data[256];
+}burst_rw_reg,Burst_RW_Reg, *pBurst_RW_Reg;
+
+typedef struct _USB_VendorReq{
+	u8	bRequest;
+	u16	wValue;
+	u16	wIndex;
+	u16	wLength;
+	u8	u8Dir;//0:OUT, 1:IN
+	u8	u8InData;
+}usb_vendor_req, USB_VendorReq, *pUSB_VendorReq;
+
+typedef struct _DR_VARIABLE_STRUCT_ {
+	u8 offset;
+	u32 variable;
+}DR_VARIABLE_STRUCT;
+
+int mp_start_joinbss(_adapter *padapter, NDIS_802_11_SSID *pssid);
+
+void _irqlevel_changed_(_irqL *irqlevel, /*BOOLEAN*/unsigned char  bLower);
+
+
+// oid_rtl_seg_87_11_00
+NDIS_STATUS oid_rt_pro8711_join_bss_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_read_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_write_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write16_eeprom_hdl (struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_rd_attrib_mem_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_wr_attrib_mem_hdl (struct oid_par_priv* poid_par_priv);
+NDIS_STATUS  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_poll_rx_status_hdl(struct oid_par_priv* poid_par_priv);
+// oid_rtl_seg_87_11_20
+NDIS_STATUS oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_tssi_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_87_11_50
+NDIS_STATUS oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_87_11_F0
+NDIS_STATUS oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_80_00
+NDIS_STATUS oid_rt_pro_set_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_start_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_stop_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_81_80_20
+NDIS_STATUS oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_modulation_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_87
+NDIS_STATUS oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_85
+NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+//oid_rtl_seg_87_12_00
+NDIS_STATUS oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_add_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_set_bandwidth_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_crystal_cap_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_max_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_get_thermal_meter_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_set_power_down_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+#ifdef _RTL871X_MP_IOCTL_C_
+
+const struct oid_obj_priv oid_rtl_seg_81_80_00[] =
+{
+	{1, &oid_null_function},			//0x00	OID_RT_PRO_RESET_DUT
+	{1, &oid_rt_pro_set_data_rate_hdl},		//0x01
+	{1, &oid_rt_pro_start_test_hdl},		//0x02
+	{1, &oid_rt_pro_stop_test_hdl},			//0x03
+	{1, &oid_null_function},			//0x04	OID_RT_PRO_SET_PREAMBLE
+	{1, &oid_null_function},			//0x05	OID_RT_PRO_SET_SCRAMBLER
+	{1, &oid_null_function},			//0x06	OID_RT_PRO_SET_FILTER_BB
+	{1, &oid_null_function},			//0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	//0x08
+	{1, &oid_null_function},			//0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL
+	{1, &oid_null_function},			//0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL
+	{1, &oid_rt_pro_set_continuous_tx_hdl},		//0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	//0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS
+	{1, &oid_null_function},			//0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		//0x0E
+	{1, &oid_null_function},			//0x0F	OID_RT_PRO_SET_CR_SCRAMBLER
+	{1, &oid_null_function},			//0x10	OID_RT_PRO_SET_CR_NEW_FILTER
+	{1, &oid_rt_pro_set_tx_power_control_hdl},	//0x11	OID_RT_PRO_SET_TX_POWER_CONTROL
+	{1, &oid_null_function},			//0x12	OID_RT_PRO_SET_CR_TX_CONFIG
+	{1, &oid_null_function},			//0x13	OID_RT_PRO_GET_TX_POWER_CONTROL
+	{1, &oid_null_function},			//0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x15	OID_RT_PRO_SET_CR_SETPOINT
+	{1, &oid_null_function},			//0x16	OID_RT_PRO_SET_INTEGRATOR
+	{1, &oid_null_function},			//0x17	OID_RT_PRO_SET_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x18	OID_RT_PRO_GET_INTEGRATOR
+	{1, &oid_null_function},			//0x19	OID_RT_PRO_GET_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE
+	{1, &oid_null_function},			//0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS
+	{1, &oid_null_function},			//0x1C	OID_RT_PRO_READ_MAC_ADDRESS
+	{1, &oid_null_function},			//0x1D	OID_RT_PRO_WRITE_CIS_DATA
+	{1, &oid_null_function},			//0x1E	OID_RT_PRO_READ_CIS_DATA
+	{1, &oid_null_function}				//0x1F	OID_RT_PRO_WRITE_POWER_CONTROL
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_20[] =
+{
+	{1, &oid_null_function},			//0x20	OID_RT_PRO_READ_POWER_CONTROL
+	{1, &oid_null_function},			//0x21	OID_RT_PRO_WRITE_EEPROM
+	{1, &oid_null_function},			//0x22	OID_RT_PRO_READ_EEPROM
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	//0x23
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	//0x24
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	//0x25
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	//0x26
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	//0x27
+	{1, &oid_null_function},			//0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS
+	{1, &oid_null_function},			//0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS
+	{1, &oid_null_function},			//0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},//0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX
+	{1, &oid_null_function},			//0x2C	OID_RT_PRO_RECEIVE_PACKET
+	{1, &oid_null_function},			//0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE
+	{1, &oid_null_function},			//0x2E	OID_RT_PRO_READ_EEPROM_BYTE
+	{1, &oid_rt_pro_set_modulation_hdl}		//0x2F
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_40[] =
+{
+	{1, &oid_null_function},			//0x40
+	{1, &oid_null_function},			//0x41
+	{1, &oid_null_function},			//0x42
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	//0x43
+	{1, &oid_null_function},			//0x44
+	{1, &oid_null_function}				//0x45
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_80[] =
+{
+	{1, &oid_null_function},			//0x80	OID_RT_DRIVER_OPTION
+	{1, &oid_null_function},			//0x81	OID_RT_RF_OFF
+	{1, &oid_null_function}				//0x82	OID_RT_AUTH_STATUS
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_85[] =
+{
+	{1, &oid_rt_wireless_mode_hdl}			//0x00	OID_RT_WIRELESS_MODE
+};
+
+struct oid_obj_priv oid_rtl_seg_81_87[] =
+{
+	{1, &oid_null_function},			//0x80	OID_RT_PRO8187_WI_POLL
+	{1, &oid_rt_pro_write_bb_reg_hdl},		//0x81
+	{1, &oid_rt_pro_read_bb_reg_hdl},		//0x82
+	{1, &oid_rt_pro_write_rf_reg_hdl},		//0x82
+	{1, &oid_rt_pro_read_rf_reg_hdl}		//0x83
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_00[] =
+{
+	{1, &oid_rt_pro8711_join_bss_hdl},		//0x00  //S
+	{1, &oid_rt_pro_read_register_hdl},		//0x01
+	{1, &oid_rt_pro_write_register_hdl},		//0x02
+	{1, &oid_rt_pro_burst_read_register_hdl},	//0x03
+	{1, &oid_rt_pro_burst_write_register_hdl},	//0x04
+	{1, &oid_rt_pro_write_txcmd_hdl},		//0x05
+	{1, &oid_rt_pro_read16_eeprom_hdl},		//0x06
+	{1, &oid_rt_pro_write16_eeprom_hdl},		//0x07
+	{1, &oid_null_function},			//0x08	OID_RT_PRO_H2C_SET_COMMAND
+	{1, &oid_null_function},			//0x09	OID_RT_PRO_H2C_QUERY_RESULT
+	{1, &oid_rt_pro8711_wi_poll_hdl},		//0x0A
+	{1, &oid_rt_pro8711_pkt_loss_hdl},		//0x0B
+	{1, &oid_rt_rd_attrib_mem_hdl},			//0x0C
+	{1, &oid_rt_wr_attrib_mem_hdl},			//0x0D
+	{1, &oid_null_function},			//0x0E
+	{1, &oid_null_function},			//0x0F
+	{1, &oid_null_function},			//0x10	OID_RT_PRO_H2C_CMD_MODE
+	{1, &oid_null_function},			//0x11	OID_RT_PRO_H2C_CMD_RSP_MODE
+	{1, &oid_null_function},			//0X12	OID_RT_PRO_WAIT_C2H_EVENT
+	{1, &oid_null_function},			//0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST
+	{1, &oid_null_function},			//0X14	OID_RT_PRO_SCSI_ACCESS_TEST
+	{1, &oid_null_function},			//0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT
+	{1, &oid_null_function},			//0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN
+	{1, &oid_null_function},			//0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL
+	{1, &oid_null_function},			//0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL
+	{1, &oid_null_function},			//0X19	OID_RT_RPO_SET_PWRMGT_TEST
+	{1, &oid_null_function},			//0X1A
+	{1, &oid_null_function},			//0X1B	OID_RT_PRO_QRY_PWRMGT_TEST
+	{1, &oid_null_function},			//0X1C	OID_RT_RPO_ASYNC_RWIO_TEST
+	{1, &oid_null_function},			//0X1D	OID_RT_RPO_ASYNC_RWIO_POLL
+	{1, &oid_rt_pro_set_rf_intfs_hdl},		//0X1E
+	{1, &oid_rt_poll_rx_status_hdl}			//0X1F
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_20[] =
+{
+	{1, &oid_rt_pro_cfg_debug_message_hdl},		//0x20
+	{1, &oid_rt_pro_set_data_rate_ex_hdl},		//0x21
+	{1, &oid_rt_pro_set_basic_rate_hdl},		//0x22
+	{1, &oid_rt_pro_read_tssi_hdl},			//0x23
+	{1, &oid_rt_pro_set_power_tracking_hdl}		//0x24
+};
+
+
+struct oid_obj_priv oid_rtl_seg_87_11_50[] =
+{
+	{1, &oid_rt_pro_qry_pwrstate_hdl},		//0x50
+	{1, &oid_rt_pro_set_pwrstate_hdl}		//0x51
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_80[] =
+{
+	{1, &oid_null_function}				//0x80
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_B0[] =
+{
+	{1, &oid_null_function}				//0xB0
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_F0[] =
+{
+	{1, &oid_null_function},			//0xF0
+	{1, &oid_null_function},			//0xF1
+	{1, &oid_null_function},			//0xF2
+	{1, &oid_null_function},			//0xF3
+	{1, &oid_null_function},			//0xF4
+	{1, &oid_null_function},			//0xF5
+	{1, &oid_null_function},			//0xF6
+	{1, &oid_null_function},			//0xF7
+	{1, &oid_null_function},			//0xF8
+	{1, &oid_null_function},			//0xF9
+	{1, &oid_null_function},			//0xFA
+	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	//0xFB
+	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	//0xFC
+	{1, &oid_null_function},			//0xFD
+	{1, &oid_null_function},			//0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST
+	{1, &oid_null_function}				//0xFF
+
+};
+
+struct oid_obj_priv oid_rtl_seg_87_12_00[]=
+{
+	{1, &oid_rt_pro_encryption_ctrl_hdl},		//0x00	Q&S
+	{1, &oid_rt_pro_add_sta_info_hdl},		//0x01	S
+	{1, &oid_rt_pro_dele_sta_info_hdl},		//0x02	S
+	{1, &oid_rt_pro_query_dr_variable_hdl},		//0x03	Q
+	{1, &oid_rt_pro_rx_packet_type_hdl},		//0x04	Q,S
+	{1, &oid_rt_pro_read_efuse_hdl},		//0x05	Q	OID_RT_PRO_READ_EFUSE
+	{1, &oid_rt_pro_write_efuse_hdl},		//0x06	S	OID_RT_PRO_WRITE_EFUSE
+	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		//0x07	Q,S
+	{1, &oid_rt_get_efuse_current_size_hdl},	//0x08 	Q
+	{1, &oid_rt_set_bandwidth_hdl},			//0x09
+	{1, &oid_rt_set_crystal_cap_hdl},		//0x0a
+	{1, &oid_rt_set_rx_packet_type_hdl},		//0x0b	S
+	{1, &oid_rt_get_efuse_max_size_hdl},		//0x0c
+	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		//0x0d
+	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		//0x0e
+	{1, &oid_null_function},			//0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING
+	{1, &oid_rt_get_thermal_meter_hdl},		//0x10	Q	OID_RT_PRO_GET_THERMAL_METER
+	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	//0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT
+	{1, &oid_rt_get_phy_rx_packet_received_hdl},	//0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED
+	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	//0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR
+	{1, &oid_rt_set_power_down_hdl},		//0x14	Q	OID_RT_SET_POWER_DOWN
+	{1, &oid_rt_get_power_mode_hdl}			//0x15	Q	OID_RT_GET_POWER_MODE
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+
+enum MP_MODE {
+	MP_START_MODE,
+	MP_STOP_MODE,
+	MP_ERR_MODE
+};
+
+struct rwreg_param{
+	unsigned int offset;
+	unsigned int width;
+	unsigned int value;
+};
+
+struct bbreg_param{
+	unsigned int offset;
+	unsigned int phymask;
+	unsigned int value;
+};
+/*
+struct rfchannel_param{
+	unsigned int ch;
+	unsigned int modem;
+};
+*/
+struct txpower_param{
+	unsigned int pwr_index;
+};
+
+
+struct datarate_param{
+	unsigned int rate_index;
+};
+
+
+struct rfintfs_parm {
+	unsigned int rfintfs;
+};
+
+struct mp_xmit_packet {
+	unsigned int len;
+	unsigned int mem[MAX_MP_XMITBUF_SZ >> 2];
+};
+
+struct psmode_param {
+	unsigned int ps_mode;
+	unsigned int smart_ps;
+};
+
+//for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM
+struct eeprom_rw_param {
+	unsigned int offset;
+	unsigned short value;
+};
+
+struct mp_ioctl_handler {
+	unsigned int paramsize;
+	unsigned int (*handler)(struct oid_par_priv* poid_par_priv);
+	unsigned int oid;
+};
+
+struct mp_ioctl_param{
+	unsigned int subcode;
+	unsigned int len;
+	unsigned char data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START), 		/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP), 			/*1*/
+	GEN_MP_IOCTL_SUBCODE(READ_REG), 		/*2*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),		/*4*/
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*6*/
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),		/*7*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),		/*9*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_RF_INTFS),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),	/*12*/
+	GEN_MP_IOCTL_SUBCODE(PS_STATE),			/*13*/
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),		/*14*/
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),		/*15*/
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),			/*16*/
+	GEN_MP_IOCTL_SUBCODE(READ_TSSI),		/*17*/
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),			/*18*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),		/*19*/
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),		/*20*/
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),	/*21*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*22*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),	/*23*/
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*24*/
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),	/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_POWER_MODE),		/*26*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE),			/*27*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*28*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),	/*29*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),	/*30*/
+	GEN_MP_IOCTL_SUBCODE(SC_TX),			/*31*/
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*32*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),			/*33*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+#ifdef _RTL871X_MP_IOCTL_C_
+
+#define GEN_MP_IOCTL_HANDLER(sz, hdl, oid) {sz, hdl, oid},
+
+#define EXT_MP_IOCTL_HANDLER(sz, subcode, oid) {sz, &mp_ioctl_ ## subcode ## _hdl, oid},
+
+
+struct mp_ioctl_handler mp_ioctl_hdl[] = {
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_start_test_hdl, OID_RT_PRO_START_TEST)/*0*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_stop_test_hdl, OID_RT_PRO_STOP_TEST)/*1*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_register_hdl, OID_RT_PRO_READ_REGISTER)/*2*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_register_hdl, OID_RT_PRO_WRITE_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_channel_direct_call_hdl, OID_RT_PRO_SET_CHANNEL_DIRECT_CALL)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct txpower_param), oid_rt_pro_set_tx_power_control_hdl, OID_RT_PRO_SET_TX_POWER_CONTROL)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_data_rate_hdl, OID_RT_PRO_SET_DATA_RATE)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_read_bb_reg_hdl, OID_RT_PRO_READ_BB_REG)/*7*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_write_bb_reg_hdl, OID_RT_PRO_WRITE_BB_REG)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_rf_reg_hdl, OID_RT_PRO_RF_READ_REGISTRY)/*9*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_rf_reg_hdl, OID_RT_PRO_RF_WRITE_REGISTRY)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rfintfs_parm), NULL, 0)
+
+	EXT_MP_IOCTL_HANDLER(0, xmit_packet, 0)/*12*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct psmode_param), NULL, 0)/*13*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)/*14*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)/*15*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(unsigned char), NULL, 0)/*16*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), NULL, 0)/*17*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_continuous_tx_hdl, OID_RT_PRO_SET_CONTINUOUS_TX)/*18*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_bandwidth_hdl, OID_RT_SET_BANDWIDTH)/*19*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_rx_packet_type_hdl, OID_RT_SET_RX_PACKET_TYPE)/*20*/
+	GEN_MP_IOCTL_HANDLER(0, oid_rt_reset_phy_rx_packet_count_hdl, OID_RT_RESET_PHY_RX_PACKET_COUNT)/*21*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl, OID_RT_GET_PHY_RX_PACKET_RECEIVED)/*22*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl, OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR)/*23*/
+	GEN_MP_IOCTL_HANDLER(sizeof(unsigned char), oid_rt_set_power_down_hdl, OID_RT_SET_POWER_DOWN)/*24*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_thermal_meter_hdl, OID_RT_PRO_GET_THERMAL_METER)/*25*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_power_mode_hdl, OID_RT_GET_POWER_MODE)/*26*/
+	GEN_MP_IOCTL_HANDLER(sizeof(EFUSE_ACCESS_STRUCT), oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE)/*27*/
+	GEN_MP_IOCTL_HANDLER(EFUSE_MAP_MAX_SIZE, oid_rt_pro_efuse_map_hdl, OID_RT_PRO_EFUSE_MAP)/*28*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_max_size_hdl, OID_RT_GET_EFUSE_MAX_SIZE)/*29*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_current_size_hdl, OID_RT_GET_EFUSE_CURRENT_SIZE)/*30*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl, OID_RT_PRO_SET_SINGLE_CARRIER_TX)/*31*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl, OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX)/*32*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl, OID_RT_PRO_SET_SINGLE_TONE_TX)/*33*/
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_mp_phy_regdef.h b/drivers/net/wireless/8712u/include/rtl871x_mp_phy_regdef.h
new file mode 100755
index 0000000..1287fe6
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_mp_phy_regdef.h
@@ -0,0 +1,1068 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_MP_PHY_REGDEF_H
+#define __RTL871X_MP_PHY_REGDEF_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       8192S Regsiter offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+//#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+//#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+//#define rFPGA0_XC_RFTiming        		0x818
+//#define rFPGA0_XD_RFTiming        		0x81c
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rFPGA0_XC_HSSIParameter1		0x830
+#define		rFPGA0_XC_HSSIParameter2		0x834
+#define		rFPGA0_XD_HSSIParameter1		0x838
+#define		rFPGA0_XD_HSSIParameter2		0x83c
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+#define		rFPGA0_XC_LSSIParameter		0x848
+#define		rFPGA0_XD_LSSIParameter		0x84c
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XC_RFInterfaceOE		0x868
+#define		rFPGA0_XD_RFInterfaceOE		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_Rate18_06				0xe00
+#define		rTxAGC_Rate54_24				0xe04
+#define		rTxAGC_CCK_Mcs32				0xe08
+#define		rTxAGC_Mcs03_Mcs00			0xe10
+#define		rTxAGC_Mcs07_Mcs04			0xe14
+#define		rTxAGC_Mcs11_Mcs08			0xe18
+#define		rTxAGC_Mcs15_Mcs12			0xe1c
+
+// Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register]
+#define 		rRx_Wait_CCCA					0xe70
+#define		rAnapar_Ctrl_BB					0xee0
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define RTL92SE_FPGA_VERIFY 0
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+//#if (RTL92SE_FPGA_VERIFY == 1)
+#define		rZebra1_Channel				0x7	// RF channel switch
+//#else
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	//
+
+#define		RF_IQADJ_G1				0x01	//
+#define		RF_IQADJ_G2				0x02	//
+#define		RF_POW_TRSW				0x05	//
+
+#define		RF_GAIN_RX					0x06	//
+#define		RF_GAIN_TX					0x07	//
+
+#define		RF_TXM_IDAC				0x08	//
+#define		RF_BS_IQGEN				0x0F	//
+
+#define		RF_MODE1					0x10	//
+#define		RF_MODE2					0x11	//
+
+#define		RF_RX_AGC_HP				0x12	//
+#define		RF_TX_AGC					0x13	//
+#define		RF_BIAS						0x14	//
+#define		RF_IPA						0x15	//
+#define		RF_POW_ABILITY			0x17	//
+#define		RF_MODE_AG				0x18	//
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	//
+
+#define		RF_RX_G1					0x1A	//
+#define		RF_RX_G2					0x1B	//
+
+#define		RF_RX_BB2					0x1C	//
+#define		RF_RX_BB1					0x1D	//
+
+#define		RF_RCK1					0x1E	//
+#define		RF_RCK2					0x1F	//
+
+#define		RF_TX_G1					0x20	//
+#define		RF_TX_G2					0x21	//
+#define		RF_TX_G3					0x22	//
+
+#define		RF_TX_BB1					0x23	//
+
+#define		RF_T_METER					0x24	//
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadAddress          		0x3f000000   //LSSI "Read" Address	// Reg 0x824 rFPGA0_XA_HSSIParameter2
+#else
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+#endif
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadBackData         		0xfff		// Reg 0x8a0 rFPGA0_XA_LSSIReadBack
+#else
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+#endif
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving         		0x80
+#define		bCCKRxPowerSaving         		0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                			0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable      		0x8000
+#define		bCCKFalseAlarmRead        		0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       		0x80000000
+#define		bCCKRxReport_MFOff        		0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      		0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       		0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       		0x4000
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             			0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             			0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               			0x3ff
+#define		bRXIQImb_B               			0xfc00
+#define		bRXIQImb_C               			0x3f0000
+#define		bRXIQImb_D               			0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              			0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              			0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              			0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     		0xe00
+#define		bFrame_Weight_Short      		0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              			0x10000
+#define		bTXIQImb_A               			0x3ff
+#define		bTXIQImb_B               			0xfc00
+#define		bTXIQImb_C               			0x3f0000
+#define		bTXIQImb_D               			0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             			0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED               0x300
+#define		bRxInitialGain           0x7f
+#define		bRxAntDivEn              0x80
+#define		bRxAGCAddressForLNA      0x7f00
+#define		bRxHighPowerFlow         0x8000
+#define		bRxAGCFreezeThres        0xc0000
+#define		bRxFreezeStep_AGC1       0x300000
+#define		bRxFreezeStep_AGC2       0xc00000
+#define		bRxFreezeStep_AGC3       0x3000000
+#define		bRxFreezeStep_AGC0       0xc000000
+#define		bRxRssi_Cmp_En           0x10000000
+#define		bRxQuickAGCEn            0x20000000
+#define		bRxAGCFreezeThresMode    0x40000000
+#define		bRxOverFlowCheckType     0x80000000
+#define		bRxAGCShift              0x7f
+#define		bTRSW_Tri_Only           0x80
+#define		bPowerThres              0x300
+#define		bRxAGCEn                 0x1
+#define		bRxAGCTogetherEn         0x2
+#define		bRxAGCMin                0x4
+#define		bRxHP_Ini                0x7
+#define		bRxHP_TRLNA              0x70
+#define		bRxHP_RSSI               0x700
+#define		bRxHP_BBP1               0x7000
+#define		bRxHP_BBP2               0x70000
+#define		bRxHP_BBP3               0x700000
+#define		bRSSI_H                  0x7f0000     //the threshold for high power
+#define		bRSSI_Gen                0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW           0x7
+#define		bRxSettle_LNA            0x38
+#define		bRxSettle_RSSI           0x1c0
+#define		bRxSettle_BBP            0xe00
+#define		bRxSettle_RxHP           0x7000
+#define		bRxSettle_AntSW_RSSI     0x38000
+#define		bRxSettle_AntSW          0xc0000
+#define		bRxProcessTime_DAGC      0x300000
+#define		bRxSettle_HSSI           0x400000
+#define		bRxProcessTime_BBPPW     0x800000
+#define		bRxAntennaPowerShift     0x3000000
+#define		bRSSITableSelect         0xc000000
+#define		bRxHP_Final              0x7000000
+#define		bRxHTSettle_BBP          0x7
+#define		bRxHTSettle_HSSI         0x8
+#define		bRxHTSettle_RxHP         0x70
+#define		bRxHTSettle_BBPPW        0x80
+#define		bRxHTSettle_Idle         0x300
+#define		bRxHTSettle_Reserved     0x1c00
+#define		bRxHTRxHPEn              0x8000
+#define		bRxHTAGCFreezeThres      0x30000
+#define		bRxHTAGCTogetherEn       0x40000
+#define		bRxHTAGCMin              0x80000
+#define		bRxHTAGCEn               0x100000
+#define		bRxHTDAGCEn              0x200000
+#define		bRxHTRxHP_BBP            0x1c00000
+#define		bRxHTRxHP_Final          0xe0000000
+#define		bRxPWRatioTH             0x3
+#define		bRxPWRatioEn             0x4
+#define		bRxMFHold                0x3800
+#define		bRxPD_Delay_TH1          0x38
+#define		bRxPD_Delay_TH2          0x1c0
+#define		bRxPD_DC_COUNT_MAX       0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH           0x8000
+#define		bRxProcess_Delay         0xf0000
+#define		bRxSearchrange_GI2_Early 0x700000
+#define		bRxFrame_Guard_Counter_L 0x3800000
+#define		bRxSGI_Guard_L           0xc000000
+#define		bRxSGI_Search_L          0x30000000
+#define		bRxSGI_TH                0xc0000000
+#define		bDFSCnt0                 0xff
+#define		bDFSCnt1                 0xff00
+#define		bDFSFlag                 0xf0000
+#define		bMFWeightSum             0x300000
+#define		bMinIdxTH                0x7f000000
+#define		bDAFormat                0x40000
+#define		bTxChEmuEnable           0x01000000
+#define		bTRSWIsolation_A         0x7f
+#define		bTRSWIsolation_B         0x7f00
+#define		bTRSWIsolation_C         0x7f0000
+#define		bTRSWIsolation_D         0x7f000000
+#define		bExtLNAGain              0x7c00
+
+// 6. PageE(0xE00)
+#define		bSTBCEn                  0x4	// Useless
+#define		bAntennaMapping          0x10
+#define		bNss                     0x20
+#define		bCFOAntSumD              0x200
+#define		bPHYCounterReset         0x8000000
+#define		bCFOReportGet            0x4000000
+#define		bOFDMContinueTx          0x10000000
+#define		bOFDMSingleCarrier       0x20000000
+#define		bOFDMSingleTone          0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect                0x100
+#define		bCFOEn                   0x10000
+#define		bCFOValue                0xfff00000
+#define		bSigTone_Re              0x3f
+#define		bSigTone_Im              0x7f00
+#define		bCounter_CCA             0xffff
+#define		bCounter_ParityFail      0xffff0000
+#define		bCounter_RateIllegal     0xffff
+#define		bCounter_CRC8Fail        0xffff0000
+#define		bCounter_MCSNoSupport    0xffff
+#define		bCounter_FastSync        0xffff
+#define		bShortCFO                0xfff
+#define		bShortCFOTLength         12   //total
+#define		bShortCFOFLength         11   //fraction
+#define		bLongCFO                 0x7ff
+#define		bLongCFOTLength          11
+#define		bLongCFOFLength          11
+#define		bTailCFO                 0x1fff
+#define		bTailCFOTLength          13
+#define		bTailCFOFLength          12
+#define		bmax_en_pwdB             0xffff
+#define		bCC_power_dB             0xffff0000
+#define		bnoise_pwdB              0xffff
+#define		bPowerMeasTLength        10
+#define		bPowerMeasFLength        3
+#define		bRx_HT_BW                0x1
+#define		bRxSC                    0x6
+#define		bRx_HT                   0x8
+#define		bNB_intf_det_on          0x1
+#define		bIntf_win_len_cfg        0x30
+#define		bNB_Intf_TH_cfg          0x1c0
+#define		bRFGain                  0x3f
+#define		bTableSel                0x40
+#define		bTRSW                    0x80
+#define		bRxSNR_A                 0xff
+#define		bRxSNR_B                 0xff00
+#define		bRxSNR_C                 0xff0000
+#define		bRxSNR_D                 0xff000000
+#define		bSNREVMTLength           8
+#define		bSNREVMFLength           1
+#define		bCSI1st                  0xff
+#define		bCSI2nd                  0xff00
+#define		bRxEVM1st                0xff0000
+#define		bRxEVM2nd                0xff000000
+#define		bSIGEVM                  0xff
+#define		bPWDB                    0xff00
+#define		bSGIEN                   0x10000
+
+#define		bSFactorQAM1             0xf	// Useless
+#define		bSFactorQAM2             0xf0
+#define		bSFactorQAM3             0xf00
+#define		bSFactorQAM4             0xf000
+#define		bSFactorQAM5             0xf0000
+#define		bSFactorQAM6             0xf0000
+#define		bSFactorQAM7             0xf00000
+#define		bSFactorQAM8             0xf000000
+#define		bSFactorQAM9             0xf0000000
+#define		bCSIScheme               0x100000
+
+#define		bNoiseLvlTopSet          0x3	// Useless
+#define		bChSmooth                0x4
+#define		bChSmoothCfg1            0x38
+#define		bChSmoothCfg2            0x1c0
+#define		bChSmoothCfg3            0xe00
+#define		bChSmoothCfg4            0x7000
+#define		bMRCMode                 0x800000
+#define		bTHEVMCfg                0x7000000
+
+#define		bLoopFitType             0x1	// Useless
+#define		bUpdCFO                  0x40
+#define		bUpdCFOOffData           0x80
+#define		bAdvUpdCFO               0x100
+#define		bAdvTimeCtrl             0x800
+#define		bUpdClko                 0x1000
+#define		bFC                      0x6000
+#define		bTrackingMode            0x8000
+#define		bPhCmpEnable             0x10000
+#define		bUpdClkoLTF              0x20000
+#define		bComChCFO                0x40000
+#define		bCSIEstiMode             0x80000
+#define		bAdvUpdEqz               0x100000
+#define		bUChCfg                  0x7000000
+#define		bUpdEqz                  0x8000000
+
+#define		bTxAGCRate18_06			0x7f7f7f7f	// Useless
+#define		bTxAGCRate54_24			0x7f7f7f7f
+#define		bTxAGCRateMCS32			0x7f
+#define		bTxAGCRateCCK			0x7f00
+#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
+#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
+#define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn         0x20000000	// Useless
+#define		bRxPesudoNoise_A         0xff
+#define		bRxPesudoNoise_B         0xff00
+#define		bRxPesudoNoise_C         0xff0000
+#define		bRxPesudoNoise_D         0xff000000
+#define		bPesudoNoiseState_A      0xffff
+#define		bPesudoNoiseState_B      0xffff0000
+#define		bPesudoNoiseState_C      0xffff
+#define		bPesudoNoiseState_D      0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable        0x8		// Useless
+#define		bZebra1_TRxControl        0xc00
+#define		bZebra1_TRxGainSetting    0x07f
+#define		bZebra1_RxCorner          0xc00
+#define		bZebra1_TxChargePump      0x38
+#define		bZebra1_RxChargePump      0x7
+#define		bZebra1_ChannelNum        0xf80
+#define		bZebra1_TxLPFBW           0x400
+#define		bZebra1_RxLPFBW           0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1      0x100	// Useless
+#define		bRTL8256RegModeCtrl0      0x40
+#define		bRTL8256_TxLPFBW          0x18
+#define		bRTL8256_RxLPFBW          0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW          0xc	// Useless
+#define		bRTL8258_RxLPFBW          0xc00
+#define		bRTL8258_RSSILPFBW        0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0                    0x1	// Useless
+#define		bByte1                    0x2
+#define		bByte2                    0x4
+#define		bByte3                    0x8
+#define		bWord0                    0x3
+#define		bWord1                    0xc
+#define		bDWord                    0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0                0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1                0xff00
+#define		bMaskByte2                0xff0000
+#define		bMaskByte3                0xff000000
+#define		bMaskHWord                0xffff0000
+#define		bMaskLWord                0x0000ffff
+#define		bMaskDWord                0xffffffff
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+#if (RTL92SE_FPGA_VERIFY == 1)
+//#define		bMask12Bits               0xfff	// RF Reg mask bits
+//#define		bMask20Bits               0xfff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfff
+#else
+//#define		bMask12Bits               0xfffff	// RF Reg mask bits
+//#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfffff
+#endif
+#define		bEnable                   0x1	// Useless
+#define		bDisable                  0x0
+
+#define		LeftAntenna               0x0	// Useless
+#define		RightAntenna              0x1
+
+#define		tCheckTxStatus            500   //500ms // Useless
+#define		tUpdateRxCounter          100   //100ms
+
+#define		rateCCK     0	// Useless
+#define		rateOFDM    1
+#define		rateHT      2
+
+//define Register-End
+#define		bPMAC_End                 0x1ff	// Useless
+#define		bFPGAPHY0_End             0x8ff
+#define		bFPGAPHY1_End             0x9ff
+#define		bCCKPHY0_End              0xaff
+#define		bOFDMPHY0_End             0xcff
+#define		bOFDMPHY1_End             0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl	0x0		// Useless
+#define		bWMACControl	0x1
+#define		bWNICControl	0x2
+
+#define		ANTENNA_A	0x1	// Useless
+#define		ANTENNA_B	0x2
+#define		ANTENNA_AB	0x3	// ANTENNA_A |ANTENNA_B
+
+#define		ANTENNA_C	0x4
+#define		ANTENNA_D	0x8
+
+
+#define RCR_AAP			BIT(0)				// accept all physical address
+#define RCR_APM			BIT(1)				// accept physical match
+#define RCR_AM			BIT(2)				// accept multicast
+#define RCR_AB			BIT(3)				// accept broadcast
+#define RCR_ACRC32		BIT(5)				// accept error packet
+#define RCR_9356SEL		BIT(6)
+#define RCR_AICV		BIT(12)				// Accept ICV error packet
+#define RCR_RXFTH0		(BIT(13)|BIT(14)|BIT(15))	// Rx FIFO threshold
+#define RCR_ADF			BIT(18)				// Accept Data(frame type) frame
+#define RCR_ACF			BIT(19)				// Accept control frame
+#define RCR_AMF			BIT(20)				// Accept management frame
+#define RCR_ADD3		BIT(21)
+#define RCR_APWRMGT		BIT(22)				// Accept power management packet
+#define RCR_CBSSID		BIT(23)				// Accept BSSID match packet
+#define RCR_ENMARP		BIT(28)				// enable mac auto reset phy
+#define RCR_EnCS1		BIT(29)				// enable carrier sense method 1
+#define RCR_EnCS2		BIT(30)				// enable carrier sense method 2
+#define RCR_OnlyErlPkt		BIT(31)				// Rx Early mode is performed for packet size greater than 1536
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	//__INC_HAL8192SPHYREG_H
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_pwrctrl.h b/drivers/net/wireless/8712u/include/rtl871x_pwrctrl.h
new file mode 100755
index 0000000..9ad3254
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_pwrctrl.h
@@ -0,0 +1,179 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_PWRCTRL_H_
+#define __RTL871X_PWRCTRL_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>		
+#include <drv_types.h>
+
+
+#define FW_PWR0	0	
+#define FW_PWR1 	1
+#define FW_PWR2 	2
+#define FW_PWR3 	3
+
+
+#define HW_PWR0	7	
+#define HW_PWR1 	6
+#define HW_PWR2 	2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+
+
+enum Power_Mgnt
+{
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM
+};
+
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define 	PS_DPS				BIT(0)
+#define 	PS_LCLK				(PS_DPS)
+#define	PS_RF_OFF			BIT(1)
+#define	PS_ALL_ON			BIT(2)
+#define	PS_ST_ACTIVE		BIT(3)
+#define	PS_LP				BIT(4)	// low performance
+
+#define	PS_STATE_MASK		(0x0F)
+#define	PS_STATE_HW_MASK	(0x07)
+#define 	PS_SEQ_MASK		(0xc0)
+
+#define	PS_STATE(x)			(PS_STATE_MASK & (x))
+#define	PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define	PS_SEQ(x)			(PS_SEQ_MASK & (x))
+
+#define	PS_STATE_S0		(PS_DPS)
+#define 	PS_STATE_S1		(PS_LCLK)
+#define	PS_STATE_S2		(PS_RF_OFF)
+#define 	PS_STATE_S3		(PS_ALL_ON)
+#define	PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define 	PS_IS_RF_ON(x)		((x) & (PS_ALL_ON))
+#define 	PS_IS_ACTIVE(x)		((x) & (PS_ST_ACTIVE))
+#define 	CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; //the CPWM value
+	unsigned short rsvd;
+}; 
+
+
+typedef _sema _pwrlock;
+
+
+static void __inline _init_pwrlock(_pwrlock *plock)
+{
+	_init_sema(plock, 1);
+}
+
+static void __inline _free_pwrlock(_pwrlock *plock)
+{
+	_free_sema(plock);
+}
+
+
+static void __inline _enter_pwrlock(_pwrlock *plock)
+{
+	_down_sema(plock);
+}
+
+
+static void __inline _exit_pwrlock(_pwrlock *plock)
+{
+	_up_sema(plock);
+}
+
+
+struct	pwrctrl_priv {
+	_pwrlock	lock;
+	volatile u8 rpwm; // requested power state for fw
+	volatile u8 cpwm; // fw current power state. updated when 1. read from HCPWM 2. driver lowers power level
+	volatile u8 tog; // toggling
+	volatile u8 cpwm_tog; // toggling
+	volatile u8 tgt_rpwm; // wanted power state 
+	uint pwr_mode;
+	uint smart_ps;
+	uint alives;
+	uint ImrContent;	// used to store original imr.
+	uint bSleep; //sleep -> active is different from active -> sleep.
+
+	_workitem SetPSModeWorkItem;
+	_workitem rpwm_workitem;
+	_timer	rpwm_check_timer;
+	u8	rpwm_retry;
+	uint	bSetPSModeWorkItemInProgress;
+
+	_sema	pnp_pwr_mgnt_sema;
+	_lock	pnp_pwr_mgnt_lock;
+	s32	pnp_current_pwr_state;
+	u8	pnp_bstop_trx;
+	u8	pnp_wwirp_pending;
+#ifdef PLATFORM_WINDOWS
+#ifdef CONFIG_USB_HCI
+	PIRP pnp_wwirp;
+	NDIS_EVENT pnp_wwirp_complete_evt;
+#endif
+#endif
+};
+
+
+
+extern void init_pwrctrl_priv(_adapter *adapter);
+extern void free_pwrctrl_priv(_adapter * adapter);
+extern sint register_tx_alive(_adapter *padapter);
+extern void unregister_tx_alive(_adapter *padapter);
+extern sint register_rx_alive(_adapter *padapter);
+extern void unregister_rx_alive(_adapter *padapter);
+extern sint register_cmd_alive(_adapter *padapter);
+extern void unregister_cmd_alive(_adapter *padapter);
+extern sint register_evt_alive(_adapter *padapter);
+extern void unregister_evt_alive(_adapter *padapter);
+extern void cpwm_int_hdl(_adapter *padapter, struct reportpwrstate_parm *preportpwrstate);
+extern void set_ps_mode(_adapter * padapter, uint ps_mode, uint smart_ps);
+extern void set_rpwm(_adapter * padapter, u8 val8);
+#endif  //__RTL871X_PWRCTRL_H_
diff --git a/drivers/net/wireless/8712u/include/rtl871x_qos.h b/drivers/net/wireless/8712u/include/rtl871x_qos.h
new file mode 100755
index 0000000..d126b4e
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_qos.h
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+
+#ifndef _RTL871X_QOS_H_
+#define _RTL871X_QOS_H_
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+
+
+
+
+struct	qos_priv	{
+	
+	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...		
+
+};
+
+
+#endif	//_RTL871X_QOS_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_recv.h b/drivers/net/wireless/8712u/include/rtl871x_recv.h
new file mode 100755
index 0000000..0d64ff9
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_recv.h
@@ -0,0 +1,514 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_RECV_H_
+#define _RTL871X_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifdef PLATFORM_OS_XP
+#define NR_RECVFRAME 256
+#else
+#define NR_RECVFRAME 256
+#endif
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+#define MAX_SUBFRAME_COUNT	64
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+static u8 SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; // Datagram Delivery Protocol
+
+static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
+static u8 oui_rfc1042[]= {0x00,0x00,0x00};
+
+/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static u8 rtw_rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 rtw_bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+/* No encapsulation header if EtherType < 0x600 (=length) */
+
+//for Rx reordering buffer control
+struct recv_reorder_ctrl
+{
+	_adapter	*padapter;
+	u16 indicate_seq;//=wstart_b, init_value=0xffff
+	u16 wend_b;
+       u8 wsize_b;	
+	u8 enable;
+	_queue pending_recvframe_queue;
+	_timer reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16 	tid_rxseq[16];
+/*	
+	unsigned short 	tid0_rxseq;
+	unsigned short 	tid1_rxseq;
+	unsigned short 	tid2_rxseq;
+	unsigned short 	tid3_rxseq;
+	unsigned short 	tid4_rxseq;
+	unsigned short 	tid5_rxseq;
+	unsigned short 	tid6_rxseq;
+	unsigned short 	tid7_rxseq;
+	unsigned short 	tid8_rxseq;
+	unsigned short 	tid9_rxseq;
+	unsigned short 	tid10_rxseq;
+	unsigned short 	tid11_rxseq;
+	unsigned short 	tid12_rxseq;
+	unsigned short 	tid13_rxseq;
+	unsigned short 	tid14_rxseq;
+	unsigned short 	tid15_rxseq;
+*/
+};
+
+#define		PHY_RSSI_SLID_WIN_MAX				100
+#define		PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+struct smooth_rssi_data {
+	u32	elements[100];	//array to store values
+	u32	index;			//index to current array to store
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+
+struct rx_pkt_attrib	{
+
+	u8 	amsdu;
+	u8	order;
+	u8	qos;
+	u8 	to_fr_ds;
+	u8	frag_num;
+	u16	seq_num;
+	u8   pw_save;
+	u8    mfrag;
+	u8    mdata;	
+	u8	privacy; //in frame_ctrl field
+	u8	bdecrypted;
+	int	hdrlen;		//the WLAN Header Len
+	int	encrypt;		//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	int	iv_len;
+	int	icv_len;
+	int	priority;
+	int	ack_policy;
+#ifdef CONFIG_MP_INCLUDED
+ 	u8	crc_err;
+#endif
+	u8 	dst[ETH_ALEN];
+	u8 	src[ETH_ALEN];
+	u8 	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+	u8 	bssid[ETH_ALEN];
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	u8	tcpchk_valid; // 0: invalid, 1: valid
+	u8	ip_chkrpt; //0: incorrect, 1: correct
+	u8	tcp_chkrpt; //0: incorrect, 1: correct
+#endif
+	u8	signal_qual;
+	s8	rx_mimo_signal_qual[2];
+	u8	mcs_rate;
+	u8	htc;
+	u8	signal_strength;
+};
+
+
+
+
+
+
+/*
+accesser of recv_priv: recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv {
+
+  	  _lock	lock;
+
+	_sema	recv_sema;
+	_sema	terminate_recvthread_sema;
+	
+	//_queue	blk_strms[MAX_RX_NUMBLKS];    // keeping the block ack frame until return ack
+	_queue	free_recv_queue;
+	_queue	recv_pending_queue;
+	
+
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf; 
+	
+	uint free_recvframe_cnt;
+	
+	_adapter	*adapter;
+	
+#ifdef PLATFORM_WINDOWS
+	_nic_hdl  RxPktPoolHdl;
+	_nic_hdl  RxBufPoolHdl;
+
+#ifdef PLATFORM_OS_XP
+	PMDL	pbytecnt_mdl;
+#endif
+	uint	counter; //record the number that up-layer will return to drv; only when counter==0 can we  release recv_priv 
+	NDIS_EVENT 	recv_resource_evt ;
+#endif	
+
+
+	uint	rx_bytes;
+	uint	rx_pkts;
+	uint	rx_drop;
+
+
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+
+#ifdef CONFIG_USB_HCI	
+	//u8 *pallocated_urb_buf;	
+	_sema allrxreturnevt;
+	u8  rx_pending_cnt;
+	uint	ff_hwaddr;
+#endif	
+#ifdef PLATFORM_LINUX
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+#endif
+
+
+
+#ifdef CONFIG_RTL8712       
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    // 4 alignment	
+	_queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+        u8 bytecnt_buf[512];
+//	u8 * recvbuf_drop_ori;
+	//u8 * recvbuf_drop;
+	struct recv_buf *recvbuf_drop;
+#endif
+
+	//For the phy informatiom
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 fw_rssi;
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+	//for A-MPDU Rx reordering buffer control
+	// move to sta_info
+	//struct recv_reorder_ctrl recvreorder_ctrl[16];	
+
+};
+
+
+struct sta_recv_priv {
+    
+    _lock	lock;
+	sint	option;	
+	
+	//_queue	blk_strms[MAX_RX_NUMBLKS];
+	_queue defrag_q;	 //keeping the fragment frame until defrag
+	
+	struct	stainfo_rxcache rxcache;  
+	
+	uint	sta_rx_bytes;
+	uint	sta_rx_pkts;
+	uint	sta_rx_fail;
+
+
+};
+
+
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_recv.h"
+#endif
+
+
+//rtl871x_recv.c
+extern union recv_frame *alloc_recvframe (_queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern int	 free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);  
+extern union recv_frame *dequeue_recvframe (_queue *queue);
+extern int	enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
+
+extern void free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue);  
+extern void init_recvframe(union recv_frame *precvframe ,struct recv_priv *precvpriv);
+
+
+extern int wlanhdr_to_ethhdr ( union recv_frame *precvframe);
+
+int recv_func(_adapter *padapter, void *pcontext);
+
+
+static __inline u8 *get_rxmem(union recv_frame *precvframe)
+{
+	//always return rx_head...
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_head;
+}
+
+static __inline u8 *get_rx_status(union recv_frame *precvframe)
+{
+	
+	return get_rxmem(precvframe);
+	
+}
+
+static __inline u8 *get_recvframe_data(union recv_frame *precvframe)
+{
+	
+	//alwasy return rx_data	
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_data;
+	
+}
+
+static __inline u8 *recvframe_push(union recv_frame *precvframe, sint sz)
+{	
+	// append data before rx_data 
+
+	/* add data to the start of recv_frame
+ *
+ *      This function extends the used data area of the recv_frame at the buffer
+ *      start. rx_data must be still larger than rx_head, after pushing.
+ */
+ 
+	if(precvframe==NULL)
+		return NULL;
+
+
+	precvframe->u.hdr.rx_data -= sz ;
+	if( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
+	{
+		precvframe->u.hdr.rx_data += sz ;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len +=sz;
+
+	return precvframe->u.hdr.rx_data;
+	
+}
+
+
+static __inline u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
+{
+	// rx_data += sz; move rx_data sz bytes  hereafter
+
+	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
+
+
+	if(precvframe==NULL)
+		return NULL;
+
+	
+	precvframe->u.hdr.rx_data += sz;
+
+	if(precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail)
+	{
+		precvframe->u.hdr.rx_data -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -=sz;
+	
+	return precvframe->u.hdr.rx_data;
+	
+}
+
+static __inline u8 *recvframe_put(union recv_frame *precvframe, sint sz)
+{
+	// rx_tai += sz; move rx_tail sz bytes  hereafter
+
+	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
+	//after putting, rx_tail must be still larger than rx_end. 
+ 	unsigned char * prev_rx_tail;
+
+	if(precvframe==NULL)
+		return NULL;
+
+	prev_rx_tail = precvframe->u.hdr.rx_tail;
+	
+	precvframe->u.hdr.rx_tail += sz;
+	
+	if(precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
+	{
+		precvframe->u.hdr.rx_tail -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len +=sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+static __inline u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
+{
+	// rmv data from rx_tail (by yitsen)
+	
+	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
+	//after pulling, rx_end must be still larger than rx_data.
+
+	if(precvframe==NULL)
+		return NULL;
+
+	precvframe->u.hdr.rx_tail -= sz;
+
+	if(precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data)
+	{
+		precvframe->u.hdr.rx_tail += sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -=sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+static __inline _buffer * get_rxbuf_desc(union recv_frame *precvframe)
+{
+	_buffer * buf_desc;
+	
+	if(precvframe==NULL)
+		return NULL;
+#ifdef PLATFORM_WINDOWS	
+	NdisQueryPacket(precvframe->u.hdr.pkt, NULL, NULL, &buf_desc, NULL);
+#endif
+
+	return buf_desc;
+}
+
+
+static __inline union recv_frame *rxmem_to_recvframe(u8 *rxmem)
+{
+	//due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame 
+	//from any given member of recv_frame.
+	// rxmem indicates the any member/address in recv_frame
+	
+	return (union recv_frame*)(((uint)rxmem>>RXFRAME_ALIGN) <<RXFRAME_ALIGN) ;
+	
+}
+
+static __inline union recv_frame *pkt_to_recvframe(_pkt *pkt)
+{
+	
+	u8 * buf_star;
+	union recv_frame * precv_frame;
+#ifdef PLATFORM_WINDOWS
+	_buffer * buf_desc;
+	uint len;
+
+	NdisQueryPacket(pkt, NULL, NULL, &buf_desc, &len);
+	NdisQueryBufferSafe(buf_desc, &buf_star, &len, HighPagePriority);
+#endif
+	precv_frame = rxmem_to_recvframe((unsigned char*)buf_star);
+
+	return precv_frame;
+}
+
+static __inline u8 *pkt_to_recvmem(_pkt *pkt)
+{
+	// return the rx_head
+	
+	union recv_frame * precv_frame = pkt_to_recvframe(pkt);
+
+	return 	precv_frame->u.hdr.rx_head;
+
+}
+
+static __inline u8 *pkt_to_recvdata(_pkt *pkt)
+{
+	// return the rx_data
+
+	union recv_frame * precv_frame =pkt_to_recvframe(pkt);
+
+	return 	precv_frame->u.hdr.rx_data;
+	
+}
+
+
+static __inline sint get_recvframe_len(union recv_frame *precvframe)
+{
+	return precvframe->u.hdr.len;
+}
+
+
+
+struct sta_info;
+
+extern void	_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+
+extern sint recvframe_chkmic(_adapter *adapter,  union recv_frame *precvframe);
+extern union recv_frame * decryptor(_adapter *adapter,union recv_frame * precv_frame);
+extern  union recv_frame * recvframe_chk_defrag(_adapter *adapter, union recv_frame* precv_frame);
+extern  union recv_frame *  recvframe_defrag(_adapter *adapter, _queue *defrag_q);
+
+extern  union recv_frame * recvframe_chk_defrag_new(_adapter *adapter, union recv_frame* precv_frame);
+extern  union recv_frame *  recvframe_defrag_new(_adapter *adapter, _queue *defrag_q, union recv_frame* precv_frame);
+extern int recv_decache(union recv_frame *precv_frame, u8 bretry, struct stainfo_rxcache *prxcache);
+
+extern int sta2sta_data_frame(_adapter *adapter, union recv_frame *precv_frame, struct sta_info**psta );
+extern int ap2sta_data_frame(_adapter *adapter, union recv_frame *precv_frame, struct sta_info**psta );
+extern int sta2ap_data_frame(_adapter *adapter, union recv_frame *precv_frame, struct sta_info**psta );
+
+extern int validate_recv_ctrl_frame(_adapter *adapter, union recv_frame *precv_frame);
+extern int validate_recv_mgnt_frame(_adapter *adapter, union recv_frame *precv_frame);
+extern int validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame);
+extern int validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame);
+union recv_frame * portctrl(_adapter *adapter,union recv_frame * precv_frame);
+
+
+void  mgt_dispatcher(_adapter *padapter, u8 *pframe, uint len);
+
+int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe);
+
+
+
+#endif
diff --git a/drivers/net/wireless/8712u/include/rtl871x_rf.h b/drivers/net/wireless/8712u/include/rtl871x_rf.h
new file mode 100755
index 0000000..3eafa04
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_rf.h
@@ -0,0 +1,110 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef	__RTL871X_RF_H_ 
+#define __RTL871X_RF_H_
+
+#include <drv_conf.h>
+#include <rtl871x_cmd.h>
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+
+#ifndef CONFIG_80211N_HT
+#define		NumRates	(13)
+#else
+//#define NumRates	(26)
+#define NumRates	(13)
+#endif
+
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+
+
+//#define NUM_CHANNELS	15
+#define NUM_CHANNELS	32
+//#define NUM_REGULATORYS	21
+#define NUM_REGULATORYS	1
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later	
+#define JAPAN						0x2 //temp, should be provided later	
+
+struct	regulatory_class {
+	u32	starting_freq;					//MHz, 
+	u8	channel_set[NUM_CHANNELS];
+	u8	channel_cck_power[NUM_CHANNELS];//dbm
+	u8	channel_ofdm_power[NUM_CHANNELS];//dbm
+	u8	txpower_limit;  				//dbm
+	u8	channel_spacing;				//MHz
+	u8	modem;
+};
+
+
+enum	_REG_PREAMBLE_MODE{
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+
+enum _RTL8712_RF_MIMO_CONFIG_{
+ RTL8712_RFCONFIG_1T=0x10,
+ RTL8712_RFCONFIG_2T=0x20,
+ RTL8712_RFCONFIG_1R=0x01,
+ RTL8712_RFCONFIG_2R=0x02,
+ RTL8712_RFCONFIG_1T1R=0x11,
+ RTL8712_RFCONFIG_1T2R=0x12,
+ RTL8712_RFCONFIG_TURBO=0x92,
+ RTL8712_RFCONFIG_2T2R=0x22
+};
+
+
+struct setphyinfo_parm;
+extern void init_phyinfo(_adapter  *adapter, struct setphyinfo_parm* psetphyinfopara);
+extern u8 writephyinfo_fw(_adapter *padapter, u32 addr);
+extern u32 ch2freq(u32 ch);
+extern u32 freq2ch(u32 freq);
+
+/*
+void SetBBReg(PADAPTER padapter, u32 addr, u32 bitmask, u32 data);
+u32 QueryBBReg(PADAPTER padapter, u32 addr, u32 bitmask);
+
+void SetRFReg(PADAPTER padapter, int rfpath, u32 addr, u32 bitmask, u32 data);
+u32 QueryRFReg(PADAPTER padapter, int rfpath, u32 addr, u32 bitmask);
+*/
+
+u32 get_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask);
+u8 set_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask, u32 value);
+u32 get_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask);
+u8 set_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask,u32 value);
+
+
+int set_ratid_cmd(PADAPTER pAdapter, unsigned short param, unsigned int bitmap);
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_rf.h"
+#endif
+
+
+#endif //_RTL8711_RF_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_security.h b/drivers/net/wireless/8712u/include/rtl871x_security.h
new file mode 100755
index 0000000..4ee099b
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_security.h
@@ -0,0 +1,280 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __RTL871X_SECURITY_H_
+#define __RTL871X_SECURITY_H_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#define _NO_PRIVACY_	0x0
+#define _WEP40_			0x1
+#define _TKIP_			0x2
+#define _TKIP_WTMIC_	0x3
+#define _AES_			0x4
+#define _WEP104_		0x5
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48	{
+	
+	u64	val;
+	
+#ifdef CONFIG_LITTLE_ENDIAN
+
+struct {
+  u8 TSC0;
+  u8 TSC1;
+  u8 TSC2;
+  u8 TSC3;
+  u8 TSC4;
+  u8 TSC5;
+  u8 TSC6;
+  u8 TSC7;
+} _byte_;
+ 
+#elif defined(CONFIG_BIG_ENDIAN)
+
+struct {
+  u8 TSC7;
+  u8 TSC6;
+  u8 TSC5;
+  u8 TSC4;
+  u8 TSC3;
+  u8 TSC2;
+  u8 TSC1;
+  u8 TSC0;
+} _byte_;
+ 
+#endif
+
+};
+
+union Keytype {
+        u8   skey[16];
+        u32    lkey[4];
+};
+
+
+typedef struct _RT_PMKID_LIST
+{
+	u8						bUsed;
+	u8 						Bssid[6];
+	u8						PMKID[16];
+	u8						SsidBuf[33];
+	u8*						ssid_octet;
+	u16 						ssid_length;
+} RT_PMKID_LIST, *PRT_PMKID_LIST;
+
+
+struct	security_priv	{
+	
+	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch 
+	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id.
+	union Keytype dot11DefKey[4];			// this is only valid for def. key	
+	u32 	dot11DefKeylen[4];
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
+	u32	dot118021XGrpKeyid;		// key id used for Grp Key
+	union Keytype	dot118021XGrpKey[2];	// 802.1x Group Key, for inx0 and inx1	
+	union Keytype	dot118021XGrptxmickey[2];
+	union Keytype	dot118021XGrprxmickey[2];
+	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
+	union pn48		dot11Grprxpn;			// PN48 used for Grp Key recv.
+
+#ifdef CONFIG_HOSTAPD_MODE
+	//extend security capabilities for AP_MODE 
+	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;	
+#endif
+
+	u8 wps_hw_pbc_pressed;//for hw pbc pressed
+	u8 wps_phase;//for wps
+	u8 wps_ie[MAX_WPA_IE_LEN<<2];
+	int wps_ie_len;
+	
+	
+	u8	binstallGrpkey;
+	u8	busetkipkey;
+	_timer tkip_timer;
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+	
+	//u8	packet_cnt;//unused, removed
+	
+	s32	sw_encrypt;//from registry_priv
+	s32	sw_decrypt;//from registry_priv
+	
+	s32 	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
+
+
+	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
+	u32 ndisauthtype;
+	u32 ndisencryptstatus;
+
+	WLAN_BSSID_EX sec_bss;  //for joinbss (h2c buffer) usage
+
+	NDIS_802_11_WEP ndiswep;
+#ifdef PLATFORM_WINDOWS
+	u8 KeyMaterial[16];// variable length depending on above field.
+#endif
+
+	u8 assoc_info[600];
+	u8 szofcapability[256]; //for wpa2 usage
+	u8 oidassociation[512]; //for wpa/wpa2 usage
+	u8 authenticator_ie[256];  //store ap security information element
+	u8 supplicant_ie[256];  //store sta security information element
+
+
+	//for tkip countermeasure
+	u32 last_mic_err_time;	
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+
+	//---------------------------------------------------------------------------
+	// For WPA2 Pre-Authentication.
+	//---------------------------------------------------------------------------
+	//u8				RegEnablePreAuth;				// Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01.
+	//u8				EnablePreAuthentication;			// Current Value: Pre-Authentication enabled or not.
+	RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	// Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13.
+	u8				PMKIDIndex;
+	//u32				PMKIDCount;						// Added by Annie, 2006-10-13.
+	//u8				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
+
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
+do{\
+	switch(psecuritypriv->dot11AuthAlgrthm)\
+	{\
+		case 0:\
+		case 1:\
+		case 3:\
+			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		case 2:\
+			if(bmcst)\
+				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
+			else\
+				encry_algo =(u8) psta->dot118021XPrivacy;\
+			break;\
+	}\
+}while(0)
+
+
+#define SET_ICE_IV_LEN( iv_len, icv_len, encrypt)\
+do{\
+	switch(encrypt)\
+	{\
+		case _WEP40_:\
+		case _WEP104_:\
+			iv_len = 4;\
+			icv_len = 4;\
+			break;\
+		case _TKIP_:\
+			iv_len = 8;\
+			icv_len = 4;\
+			break;\
+		case _AES_:\
+			iv_len = 8;\
+			icv_len = 8;\
+			break;\
+		default:\
+			iv_len = 0;\
+			icv_len = 0;\
+			break;\
+	}\
+}while(0)
+
+
+#define GET_TKIP_PN(iv,dot11txpn)\
+do{\
+	dot11txpn._byte_.TSC0=iv[2];\
+	dot11txpn._byte_.TSC1=iv[0];\
+	dot11txpn._byte_.TSC2=iv[4];\
+	dot11txpn._byte_.TSC3=iv[5];\
+	dot11txpn._byte_.TSC4=iv[6];\
+	dot11txpn._byte_.TSC5=iv[7];\
+}while(0)
+
+
+#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
+#define ROR32( A, n ) 	ROL32( (A), 32-(n) )
+
+struct mic_data
+{
+	u32  K0, K1;         // Key
+	u32  L, R;           // Current state
+	u32  M;              // Message accumulator (single word)
+	u32     nBytesInM;      // # bytes in M
+};
+
+void secmicsetkey(struct mic_data *pmicdata, u8 * key );
+void secmicappendbyte(struct mic_data *pmicdata, u8 b );
+void secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes );
+void secgetmic(struct mic_data *pmicdata, u8 * dst );
+
+void seccalctkipmic(
+	u8 * key,
+	u8 *header,
+	u8 *data,
+	u32 data_len,
+	u8 *Miccode,
+	u8   priority);
+
+u32 aes_encrypt(_adapter *padapter, u8 *pxmitframe);
+u32 tkip_encrypt(_adapter *padapter, u8 *pxmitframe);
+void wep_encrypt(_adapter *padapter, u8  *pxmitframe);
+
+u32 aes_decrypt(_adapter *padapter, u8  *precvframe);
+u32 tkip_decrypt(_adapter *padapter, u8  *precvframe);
+void wep_decrypt(_adapter *padapter, u8  *precvframe);
+
+
+
+#ifdef PLATFORM_WINDOWS
+void use_tkipkey_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+#endif
+#ifdef PLATFORM_LINUX
+void use_tkipkey_handler(void* FunctionContext);
+#endif
+#endif	//__RTL871X_SECURITY_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_wlan_mlme.h b/drivers/net/wireless/8712u/include/rtl871x_wlan_mlme.h
new file mode 100755
index 0000000..de8d3ba
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_wlan_mlme.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_WLAN_MLME_H_
+#define _RTL871X_WLAN_MLME_H_
+
+#include <ieee80211_ext.h>
+
+
+#define SURVEY_TO		(200)
+#define REAUTH_TO		(1000)
+#define REASSOC_TO		(1000)
+#define DISCONNECT_TO	(10000)
+
+#define BCN_TO			(100)
+
+#define REAUTH_LIMIT	6
+#define REASSOC_LIMIT	6
+
+
+enum Synchronization_Sta_State {
+        STATE_Sta_Min			= 0,
+        STATE_Sta_No_Bss		= 1,
+        STATE_Sta_Bss			= 2,
+        STATE_Sta_Ibss_Active	= 3,
+        STATE_Sta_Ibss_Idle		= 4,
+        STATE_Sta_Auth_Success	= 5,
+        STATE_Sta_Roaming_Scan	= 6,
+};
+
+int xmit_mgnt_frame(_adapter *padapter, struct mgnt_frame *pmgntframe);
+
+#ifdef CONFIG_AP_MODE
+unsigned char *gen_wmm_ie(struct mlme_ext_priv *pmlmeext, unsigned char *eid, unsigned int *sz);
+#endif
+
+int set_wpa_ie(struct wpa_psk *pwpa_psk, u8 *buf, int len, int key_mgmt);
+int set_rsn_ie(struct wpa_psk *pwpa_psk, u8 *buf, int len, int key_mgmt, const u8 *pmkid);
+
+
+void report_sta_join_event(_adapter *padapter, struct sta_info *psta);
+void report_join_res(_adapter *padapter, int res);
+void report_join_res_ex(_adapter *padapter, u8 *piebuf, int iebuf_len, int res);
+
+unsigned int issue_assocreq(_adapter *padapter);
+void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
+void issue_auth(_adapter *padapter, struct sta_info *pstat, unsigned short status);
+void issue_probereq(_adapter *padapter);
+void issue_probersp(_adapter *padapter, unsigned char *da, int set_privacy);
+
+void start_clnt_assoc(_adapter *padapter);
+void start_clnt_auth(_adapter* padapter);
+void start_clnt_join(_adapter* padapter);
+void start_create_bss(_adapter *padapter, int mode);
+
+void report_BSSID_info(_adapter *padapter, u8 *pframe, uint len);
+void site_survey(_adapter *padapter);
+
+
+void survey_timer_hdl (_adapter *padapter);
+void reauth_timer_hdl(_adapter *padapter);
+void reassoc_timer_hdl(_adapter *padapter);
+
+
+
+int setup_bcnframe(_adapter *padapter, unsigned char *pframe);
+void process_addba_request(_adapter *padapter, struct sta_info *psta, struct ieee80211_mgmt *mgmt, uint len);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_wlan_sme.h b/drivers/net/wireless/8712u/include/rtl871x_wlan_sme.h
new file mode 100755
index 0000000..a0e6c9c
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_wlan_sme.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_WLAN_SME_H_
+#define _RTL871X_WLAN_SME_H_
+
+
+#define MSR_APMODE		0x0C
+#define MSR_STAMODE	0x08
+#define MSR_ADHOCMODE	0x04
+#define MSR_NOLINKMODE	0x00
+
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+void get_bssrate_set(_adapter *padapter, int bssrate_ie, unsigned char *pbssrate, int *bssrate_len);
+
+void write_cam(_adapter *padapter, unsigned char entry, unsigned short ctrl, unsigned char *mac, unsigned char *key);
+void invalidate_cam_all(_adapter *padapter);
+
+int check_basic_rate(struct mlme_ext_priv *pmlmeext, unsigned char *pRate, int pLen);
+void get_matched_rate(struct mlme_ext_priv *pmlmeext, unsigned char *pRate, int *pLen, int which);
+void update_support_rate(struct sta_info *pstat, unsigned char* buf, int len);
+
+void add_rate_id(struct mlme_ext_priv *pmlmeext, struct sta_info *pstat);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/rtl871x_xmit.h b/drivers/net/wireless/8712u/include/rtl871x_xmit.h
new file mode 100755
index 0000000..10f063a
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtl871x_xmit.h
@@ -0,0 +1,471 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _RTL871X_XMIT_H_
+#define _RTL871X_XMIT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <xmit_osdep.h>
+
+#ifdef CONFIG_SDIO_HCI
+#define MAX_XMITBUF_SZ (30720)//	(2048)
+#define NR_XMITBUFF	(16)
+#else //USB
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+#define MAX_XMITBUF_SZ	(16384)
+#else
+#define MAX_XMITBUF_SZ	(2048)
+#endif //CONFIG_USB_TX_AGGREGATION
+
+#define NR_XMITBUFF	(4)
+#endif
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+#define AGGR_NR_HIGH_BOUND	(4) //(8)
+#define AGGR_NR_LOW_BOUND	(2)
+#endif //CONFIG_USB_TX_AGGREGATION
+
+#ifdef PLATFORM_OS_CE
+#define XMITBUF_ALIGN_SZ 4
+#else
+#define XMITBUF_ALIGN_SZ 512
+#endif
+
+#define TX_GUARD_BAND		5
+#define MAX_NUMBLKS		(1)
+
+// Fixed the Big Endian bug when using the software driver encryption.
+#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0: (dot11txpn.val+1);\
+}while(0)
+
+// Fixed the Big Endian bug when doing the Tx.
+// The Linksys WRH54G will check this.
+#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+
+struct	hw_xmit	{
+	_lock xmit_lock;
+	_list	pending;	
+	_queue *sta_queue;
+	struct hw_txqueue *phwtxqueue;
+	sint	txcmdcnt;		
+	int	accnt;		
+};
+
+struct pkt_attrib
+{	
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+
+	u16	ether_type;	
+	u16	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
+
+	u16	seqnum;
+	u16	last_txcmdsz;
+
+	u8	pkt_hdrlen;	//the original 802.3 pkt header len
+	u8	hdrlen;		//the WLAN Header Len
+	u8	nr_frags;
+	u8	ack_policy;
+
+	u8	mac_id;
+	u8	vcs_mode;	//virtual carrier sense method
+	u8	pctrl;//per packet txdesc control enable
+	u8	qsel;
+
+	u8	priority;
+	u8	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	u8	iv_len;
+	u8	icv_len;
+	unsigned char iv[8];
+	unsigned char icv[8];	
+	
+	u8 	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+
+	struct sta_info *psta;
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	u8 hw_tcp_csum;
+#endif
+};
+
+
+#define WLANHDR_OFFSET	64
+
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+
+#define MP_FRAMETAG		0x07
+
+
+#define TXAGG_FRAMETAG 	0x08
+
+
+struct xmit_buf
+{
+	_list	list;
+
+	u8 *pallocated_buf;
+	u8 *pbuf;
+
+	void *priv_data;
+
+#ifdef CONFIG_USB_HCI	
+	//u8 *mem_addr;//removed
+	//u32 sz[8];
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PIRP		pxmit_irp[8];
+#endif
+	//u8 bpending[8];
+	//sint ac_tag[8];//removed
+	//u8 last[8];//removed
+	//uint irpcnt;//can be removed
+	//uint fragcnt;//can be removed
+#endif	
+	   
+#ifdef CONFIG_SDIO_HCI
+	u32  len;	
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	u32 ff_hwaddr;
+#ifdef PLATFORM_OS_XP
+	PMDL pxmitbuf_mdl;
+	PIRP  pxmitbuf_irp; 
+	PSDBUS_REQUEST_PACKET pxmitbuf_sdrp;
+#endif	
+#endif
+
+	u32 aggr_nr;
+};
+
+struct xmit_frame
+{
+	_list list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int frame_tag;
+
+	_adapter *padapter;
+
+	 u8 *buf_addr;
+
+	 struct xmit_buf *pxmitbuf;
+
+#ifdef CONFIG_SDIO_HCI
+	u8 pg_num;
+#endif
+
+#ifdef CONFIG_USB_HCI
+
+	//insert urb, irp, and irpcnt info below...      
+	//max frag_cnt = 8 
+
+	u8 *mem_addr;
+	u16 sz[8];
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	PIRP	pxmit_irp[8];
+#endif
+	u8 bpending[8];
+	u8 last[8];
+	//sint ac_tag[8];
+	//uint irpcnt;
+	//uint fragcnt;
+#endif
+	
+	//uint	mem[(MAX_XMITBUF_SZ >> 2)];
+	//uint	mem[1];
+};
+
+struct tx_servq {
+	_list	tx_pending;
+	_queue	sta_pending;	
+	int qcnt;		
+};
+
+
+
+struct sta_xmit_priv
+{
+	_lock	lock;
+	sint	option;
+	sint	apsd_setting;	//When bit mask is on, the associated edca queue supports APSD.
+
+
+	//struct tx_servq blk_q[MAX_NUMBLKS];
+	struct tx_servq	be_q;			//priority == 0,3 
+	struct tx_servq	bk_q;			//priority == 1,2
+	struct tx_servq	vi_q;			//priority == 4,5
+	struct tx_servq	vo_q;			//priority == 6,7
+	_list 	legacy_dz;
+	_list  apsd;
+
+	u16 txseq_tid[16];
+
+	uint	sta_tx_bytes;
+	u64	sta_tx_pkts;
+	uint	sta_tx_fail;
+
+};
+
+
+struct	hw_txqueue {
+	volatile sint	head;
+	volatile sint	tail;
+	volatile sint 	free_sz;	//in units of 64 bytes
+	//volatile sint	budget_sz;
+	volatile sint      free_cmdsz;
+	volatile sint	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	sint	ac_tag;
+};
+
+
+struct	xmit_priv {
+	
+	_lock	lock;
+
+	_sema	xmit_sema;
+	_sema	terminate_xmitthread_sema;
+	
+	//_queue	blk_strms[MAX_NUMBLKS];
+	_queue	be_pending;
+	_queue	bk_pending;
+	_queue	vi_pending;
+	_queue	vo_pending;
+	_queue	bm_pending;
+	
+	_queue	legacy_dz_queue;
+	_queue	apsd_queue;
+	
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+
+	uint mapping_addr;
+	uint pkt_sz;	
+	
+	_queue	free_xmit_queue;
+	
+
+	struct	hw_txqueue	be_txqueue;
+	struct	hw_txqueue	bk_txqueue;
+	struct	hw_txqueue	vi_txqueue;
+	struct	hw_txqueue	vo_txqueue;
+	struct	hw_txqueue	bmc_txqueue;
+
+	uint	frag_len;
+
+	_adapter	*adapter;
+	
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	u16  rts_thresh;
+	
+	uint	tx_bytes;
+	u64	tx_pkts;
+	uint	tx_drop;
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+
+#ifdef CONFIG_USB_HCI
+	_sema	tx_retevt;//all tx return event;
+	u8		txirp_cnt;//
+	
+#ifdef PLATFORM_OS_CE
+	USB_TRANSFER	usb_transfer_write_port;
+//	USB_TRANSFER	usb_transfer_write_mem;
+#endif
+#ifdef PLATFORM_LINUX
+	struct tasklet_struct xmit_tasklet;
+	_workitem xmit_pipe4_reset_wi;
+	_workitem xmit_pipe6_reset_wi;
+	_workitem xmit_piped_reset_wi;
+
+#endif
+	//per AC pending irp
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+	
+#endif
+
+#ifdef CONFIG_RTL8712
+	_queue	free_amsdu_xmit_queue;
+	u8 *pallocated_amsdu_frame_buf;
+	u8 *pxmit_amsdu_frame_buf;
+	uint free_amsdu_xmitframe_cnt;
+
+	_queue free_txagg_xmit_queue;
+	u8 *pallocated_txagg_frame_buf;
+	u8 *pxmit_txagg_frame_buf;
+	uint free_txagg_xmitframe_cnt;	
+
+	int cmdseq;
+#endif
+#ifdef CONFIG_SDIO_HCI
+	u8 free_pg[8];
+	u8	public_pgsz;
+	u8	required_pgsz;
+	u8	used_pgsz;
+	u8	init_pgsz;
+#ifdef PLATFORM_OS_XP
+	PMDL prd_freesz_mdl[2];
+	u8 brd_freesz_pending[2];
+	PIRP  prd_freesz_irp[2]; 
+	PSDBUS_REQUEST_PACKET prd_freesz_sdrp[2];
+	u8 rd_freesz_irp_idx;
+#endif
+
+#endif
+
+
+	_queue free_xmitbuf_queue;
+	_queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;	
+
+
+};
+
+
+static __inline _queue *get_free_xmit_queue(struct	xmit_priv	*pxmitpriv)
+{
+	return &(pxmitpriv->free_xmit_queue);
+}
+
+
+extern int free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+extern struct xmit_buf *alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+
+extern void update_protection(_adapter *padapter, u8 *ie, uint ie_len);
+extern struct xmit_frame *alloc_xmitframe(struct xmit_priv *pxmitpriv);
+extern sint make_wlanhdr (_adapter *padapter, unsigned char *hdr, struct pkt_attrib *pattrib);
+extern sint rtl8711_put_snap(u8 *data, u16 h_proto);
+extern sint free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+extern void free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue );
+extern sint xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern thread_return xmit_thread(thread_context context);
+extern sint xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
+
+sint _init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
+void	_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+sint update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattrib);
+
+
+sint txframes_pending(_adapter *padapter);
+int txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
+void init_hwxmits(struct hw_xmit *phwxmit, sint entry);
+
+
+sint _init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
+void _free_xmit_priv (struct xmit_priv *pxmitpriv);
+
+
+
+//new added for 871x
+int init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
+void free_xmit_priv (struct xmit_priv *pxmitpriv);
+
+void alloc_hwxmits(_adapter *padapter);
+void free_hwxmits(_adapter *padapter);
+
+struct xmit_frame *alloc_xmitframe_ex(struct xmit_priv *pxmitpriv, int tag);
+int free_xmitframe_ex(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+
+int pre_xmit(_adapter *padapter, struct xmit_frame *pxmitframe);
+void check_xmit(_adapter *padapter);
+int check_xmit_resource(_adapter *padapter, struct xmit_frame *pxmitframe);
+int xmit_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+int xmit_direct(_adapter *padapter, struct xmit_frame *pxmitframe);
+
+#if defined (CONFIG_USB_HCI) && defined(PLATFORM_LINUX)
+extern void xmit_bh(void *priv);
+#endif
+
+void xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe, struct xmit_buf *pxmitbuf);
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_xmit.h"
+#endif
+
+#endif	//_RTL871X_XMIT_H_
+
diff --git a/drivers/net/wireless/8712u/include/rtw_android.h b/drivers/net/wireless/8712u/include/rtw_android.h
new file mode 100755
index 0000000..1294221
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/rtw_android.h
@@ -0,0 +1,99 @@
+/*
+ * Linux cfg80211 driver - Android related functions
+ *
+ * Copyright (C) 1999-2011, Broadcom Corporation
+ *
+ *         Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * $Id: wl_android.c,v 1.1.4.1.2.14 2011/02/09 01:40:07 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#if 0
+#include <wldev_common.h>
+#endif
+
+/**
+ * Android platform dependent functions, feel free to add Android specific functions here
+ * (save the macros in dhd). Please do NOT declare functions that are NOT exposed to dhd
+ * or cfg, define them as static in wl_android.c
+ */
+
+#if 0
+/**
+ * wl_android_init will be called from module init function (dhd_module_init now), similarly
+ * wl_android_exit will be called from module exit function (dhd_module_cleanup now)
+ */
+int wl_android_init(void);
+int wl_android_exit(void);
+int wl_android_post_init(void);
+int wl_android_wifi_on(struct net_device *dev);
+int wl_android_wifi_off(struct net_device *dev);
+#endif
+
+enum ANDROID_WIFI_CMD {
+	ANDROID_WIFI_CMD_START,				
+	ANDROID_WIFI_CMD_STOP,			
+	ANDROID_WIFI_CMD_SCAN_ACTIVE,
+	ANDROID_WIFI_CMD_SCAN_PASSIVE,		
+	ANDROID_WIFI_CMD_RSSI,	
+	ANDROID_WIFI_CMD_LINKSPEED,
+	ANDROID_WIFI_CMD_RXFILTER_START,
+	ANDROID_WIFI_CMD_RXFILTER_STOP,	
+	ANDROID_WIFI_CMD_RXFILTER_ADD,	
+	ANDROID_WIFI_CMD_RXFILTER_REMOVE,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_START,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP,
+	ANDROID_WIFI_CMD_BTCOEXMODE,
+	ANDROID_WIFI_CMD_SETSUSPENDOPT,
+	ANDROID_WIFI_CMD_P2P_DEV_ADDR,	
+	ANDROID_WIFI_CMD_SETFWPATH,		
+	ANDROID_WIFI_CMD_SETBAND,		
+	ANDROID_WIFI_CMD_GETBAND,			
+	ANDROID_WIFI_CMD_COUNTRY,			
+	ANDROID_WIFI_CMD_P2P_SET_NOA,
+	ANDROID_WIFI_CMD_P2P_GET_NOA,	
+	ANDROID_WIFI_CMD_P2P_SET_PS,	
+	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
+#ifdef PNO_SUPPORT
+	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
+	ANDROID_WIFI_CMD_PNOSETUP_SET,
+	ANDROID_WIFI_CMD_PNOENABLE_SET,
+	ANDROID_WIFI_CMD_PNODEBUG_SET,
+#endif
+
+	ANDROID_WIFI_CMD_MACADDR,
+
+	ANDROID_WIFI_CMD_MAX
+};
+
+int rtw_android_cmdstr_to_num(char *cmdstr);
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+int wl_android_wifictrl_func_add(void);
+void wl_android_wifictrl_func_del(void);
+void* wl_android_prealloc(int section, unsigned long size);
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr);
+int wifi_set_power(int on, unsigned long msec);
+int wifi_get_mac_addr(unsigned char *buf);
+void *wifi_get_country_code(char *ccode);
+#endif /* CONFIG_WIFI_CONTROL_FUNC */
diff --git a/drivers/net/wireless/8712u/include/sdio_hal.h b/drivers/net/wireless/8712u/include/sdio_hal.h
new file mode 100755
index 0000000..38136a7
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sdio_hal.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __SDIO_HAL_H__
+
+#define __SDIO_HAL_H__
+
+extern u8 sd_hal_bus_init(_adapter * adapter);
+extern u8 sd_hal_bus_deinit(_adapter * adapter);
+
+
+u8  sd_int_isr (IN PADAPTER	padapter);
+void sd_int_dpc(PADAPTER padapter);
+
+
+#endif //__SDIO_HAL_H__
+
diff --git a/drivers/net/wireless/8712u/include/sdio_ops.h b/drivers/net/wireless/8712u/include/sdio_ops.h
new file mode 100755
index 0000000..a612b71
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sdio_ops.h
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __SDIO_OPS_H_
+#define __SDIO_OPS_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#ifdef PLATFORM_LINUX
+#include <sdio_ops_linux.h>
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef PLATFORM_OS_XP
+#include <sdio_ops_xp.h>
+struct async_context
+{
+	PMDL pmdl;
+	PSDBUS_REQUEST_PACKET sdrp;
+	unsigned char* r_buf;
+	unsigned char* padapter;
+};
+#endif
+#ifdef PLATFORM_OS_CE
+#include <sdio_ops_ce.h>
+#endif
+#endif
+
+
+
+extern void sdio_set_intf_option(u32 *poption);
+
+extern void sdio_set_intf_funs(struct intf_hdl *pintf_hdl);
+
+extern uint sdio_init_intf_priv(struct intf_priv *pintfpriv);
+
+extern void sdio_unload_intf_priv(struct intf_priv *pintfpriv);
+
+extern void sdio_intf_hdl_init(u8 *priv);
+
+extern void sdio_intf_hdl_unload(u8 *priv);
+
+extern void sdio_intf_hdl_open(u8 *priv);
+
+extern void sdio_intf_hdl_close(u8 *priv);
+
+extern void sdio_set_intf_ops(struct _io_ops *pops);
+	
+//extern void sdio_set_intf_callbacks(struct _io_callbacks *pcallbacks);
+extern void sdio_func1cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+extern void sdio_func1cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+
+extern	uint __inline _cvrt2ftaddr(const u32 addr, u32 *pftaddr)  ;
+
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/sdio_ops_ce.h b/drivers/net/wireless/8712u/include/sdio_ops_ce.h
new file mode 100755
index 0000000..2a07c19
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sdio_ops_ce.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _SDIO_OPS_WINCE_H_
+#define _SDIO_OPS_WINCE_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_OS_CE
+
+
+extern u8 sdbus_cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w_ce(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+
+
+uint sdbus_read_blocks_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+extern uint sdbus_read_bytes_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern u8 sdbus_func1cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_func1cmd52w_ce(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/sdio_ops_linux.h b/drivers/net/wireless/8712u/include/sdio_ops_linux.h
new file mode 100755
index 0000000..77214b1
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sdio_ops_linux.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _SDIO_OPS_LINUX_H_
+#define _SDIO_OPS_LINUX_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_LINUX
+
+
+extern u8 sdbus_cmd52r(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+extern u8 sdbus_direct_read8(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_direct_write8(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+
+extern uint sdbus_read_bytes_to_recvbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern uint sdbus_read_blocks_to_recvbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_xmitbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_xmitbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/sdio_ops_xp.h b/drivers/net/wireless/8712u/include/sdio_ops_xp.h
new file mode 100755
index 0000000..eaa0384
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sdio_ops_xp.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _SDIO_OPS_XP_H_
+#define _SDIO_OPS_XP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_OS_XP
+
+
+extern u8 sdbus_cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w_xp(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+
+
+uint sdbus_read_blocks_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+extern uint sdbus_read_bytes_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern u8 sdbus_func1cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_func1cmd52w_xp(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/sdio_osintf.h b/drivers/net/wireless/8712u/include/sdio_osintf.h
new file mode 100755
index 0000000..b6ac1b6
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sdio_osintf.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __SDIO_OSINTF_H
+#define __SDIO_OSINTF_H
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+extern unsigned int sd_dvobj_init(_adapter * adapter);
+extern void sd_dvobj_deinit(_adapter * adapter);
+
+void rtl871x_intf_stop(_adapter *padapter);
+
+u8 sd_hal_bus_init(_adapter * padapter);
+u8 sd_hal_bus_deinit(_adapter * padapter);
+void update_xmit_hw_res(_adapter * padapter);
+void sd_c2h_hdl( PADAPTER	padapter);
+
+#ifdef PLATFORM_OS_CE
+extern NDIS_STATUS ce_sd_get_dev_hdl(_adapter *padapter );
+SD_API_STATUS  
+ce_sd_int_callback(SD_DEVICE_HANDLE hDevice, _adapter* padapter);
+extern void sd_setup_irs(_adapter *padapter);
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/sta_info.h b/drivers/net/wireless/8712u/include/sta_info.h
new file mode 100755
index 0000000..b12907c
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/sta_info.h
@@ -0,0 +1,182 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+
+#define NUM_STA 32
+#define NUM_ACL 64
+
+
+//if mode ==0, then the sta is allowed once the addr is hit.
+//if mode ==1, then the sta is rejected once the addr is non-hit.
+struct wlan_acl_node {
+        _list		        list;
+        u8       addr[ETH_ALEN];
+        u8       mode;
+};
+
+struct wlan_acl_pool {
+        struct wlan_acl_node aclnode[NUM_ACL];
+};
+
+
+struct	stainfo_stats	{
+
+	uint	rx_pkts;
+	uint	rx_bytes;
+	u64	tx_pkts;
+	uint	tx_bytes;
+
+};
+
+struct sta_info {
+
+	_lock lock;
+	_list list; //free_sta_queue
+	_list hash_list; //sta_hash
+	//_list asoc_list; //20061114
+	//_list sleep_list;//sleep_q
+	//_list wakeup_list;//wakeup_q
+	
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+	
+	uint state;
+	uint aid;
+	uint mac_id;
+	uint qos_option;
+	u8	hwaddr[ETH_ALEN];
+
+	uint	ieee8021x_blocked;	//0: allowed, 1:blocked 
+	uint	dot118021XPrivacy; //aes, tkip...
+	union Keytype	dot11tkiptxmickey;
+	union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;	
+	union pn48		dot11txpn;			// PN48 used for Unicast xmit.
+	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
+
+
+	u8	bssrateset[16];
+	uint	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+
+	struct stainfo_stats sta_stats;
+
+	//for A-MPDU Rx reordering buffer control 
+	struct recv_reorder_ctrl recvreorder_ctrl[16];
+
+	
+#ifdef CONFIG_80211N_HT
+	struct ht_priv	htpriv;	
+#endif
+	
+
+	//Notes:	
+	//STA_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO	
+	//scan_q: AP CAP/INFO
+
+	//AP_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
+	//sta_info: (AP & STA) CAP/INFO
+	
+#ifdef CONFIG_AP_MODE
+
+	_list asoc_list;
+	_list auth_list;
+	 
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+
+	unsigned int tx_ra_bitmap;
+
+#endif	
+
+	
+
+};
+
+
+
+struct	sta_priv {
+	
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	_queue	free_sta_queue;
+	
+	_lock sta_hash_lock;
+	_list   sta_hash[NUM_STA];
+	int asoc_sta_count;
+	_queue sleep_q;
+	_queue wakeup_q;
+	
+	_adapter *padapter;
+	
+#ifdef CONFIG_AP_MODE
+    	
+	_list asoc_list;
+	_list auth_list;
+
+	unsigned int auth_to;  //sec, time to expire in authenticating.
+	unsigned int assoc_to; //sec, time to expire before associating.
+	unsigned int expire_to; //sec , time to expire after associated.
+	
+#endif		
+	
+};
+
+
+static __inline u32 wifi_mac_hash(u8 *mac)
+{
+        u32 x;
+
+        x = mac[0];
+        x = (x << 2) ^ mac[1];
+        x = (x << 2) ^ mac[2];
+        x = (x << 2) ^ mac[3];
+        x = (x << 2) ^ mac[4];
+        x = (x << 2) ^ mac[5];
+
+        x ^= x >> 8;
+        x  = x & (NUM_STA - 1);
+		
+        return x;
+}
+
+
+extern u32	_init_sta_priv(struct sta_priv *pstapriv);
+extern u32	_free_sta_priv(struct sta_priv *pstapriv);
+extern struct sta_info *alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
+extern u32	free_stainfo(_adapter *padapter , struct sta_info *psta);
+extern void free_all_stainfo(_adapter *padapter);
+extern struct sta_info *get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+extern u32 init_bcmc_stainfo(_adapter* padapter);
+extern struct sta_info* get_bcmc_stainfo(_adapter* padapter);
+extern u8 access_ctrl(struct wlan_acl_pool* pacl_list, u8 * mac_addr);
+
+#endif //_STA_INFO_H_
diff --git a/drivers/net/wireless/8712u/include/usb_hal.h b/drivers/net/wireless/8712u/include/usb_hal.h
new file mode 100755
index 0000000..4f1c568
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/usb_hal.h
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __USB_HAL_H__
+#define __USB_HAL_H__
+
+
+extern u8 usb_hal_bus_init(_adapter * adapter);
+extern u8 usb_hal_bus_deinit(_adapter * adapter);
+
+#endif //__USB_HAL_H__
+
diff --git a/drivers/net/wireless/8712u/include/usb_ops.h b/drivers/net/wireless/8712u/include/usb_ops.h
new file mode 100755
index 0000000..d5fbd8a
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/usb_ops.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+extern void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+extern void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+
+extern u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+extern u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+
+extern void usb_set_intf_option(u32 *poption);
+
+extern void usb_set_intf_funs(struct intf_hdl *pintf_hdl);
+
+extern uint usb_init_intf_priv(struct intf_priv *pintfpriv);
+
+extern void usb_unload_intf_priv(struct intf_priv *pintfpriv);
+
+extern void usb_intf_hdl_init(u8 *priv);
+
+extern void usb_intf_hdl_unload(u8 *priv);
+
+extern void usb_intf_hdl_open(u8 *priv);
+
+extern void usb_intf_hdl_close(u8 *priv);
+
+extern void usb_set_intf_ops(struct _io_ops *pops);	
+
+
+void usb_read_port_cancel(_adapter *padapter);
+void usb_write_port_cancel(_adapter *padapter);
+
+void _async_protocol_read(struct io_queue *pio_q);
+void _async_protocol_write(struct io_queue *pio_q);
+
+void async_rd_io_callback(_adapter *padapter, struct io_req *pio_req, u8 *cnxt);
+void usb_cancel_io_irp(_adapter *padapter);
+uint usb_write_scsi(struct intf_hdl *pintfhdl, u32 cnt, u8 *wmem);
+
+
+int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+
+
+#ifdef PLATFORM_WINDOWS
+void io_irp_timeout_handler (	IN	PVOID	SystemSpecific1,IN	PVOID	FunctionContext,IN	PVOID	SystemSpecific2,IN	PVOID	SystemSpecific3);
+#endif
+#ifdef PLATFORM_LINUX
+void io_irp_timeout_handler(void* FunctionContext);
+#endif
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/usb_osintf.h b/drivers/net/wireless/8712u/include/usb_osintf.h
new file mode 100755
index 0000000..8a50264
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/usb_osintf.h
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <usb_vendor_req.h>
+
+#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)
+
+
+uint usb_dvobj_init(_adapter * adapter);
+void usb_dvobj_deinit(_adapter * adapter);
+
+unsigned int usb_inirp_init(_adapter * padapter);
+unsigned int usb_inirp_deinit(_adapter * padapter);
+
+
+u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv, RT_USB_BREQUEST brequest, RT_USB_WVALUE wvalue, u8 windex, void* data, u8 datalen, u8 isdirectionin);
+
+void rtl871x_intf_stop(_adapter *padapter);
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/include/usb_vendor_req.h b/drivers/net/wireless/8712u/include/usb_vendor_req.h
new file mode 100755
index 0000000..1549f5e
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/usb_vendor_req.h
@@ -0,0 +1,59 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+//4	Set/Get Register related wIndex/Data
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON				1
+#define	RT_USB_LDO_OFF				0
+
+//4	Set/Get SYSCLK related	wValue or Data
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+
+typedef enum _RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+} RT_USB_BREQUEST;
+
+
+typedef enum _RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO			=	4,
+	RT_USB_BOOT_TYPE	=	5
+} RT_USB_WVALUE;
+
+
+//BOOLEAN usbvendorrequest(PCE_USB_DEVICE	CEdevice, RT_USB_BREQUEST bRequest, RT_USB_WVALUE wValue, UCHAR wIndex, PVOID Data, UCHAR DataLength, BOOLEAN isDirectionIn);
+//BOOLEAN CEusbGetStatusRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT Index, PVOID Data);
+//BOOLEAN CEusbFeatureRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT FeatureSelector, IN USHORT Index);
+//BOOLEAN CEusbGetDescriptorRequest(PCE_USB_DEVICE CEdevice, IN short urbLength, IN UCHAR DescriptorType, IN UCHAR Index, IN USHORT LanguageId, IN PVOID  TransferBuffer, IN ULONG TransferBufferLength);
+
+#endif
diff --git a/drivers/net/wireless/8712u/include/version.h b/drivers/net/wireless/8712u/include/version.h
new file mode 100644
index 0000000..e8694da
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/version.h
@@ -0,0 +1 @@
+#define DRVER  "v2.6.6.0.20120405"
diff --git a/drivers/net/wireless/8712u/include/wifi.h b/drivers/net/wireless/8712u/include/wifi.h
new file mode 100755
index 0000000..f877304
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/wifi.h
@@ -0,0 +1,676 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+#include <rtl871x_byteorder.h>
+
+#ifdef BIT
+//#error	"BIT define occurred earlier elsewhere!\n"
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+#ifdef GREEN_HILL
+#pragma pack(1)
+#endif
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data	
+};
+
+enum WIFI_FRAME_SUBTYPE {
+
+    // below is for mgt frame
+    WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+    WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+    WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+    WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+    WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+    WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+    WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+    WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+
+    // below is for control frame
+    WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+    WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+
+    // below is for data frame
+    WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+    WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+    WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	// WPA reason
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	//belowing are Realtek definition
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+};
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+};
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC		= 1,
+	DOMAIN_IC		= 2,
+	DOMAIN_ETSI		= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK		= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1		= 8,
+	DOMAIN_MKK2		= 9,
+	DOMAIN_MKK3		= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while(0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while(0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while(0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while(0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while(0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while(0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while(0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while(0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while(0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while(0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while(0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while(0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while(0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while(0)
+
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf,type)	\
+	do { 	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while(0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+#define SetFrameSubType(pbuf,type) \
+	do {    \
+		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+	} while(0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((unsigned int)(pbuf) + 22) = \
+			((*(unsigned short *)((unsigned int)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while(0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((unsigned int)(pbuf) + 22) = \
+			((*(unsigned short *)((unsigned int)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while(0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)((unsigned int)(pbuf) + 2) |= cpu_to_le16(0xffff & (dur)); \
+	} while(0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while(0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
+	} while(0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
+	} while(0)	
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((unsigned int)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((unsigned int)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((unsigned int)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((unsigned int)(pbuf) + 24))
+
+
+
+static __inline int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return _TRUE;
+	else
+		return _FALSE;
+}
+
+
+static __inline unsigned char * get_da(unsigned char *pframe)
+{
+	unsigned char 	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			da = GetAddr3Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			da = GetAddr3Ptr(pframe);
+			break;
+	}
+
+	return da;
+}
+
+
+static __inline unsigned char * get_sa(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			sa = GetAddr4Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+static __inline unsigned char * get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr1Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			sa =NULL; //???????
+			break;
+	}
+
+	return sa;
+}
+
+
+
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_		2
+#define _PRE_ALLOCMEM_			1
+#define _PRE_ALLOCHDR_			3
+#define _PRE_ALLOCLLCHDR_		4
+#define _PRE_ALLOCICVHDR_		5
+#define _PRE_ALLOCMICHDR_		6
+
+#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A)?16:10)
+#define _ACKCTSLNG_				14	//14 bytes long, including crclng
+#define _CRCLNG_				4
+
+#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define _SSID_IE_				0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_				3
+#define _TIM_IE_					5
+#define _IBSS_PARA_IE_			6
+#define _CHLGETXT_IE_			16
+#define _RSN_IE_2_				48
+#define _SSN_IE_1_					221
+#define _ERPINFO_IE_			42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_			45
+#define _HT_EXTRA_INFO_IE_			61
+#define _HT_ADD_INFO_IE_			61 //_HT_EXTRA_INFO_IE_
+
+#define _VENDOR_SPECIFIC_IE_		221
+
+#define	_RESERVED47_				47
+
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1		// WPA
+#define _IEEE8021X_PSK_			2		// WPA with pre-shared key
+
+/*
+#define _NO_PRIVACY_			0
+#define _WEP_40_PRIVACY_		1
+#define _TKIP_PRIVACY_			2
+#define _WRAP_PRIVACY_			3
+#define _CCMP_PRIVACY_			4
+#define _WEP_104_PRIVACY_		5
+#define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
+*/
+				
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  // for WMM STA
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n 
+------------------------------------------------------------------------------*/
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+//#ifdef CONFIG_80211N_HT
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while(0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+
+/**
+ * struct rtw_ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+ #if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8712FW)
+struct rtw_ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __attribute__((packed));
+ #endif
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+
+ #if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8712FW)
+
+ /**
+ * struct rtw_ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+ 
+struct rtw_ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __attribute__ ((packed));
+
+/**
+ * struct rtw_ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} __attribute__ ((packed));
+
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+};
+
+
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+};
+
+#pragma pack()
+
+#endif
+
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE	 	0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE 		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW 		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+
+//#endif
+
+#endif // _WIFI_H_
+
diff --git a/drivers/net/wireless/8712u/include/wlan_bssdef.h b/drivers/net/wireless/8712u/include/wlan_bssdef.h
new file mode 100755
index 0000000..eab4df4
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/wlan_bssdef.h
@@ -0,0 +1,408 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+
+//#define MAX_IE_SZ	512
+#define MAX_IE_SZ	768
+
+
+#ifdef PLATFORM_LINUX
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
+typedef long    		NDIS_802_11_RSSI;           // in dBm
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+
+typedef  ULONG  NDIS_802_11_KEY_INDEX;
+typedef unsigned long long NDIS_802_11_KEY_RSC;
+
+
+typedef struct _NDIS_802_11_SSID
+{
+  ULONG  SsidLength;
+  UCHAR  Ssid[32];
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+    Ndis802_11FH,
+    Ndis802_11DS,
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+    ULONG           Length;             // Length of structure
+    ULONG           HopPattern;         // As defined by 802.11, MSB set
+    ULONG           HopSet;             // to one if non-802.11
+    ULONG           DwellTime;          // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+ 
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.	
+*/
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+    ULONG           Length;             // Length of structure
+    ULONG           BeaconPeriod;       // units are Kusec
+    ULONG           ATIMWindow;         // units are Kusec
+    ULONG           DSConfig;           // Frequency, units are kHz
+    NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+    Ndis802_11IBSS,
+    Ndis802_11Infrastructure,
+    Ndis802_11AutoUnknown,
+    Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
+    Ndis802_11APMode
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+
+
+
+
+typedef struct _NDIS_802_11_FIXED_IEs
+{
+  UCHAR  Timestamp[8];
+  USHORT  BeaconInterval;
+  USHORT  Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+
+
+typedef struct _NDIS_802_11_VARIABLE_IEs
+{
+  UCHAR  ElementID;
+  UCHAR  Length;
+  UCHAR  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+
+
+/*
+
+
+
+Length is the 4 bytes multiples of the sume of
+	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (ULONG)
++   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
++   sizeof (NDIS_802_11_RATES_EX) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+
+*/
+
+typedef struct _NDIS_WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+  ULONG  NumberOfItems;
+  NDIS_WLAN_BSSID_EX  Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+    Ndis802_11AuthModeOpen,
+    Ndis802_11AuthModeShared,
+    Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+    Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+    Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+    Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+    Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    USHORT Capabilities;
+    USHORT ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    USHORT Capabilities;
+    USHORT StatusCode;
+    USHORT AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    ULONG                   Length;
+    USHORT                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    ULONG                   RequestIELength;
+    ULONG                   OffsetRequestIEs;
+    USHORT                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    ULONG                   ResponseIELength;
+    ULONG                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;           
+    ULONG           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    UCHAR           KeyMaterial[32];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    ULONG                   Length;        // Length of this structure
+    ULONG                   KeyIndex;           
+    NDIS_802_11_MAC_ADDRESS BSSID;      
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP
+{
+    ULONG     Length;        // Length of this structure
+    ULONG     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
+    ULONG     KeyLength;     // length of key in bytes
+    UCHAR     KeyMaterial[16];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    ULONG Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    ULONG Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,		
+	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+// MIC check time, 60 seconds.
+#define MIC_CHECK_TIME	60000000
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+        
+typedef struct _NDIS_802_11_TEST
+{
+    ULONG Length;
+    ULONG Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+
+#endif //end of #ifdef PLATFORM_LINUX
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+struct	wlan_network {
+	_list	list;	
+	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
+	int	fixed;			// set to fixed when not to be removed as site-surveying
+	unsigned long	last_scanned; //timestamp for the network
+	int	aid;			//will only be valid when a BSS is joinned.
+	int	join_res;
+	NDIS_WLAN_BSSID_EX	network; //must be the last item
+#ifdef PLATFORM_WINDOWS	
+	unsigned char  iebuf[MAX_IE_SZ];
+#endif
+
+};
+
+enum VRTL_CARRIER_SENSE
+{
+    DISABLE_VCS,	
+    ENABLE_VCS,	
+    AUTO_VCS
+};
+
+enum VCS_TYPE
+{
+    NONE_VCS,	
+    RTS_CTS,
+    CTS_TO_SELF 
+};
+
+
+
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+
+enum UAPSD_MAX_SP
+{
+	NO_LIMIT,
+       TWO_MSDU,
+       FOUR_MSDU,
+       SIX_MSDU
+};
+
+
+//john
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+* 	WPA2
+*/
+
+#ifndef PLATFORM_OS_CE
+typedef struct _PMKID_CANDIDATE {
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    ULONG Flags;
+} PMKID_CANDIDATE, *PPMKID_CANDIDATE;
+
+typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
+{
+    ULONG Version;       // Version of the structure
+    ULONG NumCandidates; // No. of pmkid candidates
+    PMKID_CANDIDATE CandidateList[1];
+} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
+
+
+typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
+{
+	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
+	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
+	
+} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
+
+typedef struct _NDIS_802_11_CAPABILITY 
+{
+	ULONG  Length;
+	ULONG  Version;
+	ULONG  NoOfPMKIDs;
+	ULONG  NoOfAuthEncryptPairsSupported;
+	NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
+	
+} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
+#endif
+
+
+typedef struct _WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} WLAN_BSSID_EX, *PWLAN_BSSID_EX;
+
+
+
+#endif //#ifndef WLAN_BSSDEF_H_
+
diff --git a/drivers/net/wireless/8712u/include/xmit_osdep.h b/drivers/net/wireless/8712u/include/xmit_osdep.h
new file mode 100755
index 0000000..690a57b
--- /dev/null
+++ b/drivers/net/wireless/8712u/include/xmit_osdep.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+struct pkt_file {
+	_pkt *pkt;
+	u32	pkt_len;	 //the remainder length of the open_file
+	_buffer *cur_buffer;
+	u8 *buf_start;
+	u8 *cur_addr;
+	u32 buf_len;
+};
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef PLATFORM_OS_XP
+#ifdef CONFIG_USB_HCI
+#include <usb.h>
+#include <usbdlib.h>
+#include <usbioctl.h>
+#endif
+#endif
+
+#define NR_XMITFRAME     128
+
+#define ETH_ALEN	6
+
+extern NDIS_STATUS xmit_entry(
+IN _nic_hdl		cnxt,
+IN NDIS_PACKET		*pkt,
+IN UINT				flags
+);
+
+#endif
+
+
+#ifdef PLATFORM_LINUX
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+extern int xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+extern void SetFilter(struct work_struct *work);
+#endif
+
+
+int os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf);
+void os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf);
+
+extern void set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib);
+
+extern uint remainder_len(struct pkt_file *pfile);
+extern void _open_pktfile (_pkt *pktptr, struct pkt_file *pfile);
+extern uint _pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen);
+extern sint endofpktfile (struct pkt_file *pfile);
+
+extern void os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);
+
+#endif //
+
diff --git a/drivers/net/wireless/8712u/io/rtl8712_io.c b/drivers/net/wireless/8712u/io/rtl8712_io.c
new file mode 100755
index 0000000..d424b6d
--- /dev/null
+++ b/drivers/net/wireless/8712u/io/rtl8712_io.c
@@ -0,0 +1,270 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#define _RTL8712_IO_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_io.h>
+#include <osdep_intf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_ops.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+u8 read8(_adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	u8 r_val;
+
+_func_enter_;
+
+	_read8 = pintfhdl->io_ops._read8;
+	r_val = _read8(pintfhdl, addr);
+
+_func_exit_;
+
+	return r_val;
+}
+
+u16 read16(_adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	u16 r_val;
+
+_func_enter_;
+
+	_read16 = pintfhdl->io_ops._read16;
+	r_val = _read16(pintfhdl, addr);
+
+_func_exit_;
+
+	return r_val;
+}
+	
+u32 read32(_adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+	u32 r_val;
+
+_func_enter_;
+
+	_read32 = pintfhdl->io_ops._read32;
+	r_val = _read32(pintfhdl, addr);
+
+_func_exit_;
+
+	return r_val;
+}
+
+void write8(_adapter *adapter, u32 addr, u8 val)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+
+_func_enter_;
+
+	_write8 = pintfhdl->io_ops._write8;
+	_write8(pintfhdl, addr, val);
+
+_func_exit_;
+}
+
+void write16(_adapter *adapter, u32 addr, u16 val)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+
+_func_enter_;
+
+	_write16 = pintfhdl->io_ops._write16;
+	_write16(pintfhdl, addr, val);
+
+_func_exit_;
+}
+
+void write32(_adapter *adapter, u32 addr, u32 val)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = (struct intf_hdl*)(&(pio_queue->intf));
+
+	void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+
+_func_enter_;
+
+	_write32 = pintfhdl->io_ops._write32;
+	_write32(pintfhdl, addr, val);	
+
+_func_exit_;
+}
+
+void read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);	
+
+_func_enter_;
+
+	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE)) {
+		RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
+		return;
+	}
+
+	_read_mem = pintfhdl->io_ops._read_mem;
+	_read_mem(pintfhdl, addr, cnt, pmem);
+	
+_func_exit_;
+}
+
+void write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{	
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);	
+
+_func_enter_;
+
+	_write_mem = pintfhdl->io_ops._write_mem;
+	_write_mem(pintfhdl, addr, cnt, pmem);
+
+_func_exit_;
+}
+
+void read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{	
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &(pio_queue->intf);
+
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);	
+
+_func_enter_;
+
+	if ((adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE)) {
+		RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
+		return;
+	}
+
+	_read_port = pintfhdl->io_ops._read_port;
+	_read_port(pintfhdl, addr, cnt, pmem);
+
+_func_exit_;
+}
+
+void write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{	
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+_func_enter_;	
+
+	_write_port = pintfhdl->io_ops._write_port;
+	_write_port(pintfhdl, addr, cnt, pmem);
+
+ _func_exit_;
+}
+
+void attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem) {
+#ifdef CONFIG_SDIO_HCI
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_attrib_read)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+_func_enter_;	
+
+	_attrib_read = pintfhdl->io_ops._attrib_read;
+	_attrib_read(pintfhdl, addr, cnt, pmem);
+	
+_func_exit_;
+#endif
+}
+void attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem) {
+#ifdef CONFIG_SDIO_HCI
+	struct io_queue *pio_queue = (struct io_queue*)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_attrib_write)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+_func_enter_;	
+
+	_attrib_write= pintfhdl->io_ops._attrib_write;
+	_attrib_write(pintfhdl, addr, cnt, pmem);
+
+ _func_exit_;
+#endif
+}
+
diff --git a/drivers/net/wireless/8712u/io/rtl871x_io.c b/drivers/net/wireless/8712u/io/rtl871x_io.c
new file mode 100755
index 0000000..5866983
--- /dev/null
+++ b/drivers/net/wireless/8712u/io/rtl871x_io.c
@@ -0,0 +1,571 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+/*
+
+The purpose of rtl871x_io.c
+
+a. provides the API 
+
+b. provides the protocol engine
+
+c. provides the software interface between caller and the hardware interface
+
+
+Compiler Flag Option:
+
+1. CONFIG_SDIO_HCI:
+    a. USE_SYNC_IRP:  Only sync operations are provided.
+    b. USE_ASYNC_IRP:Both sync/async operations are provided.
+
+2. CONFIG_USB_HCI:
+   a. USE_ASYNC_IRP: Both sync/async operations are provided.
+
+3. CONFIG_CFIO_HCI:
+   b. USE_SYNC_IRP: Only sync operations are provided.
+
+
+Only sync read/write_mem operations are provided.
+
+jackson@realtek.com.tw
+
+*/
+
+#define _RTL871X_IO_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_io.h>
+#include <osdep_intf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_ops.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+uint _init_intf_hdl(_adapter *padapter, struct intf_hdl *pintf_hdl)
+{	
+	struct	intf_priv	*pintf_priv;
+	void (*set_intf_option)(u32 *poption) = NULL;
+	void (*set_intf_funs)(struct intf_hdl *pintf_hdl);
+	void (*set_intf_ops)(struct _io_ops	*pops);
+	uint (*init_intf_priv)(struct intf_priv *pintfpriv);
+
+_func_enter_;
+	
+#ifdef CONFIG_SDIO_HCI
+	set_intf_option = &(sdio_set_intf_option);
+	set_intf_funs = &(sdio_set_intf_funs);
+	set_intf_ops = &sdio_set_intf_ops;
+	init_intf_priv = &sdio_init_intf_priv;
+#endif
+
+#ifdef CONFIG_USB_HCI
+	set_intf_option = &(usb_set_intf_option);
+	set_intf_funs = &(usb_set_intf_funs);
+	set_intf_ops = &usb_set_intf_ops;
+	init_intf_priv = &usb_init_intf_priv;
+#endif
+
+	pintf_priv = pintf_hdl->pintfpriv =(struct intf_priv *) _malloc(sizeof(struct intf_priv));
+	
+	if (pintf_priv == NULL)
+		goto _init_intf_hdl_fail;
+
+	pintf_hdl->adapter = (u8*)padapter;
+	
+	set_intf_option(&pintf_hdl->intf_option);
+	set_intf_funs(pintf_hdl);
+	set_intf_ops(&pintf_hdl->io_ops);
+
+	pintf_priv->intf_dev = (u8 *)&(padapter->dvobjpriv);
+	
+	if (init_intf_priv(pintf_priv) == _FAIL)
+		goto _init_intf_hdl_fail;
+	
+_func_exit_;
+
+	return _SUCCESS;
+
+_init_intf_hdl_fail:
+	
+	if (pintf_priv) {
+		_mfree((u8 *)pintf_priv, sizeof(struct intf_priv));
+	}
+	
+_func_exit_;
+
+	return _FAIL;
+	
+}
+
+void _unload_intf_hdl(struct intf_priv *pintfpriv)
+{
+	void (*unload_intf_priv)(struct intf_priv *pintfpriv);
+
+_func_enter_;	
+		
+#ifdef CONFIG_SDIO_HCI
+	unload_intf_priv = &sdio_unload_intf_priv;
+#endif
+
+#ifdef CONFIG_USB_HCI	
+      unload_intf_priv = &usb_unload_intf_priv;
+#endif 
+	
+	unload_intf_priv(pintfpriv);
+
+	if(pintfpriv){
+		_mfree((u8 *)pintfpriv, sizeof(struct intf_priv));
+	}
+	
+_func_exit_;
+}
+
+uint register_intf_hdl (u8 *dev, struct intf_hdl 	*pintfhdl)
+{
+	_adapter *adapter = (_adapter *)dev;
+	
+	pintfhdl->intf_option = 0;
+	pintfhdl->adapter = dev;
+	pintfhdl->intf_dev = (u8 *)&(adapter->dvobjpriv);
+	//pintfhdl->len = 0;
+	//pintfhdl->done_len = 0;
+	//pintfhdl->do_flush = _FALSE;
+	
+_func_enter_;
+
+	if (_init_intf_hdl(adapter, pintfhdl) == _FALSE)
+		goto register_intf_hdl_fail;
+
+_func_exit_;
+	
+	return _SUCCESS;
+
+register_intf_hdl_fail:
+	
+	// shall release all the allocated resources here...
+	//if(pintfhdl) //deleted
+	//	_mfree((u8 *)pintfhdl, (sizeof (struct intf_hdl)));
+	
+_func_exit_;		
+
+	return _FALSE;
+}
+
+void unregister_intf_hdl(struct intf_hdl *pintfhdl)
+{
+_func_enter_;
+
+	_unload_intf_hdl(pintfhdl->pintfpriv);	
+
+	_memset((u8 *)pintfhdl, 0, sizeof(struct intf_hdl));	
+	
+_func_exit_;
+}
+
+/*
+
+Must use critical section to protect alloc_ioreq and free_ioreq,
+due to the irq level possibilities of the callers.
+This is to guarantee the atomic context of the service.
+
+*/
+struct io_req *alloc_ioreq(struct io_queue *pio_q)
+{
+	_irqL	irqL;
+	_list	*phead = &pio_q->free_ioreqs;
+	struct io_req *preq = NULL;
+
+_func_enter_;
+
+	_enter_critical(&pio_q->lock, &irqL);
+
+	if (is_list_empty(phead) == _FALSE)
+	{
+		preq = LIST_CONTAINOR(get_next(phead), struct io_req, list);
+		list_delete(&preq->list);
+
+		//_memset((u8 *)preq, 0, sizeof(struct io_req));//!!!
+
+		_init_listhead(&preq->list);	
+		_init_sema(&preq->sema, 0);
+
+	}
+
+	_exit_critical(&pio_q->lock, &irqL);
+
+_func_exit_;
+
+	return preq;
+}
+
+/*
+
+	must use critical section to protect alloc_ioreq and free_ioreq,
+	due to the irq level possibilities of the callers.
+	This is to guarantee the atomic context of the service.
+
+*/
+uint free_ioreq(struct io_req *preq, struct io_queue *pio_q)
+{
+	_irqL	irqL;
+	_list	*phead = &pio_q->free_ioreqs;	
+
+_func_enter_;
+
+	_enter_critical(&pio_q->lock, &irqL);
+
+	list_insert_tail(&(preq->list), phead);
+
+	_exit_critical(&pio_q->lock, &irqL);
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+#if 0
+void query_ioreq_sz(struct io_req *pio_req, u32 *w_sz, u32 *r_sz)
+{
+	*w_sz = 2;
+	*r_sz = 0;
+
+_func_enter_;
+
+	if (pio_req->command & _IO_WRITE_)
+	{
+		if (pio_req->command & _IO_BURST_)
+			*w_sz = (*w_sz) + (((pio_req->command) & _IOSZ_MASK_) >> 2);
+		else
+			*w_sz = (*w_sz) + 1;
+	}
+	else
+	{
+	#if 0	
+		if ((*r_sz) == 0)
+			*r_sz = 1;
+	#endif
+		
+		*r_sz = 2;
+		
+		if (pio_req->command & _IO_BURST_)
+		{
+			*r_sz = (*r_sz) + (((pio_req->command) & _IOSZ_MASK_) >> 2);			
+		}
+		else
+		{
+			*r_sz = (*r_sz) + 1;
+		}
+	}
+
+_func_exit_;
+}
+
+/*
+
+*/
+static u32 _fillin_iocmd(struct io_req *pio_req, volatile u32 **ppcmdbuf)
+{
+	u32 w_cnt = 2;
+	u32 cmd;
+	volatile u32 *pcmdbuf = *ppcmdbuf;
+
+_func_enter_;	
+
+	cmd = ((pio_req->command) &  _IO_CMDMASK_);
+	
+	if (pio_req->command & _IO_BURST_)
+		cmd |= ((pio_req->command) & _IOSZ_MASK_);
+
+	*pcmdbuf = cmd;
+	pcmdbuf++;
+	*pcmdbuf = pio_req->addr;
+	pcmdbuf++;	
+
+	if (pio_req->command & _IO_WRITE_)
+	{
+		if (pio_req->command & _IO_BURST_)
+		{
+			
+			_memcpy((u8 *)pcmdbuf, pio_req->pbuf, ((pio_req->command) & _IOSZ_MASK_));
+			
+			pcmdbuf += (((pio_req->command) & _IOSZ_MASK_) >> 2);
+			
+			w_cnt += (((pio_req->command) & _IOSZ_MASK_) >> 2);
+		}
+		else
+		{
+			*pcmdbuf = pio_req->val;
+			pcmdbuf ++;
+			w_cnt ++;
+		}
+	}
+	else
+	{
+#if 0		
+		if (*r_cnt == 0)
+			*r_cnt = 1;
+		
+		*r_cnt = (*r_cnt) + 2;
+		
+		if (pio_req->command & _IO_BURST_)
+		{
+			*r_cnt += (((pio_req->command) & _IOSZ_MASK_) >> 2);			
+		}
+		else
+		{
+			*r_cnt = (*r_cnt) + 1;
+		}
+#endif
+
+	}
+
+	*ppcmdbuf = pcmdbuf;
+
+_func_exit_;
+
+	return w_cnt;
+}
+
+u32 _ioreq2rwmem(struct io_queue *pio_q)
+{
+	_list *phead, *plist;
+
+	struct io_req *pio_req;
+
+	struct intf_hdl *pintf = &(pio_q->intf);
+
+	struct intf_priv *pintfpriv = pintf->pintfpriv;
+	volatile u32 *pnum_reqs = (volatile u32 *)pintfpriv->io_rwmem;
+	volatile u32 *pcmd = (volatile u32 *)pintfpriv->io_rwmem;
+
+	u32 r_sz = 0, all_r_sz = 1,  w_sz = 0, all_w_sz = 1;
+
+_func_enter_;
+
+	phead = &(pio_q->pending);
+
+	plist = get_next(phead);
+
+	_memset((u8 *)pintfpriv->io_rwmem, 0, pintfpriv->max_iosz);
+	
+	pcmd++;
+	while (1)
+	{
+		if ((is_list_empty(phead)) == _TRUE)
+			break;
+		
+		pio_req = LIST_CONTAINOR(plist, struct io_req, list);
+		
+		query_ioreq_sz(pio_req, &w_sz, &r_sz);
+
+		if ((all_r_sz + r_sz) > (pintfpriv->max_iosz >> 2))
+			break;
+		if ((all_w_sz + w_sz) > (pintfpriv->max_iosz >> 2))
+			break;
+
+		list_delete(&(pio_req->list));
+		
+		 _fillin_iocmd(pio_req, &pcmd);	
+
+		list_insert_tail(&(pio_req->list),&(pio_q->processing));
+
+		plist = get_next(phead);
+
+		all_r_sz += r_sz;
+		all_w_sz += w_sz;
+		
+		*pnum_reqs = *pnum_reqs + 1;
+	}
+
+	pintfpriv->io_rsz = all_r_sz;
+	pintfpriv->io_wsz = all_w_sz;
+	
+	if ((all_r_sz > 1 ) || (all_w_sz > 1)) {
+		_func_exit_;
+		return _TRUE;
+	} else {
+		_func_exit_;
+		return _FALSE;
+	}
+}
+#endif
+
+
+uint alloc_io_queue(_adapter *adapter)
+{
+	u32 i;
+	struct io_queue *pio_queue; 
+	struct io_req *pio_req;
+
+_func_enter_;
+
+	pio_queue = (struct io_queue *)_malloc (sizeof (struct io_queue));
+
+	if (pio_queue == NULL) {
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("\n  alloc_io_queue:pio_queue == NULL !!!!\n"));
+		goto alloc_io_queue_fail;	
+	}
+
+	_init_listhead(&pio_queue->free_ioreqs);
+	_init_listhead(&pio_queue->processing);
+	_init_listhead(&pio_queue->pending);
+
+	_spinlock_init(&pio_queue->lock);
+
+	pio_queue->pallocated_free_ioreqs_buf = (u8 *)_malloc(NUM_IOREQ *(sizeof (struct io_req)) + 4);
+
+	if ((pio_queue->pallocated_free_ioreqs_buf) == NULL) {
+		RT_TRACE(_module_rtl871x_io_c_,_drv_err_,("\n  alloc_io_queue:(pio_queue->pallocated_free_ioreqs_buf) == NULL!!!!\n"));
+		goto alloc_io_queue_fail;
+	}
+
+	_memset(pio_queue->pallocated_free_ioreqs_buf, 0, (NUM_IOREQ *(sizeof (struct io_req)) + 4));
+
+	pio_queue->free_ioreqs_buf = pio_queue->pallocated_free_ioreqs_buf + 4 
+			- ((u32 )(pio_queue->pallocated_free_ioreqs_buf)  & 3);
+
+	pio_req = (struct io_req *)(pio_queue->free_ioreqs_buf);
+
+	for(i = 0; i < 	NUM_IOREQ; i++)
+	{
+		_init_listhead(&pio_req->list);
+
+		_init_sema(&pio_req->sema, 0);
+
+#if defined ( PLATFORM_OS_XP) && defined (CONFIG_SDIO_HCI)
+	pio_req->pirp = IoAllocateIrp(adapter->dvobjpriv.nextdevstacksz+2, FALSE);
+	if (pio_req->pirp == NULL)
+		goto alloc_io_queue_fail;
+	pio_req->pmdl=IoAllocateMdl((u8 *)&pio_req->val, 4, FALSE, FALSE, NULL);
+	if (pio_req->pmdl== NULL) {
+		RT_TRACE(_module_rtl871x_io_c_,_drv_err_,("alloc_io_queue : MDL is NULL.\n "));	
+		goto alloc_io_queue_fail;
+	}
+	MmBuildMdlForNonPagedPool(pio_req->pmdl);
+	pio_req->sdrp = ExAllocatePool(NonPagedPool, sizeof(SDBUS_REQUEST_PACKET));
+	if (pio_req->sdrp == NULL) {
+		RT_TRACE(_module_rtl871x_io_c_,_drv_err_,("alloc_io_queue : sdrp is NULL.\n "));	
+		goto alloc_io_queue_fail;
+	}
+#endif
+		list_insert_tail(&pio_req->list, &pio_queue->free_ioreqs);
+
+		pio_req++;	
+	}		
+
+	if ((register_intf_hdl((u8*)adapter, &(pio_queue->intf))) == _FAIL) {
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("\n  alloc_io_queue:register_intf_hdl == _FAIL !!!!\n"));
+		goto alloc_io_queue_fail;
+	}
+
+	adapter->pio_queue = pio_queue;
+
+_func_exit_;
+
+	return _SUCCESS;
+	
+alloc_io_queue_fail:
+
+	if (pio_queue) {
+		if (pio_queue->pallocated_free_ioreqs_buf)
+			_mfree(pio_queue->pallocated_free_ioreqs_buf, NUM_IOREQ *(sizeof (struct io_req)) + 4);	
+
+		_mfree((u8*)pio_queue, sizeof (struct io_queue));
+	}
+
+	adapter->pio_queue = NULL;
+
+_func_exit_;
+
+	return _FAIL;
+}
+
+void mfree_io_queue_lock(struct io_queue	*pio_queue)
+{
+	u32 i;
+	struct io_req *pio_req;
+
+	_spinlock_free(&pio_queue->lock);
+
+	pio_req = (struct io_req *)(pio_queue->free_ioreqs_buf);
+
+	for (i = 0; i < NUM_IOREQ; i++) {
+		_free_sema(&(pio_req->sema));
+	}
+}
+
+void free_io_queue(_adapter *adapter)
+{
+	struct io_queue *pio_queue = (struct io_queue *)(adapter->pio_queue);
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("free_io_queue\n"));
+	
+	if (pio_queue) {
+		mfree_io_queue_lock(pio_queue);
+		if (pio_queue->pallocated_free_ioreqs_buf)
+			_mfree(pio_queue->pallocated_free_ioreqs_buf, NUM_IOREQ *(sizeof (struct io_req)) + 4);	
+		adapter->pio_queue = NULL;
+		unregister_intf_hdl(&pio_queue->intf);
+		_mfree((u8*)pio_queue, sizeof (struct io_queue));		
+	}
+
+_func_exit_;
+}
+
diff --git a/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_linux.c b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_linux.c
new file mode 100755
index 0000000..b11ce39
--- /dev/null
+++ b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_linux.c
@@ -0,0 +1,4082 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_IOCTL_LINUX_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+#include <rtl871x_debug.h>
+#include <wifi.h>
+#include <rtl871x_mlme.h>
+#include <rtl871x_ioctl.h>
+#include <rtl871x_ioctl_set.h>
+#include <rtl871x_ioctl_query.h>
+#ifdef CONFIG_MP_INCLUDED
+#include <rtl871x_mp_ioctl.h>
+#endif
+
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#define  iwe_stream_add_event(a, b, c, d, e)  iwe_stream_add_event(b, c, d, e)
+#define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
+#endif
+
+
+#define RTL_IOCTL_WPA_SUPPLICANT	SIOCIWFIRSTPRIV+0x1E
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+// combo scan
+#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
+#define WEXT_CSCAN_HEADER_SIZE		12
+#define WEXT_CSCAN_SSID_SECTION		'S'
+#define WEXT_CSCAN_CHANNEL_SECTION	'C'
+#define WEXT_CSCAN_NPROBE_SECTION	'N'
+#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
+#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
+#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
+#define WEXT_CSCAN_TYPE_SECTION		'T'
+
+
+u32 rtl8180_rates[] = {1000000,2000000,5500000,11000000,
+	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
+
+const long ieee80211_wlan_frequencies[] = {
+	2412, 2417, 2422, 2427,
+	2432, 2437, 2442, 2447,
+	2452, 2457, 2462, 2467,
+	2472, 2484
+};
+
+const char * const iw_operation_mode[] =
+{
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor"
+};
+
+static int hex2num_i(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return -1;
+}
+
+static int hex2byte_i(const char *hex)
+{
+	int a, b;
+	a = hex2num_i(*hex++);
+	if (a < 0)
+		return -1;
+	b = hex2num_i(*hex++);
+	if (b < 0)
+		return -1;
+	return (a << 4) | b;
+}
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex2num_i(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex2num_i(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+static void indicate_wx_custom_event(_adapter *padapter, char *msg)
+{
+	u8 *buff, *p;
+	union iwreq_data wrqu;
+
+	if (strlen(msg) > IW_CUSTOM_MAX) {
+		printk("%s strlen(msg):%u > IW_CUSTOM_MAX:%u\n", __FUNCTION__ ,strlen(msg), IW_CUSTOM_MAX);
+		return;
+	}
+
+	buff = _malloc(IW_CUSTOM_MAX+1);
+	if(!buff)
+		return;
+
+	_memset(buff, 0, IW_CUSTOM_MAX+1);	
+	
+	_memcpy(buff, msg, strlen(msg));
+		
+	_memset(&wrqu,0,sizeof(wrqu));
+	wrqu.data.length = strlen(msg);
+
+	printk("%s %s\n", __FUNCTION__, buff);	
+	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+
+	_mfree(buff, IW_CUSTOM_MAX+1);
+
+}
+
+void request_wps_pbc_event(_adapter *padapter)
+{
+	u8 *buff, *p;
+	union iwreq_data wrqu;
+
+
+	buff = _malloc(IW_CUSTOM_MAX);
+	if(!buff)
+		return;
+		
+	_memset(buff, 0, IW_CUSTOM_MAX);
+		
+	p=buff;
+		
+	p+=sprintf(p, "WPS_PBC_START.request=TRUE");
+		
+	_memset(&wrqu,0,sizeof(wrqu));
+		
+	wrqu.data.length = p-buff;
+		
+	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+	printk("%s\n", __FUNCTION__);
+		
+	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+
+	if(buff)
+	{
+		_mfree(buff, IW_CUSTOM_MAX);
+	}
+
+}
+
+void indicate_wx_scan_complete_event(_adapter *padapter)
+{	
+	union iwreq_data wrqu;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+
+	_memset(&wrqu, 0, sizeof(union iwreq_data));
+
+	wireless_send_event(padapter->pnetdev, SIOCGIWSCAN, &wrqu, NULL);
+}
+
+void indicate_wx_assoc_event(_adapter *padapter)
+{
+	union iwreq_data wrqu;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+	_memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
+
+	//printk("+indicate_wx_assoc_event\n");
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+void indicate_wx_disassoc_event(_adapter *padapter)
+{
+	union iwreq_data wrqu;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+
+	//printk("+indicate_wx_disassoc_event\n");
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+/*
+uint is_cckrates_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0)
+	{
+		if ( (((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||
+			(((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22) )
+			return _TRUE;
+		i++;
+	}
+
+	return _FALSE;
+}
+
+uint is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0)
+	{
+		if ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+			(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+			return _FALSE;
+		i++;
+	}
+
+	return _TRUE;
+}
+*/
+
+static inline char *translate_scan(_adapter *padapter, struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{
+	struct iw_event iwe;
+	u16 cap;
+	u32 ht_ielen = 0;
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	u16 max_rate, rate, ht_cap=_FALSE;
+	u32 i = 0;
+	char *current_val;
+	long rssi;
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	u8 bw_40MHz=0, short_GI=0;
+	u16 mcs_rate=0;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+
+	if ( ( pnetwork->network.Configuration.DSConfig < 1 ) || ( pnetwork->network.Configuration.DSConfig > 14 ) )
+	{
+		printk( "[%s] SSID = %s, DSConfig = %d\n", __FUNCTION__, pnetwork->network.Ssid.Ssid,
+								pnetwork->network.Configuration.DSConfig );
+		if ( pnetwork->network.Configuration.DSConfig < 1 )
+		{
+			pnetwork->network.Configuration.DSConfig = 1;
+		}
+		else
+		{
+			pnetwork->network.Configuration.DSConfig = 14;
+		}
+	}
+
+	/* AP MAC address */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	_memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+
+	/* Add the ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	//parsing HT_CAP_IE
+	p = get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
+	if(p && ht_ielen>0)
+	{
+		ht_cap = _TRUE;
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if ((is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	}
+	else if ((is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	}
+	else
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+	}
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	_memcpy((u8 *)&cap, get_capability_from_ie(pnetwork->network.IEs), 2);
+
+	cap = le16_to_cpu(cap);
+
+	if (cap & (WLAN_CAPABILITY_IBSS|WLAN_CAPABILITY_BSS)) {
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+
+	/* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = ieee80211_wlan_frequencies[pnetwork->network.Configuration.DSConfig-1] * 100000;
+	iwe.u.freq.e = 1;
+	iwe.u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	/*Add basic and extended rates */
+	max_rate = 0;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while (pnetwork->network.SupportedRates[i] != 0)
+	{
+		rate = pnetwork->network.SupportedRates[i]&0x7F;
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+
+	if(ht_cap == _TRUE)
+	{
+		if(mcs_rate&0x8000)//MCS15
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+
+		}
+		else if(mcs_rate&0x0080)//MCS7
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+		else//default MCS7
+		{
+			printk("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate);
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+#if 0
+#ifdef CONFIG_80211N_HT
+		bw_40MHz = pregpriv->cbw40_enable;
+#else
+		bw_40MHz = 0;
+#endif
+
+		switch (pregpriv->rf_config)
+		{
+			case RTL8712_RF_1T1R:
+				max_rate = (bw_40MHz) ? 150:65;
+				break;
+			case RTL8712_RF_2T2R:
+				max_rate = (bw_40MHz) ? 300:130;
+				break;
+			case RTL8712_RF_1T2R:
+			default:
+				max_rate = (bw_40MHz) ? 270:130;
+				break;
+		}
+#endif
+		max_rate = max_rate*2;//Mbps/2;
+	}
+
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = max_rate * 500000;
+	start = iwe_stream_add_event(info, start, stop, &iwe,
+				     IW_EV_PARAM_LEN);
+
+	//parsing WPA/WPA2 IE
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 wpa_ie[255],rsn_ie[255],wps_ie[255];
+		u16 wpa_len=0,rsn_len=0,wps_len=0;
+		u8 *p;
+		sint out_len=0;
+		out_len=get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("r8711_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("r8711_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
+
+		if (wpa_len > 0)
+		{
+			p = buf;
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "wpa_ie=");
+			for (i = 0; i < wpa_len; i++) {
+				p += sprintf(p, "%02x", wpa_ie[i]);
+			}
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = wpa_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);
+		}
+		if (rsn_len > 0)
+		{
+			p = buf;
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "rsn_ie=");
+			for (i = 0; i < rsn_len; i++) {
+				p += sprintf(p, "%02x", rsn_ie[i]);
+			}
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);
+		}
+	}
+
+	{//parsing WPS IE
+		u8 wps_ie[512];
+		uint wps_ielen;
+
+		if(get_wps_ie(pnetwork->network.IEs, pnetwork->network.IELength, wps_ie, &wps_ielen))
+		{
+			if(wps_ielen>2)
+			{
+				iwe.cmd =IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop, &iwe, wps_ie);
+			}
+		}
+	}
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	rssi = signal_scale_mapping(pnetwork->network.Rssi);
+
+	//printk("RSSI=%d\n", (u8)rssi);
+
+	//iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID;
+
+	// we only update signal_level (signal strength) that is rssi.
+	iwe.u.qual.updated = IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID;
+
+	//H(signal strength) = H(signal quality) + H(noise level);
+
+#ifdef CONFIG_PLATFORM_MT53XX
+	iwe.u.qual.level = (u8)rssi;  //force showing % in MT53XX
+#else
+	#ifdef CONFIG_ANDROID
+	iwe.u.qual.level = (u8) (pnetwork->network.Rssi>>1)-95;
+	#else
+	iwe.u.qual.level = (u8)rssi;  //signal strength
+	#endif
+	iwe.u.qual.qual = 0; // signal quality
+	iwe.u.qual.noise = 0; // noise level
+#endif
+
+	//printk("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+
+	//how to translate rssi to ?%
+	//rssi = (iwe.u.qual.level*2) + 190;
+	//if(rssi>100) rssi = 100;
+	//if(rssi<0) rssi = 0;
+
+	return start;
+}
+
+static int wpa_set_auth_algs(struct net_device *dev, u32 value)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM))
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY and  AUTH_ALG_OPEN_SYSTEM [value:0x%x]\n", value));
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.dot11AuthAlgrthm = 3;
+	}
+	else if (value & AUTH_ALG_SHARED_KEY)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY  [value:0x%x]\n", value));
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.dot11AuthAlgrthm = 3;
+#else
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
+		padapter->securitypriv.dot11AuthAlgrthm = 1;
+#endif
+
+	}
+	else if (value & AUTH_ALG_OPEN_SYSTEM)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n"));
+		//padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		if (padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK)
+		{
+
+#ifdef CONFIG_PLATFORM_MT53XX
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+ 			padapter->securitypriv.dot11AuthAlgrthm = 3;
+#else
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+ 			padapter->securitypriv.dot11AuthAlgrthm = 0;
+#endif
+
+		}
+	}
+	else if (value & AUTH_ALG_LEAP) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("wpa_set_auth_algs, AUTH_ALG_LEAP\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			("wpa_set_auth_algs, error!\n"));
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len=0;
+	NDIS_802_11_WEP	 *pwep = NULL;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+_func_enter_;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len != (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("wpa_set_encryption, crypt.alg = WEP\n"));
+		printk("wpa_set_encryption, crypt.alg = WEP\n");
+
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(1)wep_key_idx=%d\n", wep_key_idx));
+		printk("(1)wep_key_idx=%d\n", wep_key_idx);
+
+		if (wep_key_idx > WEP_KEYS)
+			return -EINVAL;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(2)wep_key_idx=%d\n", wep_key_idx));
+
+		if (wep_key_len > 0)
+		{
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+
+			pwep = (NDIS_802_11_WEP*) _malloc(wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial));
+			if (pwep == NULL) {
+				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
+				goto exit;
+			}
+
+			_memset(pwep, 0, sizeof(NDIS_802_11_WEP));
+
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+
+			if (wep_key_len == 13)
+			{
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}
+		}
+		else {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		_memcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);
+
+		if (param->u.crypt.set_tx)
+		{
+			printk("wep, set_tx=1\n");
+
+			if (set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			{
+				ret = -EOPNOTSUPP;
+			}
+		}
+		else
+		{
+			printk("wep, set_tx=0\n");
+
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and
+			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can set_key to fw/cam
+
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP;
+				goto exit;
+			}
+
+			_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;
+			set_key(padapter, psecuritypriv, wep_key_idx);
+		}
+
+		goto exit;
+	}
+
+	if (padapter->securitypriv.dot11AuthAlgrthm == 2) // 802_1x
+	{
+		struct sta_info *psta, *pbcmc_sta;
+		struct sta_priv *pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		{
+			psta = get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			if (psta == NULL) {
+				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
+			}
+			else
+			{
+				psta->ieee8021x_blocked = _FALSE;
+
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}
+
+				if(param->u.crypt.set_tx ==1)//pairwise key
+				{
+					_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					{
+						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey=_FALSE;
+						_set_timer(&padapter->securitypriv.tkip_timer, 50);
+					}
+
+					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
+					//DEBUG_ERR(("\n ~~~~stastakey:unicastkey\n"));
+
+					setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
+				}
+				else//group key
+				{
+					if( ( 0 < param->u.crypt.idx ) &&  ( param->u.crypt.idx < 3 ) )
+					{  //group key idx is 1 or 2
+				
+						_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+						_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx-1].skey,&(param->u.crypt.key[16]),8);
+						_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx-1].skey,&(param->u.crypt.key[24]),8);
+
+						padapter->securitypriv.binstallGrpkey = _TRUE;
+						//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						//DEBUG_ERR(("\n ~~~~stastakey:groupkey\n"));
+						set_key(padapter,&padapter->securitypriv,param->u.crypt.idx);
+#ifdef CONFIG_PWRCTRL
+						if(padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE){
+							if(padapter->registrypriv.power_mgnt != padapter->pwrctrlpriv.pwr_mode){
+								_set_timer(&(padapter->mlmepriv.dhcp_timer), 60000);
+							}
+						}
+#endif
+					}
+				}
+			}
+
+			pbcmc_sta=get_bcmc_stainfo(padapter);
+			if (pbcmc_sta == NULL)
+			{
+				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
+			}
+			else
+			{
+				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}
+			}
+		}
+		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		{
+		}
+	}
+
+exit:
+
+	if (pwep) {
+		_mfree((u8 *)pwep, wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial));
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r871x_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
+{
+	u8 *buf = NULL, *pos = NULL;
+	u32 left;
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL))
+		return -EINVAL;
+
+	if (ielen)
+	{
+		buf = _malloc(ielen);
+		if (buf == NULL){
+			ret = -ENOMEM;
+			goto exit;
+		}
+
+		_memcpy(buf, pie , ielen);
+
+		//dump
+		{
+			int i;
+			printk("\n wpa_ie(length:%d):\n", ielen);
+			for(i=0;i<ielen;i=i+8)
+				printk("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+		}
+
+		pos = buf;
+		if (ielen < RSN_HEADER_LEN) {
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
+			ret  = -1;
+			goto exit;
+		}
+
+#if 0
+		pos += RSN_HEADER_LEN;
+		left = ielen - RSN_HEADER_LEN;
+
+		if (left >= RSN_SELECTOR_LEN) {
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+		else if (left > 0){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
+			ret = -1;
+			goto exit;
+		}
+#endif
+
+		if (parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm = 2;
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;
+		}
+
+		if (parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm = 2;
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;
+		}
+
+		switch (group_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot118021XGrpPrivacy = _AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:
+				padapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+
+		switch (pairwise_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+
+		padapter->securitypriv.wps_phase = _FALSE;
+		{//set wps_ie
+			u16 cnt = 0;
+			u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+
+			while (cnt < ielen)
+			{
+				eid = buf[cnt];
+
+				if((eid==_VENDOR_SPECIFIC_IE_)&&(_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
+				{
+					printk("SET WPS_IE\n");
+
+					padapter->securitypriv.wps_ie_len = ( (buf[cnt+1]+2) < (MAX_WPA_IE_LEN<<2)) ? (buf[cnt+1]+2):(MAX_WPA_IE_LEN<<2);
+
+					_memcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);
+
+					padapter->securitypriv.wps_phase = _TRUE;
+
+					printk("SET WPS_IE, wps_phase==_TRUE\n");
+
+					cnt += buf[cnt+1]+2;
+
+					break;
+				} else {
+					cnt += buf[cnt+1]+2; //goto next
+				}
+			}
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("r871x_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
+		  pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+
+exit:
+
+	if (buf) _mfree(buf, ielen);
+
+	return ret;
+}
+
+static int r8711_wx_get_name(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u16 cap;
+	u32 ht_ielen = 0;
+	char *p;
+	u8 ht_cap=_FALSE;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	NDIS_WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	NDIS_802_11_RATES_EX* prates = NULL;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("cmd_code=%x\n", info->cmd));
+
+_func_enter_;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		//parsing HT_CAP_IE
+		p = get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if(p && ht_ielen>0)
+		{
+			ht_cap = _TRUE;
+		}
+
+		prates = &pcur_bss->SupportedRates;
+
+		if (is_cckratesonly_included((u8*)prates) == _TRUE)
+		{
+			if (ht_cap == _TRUE)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
+		}
+		else if ((is_cckrates_included((u8*)prates)) == _TRUE)
+		{
+			if (ht_cap == _TRUE)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
+		}
+		else
+		{
+			if(ht_cap == _TRUE)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+		}
+	}
+	else
+	{
+		//prates = &padapter->registrypriv.dev_network.SupportedRates;
+		//snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	}
+
+_func_exit_;
+
+	return 0;
+}
+static const long frequency_list[] = {
+    2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462, 2467, 2472, 2484,
+    4915, 4920, 4925, 4935, 4940, 4945, 4960, 4980,
+    5035, 5040, 5045, 5055, 5060, 5080, 5170, 5180, 5190, 5200, 5210, 5220, 5230, 5240,
+    5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560, 5580, 5600, 5620, 5640, 5660, 5680,
+    5700, 5745, 5765, 5785, 5805, 5825
+};
+
+static int r8711_wx_set_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_freq *fwrq = & wrqu->freq;
+	int rc = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+r8711_wx_set_freq\n"));
+	//If setting by frequency, convert to a channel
+	if((fwrq->e == 1) &&
+		(fwrq->m >= (int) 2.412e8) &&
+		(fwrq->m <= (int) 2.487e8)) {
+		int f = fwrq->m / 100000;
+		int c = 0;
+		while((c < 14) && (f != frequency_list[c]))
+			c++;
+		fwrq->e = 0;
+		fwrq->m = c + 1;
+		printk("+r8711_wx_set_freq  f=%x c=%x wrqu->e=%x wrqu->m=%x\n",f,c,fwrq->e,fwrq->m);
+	}
+	// Setting by channel number
+	if((fwrq->m > 14) || (fwrq->e > 0))
+		rc = -EOPNOTSUPP;
+	else {
+		int channel = fwrq->m;
+		if((channel < 1) || (channel > 14)) {
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("%s: New channel value of %d is invalid!\n", dev->name, fwrq->m));
+			rc = -EINVAL;
+		} else {
+			// Yes ! We can set it !!!
+             RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, (" Set to channel = %d\n", channel));
+			padapter->registrypriv.channel=channel;  
+		}
+	}
+
+_func_exit_;
+
+	return rc;
+}
+
+static int r8711_wx_get_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	NDIS_WLAN_BSSID_EX *pcur_bss = &pmlmepriv->cur_network.network;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+r8711_wx_get_freq\n"));
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	{
+		wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+	} else
+		return -1;
+
+	return 0;
+}
+
+static int r8711_wx_set_mode(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+	int ret = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r8711_wx_set_mode: mode=0x%x\n", wrqu->mode));
+
+	switch(wrqu->mode)
+	{
+		case IW_MODE_AUTO: // 0
+			networkType = Ndis802_11AutoUnknown;
+			printk("set_mode = IW_MODE_AUTO\n");
+			break;
+		case IW_MODE_ADHOC: // 1
+			networkType = Ndis802_11IBSS;
+			printk("set_mode = IW_MODE_ADHOC\n");
+			break;
+		case IW_MODE_MASTER: // 3
+			networkType = Ndis802_11APMode;
+			printk("set_mode = IW_MODE_MASTER\n");
+			//setopmode_cmd(padapter, networkType);
+			break;
+		case IW_MODE_INFRA: // 2
+			networkType = Ndis802_11Infrastructure;
+			printk("set_mode = IW_MODE_INFRA\n");
+			break;
+
+		default :
+			ret = -EINVAL;
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("Mode: %d is not supported\n", wrqu->mode));
+//			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("Mode: %s is not supported\n", iw_operation_mode[wrqu->mode]));
+			goto exit;
+	}
+
+	if (Ndis802_11APMode == networkType) {
+		setopmode_cmd(padapter, networkType);
+	} else {
+		setopmode_cmd(padapter, Ndis802_11AutoUnknown);
+	}
+
+	if (set_802_11_infrastructure_mode(padapter, networkType) == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r8711_wx_get_mode\n"));
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE) {
+		wrqu->mode = IW_MODE_INFRA;
+	} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE) == _TRUE) {
+		wrqu->mode = IW_MODE_ADHOC;
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+		wrqu->mode = IW_MODE_MASTER;
+	}
+	else
+	{
+		wrqu->mode = IW_MODE_AUTO;
+	}
+
+_func_exit_;
+
+	return 0;
+}
+
+static int r871x_wx_set_pmkid(struct net_device *dev,
+			     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	struct iw_pmksa *pPMK = (struct iw_pmksa*) extra;
+
+	u8 strZeroMacAddress[ETH_ALEN] = { 0x00 };
+	u8 strIssueBssid[ETH_ALEN] = { 0x00 };
+
+	u8 j, blInserted = _FALSE;
+	int intReturn = _FALSE;
+
+#if 0
+	struct iw_pmksa
+	{
+		__u32 cmd;
+		struct sockaddr bssid;
+		__u8 pmkid[IW_PMKID_LEN];	//IW_PMKID_LEN=16
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+r871x_wx_set_pmkid\n"));
+/*
+	There are the BSSID information in the bssid.sa_data array.
+	If cmd is IW_PMKSA_FLUSH, it means the wpa_suppplicant wants to clear all the PMKID information.
+	If cmd is IW_PMKSA_ADD, it means the wpa_supplicant wants to add a PMKID/BSSID to driver.
+	If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to remove a PMKID/BSSID from driver.
+*/
+
+	_memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+
+	if (pPMK->cmd == IW_PMKSA_ADD)
+	{
+		printk("r871x_wx_set_pmkid: IW_PMKSA_ADD!\n");
+		if (_memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN) == _TRUE) {
+			return intReturn;
+		} else {
+			intReturn = _TRUE;
+		}
+		blInserted = _FALSE;
+
+		//overwrite PMKID
+		for (j=0 ; j<NUM_PMKID_CACHE; j++)
+		{
+			if (_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
+			{ // BSSID is matched, the same AP => rewrite with new PMKID.
+				printk( "r871x_wx_set_pmkid: BSSID exists in the PMKList.\n" );
+
+				_memcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+				psecuritypriv->PMKIDList[j].bUsed = _TRUE;
+				psecuritypriv->PMKIDIndex = j + 1; //?
+				blInserted = _TRUE;
+				break;
+			}
+		}
+
+		if (!blInserted)
+		{
+			// Find a new entry
+			printk("r871x_wx_set_pmkid: Use the new entry index = %d for this PMKID.\n",
+				psecuritypriv->PMKIDIndex);
+
+			_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+			_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+
+			psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = _TRUE;
+			psecuritypriv->PMKIDIndex++ ;
+			if (psecuritypriv->PMKIDIndex == NUM_PMKID_CACHE) {
+				psecuritypriv->PMKIDIndex = 0;
+			}
+		}
+	}
+	else if (pPMK->cmd == IW_PMKSA_REMOVE)
+	{
+		printk("r871x_wx_set_pmkid: IW_PMKSA_REMOVE!\n");
+		intReturn = _TRUE;
+		for (j=0; j<NUM_PMKID_CACHE; j++)
+		{
+			if( _memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
+			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
+				_memset( psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN );
+				psecuritypriv->PMKIDList[ j ].bUsed = _FALSE;
+				break;
+			}
+		}
+	}
+	else if (pPMK->cmd == IW_PMKSA_FLUSH)
+	{
+		printk("r871x_wx_set_pmkid: IW_PMKSA_FLUSH!\n");
+		_memset(psecuritypriv->PMKIDList, 0, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		psecuritypriv->PMKIDIndex = 0;
+		intReturn = _TRUE;
+	}
+
+	return intReturn;
+}
+
+static int r8711_wx_get_sens(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = rtw_netdev_priv(dev);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+r8711_wx_get_sens\n"));
+
+	wrqu->sens.value = 0;
+	wrqu->sens.fixed = 0;	/* no auto select */
+	wrqu->sens.disabled = 1;
+
+	return 0;
+}
+
+static int r8711_wx_get_range(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+//	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	u16 val;
+	int i;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("+r8711_wx_get_range: cmd_code=%x\n", info->cmd));
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;
+
+	// TODO: Not used in 802.11b?
+//	range->min_nwid;	/* Minimal NWID we are able to set */
+	// TODO: Not used in 802.11b?
+//	range->max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+//	range->old_num_channels;
+//	range->old_num_frequency;
+//	range->old_freq[6]; /* Filler to keep "version" at the same offset */
+
+	// TODO: 8711 sensitivity ?
+	/* signal level threshold range */
+
+#ifdef CONFIG_RTL8711
+	range->max_qual.qual = 100;
+	/* TODO: Find real max RSSI and stick here */
+	range->max_qual.level = 0;
+	range->max_qual.noise = -98;
+	range->max_qual.updated = 7; /* Updated all three */
+#endif
+
+#ifdef CONFIG_RTL8712
+	//percent values between 0 and 100.
+	range->max_qual.qual = 100;
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = 7; /* Updated all three */
+#endif
+
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + -98;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+
+	range->num_bitrates = RATE_COUNT;
+
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = rtl8180_rates[i];
+	}
+
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+	range->pm_capa = 0;
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+//	range->retry_capa;	/* What retry options are supported */
+//	range->retry_flags;	/* How to decode max/min retry limit */
+//	range->r_time_flags;	/* How to decode max/min retry life */
+//	range->min_retry;	/* Minimal number of retries */
+//	range->max_retry;	/* Maximal number of retries */
+//	range->min_r_time;	/* Minimal retry lifetime */
+//	range->max_r_time;	/* Maximal retry lifetime */
+
+	range->num_channels = 14;
+
+	for (i = 0, val = 0; i < 14; i++) {
+
+		// Include only legal frequencies for some countries
+		//if ((priv->challow)[i+1]) {
+			range->freq[val].i = i + 1;
+			range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
+			range->freq[val].e = 1;
+			val++;
+		//} else {
+			// FIXME: do we need to set anything for channels
+			// we don't use ?
+		//}
+
+		if (val == IW_MAX_FREQUENCIES)
+		break;
+	}
+
+	range->num_frequency = val;
+
+// Commented by Albert 2009/10/13
+// The following code will proivde the security capability to network manager.
+// If the driver doesn't provide this capability to network manager,
+// the WPA/WPA2 routers can't be choosen in the network manager.
+
+/*
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+*/
+
+#if WIRELESS_EXT > 17
+	range->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|
+				IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
+#endif
+
+#ifdef IW_SCAN_CAPA_ESSID
+	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE |IW_SCAN_CAPA_BSSID|
+					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
+#endif
+
+_func_exit_;
+
+	return 0;
+}
+
+//set bssid flow
+//s1. set_802_11_infrastructure_mode()
+//s2. set_802_11_authentication_mode()
+//s3. set_802_11_encryption_mode()
+//s4. set_802_11_bssid()
+static int r8711_wx_set_wap(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	int ret = 0;
+
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+
+	struct sockaddr *temp = (struct sockaddr *)awrq;
+
+	_irqL irqL;
+	_list *phead;
+	u8 *dst_bssid;
+	struct wlan_network *pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r8711_wx_set_wap\n"));
+
+	if (padapter->bup == _FALSE)
+		return -1;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
+		return -1;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		return ret;
+
+	if (temp->sa_family != ARPHRD_ETHER)
+		return -EINVAL;
+
+	authmode = padapter->securitypriv.ndisauthtype;
+
+	_enter_critical(&queue->lock, &irqL);
+
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+
+	while (1)
+	{
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		dst_bssid = pnetwork->network.MacAddress;
+
+		if (_memcmp(dst_bssid, temp->sa_data, ETH_ALEN) == _TRUE)
+		{
+			if (set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+				ret = -1;
+
+			break;
+		}
+	}
+
+	_exit_critical(&queue->lock, &irqL);
+
+	if (!ret) {
+		if (set_802_11_authentication_mode(padapter, authmode) == _FALSE)
+			ret = -1;
+		else {
+//			set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+
+			if (set_802_11_bssid(padapter, temp->sa_data) == _FALSE) {
+				ret = -1;
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("-r8711_wx_set_wap: set bssid fail!\n"));
+			}
+		}
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_wap(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	NDIS_WLAN_BSSID_EX *pcur_bss = &pmlmepriv->cur_network.network;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r8711_wx_get_wap\n"));
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+	_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE) == _TRUE) {
+		_memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+			 ("-r8711_wx_get_wap: AP=%02x:%02x:%02x:%02x:%02x:%02x\n",
+			  pcur_bss->MacAddress[0], pcur_bss->MacAddress[1], pcur_bss->MacAddress[2],
+			  pcur_bss->MacAddress[3], pcur_bss->MacAddress[4], pcur_bss->MacAddress[5]));
+	}
+
+_func_exit_;
+
+	return 0;
+}
+
+static int r871x_wx_set_mlme(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+#if 0
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+#endif
+
+	int ret = 0;
+	u16 reason;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+
+
+	if (mlme == NULL)
+		return -1;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("+r871x_wx_set_mlme: cmd=%d\n", mlme->cmd));
+
+	reason = cpu_to_le16(mlme->reason_code); //?
+
+	switch (mlme->cmd)
+	{
+		case IW_MLME_DEAUTH:
+			if (!set_802_11_disassociate(padapter))
+				ret = -1;
+			break;
+
+		case IW_MLME_DISASSOC:
+			if (!set_802_11_disassociate(padapter))
+				ret = -1;
+
+			break;
+
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("-r871x_wx_set_mlme: ret=%d\n", ret));
+
+	return ret;
+}
+
+int r8711_wx_set_scan(struct net_device *dev,
+			struct iw_request_info *a,
+			union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	NDIS_802_11_SSID ssid;
+	_irqL irqL;
+	u8 status = _TRUE;
+	int ret = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r8711_wx_set_scan\n"));
+
+	if (padapter->bDriverStopped == _TRUE) {
+		printk("!r8711_wx_set_scan: bDriverStopped=%d\n", padapter->bDriverStopped);
+		ret = -1;
+		goto exit;
+	}
+
+	if (padapter->bup == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (padapter->hw_init_completed == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+	// When Busy Traffic, driver do not site survey. So driver return success.
+	// wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout.
+	// modify by thomas 2011-02-22.
+	// merged by Kurt @20111018
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE))
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	} 
+
+#if WIRELESS_EXT >= 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req))
+	{
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID)
+		{
+			int len = min((int)req->essid_len, IW_ESSID_MAX_SIZE);
+
+			_memset((unsigned char*)&ssid, 0, sizeof(NDIS_802_11_SSID));
+
+			_memcpy(ssid.Ssid, req->essid, len);
+			ssid.SsidLength = len;
+
+			printk("r8711_wx_set_scan: IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
+
+			_enter_critical(&pmlmepriv->lock, &irqL);
+
+			if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
+			    (pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE)) {
+				if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+					status = _FALSE;
+			} else
+				status = sitesurvey_cmd(padapter, &ssid);
+
+			_exit_critical(&pmlmepriv->lock, &irqL);
+		}
+		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
+		{
+			printk("r8711_wx_set_scan: req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
+		}
+	}
+	else
+#endif
+
+	if(	wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE
+		&& _memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
+	)
+	{
+		int len = wrqu->data.length -WEXT_CSCAN_HEADER_SIZE;
+		char *pos = extra+WEXT_CSCAN_HEADER_SIZE;
+		char section;
+		char sec_len;
+
+		//printk("%s COMBO_SCAN header is recognized\n", __FUNCTION__);
+
+		_memset((unsigned char*)&ssid, 0, sizeof(NDIS_802_11_SSID));
+
+		while(len >= 1) {
+			sscanf(pos, "%c", &section);
+			pos+=1; len-=1;
+
+			switch(section) {
+				case WEXT_CSCAN_SSID_SECTION:
+					printk("WEXT_CSCAN_SSID_SECTION\n");
+					if(len < 1) len = 0;
+					sscanf(pos, "%c", &sec_len);
+					pos+=1; len-=1;
+
+					#if 0 //the 8712fw will only report AP with the specific ssid, this will cause some problem..., don't spcifiy ssid
+					if(len >= sec_len) {
+						ssid.SsidLength = sec_len;
+						_memcpy(ssid.Ssid, pos, ssid.SsidLength);
+						printk("%s COMBO_SCAN with specific ssid:%s\n", __FUNCTION__, ssid.Ssid);
+					}
+					#endif
+					
+					pos+=sec_len; len-=sec_len;
+					break;
+					
+				#if 0
+				case WEXT_CSCAN_CHANNEL_SECTION:
+					DBG_871X("WEXT_CSCAN_CHANNEL_SECTION\n");
+					
+					pos+=1; len-=1;
+					break;
+				case WEXT_CSCAN_NPROBE_SECTION:
+					DBG_871X("WEXT_CSCAN_NPROBE_SECTION\n");
+					break;
+				case WEXT_CSCAN_ACTV_DWELL_SECTION:
+					DBG_871X("WEXT_CSCAN_ACTV_DWELL_SECTION\n");
+					break;
+				case WEXT_CSCAN_PASV_DWELL_SECTION:
+					DBG_871X("WEXT_CSCAN_PASV_DWELL_SECTION\n");
+					break;
+				case WEXT_CSCAN_HOME_DWELL_SECTION:
+					DBG_871X("WEXT_CSCAN_HOME_DWELL_SECTION\n");
+					break;
+				case WEXT_CSCAN_TYPE_SECTION:
+					DBG_871X("WEXT_CSCAN_TYPE_SECTION\n");
+					break;
+				#endif
+				
+				default:
+					//DBG_871X("Unknown CSCAN section %c\n", section);
+					len = 0; // stop parsing
+			}
+			
+		}
+		
+		//jeff: it has still some scan paramater to parse, we only do this now...			
+		_enter_critical(&pmlmepriv->lock, &irqL);				
+		status = sitesurvey_cmd(padapter, &ssid);	
+		_exit_critical(&pmlmepriv->lock, &irqL);
+		
+	} else
+	{
+		status = set_802_11_bssid_list_scan(padapter);
+	}
+
+	if (status == _FALSE)
+		ret = -1;
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_scan(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+
+	_irqL irqL;
+	_list *plist, *phead;
+
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0, cnt = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r8711_wx_get_scan: Start of Query SIOCGIWSCAN\n"));
+
+	if (padapter->bDriverStopped) {
+		ret= -EINVAL;
+		goto exit;
+	}
+
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{
+		msleep_os(30);
+		cnt++;
+		if (cnt > 100)
+			break;
+	}
+
+	_enter_critical(&queue->lock, &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (end_of_queue_search(phead, plist) == _TRUE)
+			break;
+
+		if ((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		
+		#ifdef CONFIG_VALIDATE_SSID
+		if(validate_ssid(&(pnetwork->network.Ssid))==_TRUE)
+		#endif
+		{
+			ev = translate_scan(padapter, a, pnetwork, ev, stop);
+		}
+
+		plist = get_next(plist);
+	}
+
+	_exit_critical(&queue->lock, &irqL);
+
+	wrqu->data.length = ev - extra;
+	wrqu->data.flags = 0;
+
+exit:
+
+_func_exit_;
+
+//	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("-r8711_wx_get_scan\n"));
+
+	return ret;
+}
+
+//set ssid flow
+//s1. set_802_11_infrastructure_mode()
+//s2. set_802_11_authenticaion_mode()
+//s3. set_802_11_encryption_mode()
+//s4. set_802_11_ssid()
+static int r8711_wx_set_essid(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+
+	struct wlan_network *pnetwork = NULL;
+
+	NDIS_802_11_AUTHENTICATION_MODE	authmode;
+	NDIS_802_11_SSID ndis_ssid;
+
+	u8 *dst_ssid, *src_ssid;
+	_list *phead;
+	u32 ret = 0, len;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("+r871x_wx_set_essid: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+
+	if (padapter->bup == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		goto exit;
+
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE) {
+		ret = -E2BIG;
+		goto exit;
+	}
+
+	authmode = padapter->securitypriv.ndisauthtype;
+
+	if (wrqu->essid.flags && wrqu->essid.length)
+	{
+		// Commented by Albert 20100519
+		// We got the codes in "set_info" function of iwconfig source code.
+		//	=========================================
+		//	wrq.u.essid.length = strlen(essid) + 1;
+	  	//	if(we_kernel_version > 20)
+		//		wrq.u.essid.length--;
+		//	=========================================
+		//	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
+#if WIRELESS_EXT <= 20
+		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
+#else
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;
+#endif
+
+		_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
+		ndis_ssid.SsidLength = len;
+		_memcpy(ndis_ssid.Ssid, extra, len);
+		src_ssid = ndis_ssid.Ssid;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("r871x_wx_set_essid: ssid=[%s]\n", src_ssid));
+
+		phead = get_list_head(queue);
+		pmlmepriv->pscanned = get_next(phead);
+
+		while (1)
+		{
+			if (end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+			{
+#if 0
+				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				{
+					set_802_11_ssid(padapter, &ndis_ssid);
+
+					goto exit;
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("r871x_wx_set_ssid(): scanned_queue is empty\n"));
+					ret = -EINVAL;
+					goto exit;
+				}
+#endif
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
+					 ("r871x_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
+
+				break;
+			}
+
+			pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+
+			pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+				 ("r871x_wx_set_essid: dst_ssid=%s\n",
+				  pnetwork->network.Ssid.Ssid));
+
+			if ((_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == _TRUE) &&
+			    (pnetwork->network.Ssid.SsidLength == ndis_ssid.SsidLength))
+			{
+
+				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				{
+					if ( pnetwork->network.InfrastructureMode != padapter->mlmepriv.cur_network.network.InfrastructureMode )
+						continue;
+				}
+				
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("r871x_wx_set_essid: find match, set infra mode\n"));
+
+				if (set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+				{
+					ret = -1;
+					goto exit;
+				}
+
+				break;
+			}
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
+		set_802_11_authentication_mode(padapter, authmode);
+		//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+		if (set_802_11_ssid(padapter, &ndis_ssid) == _FALSE)
+			ret = -1;
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_essid(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	NDIS_WLAN_BSSID_EX *pcur_bss = &pmlmepriv->cur_network.network;
+
+	u32 len, ret = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+r8711_wx_get_essid\n"));
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		len = pcur_bss->Ssid.SsidLength;
+
+		wrqu->essid.length = len;
+
+		_memcpy(extra, pcur_bss->Ssid.Ssid, len);
+
+		wrqu->essid.flags = 1;
+	} else
+		ret = -1;
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_set_rate(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	u32 target_rate = wrqu->bitrate.value;
+	u32 fixed = wrqu->bitrate.fixed;
+
+	u32 ratevalue = 0;
+	u8 datarates[NumRates];
+	u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+
+	int i, ret = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_notice_,("+r8711_wx_set_rate: target_rate=%d, fixed=%d\n", target_rate, fixed));
+
+	if (target_rate == -1) {
+		ratevalue = 11;
+		goto set_rate;
+	}
+
+	target_rate = target_rate/100000;
+
+	switch (target_rate)
+	{
+		case 10:
+			ratevalue = 0;
+			break;
+		case 20:
+			ratevalue = 1;
+			break;
+		case 55:
+			ratevalue = 2;
+			break;
+		case 60:
+			ratevalue = 3;
+			break;
+		case 90:
+			ratevalue = 4;
+			break;
+		case 110:
+			ratevalue = 5;
+			break;
+		case 120:
+			ratevalue = 6;
+			break;
+		case 180:
+			ratevalue = 7;
+			break;
+		case 240:
+			ratevalue = 8;
+			break;
+		case 360:
+			ratevalue = 9;
+			break;
+		case 480:
+			ratevalue = 10;
+			break;
+		case 540:
+			ratevalue = 11;
+			break;
+		default:
+			ratevalue = 11;
+			break;
+	}
+
+set_rate:
+
+	for (i=0; i<NumRates; i++)
+	{
+		if (ratevalue == mpdatarate[i]) {
+			datarates[i] = mpdatarate[i];
+			if (fixed == 0) break;
+		} else {
+			datarates[i] = 0xff;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("datarate_inx=%d\n",datarates[i]));
+	}
+
+	if (setdatarate_cmd(padapter, datarates) != _SUCCESS) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("r8711_wx_set_rate Fail!!!\n"));
+		ret = -1;
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	NDIS_WLAN_BSSID_EX *pcur_bss = &pmlmepriv->cur_network.network;
+
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	unsigned char rf_type=padapter->registrypriv.rf_config;
+	
+
+	int i;
+	u8 *p;
+	u16 rate, max_rate=0, ht_cap=_FALSE;
+	u32 ht_ielen = 0;
+	u8 bw_40MHz = 0, short_GI = 0;
+	u16 mcs_rate = 0;
+
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_notice_,("+r8711_wx_get_rate\n"));
+
+	i = 0;
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		p = get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if (p && ht_ielen>0)
+		{
+			ht_cap = _TRUE;
+
+			pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+
+			_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+
+			bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+
+			short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+		}
+
+		while ((pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
+		{
+			rate = pcur_bss->SupportedRates[i] & 0x7F;
+			if (rate > max_rate)
+				max_rate = rate;
+
+			wrqu->bitrate.fixed = 0;	/* no auto select */
+			//wrqu->bitrate.disabled = 1/;
+			wrqu->bitrate.value = rate*500000;
+
+			i++;
+		}
+
+		if (ht_cap == _TRUE)
+		{
+			if (mcs_rate & 0x8000//MCS15
+				&&  (RTL8712_RF_2T2R == rf_type) )
+			{
+				max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+
+			}
+			else if (mcs_rate & 0x0080)//MCS7
+			{
+				max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+			}
+			else//default MCS7
+			{
+				//printk("wx_get_rate, mcs_rate_bitmap=0x%x\n", mcs_rate);
+				max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+			}
+#if 0
+#ifdef CONFIG_80211N_HT
+			bw_40MHz = pregpriv->cbw40_enable;
+#else
+			bw_40MHz = 0;
+#endif
+
+			switch (pregpriv->rf_config)
+			{
+				case RTL8712_RF_1T1R:
+					max_rate = (bw_40MHz) ? 150:65;
+					break;
+				case RTL8712_RF_2T2R:
+					max_rate = (bw_40MHz) ? 300:130;
+					break;
+				case RTL8712_RF_1T2R:
+				default:
+					max_rate = (bw_40MHz) ? 270:130;
+					break;
+			}
+#endif
+
+			max_rate *= 2; // Mbps/2
+			wrqu->bitrate.value = max_rate * 500000;
+		}
+		else
+		{
+			wrqu->bitrate.value = max_rate * 500000;
+		}
+	}
+	else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int r8711_wx_get_rts(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+r8711_wx_get_rts\n"));
+
+	wrqu->rts.value = padapter->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+	//wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);
+
+_func_exit_;
+
+	return 0;
+}
+
+static int r8711_wx_set_frag(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+_func_enter_;
+
+	if (wrqu->frag.disabled)
+		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+
+		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+
+_func_exit_;
+
+	return 0;
+}
+
+static int r8711_wx_get_frag(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+_func_enter_;
+
+	wrqu->frag.value = padapter->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+	//wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
+
+_func_exit_;
+
+	return 0;
+}
+
+static int r8711_wx_get_retry(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = rtw_netdev_priv(dev);
+
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+
+	return 0;
+}
+
+#if 0
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+/*
+iwconfig wlan0 key on -> flags = 0x6001 -> maybe it means auto
+iwconfig wlan0 key off -> flags = 0x8800
+iwconfig wlan0 key open -> flags = 0x2800
+iwconfig wlan0 key open 1234567890 -> flags = 0x2000
+iwconfig wlan0 key restricted -> flags = 0x4800
+iwconfig wlan0 key open [3] 1234567890 -> flags = 0x2003
+iwconfig wlan0 key restricted [2] 1234567890 -> flags = 0x4002
+iwconfig wlan0 key open [3] -> flags = 0x2803
+iwconfig wlan0 key restricted [2] -> flags = 0x4802
+*/
+#endif
+
+static int r8711_wx_set_enc(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	u32 key, ret = 0;
+	u32 keyindex_provided;
+	NDIS_802_11_WEP	 wep;	
+	NDIS_802_11_AUTHENTICATION_MODE authmode;
+
+	struct iw_point *erq = &(wrqu->encoding);
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+	key = erq->flags & IW_ENCODE_INDEX;
+
+_func_enter_;
+
+	printk("+r8711_wx_set_enc: flags=0x%x\n", erq->flags);
+
+	_memset(&wep, 0, sizeof(NDIS_802_11_WEP));
+
+	if (erq->flags & IW_ENCODE_DISABLED)
+	{
+		printk("r8711_wx_set_enc: EncryptionDisabled\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+		padapter->securitypriv.dot11AuthAlgrthm= 0; //open system
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+
+		goto exit;
+	}
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	} 
+	else
+	{
+		keyindex_provided = 0;
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+		printk("r871x_wx_set_enc, key=%d\n", key);
+	}
+	
+	//set authentication mode
+	if (erq->flags & IW_ENCODE_OPEN)
+	{
+		printk("r8711_wx_set_enc: IW_ENCODE_OPEN\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.dot11AuthAlgrthm = 3; //open system
+#else
+		padapter->securitypriv.dot11AuthAlgrthm = 0; //open system
+#endif
+
+		padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+	else if (erq->flags & IW_ENCODE_RESTRICTED)
+	{
+		printk("r8711_wx_set_enc: IW_ENCODE_RESTRICTED\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.dot11AuthAlgrthm = 3; //shared system
+#else
+		padapter->securitypriv.dot11AuthAlgrthm = 1; //shared system
+#endif
+
+		padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+		authmode = Ndis802_11AuthModeShared;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+	else
+	{
+//		printk("r8711_wx_set_enc(): erq->flags=0x%x\n", erq->flags);
+
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.dot11AuthAlgrthm = 0; //open system
+		padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+
+	wep.KeyIndex = key;
+
+	if (erq->length > 0) {
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+		wep.Length = wep.KeyLength + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+	} else {
+		wep.KeyLength = 0 ;
+
+		if (keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
+		{
+			padapter->securitypriv.dot11PrivacyKeyIndex = key;
+
+			printk("r871x_wx_set_enc: keyindex provided, keyid=%d, key_len=%d\n", key, padapter->securitypriv.dot11DefKeylen[key]);
+
+			switch (padapter->securitypriv.dot11DefKeylen[key])
+			{
+				case 5:
+					padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+					break;
+				case 13:
+					padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+					break;
+				default:
+					padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+					break;
+			}
+
+			goto exit;
+		}
+	}
+
+	wep.KeyIndex |= 0x80000000;	// transmit key
+
+	_memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+
+	if(set_802_11_add_wep(padapter, &wep) == _FAIL)
+	{
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_enc(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret =0;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+_func_enter_;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+	{
+		if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _FALSE)
+		{
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+			return 0;
+		}
+	}
+
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else {
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+	}
+
+	erq->flags = key + 1;
+
+	//if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+	//{
+	//	erq->flags |= IW_ENCODE_OPEN;
+	//}
+
+	switch (padapter->securitypriv.ndisencryptstatus)
+	{
+		case Ndis802_11EncryptionNotSupported:
+		case Ndis802_11EncryptionDisabled:
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+			break;
+
+		case Ndis802_11Encryption1Enabled:
+			erq->length = padapter->securitypriv.dot11DefKeylen[key];
+			if (erq->length) {
+				_memcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);
+
+				erq->flags |= IW_ENCODE_ENABLED;
+
+				if (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+				{
+					erq->flags |= IW_ENCODE_OPEN;
+				}
+				else if (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)
+				{
+					erq->flags |= IW_ENCODE_RESTRICTED;
+				}
+			} else {
+				erq->length = 0;
+				erq->flags |= IW_ENCODE_DISABLED;
+			}
+			break;
+
+		case Ndis802_11Encryption2Enabled:
+		case Ndis802_11Encryption3Enabled:
+			erq->length = 16;
+			erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);
+			break;
+
+		default:
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+			break;
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+static int r8711_wx_get_power(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = rtw_netdev_priv(dev);
+
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+
+	return 0;
+}
+
+static int r871x_wx_set_gen_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+	return r871x_set_wpa_ie(padapter, extra, wrqu->data.length);
+}
+
+#ifdef CONFIG_PLATFORM_MT53XX
+static int r871x_wx_set_mtk_wps_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+	return r871x_set_wpa_ie(padapter, wrqu->data.pointer, wrqu->data.length);
+}
+#endif
+
+static int r871x_wx_set_auth(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_param *param = (struct iw_param*)&(wrqu->param);
+	int paramid;
+	int paramval;
+	int ret = 0;
+
+
+	paramid = param->flags & IW_AUTH_INDEX;
+	paramval = param->value;
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("+r871x_wx_set_auth: id=0x%x, val=%d\n",
+		  paramid, paramval));
+
+	switch (paramid)
+	{
+		case IW_AUTH_WPA_VERSION: // 0
+			break;
+		case IW_AUTH_CIPHER_PAIRWISE: // 1
+			break;
+		case IW_AUTH_CIPHER_GROUP: // 2
+			break;
+		case IW_AUTH_KEY_MGMT: // 3
+			/*
+			 *  ??? does not use these parameters
+			 */
+			break;
+
+		case IW_AUTH_TKIP_COUNTERMEASURES: // 4
+		{
+			if (paramval) {
+				// wpa_supplicant is enabling the tkip countermeasure.
+				padapter->securitypriv.btkip_countermeasure = _TRUE;
+			} else {
+				// wpa_supplicant is disabling the tkip countermeasure.
+				padapter->securitypriv.btkip_countermeasure = _FALSE;
+			}
+			break;
+		}
+
+		case IW_AUTH_DROP_UNENCRYPTED: // 5
+		{
+			/* HACK:
+			 *
+			 * wpa_supplicant calls set_wpa_enabled when the driver
+			 * is loaded and unloaded, regardless of if WPA is being
+			 * used.  No other calls are made which can be used to
+			 * determine if encryption will be used or not prior to
+			 * association being expected.  If encryption is not being
+			 * used, drop_unencrypted is set to false, else true -- we
+			 * can use this to determine if the CAP_PRIVACY_ON bit should
+			 * be set.
+			 */
+
+			if (padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)
+			{
+				break;//it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled,
+						// then it needn't reset it;
+			}
+
+			if (paramval) {
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+				padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+				padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+				padapter->securitypriv.dot11AuthAlgrthm= 0; //open system
+				padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeOpen;
+			}
+
+			break;
+		}
+
+		case IW_AUTH_80211_AUTH_ALG: // 6
+
+			#ifdef CONFIG_ANDROID
+			/*
+			 *  It's the starting point of a link layer connection using wpa_supplicant
+			*/
+			if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+				disassoc_cmd(padapter);
+				indicate_disconnect(padapter);
+			}
+			#endif
+			
+			ret = wpa_set_auth_algs(dev, (u32)paramval);
+			break;
+
+		case IW_AUTH_WPA_ENABLED: // 7
+#if 0
+			if (paramval)
+				padapter->securitypriv.dot11AuthAlgrthm = 2; //802.1x
+			else
+				padapter->securitypriv.dot11AuthAlgrthm = 0; //open system
+#endif
+			//_disassociate(priv);
+			break;
+
+		case IW_AUTH_RX_UNENCRYPTED_EAPOL: // 8
+			//ieee->ieee802_1x = param->value;
+			break;
+
+		case IW_AUTH_PRIVACY_INVOKED: // 10
+			//ieee->privacy_invoked = param->value;
+			break;
+
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int r871x_wx_set_enc_ext(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct iw_point *pencoding = &wrqu->encoding;
+ 	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+
+	struct ieee_param *param = NULL;
+	char *alg_name;
+	u32 param_len;
+
+	int ret = 0;
+
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)_malloc(param_len);
+	if (param == NULL)
+		return -1;
+	_memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+
+	_memset(param->sta_addr, 0xff, ETH_ALEN);
+
+	switch (pext->alg) {
+		case IW_ENCODE_ALG_NONE:
+		//todo: remove key 
+		//remove = 1;	
+			alg_name = "none";
+			break;
+		case IW_ENCODE_ALG_WEP:
+			alg_name = "WEP";
+			break;
+		case IW_ENCODE_ALG_TKIP:
+			alg_name = "TKIP";
+			break;
+		case IW_ENCODE_ALG_CCMP:
+			alg_name = "CCMP";
+			break;
+		default:
+			return -1;
+	}
+
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+
+	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)//?
+	{
+		param->u.crypt.set_tx = 0;
+	}
+
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)//?
+	{
+		param->u.crypt.set_tx = 1;
+	}
+
+	param->u.crypt.idx = (pencoding->flags & 0x00FF) -1;
+
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+		_memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	}
+
+	if (pext->key_len) {
+		param->u.crypt.key_len = pext->key_len;
+		_memcpy(param + 1, pext + 1, pext->key_len);
+	}
+
+
+	if (pencoding->flags & IW_ENCODE_DISABLED)
+	{		
+		//todo: remove key 
+		//remove = 1;		
+	}	
+	
+	ret = wpa_set_encryption(dev, param, param_len);
+
+	if (param) {
+		_mfree((u8*)param, param_len);
+	}
+
+	return ret;
+}
+
+static int r871x_wx_get_nick(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	if (extra) {
+		wrqu->data.length = 8;
+		wrqu->data.flags = 1;
+		_memcpy(extra, "rtl_wifi", 8);
+	}
+
+	return 0;
+}
+
+static int r8711_wx_read32(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	//uint key, ret = 0;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	//struct iw_point *erq = &wrqu->encoding;
+
+	u32 addr;
+	u32 data32;
+
+	get_user(addr, (u32*)wrqu->data.pointer);
+	data32 = read32(padapter, addr);
+
+	put_user(data32, (u32*)wrqu->data.pointer);
+
+	wrqu->data.length = (data32 & 0xffff0000) >> 16;
+	wrqu->data.flags = data32 & 0xffff;
+
+	//printk(" read addr = %x, data32 = %x\n", addr, data32);
+	//printk(" read length = %x, flags = %x\n", wrqu->data.length, wrqu->data.flags );
+
+	get_user(addr, (u32*)wrqu->data.pointer);
+
+	//printk(" read pointer = %x", addr);
+	//printk(" read pointer = %x", addr);
+
+	return 0;
+}
+
+static int r8711_wx_write32(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *keybuf)
+{
+	//uint key, ret = 0;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	//struct iw_point *erq = &wrqu->encoding;
+
+	u32 addr;
+	u32 data32;
+
+	get_user(addr, (u32*)wrqu->data.pointer);
+	data32 = ( (u32)wrqu->data.length<<16 ) | (u32)wrqu->data.flags ;
+	write32(padapter, addr, data32);
+
+	//printk("write length = %x, flags = %x\n", wrqu->data.length, wrqu->data.flags);
+	//printk("write addr = %x, data32 = %x\n", addr, data32);
+
+	return 0;
+}
+
+static int dummy(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("WLAN IOCTL: cmd_code=%x, fwstate=0x%x\n",
+		  a->cmd, pmlmepriv->fw_state));
+
+	return -1;
+}
+
+#ifdef CONFIG_PLATFORM_MT53XX
+static int r871x_wx_set_mtk_wps_probe_ie(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("WLAN IOCTL: cmd_code=%x, fwstate=0x%x\n",
+		  a->cmd, pmlmepriv->fw_state));
+
+	return 0;
+}
+
+static int r871x_wx_get_sensitivity(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *buf)
+{
+
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+    //wrqu->qual.level = (u8)padapter->mlmepriv.cur_network.network.Rssi;
+
+	wrqu->qual.level = padapter->recvpriv.fw_rssi;
+
+    printk(" level = %u\n",  wrqu->qual.level );
+
+	return 0;
+}
+#endif
+
+/*
+typedef int (*iw_handler)(struct net_device *dev, struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra);
+*/
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+static int r8711_drvext_hdl(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+
+#if 0
+struct	iw_point
+{
+	void __user *pointer;	/* Pointer to the data  (in user space) */
+	__u16 length;		/* number of fields or size in bytes */
+	__u16 flags;		/* Optional params */
+};
+#endif
+
+#if 0
+	u8 res;
+	struct drvext_handler *phandler;
+	struct drvext_oidparam *poidparam;
+	int ret;
+	u16 len;
+	u8 *pparmbuf, bset;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _r8711_drvext_hdl_exit;
+	}
+
+	bset = (u8)(p->flags&0xFFFF);
+	len = p->length;
+	pparmbuf = (u8*)_malloc(len);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _r8711_drvext_hdl_exit;
+	}
+
+	if(bset)//set info
+	{
+		if (copy_from_user(pparmbuf, p->pointer,len)) {
+			_mfree(pparmbuf, len);
+			ret = -EFAULT;
+			goto _r8711_drvext_hdl_exit;
+		}
+	}
+	else//query info
+	{
+
+	}
+
+	poidparam = (struct drvext_oidparam *)pparmbuf;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
+						 poidparam->subcode, poidparam->len, len));
+
+
+	//check subcode
+	if ( poidparam->subcode >= MAX_DRVEXT_HANDLERS)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext handlers\r\n"));
+		ret = -EINVAL;
+		goto exit_drvext_set_info;
+	}
+
+
+	if ( poidparam->subcode >= MAX_DRVEXT_OID_SUBCODES)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext subcodes\r\n"));
+		ret = -EINVAL;
+		goto _r8711_drvext_hdl_exit;
+	}
+
+	phandler = drvextoidhandlers + poidparam->subcode;
+
+	if (poidparam->len != phandler->parmsize)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext param size %d vs %d\r\n",
+						poidparam->len , phandler->parmsize));
+		ret = -EINVAL;
+		goto _r8711_drvext_hdl_exit;
+	}
+
+	res = phandler->handler(padapter, bset, poidparam->data);
+
+	if (res == 0)
+		ret = 0
+	else
+		ret = -EFAULT;
+
+_r8711_drvext_hdl_exit:
+
+	return ret;
+
+#endif
+
+	return 0;
+}
+
+static int r871x_mp_ioctl_hdl(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+	struct iw_point *p = &wrqu->data;
+
+	struct oid_par_priv oid_par;
+	struct mp_ioctl_handler *phandler;
+	struct mp_ioctl_param *poidparam;
+	unsigned long BytesRead, BytesWritten, BytesNeeded;
+	u8 *pparmbuf = NULL, bset;
+
+	u16 len;
+	uint status;
+	int ret = 0;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r871x_mp_ioctl_hdl\n"));
+
+	//mutex_lock(&ioctl_mutex);
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+
+	pparmbuf = NULL;
+	pparmbuf = (u8*)_malloc(len);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+	poidparam = (struct mp_ioctl_param *)pparmbuf;
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("r871x_mp_ioctl_hdl: buffer_len[%d] subcode[%d] len[%d]\n",
+		  len, poidparam->subcode, poidparam->len));
+
+	if (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("!r871x_mp_ioctl_hdl: no matching drvext subcodes\n"));
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+	phandler = mp_ioctl_hdl + poidparam->subcode;
+
+	if ((phandler->paramsize != 0) && (poidparam->len < phandler->paramsize))
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("!r871x_mp_ioctl_hdl: param size not match %d\n",
+			  phandler->paramsize));
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+	if (phandler->oid == 0 && phandler->handler) {
+	        status = phandler->handler(&oid_par);
+	}
+	else if (phandler->handler)
+	{
+		oid_par.adapter_context = padapter;
+		oid_par.oid = phandler->oid;
+		oid_par.information_buf = poidparam->data;
+		oid_par.information_buf_len = poidparam->len;
+		oid_par.dbg = 0;
+
+		BytesWritten = 0;
+		BytesNeeded = 0;
+
+		if (bset) {
+			oid_par.bytes_rw = &BytesRead;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = SET_OID;
+		} else {
+			oid_par.bytes_rw = &BytesWritten;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = QUERY_OID;
+		}
+
+		status = phandler->handler(&oid_par);
+
+		//todo:check status, BytesNeeded, etc.
+	}
+	else {
+		printk("r871x_mp_ioctl_hdl(): err!, subcode=%d, oid=%d, handler=%p\n", 
+			poidparam->subcode, phandler->oid, phandler->handler);
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+	if (bset == 0x00) {//query info
+		//_memcpy(p->pointer, pparmbuf, len);
+		if (copy_to_user(p->pointer, pparmbuf, len))
+			ret = -EFAULT;
+	}
+
+	if (status) {
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+
+_r871x_mp_ioctl_hdl_exit:
+
+	if (pparmbuf != NULL)
+		_mfree(pparmbuf, 0);
+
+	//mutex_unlock(&ioctl_mutex);
+
+	return ret;
+}
+
+static int r871x_get_ap_info(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+	struct iw_point *pdata = &wrqu->data;
+
+	struct wlan_network *pnetwork = NULL;
+
+	int bssid_match, ret = 0;
+	u32 cnt = 0, wpa_ielen;
+	_irqL irqL;
+	_list *plist, *phead;
+	unsigned char *pbuf;
+	u8 bssid[ETH_ALEN];
+	char data[32];
+	printk("+r871x_get_aplist_info\n");
+
+	if (padapter->bDriverStopped || (pdata==NULL)) {
+		ret= -EINVAL;
+		goto exit;
+	}
+
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) {
+		msleep_os(30);
+		cnt++;
+		if(cnt > 100)
+			break;
+	}
+
+
+	//pdata->length = 0;//?	
+	pdata->flags = 0;
+	if(pdata->length>=32)
+	{
+		if(copy_from_user(data, pdata->pointer, 32))
+		{
+			ret= -EINVAL;
+			goto exit;
+		}
+	}	
+	else
+	{
+		ret= -EINVAL;
+		goto exit;
+	}	
+
+	_enter_critical(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//if(hwaddr_aton_i(pdata->pointer, bssid)) 
+		if(hwaddr_aton_i(data, bssid)) 
+		{			
+			printk("Invalid BSSID '%s'.\n", (u8*)data);
+			return -EINVAL;
+		}
+
+		printk("BSSID:" MACSTR "\n", MAC2STR(bssid));
+
+		if(_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
+		{
+			pbuf = get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen>0)) {
+				pdata->flags = 1;
+				break;
+			}
+
+			pbuf = get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			if(pbuf && (wpa_ielen>0)) {
+				pdata->flags = 2;
+				break;
+			}
+		}
+		plist = get_next(plist);
+	}
+
+	_exit_critical(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if(pdata->length>=34)
+	{
+		if(copy_to_user((u8*)pdata->pointer+32, (u8*)&pdata->flags, 1))
+		{
+			ret= -EINVAL;
+			goto exit;
+		}
+	}	
+	
+exit:
+
+	return ret;
+}
+
+static int r871x_set_pid(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+
+	printk("+r871x_set_pid\n");
+
+	if((padapter->bDriverStopped) || (pdata==NULL))
+	{
+		ret= -EINVAL;
+		goto exit;
+	}
+
+	//pdata->length = 0;
+	//pdata->flags = 0;
+
+	//_memcpy(&padapter->pid, pdata->pointer, sizeof(int));
+	if(copy_from_user(&padapter->pid, pdata->pointer, sizeof(int)))
+	{
+		ret= -EINVAL;
+		goto exit;
+	}
+
+	printk("got pid=%d\n", padapter->pid);
+
+exit:
+
+	return ret;
+}
+
+static int r871x_set_chplan(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	int ch_plan = -1;
+
+	printk("+r871x_set_chplan\n");
+
+	if((padapter->bDriverStopped) || (pdata==NULL))
+	{
+		ret= -EINVAL;
+		goto exit;
+	}
+
+	//pdata->length = 0;
+	//pdata->flags = 0;
+
+	//_memcpy(&padapter->pid, pdata->pointer, sizeof(int));
+	//if(copy_from_user(&ch_plan, pdata->pointer, sizeof(int)))
+
+	ch_plan=(int)*extra;
+	set_chplan_cmd(padapter, ch_plan);
+
+
+exit:
+
+	return ret;
+}
+
+static int r871x_wps_start(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	u32   u32wps_start = 0;
+        unsigned int uintRet = 0;
+
+        uintRet = copy_from_user( ( void* ) &u32wps_start, pdata->pointer, 4 );
+
+	if((padapter->bDriverStopped) || (pdata==NULL))
+	{                
+		ret= -EINVAL;
+		goto exit;
+	}		
+
+       if ( u32wps_start == 0 )
+       {
+           u32wps_start = *extra;
+       }
+
+       printk( "[%s] wps_start = %d\n", __FUNCTION__, u32wps_start );
+
+       if ( u32wps_start == 1 ) // WPS Start
+       {
+           padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_WPS);
+       }
+	else if ( u32wps_start == 2 ) // WPS Stop because of wps success
+	{
+           padapter->ledpriv.LedControlHandler(padapter, LED_CTL_STOP_WPS);
+	}
+	else if ( u32wps_start == 3 ) // WPS Stop because of wps fail
+	{
+           padapter->ledpriv.LedControlHandler(padapter, LED_CTL_STOP_WPS_FAIL);
+	}
+exit:
+	
+	return ret;
+		
+}
+
+
+#ifdef RTK_DMP_PLATFORM
+static int r871x_wx_null(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+
+static int r871x_wx_get_ap_status(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	int name_len;
+
+	//count the length of input ssid
+	for(name_len=0 ; ((char*)wrqu->data.pointer)[name_len]!='\0' ; name_len++);
+
+	wrqu->data.length = (padapter->recvpriv.rssi + 95)*2;
+
+	return 0;
+}
+
+static int r871x_wx_set_countrycode(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	int	countrycode=0;
+
+	countrycode = (int)wrqu->data.pointer;
+	printk("\n======== Set Countrycode = %d !!!! ========\n",countrycode);
+
+	return 0;
+}
+#endif
+
+static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
+{
+	uint ret = 0;
+	u32 flags;
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+	switch (name)
+	{
+		case IEEE_PARAM_WPA_ENABLED:
+			padapter->securitypriv.dot11AuthAlgrthm = 2; //802.1x
+			//ret = ieee80211_wpa_enable(ieee, value);
+
+			switch((value)&0xff)
+			{
+				case 1 : //WPA
+					padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK; //WPA_PSK
+					padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+					break;
+				case 2: //WPA2
+					padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK; //WPA2_PSK
+					padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+					break;
+			}
+
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("wpa_set_param:padapter->securitypriv.ndisauthtype=%d\n", padapter->securitypriv.ndisauthtype));
+
+			break;
+
+		case IEEE_PARAM_TKIP_COUNTERMEASURES:
+			//ieee->tkip_countermeasures=value;
+			break;
+
+		case IEEE_PARAM_DROP_UNENCRYPTED:
+		{
+			/* HACK:
+			 *
+			 * wpa_supplicant calls set_wpa_enabled when the driver
+			 * is loaded and unloaded, regardless of if WPA is being
+			 * used.  No other calls are made which can be used to
+			 * determine if encryption will be used or not prior to
+			 * association being expected.  If encryption is not being
+			 * used, drop_unencrypted is set to false, else true -- we
+			 * can use this to determine if the CAP_PRIVACY_ON bit should
+			 * be set.
+			 */
+
+#if 0
+			struct ieee80211_security sec = {
+				.flags = SEC_ENABLED,
+				.enabled = value,
+			};
+ 			ieee->drop_unencrypted = value;
+			/* We only change SEC_LEVEL for open mode. Others
+			 * are set by ipw_wpa_set_encryption.
+			 */
+			if (!value) {
+				sec.flags |= SEC_LEVEL;
+				sec.level = SEC_LEVEL_0;
+			}
+			else {
+				sec.flags |= SEC_LEVEL;
+				sec.level = SEC_LEVEL_1;
+			}
+			if (ieee->set_security)
+				ieee->set_security(ieee->dev, &sec);
+#endif
+			break;
+		}
+
+		case IEEE_PARAM_PRIVACY_INVOKED:
+			//ieee->privacy_invoked=value;
+			break;
+
+		case IEEE_PARAM_AUTH_ALGS:
+			ret = wpa_set_auth_algs(dev, value);
+			break;
+
+		case IEEE_PARAM_IEEE_802_1X:
+			//ieee->ieee802_1x=value;
+			break;
+
+		case IEEE_PARAM_WPAX_SELECT:
+			// added for WPA2 mixed mode
+			//printk(KERN_WARNING "------------------------>wpax value = %x\n", value);
+			/*
+			spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
+			ieee->wpax_type_set = 1;
+			ieee->wpax_type_notify = value;
+			spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
+			*/
+			break;
+
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	return ret;
+}
+
+static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
+{
+	int ret = 0;
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+	switch (command)
+	{
+		case IEEE_MLME_STA_DEAUTH:
+			if (!set_802_11_disassociate(padapter))
+				ret = -1;
+			break;
+
+		case IEEE_MLME_STA_DISASSOC:
+			if (!set_802_11_disassociate(padapter))
+				ret = -1;
+			break;
+
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	return ret;
+}
+
+#if 0
+static int wpa_set_wpa_ie(struct net_device *dev,
+			      struct ieee_param *param, u32 plen)
+{
+	u8 *buf;
+	uint ret = 0;
+	u32 left;
+ 	u8 *pos;
+	int group_cipher, pairwise_cipher;
+	_adapter *padapter = rtw_netdev_priv(dev);
+
+
+	if((param->u.wpa_ie.len > MAX_WPA_IE_LEN) || (param->u.wpa_ie.data == NULL))
+		return -EINVAL;
+
+	if (param->u.wpa_ie.len)
+	{
+		buf = _malloc(param->u.wpa_ie.len);
+		if (buf == NULL){
+			ret =  -ENOMEM;
+			goto exit;
+		}
+
+		_memcpy(buf, param->u.wpa_ie.data, param->u.wpa_ie.len);
+
+		//dump
+		{
+			int i;
+			printk("\n wpa_ie(length:%d):\n",param->u.wpa_ie.len);
+			for(i=0;i<param->u.wpa_ie.len;i=i+8)
+				printk("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+		}
+
+		pos = buf;
+		if(param->u.wpa_ie.len < RSN_HEADER_LEN){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %lu\n",(u32)param->u.wpa_ie.len ));
+			ret  = -1;
+			goto exit;
+		}
+
+		pos += RSN_HEADER_LEN;
+		left = param->u.wpa_ie.len - RSN_HEADER_LEN;
+
+		if (left >= RSN_SELECTOR_LEN){
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+		else if (left > 0) {
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
+			ret =-1;
+			goto exit;
+		}
+
+		group_cipher = 0; pairwise_cipher = 0;
+		if(parse_wpa_ie(buf, param->u.wpa_ie.len, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= 2;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
+		}
+
+		group_cipher = 0; pairwise_cipher = 0;
+		if(parse_wpa2_ie(buf, param->u.wpa_ie.len, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= 2;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;
+		}
+
+		switch (group_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+
+		switch(pairwise_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				printk("(TKIP Pairwise)ndisencryptstatus=%d\n", padapter->securitypriv.ndisencryptstatus);
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				printk("(AES Pairwise)ndisencryptstatus=%d\n",padapter->securitypriv.ndisencryptstatus);
+				break;
+			case WPA_CIPHER_WEP104:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("wpa_set_wpa_ie: pairwise_cipher=%d padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype=%d\n",pairwise_cipher,padapter->securitypriv.ndisencryptstatus,padapter->securitypriv.ndisauthtype));
+
+exit:
+
+	return ret;
+}
+#endif
+
+int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	uint ret=0;
+
+	//down(&ieee->wx_sem);
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("+wpa_supplicant_ioctl: cmd=%d\n", param->cmd));
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer){
+		ret = -EINVAL;
+		goto out;
+	}
+
+	param = (struct ieee_param *)_malloc(p->length);
+	if (param == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (copy_from_user(param, p->pointer, p->length))
+	{
+		_mfree((u8*)param, 0);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	switch (param->cmd)
+	{
+		case IEEE_CMD_SET_WPA_PARAM:
+			ret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);
+			break;
+
+		case IEEE_CMD_SET_WPA_IE:
+			//ret = wpa_set_wpa_ie(dev, param, p->length);
+			ret =  r871x_set_wpa_ie((_adapter *)rtw_netdev_priv(dev), (char*)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
+			break;
+
+		case IEEE_CMD_SET_ENCRYPTION:
+			ret = wpa_set_encryption(dev, param, p->length);
+			break;
+
+		case IEEE_CMD_MLME:
+			ret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);
+			break;
+
+		default:
+			printk("Unknown WPA supplicant request: %d\n", param->cmd);
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	_mfree((u8 *)param, sizeof(struct ieee_param));
+
+out:
+
+	//up(&ieee->wx_sem);
+
+	return ret;
+}
+
+#include <rtw_android.h>
+static int r871x_wx_set_priv(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+	int ret = 0, len = 0;
+	char *ext;
+	int i;
+
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_point *dwrq = (struct iw_point*)awrq;
+
+	#ifdef DEBUG_RTW_WX_SET_PRIV
+	char *ext_dbg;
+	#endif
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+r871x_wx_set_priv\n"));
+
+	len = dwrq->length;
+	if ( len == 0 )
+		return ret;
+	
+	if (!(ext = _malloc(len)))
+		return -ENOMEM;
+
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		_mfree(ext, len);
+		return -EFAULT;
+	}
+
+	#ifdef DEBUG_RTW_WX_SET_PRIV
+	if (!(ext_dbg = _malloc(len)))
+		return -ENOMEM;
+	
+	_memcpy(ext_dbg, ext, len);
+	#endif
+
+	if(	len >= WEXT_CSCAN_HEADER_SIZE
+		&& _memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
+	){
+		ret = r8711_wx_set_scan(dev, info, awrq, ext);
+		goto FREE_EXT;
+	}
+	
+#ifdef CONFIG_ANDROID
+	//DBG_871X("rtw_wx_set_priv: %s req=%s\n", dev->name, ext);
+#if 0
+	for(i=0; i<len; i++) {
+		if(*(ext+i)>='a' && *(ext+i)<='z' ) {
+			*(ext+i)+= 'A'-'a';
+		}
+	}
+
+	for(i=0 ; i<ANDROID_WIFI_CMD_MAX; i++)
+		if(0 == strncmp(ext , android_wifi_cmd_str[i], strlen(android_wifi_cmd_str[i])) )
+			break;
+#endif
+	i = rtw_android_cmdstr_to_num(ext);
+
+	switch(i) {
+		case ANDROID_WIFI_CMD_START :
+			indicate_wx_custom_event(padapter, "START");
+			break;
+		case ANDROID_WIFI_CMD_STOP :
+			indicate_wx_custom_event(padapter, "STOP");
+			break;
+		case ANDROID_WIFI_CMD_RSSI :
+			{
+				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+				struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+				//static u8 xxxx;
+				if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+					sprintf(ext, "%s rssi %d",
+						pcur_network->network.Ssid.Ssid,
+						//(xxxx=xxxx+10)
+						((padapter->recvpriv.fw_rssi)>>1)-95
+						//pcur_network->network.Rssi
+						);
+				} else {
+					sprintf(ext, "OK");
+				}
+			}
+			break;
+		case ANDROID_WIFI_CMD_LINKSPEED :
+			{
+				union iwreq_data wrqd;
+				int ret_inner;
+				int mbps;
+				
+				if( 0!=(ret_inner=r8711_wx_get_rate(dev, info, &wrqd, extra)) ){
+					mbps=0;
+				} else {
+					mbps=wrqd.bitrate.value / 1000000;
+				}
+				
+				sprintf(ext, "LINKSPEED %d", mbps);
+			}
+			break;
+		case ANDROID_WIFI_CMD_MACADDR :
+			sprintf(ext, "MACADDR = " MAC_FMT, MAC_ARG(dev->dev_addr));
+			break;
+		case ANDROID_WIFI_CMD_SCAN_ACTIVE :
+			{
+				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+				pmlmepriv->passive_mode=1;
+				sprintf(ext, "OK");
+			}
+			break;
+		case ANDROID_WIFI_CMD_SCAN_PASSIVE :
+			{
+				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+				pmlmepriv->passive_mode=0;
+				sprintf(ext, "OK");
+			}
+			break;
+
+		#if 0
+		case ANDROID_WIFI_CMD_COUNTRY :
+			{
+				char country_code[10];
+				int channel_plan;
+				union iwreq_data wrqd;
+				int ret_inner;
+					
+				sscanf(ext,"%*s %s",country_code);
+		
+				if(0 == strcmp(country_code, "US"))
+					channel_plan = RT_CHANNEL_DOMAIN_FCC;
+				else if(0 == strcmp(country_code, "EU"))
+					channel_plan = RT_CHANNEL_DOMAIN_ETSI;
+				else if(0 == strcmp(country_code, "JP"))
+					channel_plan = RT_CHANNEL_DOMAIN_MKK;
+				else
+					DBG_871X("%s unknown country_code:%s\n", __FUNCTION__, country_code);
+				
+				_rtw_memcpy(&wrqd, &channel_plan, sizeof(int));
+				
+				if( 0!=(ret_inner=rtw_wx_set_channel_plan(dev, info, &wrqd, extra)) ){
+					printk("%s rtw_wx_set_channel_plan error\n", __FUNCTION__);
+				}
+				
+				sprintf(ext, "OK");
+			}
+			break;
+		#endif
+			
+		default :
+			#ifdef  DEBUG_RTW_WX_SET_PRIV
+			printk("%s: %s unknowned req=%s\n", __FUNCTION__,
+				dev->name, ext_dbg);
+			#endif
+
+			sprintf(ext, "OK");
+		
+	}
+
+	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext)+1)) ) )
+		ret = -EFAULT;
+
+	#ifdef DEBUG_RTW_WX_SET_PRIV
+	printk("%s: %s req=%s rep=%s dwrq->length=%d, strlen(ext)+1=%d\n", __FUNCTION__,
+		dev->name, ext_dbg ,ext, dwrq->length, (u16)(strlen(ext)+1));
+	#endif
+#endif //end of CONFIG_ANDROID
+
+
+FREE_EXT:
+	_mfree(ext, len);
+	#ifdef DEBUG_RTW_WX_SET_PRIV
+	_mfree(ext_dbg, len);
+	#endif
+
+	return ret;
+}
+
+
+//based on "driver_ipw" and for hostapd
+int r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret = 0;
+
+	//down(&priv->wx_sem);
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("+r871x_ioctl: cmd=%x\n", cmd));
+
+	switch (cmd)
+	{
+		case RTL_IOCTL_WPA_SUPPLICANT:
+			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+			break;
+#ifdef CONFIG_HOSTAPD_MODE
+		case RTL_IOCTL_HOSTAPD:
+			ret = rtl871x_hostapd_ioctl(dev, &wrq->u.data);
+			break;
+#endif
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	//up(&priv->wx_sem);
+
+	return ret;
+}
+
+static iw_handler r8711_handlers[] =
+{
+	NULL,				/* SIOCSIWCOMMIT */
+	r8711_wx_get_name,		/* SIOCGIWNAME */
+        dummy,                    	/* SIOCSIWNWID */
+        dummy,                   	/* SIOCGIWNWID */
+	r8711_wx_set_freq,		/* SIOCSIWFREQ */
+	r8711_wx_get_freq,		/* SIOCGIWFREQ */
+	r8711_wx_set_mode,		/* SIOCSIWMODE */
+	r8711_wx_get_mode,		/* SIOCGIWMODE */
+        dummy,//r8711_wx_set_sens,       /* SIOCSIWSENS */
+	r8711_wx_get_sens,		/* SIOCGIWSENS */
+	NULL,				/* SIOCSIWRANGE */
+	r8711_wx_get_range,		/* SIOCGIWRANGE */
+	r871x_wx_set_priv,		/* SIOCSIWPRIV */
+	NULL,				/* SIOCGIWPRIV */
+	NULL,				/* SIOCSIWSTATS */
+	NULL,				/* SIOCGIWSTATS */
+	dummy,				/* SIOCSIWSPY */
+	dummy,				/* SIOCGIWSPY */
+	NULL,				/* SIOCGIWTHRSPY */
+	NULL,				/* SIOCWIWTHRSPY */
+	r8711_wx_set_wap,		/* SIOCSIWAP */
+	r8711_wx_get_wap,		/* SIOCGIWAP */
+	r871x_wx_set_mlme,		/* request MLME operation; uses struct iw_mlme */
+        dummy,                     	/* SIOCGIWAPLIST -- depricated */
+	r8711_wx_set_scan,		/* SIOCSIWSCAN */
+	r8711_wx_get_scan,		/* SIOCGIWSCAN */
+	r8711_wx_set_essid,		/* SIOCSIWESSID */
+	r8711_wx_get_essid,		/* SIOCGIWESSID */
+	dummy,				/* SIOCSIWNICKN */
+	r871x_wx_get_nick,		/* SIOCGIWNICKN */
+	NULL,				/* -- hole -- */
+	NULL,				/* -- hole -- */
+	r8711_wx_set_rate,		/* SIOCSIWRATE */
+	r8711_wx_get_rate,		/* SIOCGIWRATE */
+	dummy,				/* SIOCSIWRTS */
+	r8711_wx_get_rts,		/* SIOCGIWRTS */
+	r8711_wx_set_frag,		/* SIOCSIWFRAG */
+	r8711_wx_get_frag,		/* SIOCGIWFRAG */
+	dummy,				/* SIOCSIWTXPOW */
+	dummy,				/* SIOCGIWTXPOW */
+	dummy,//r8711_wx_set_retry,	/* SIOCSIWRETRY */
+	r8711_wx_get_retry,		/* SIOCGIWRETRY */
+	r8711_wx_set_enc,		/* SIOCSIWENCODE */
+	r8711_wx_get_enc,		/* SIOCGIWENCODE */
+	dummy,				/* SIOCSIWPOWER */
+	r8711_wx_get_power,		/* SIOCGIWPOWER */
+	NULL,				/*---hole---*/
+	NULL,				/*---hole---*/
+	r871x_wx_set_gen_ie,		/* SIOCSIWGENIE */
+	NULL,				/* SIOCGIWGENIE */
+	r871x_wx_set_auth,		/* SIOCSIWAUTH */
+	NULL,				/* SIOCGIWAUTH */
+	r871x_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
+	NULL,				/* SIOCGIWENCODEEXT */
+	r871x_wx_set_pmkid,		/* SIOCSIWPMKSA */
+	NULL,				/*---hole---*/
+};
+
+static const struct iw_priv_args r8711_private_args[] =
+{
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "read32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "write32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "setpid"
+	}, 
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	}
+#ifdef RTK_DMP_PLATFORM
+	,
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apstatus"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xa,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "countrycode"
+	}
+#endif
+
+#ifdef CONFIG_PLATFORM_MT53XX
+	,
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x8,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_prob_req_ie"
+	},	
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
+	}
+#endif
+	,
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "chplan"
+	}
+};
+
+static iw_handler r8711_private_handler[] =
+{
+	r8711_wx_read32,
+	r8711_wx_write32,
+	r8711_drvext_hdl,
+	r871x_mp_ioctl_hdl,
+	r871x_get_ap_info, /*for MM DTV platform*/
+	r871x_set_pid,
+	r871x_wps_start,
+#ifdef RTK_DMP_PLATFORM
+	r871x_wx_null,
+	r871x_wx_null,
+	r871x_wx_get_ap_status, /* offset must be 9 for DMP platform*/
+	r871x_wx_set_countrycode, //Set Channel depend on the country code
+#endif
+
+#ifdef CONFIG_PLATFORM_MT53XX
+	r871x_wx_get_sensitivity,
+	r871x_wx_set_mtk_wps_probe_ie,
+	r871x_wx_set_mtk_wps_ie,
+#endif
+	r871x_set_chplan,
+};
+
+#if WIRELESS_EXT >= 17
+static struct iw_statistics *r871x_get_wireless_stats(struct net_device *dev)
+{
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct iw_statistics *piwstats = &padapter->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != _TRUE)
+	{
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+		//printk("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
+	}
+	else {
+		//show percentage 0~100, we need transfer dbm to orignal value.
+		tmp_level = padapter->recvpriv.fw_rssi;
+		tmp_qual = padapter->recvpriv.signal;
+		tmp_noise = padapter->recvpriv.noise;
+		//printk("level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
+
+		piwstats->qual.level = tmp_level;
+		//piwstats->qual.qual = tmp_qual;
+		//	Modified by Albert 2010/06/25
+		//	The NetworkManager of Fedora 10, 13 will use the link quality for its display.
+		//	So, use the fw_rssi on link quality variable because fw_rssi will be updated per 2 seconds.		
+		piwstats->qual.qual = tmp_level;
+		piwstats->qual.noise = tmp_noise;
+
+		#ifdef CONFIG_ANDROID
+		piwstats->qual.level=(padapter->recvpriv.fw_rssi>>1)-95;
+		#endif
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
+	//	Use the percentage for signal, noise display.
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED
+		#ifdef CONFIG_ANDROID
+		| IW_QUAL_DBM
+		#endif
+		;
+#else
+	//IW_QUAL_DBM= 0x8, if driver use this flag, wireless extension will show value of dbm.
+	//remove this flag for show percentage 0~100
+
+	//	The value of IW_QUAL_ALL_UPDATED constant is 0x07.
+	piwstats->qual.updated = 0x07;
+#endif
+
+	return &padapter->iwstats;
+}
+#endif
+
+struct iw_handler_def r871x_handlers_def =
+{
+	.standard = r8711_handlers,
+	.num_standard = sizeof(r8711_handlers) / sizeof(iw_handler),
+	.private = r8711_private_handler,
+	.private_args = (struct iw_priv_args *)r8711_private_args,
+	.num_private = sizeof(r8711_private_handler) / sizeof(iw_handler),
+ 	.num_private_args = sizeof(r8711_private_args) / sizeof(struct iw_priv_args),
+#if WIRELESS_EXT >= 17
+	.get_wireless_stats = r871x_get_wireless_stats,
+#endif
+};
+
diff --git a/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_query.c b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_query.c
new file mode 100755
index 0000000..12f10c5
--- /dev/null
+++ b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_query.c
@@ -0,0 +1,196 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_IOCTL_QUERY_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_ioctl_query.h>
+#include <wifi.h>
+
+
+#ifdef PLATFORM_WINDOWS
+//
+// Added for WPA2-PSK, by Annie, 2005-09-20.
+//
+u8
+query_802_11_capability(
+	_adapter*		Adapter,
+	u8*			pucBuf,
+	u32 *		pulOutLen
+)
+{
+	static NDIS_802_11_AUTHENTICATION_ENCRYPTION szAuthEnc[] = 
+	{
+		{Ndis802_11AuthModeOpen, Ndis802_11EncryptionDisabled}, 
+		{Ndis802_11AuthModeOpen, Ndis802_11Encryption1Enabled},
+		{Ndis802_11AuthModeShared, Ndis802_11EncryptionDisabled}, 
+		{Ndis802_11AuthModeShared, Ndis802_11Encryption1Enabled},
+		{Ndis802_11AuthModeWPA, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPA, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption3Enabled}
+	};	
+	static ULONG	ulNumOfPairSupported = sizeof(szAuthEnc)/sizeof(NDIS_802_11_AUTHENTICATION_ENCRYPTION);
+	NDIS_802_11_CAPABILITY * pCap = (NDIS_802_11_CAPABILITY *)pucBuf;
+	u8*	pucAuthEncryptionSupported = (u8*) pCap->AuthenticationEncryptionSupported;
+
+
+	pCap->Length = sizeof(NDIS_802_11_CAPABILITY);
+	if(ulNumOfPairSupported > 1 )
+		pCap->Length += 	(ulNumOfPairSupported-1) * sizeof(NDIS_802_11_AUTHENTICATION_ENCRYPTION);
+	
+	pCap->Version = 2;	
+	pCap->NoOfPMKIDs = NUM_PMKID_CACHE;	
+	pCap->NoOfAuthEncryptPairsSupported = ulNumOfPairSupported;
+
+	if( sizeof (szAuthEnc) <= 240 )		// 240 = 256 - 4*4	// SecurityInfo.szCapability: only 256 bytes in size.
+	{
+		_memcpy( pucAuthEncryptionSupported, (u8*)szAuthEnc,  sizeof (szAuthEnc) );
+		*pulOutLen = pCap->Length;
+		return _TRUE;
+	}
+	else
+	{
+		*pulOutLen = 0;
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("_query_802_11_capability(): szAuthEnc size is too large.\n"));
+		return _FALSE;
+	}
+}
+
+u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIATION_INFORMATION	pAssocInfo)
+{
+	struct wlan_network *tgt_network;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	security_priv  *psecuritypriv=&(padapter->securitypriv);
+	NDIS_WLAN_BSSID_EX	*psecnetwork=(NDIS_WLAN_BSSID_EX*)&(psecuritypriv->sec_bss);					
+	u8 *	pDest = (u8 *)pAssocInfo + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+	unsigned char i,*auth_ie,*supp_ie;
+
+	//NdisZeroMemory(pAssocInfo, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	memset(pAssocInfo, 0, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	//pAssocInfo->Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+
+	//------------------------------------------------------
+	// Association Request related information
+	//------------------------------------------------------
+	// Req_1. AvailableRequestFixedIEs
+	if(psecnetwork!=NULL){
+		
+	pAssocInfo->AvailableRequestFixedIEs |= NDIS_802_11_AI_REQFI_CAPABILITIES|NDIS_802_11_AI_REQFI_CURRENTAPADDRESS;
+	pAssocInfo->RequestFixedIEs.Capabilities = (unsigned short)* & psecnetwork->IEs[10];
+	_memcpy(pAssocInfo->RequestFixedIEs.CurrentAPAddress,
+		& psecnetwork->MacAddress, 6);
+
+	pAssocInfo->OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+
+	if(check_fwstate( pmlmepriv, _FW_UNDER_LINKING|_FW_LINKED)==_TRUE)
+	{
+		
+		if(psecuritypriv->ndisauthtype>=Ndis802_11AuthModeWPA2)
+			pDest[0] =48;		//RSN Information Element
+		else 
+			pDest[0] =221;	//WPA(SSN) Information Element
+		
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n Adapter->ndisauthtype==Ndis802_11AuthModeWPA)?0xdd:0x30 [%d]",pDest[0]));
+		supp_ie=&psecuritypriv->supplicant_ie[0];
+		for(i=0;i<supp_ie[0];i++)
+		{
+			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("IEs [%d] = 0x%x \n\n", i,supp_ie[i]));
+		}
+
+		i=13;	//0~11 is fixed information element		
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("i= %d tgt_network->network.IELength=%d\n\n", i,(int)psecnetwork->IELength));
+		while((i<supp_ie[0]) && (i<256)){
+			if((unsigned char)supp_ie[i]==pDest[0]){
+						_memcpy((u8 *)(pDest),
+							&supp_ie[i], 
+							supp_ie[1+i]+2);
+			
+				break;
+			}
+			
+			i=i+supp_ie[i+1]+2;
+			if(supp_ie[1+i]==0)
+				i=i+1;
+			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("iteration i=%d IEs [%d] = 0x%x \n\n", i,i,supp_ie[i+1]));
+			
+		}
+		
+
+		pAssocInfo->RequestIELength += (2 + supp_ie[1+i]);// (2 + psecnetwork->IEs[1+i]+4);
+
+	}
+	
+
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n psecnetwork != NULL,fwstate==_FW_UNDER_LINKING \n"));
+
+	}
+	
+
+	//------------------------------------------------------
+	// Association Response related information
+	//------------------------------------------------------
+
+	if(check_fwstate( pmlmepriv, _FW_LINKED)==_TRUE)
+	{
+		tgt_network =&(pmlmepriv->cur_network);
+		if(tgt_network!=NULL){
+		pAssocInfo->AvailableResponseFixedIEs =
+				NDIS_802_11_AI_RESFI_CAPABILITIES
+				|NDIS_802_11_AI_RESFI_ASSOCIATIONID
+				;
+
+		pAssocInfo->ResponseFixedIEs.Capabilities =(unsigned short)* & tgt_network->network.IEs[10];
+		pAssocInfo->ResponseFixedIEs.StatusCode = 0;
+		pAssocInfo->ResponseFixedIEs.AssociationId =(unsigned short) tgt_network->aid;
+
+		pDest = (u8 *)pAssocInfo + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION)+pAssocInfo->RequestIELength;
+		auth_ie=&psecuritypriv->authenticator_ie[0];
+
+		for(i=0;i<auth_ie[0];i++)
+			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("IEs [%d] = 0x%x \n\n", i,auth_ie[i]));
+
+		i=auth_ie[0]-12;
+		if(i>0){
+			_memcpy((u8 *)&pDest[0],&auth_ie[1],i);
+			pAssocInfo->ResponseIELength =i; 
+		}
+
+
+		pAssocInfo->OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAssocInfo->RequestIELength;  
+
+
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n tgt_network != NULL,fwstate==_FW_LINKED \n"));
+		}
+	}												  	
+	RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n exit query_802_11_association_information \n"));
+_func_exit_;
+
+	return _TRUE;
+}
+#endif
+
diff --git a/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_rtl.c b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_rtl.c
new file mode 100755
index 0000000..174da0a
--- /dev/null
+++ b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_rtl.c
@@ -0,0 +1,1028 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define  _RTL871X_IOCTL_RTL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+#include <wifi.h>
+#include <rtl871x_ioctl.h>
+#include <rtl871x_ioctl_set.h>
+#include <rtl871x_ioctl_query.h>
+#include <rtl871x_ioctl_rtl.h>
+#include <mp_custom_oid.h>
+#ifdef CONFIG_MP_INCLUDED
+#include <rtl871x_mp.h>
+#include <rtl871x_mp_ioctl.h>
+#endif
+
+struct oid_obj_priv oid_rtl_seg_01_01[] =
+{
+	{1, &oid_null_function},										//0x80
+	{1, &oid_null_function},										//0x81
+	{1, &oid_null_function},										//0x82
+	{1, &oid_null_function},										//0x83//OID_RT_SET_SNIFFER_MODE
+	{1, &oid_rt_get_signal_quality_hdl},							//0x84
+	{1, &oid_rt_get_small_packet_crc_hdl},						//0x85
+	{1, &oid_rt_get_middle_packet_crc_hdl},						//0x86
+	{1, &oid_rt_get_large_packet_crc_hdl},						//0x87
+	{1, &oid_rt_get_tx_retry_hdl},								//0x88
+	{1, &oid_rt_get_rx_retry_hdl},								//0x89
+	{1, &oid_rt_pro_set_fw_dig_state_hdl},						//0x8A
+	{1, &oid_rt_pro_set_fw_ra_state_hdl}	,						//0x8B
+	{1, &oid_null_function},										//0x8C
+	{1, &oid_null_function},										//0x8D
+	{1, &oid_null_function},										//0x8E
+	{1, &oid_null_function},										//0x8F
+	{1, &oid_rt_get_rx_total_packet_hdl},							//0x90
+	{1, &oid_rt_get_tx_beacon_ok_hdl},							//0x91
+	{1, &oid_rt_get_tx_beacon_err_hdl},							//0x92
+	{1, &oid_rt_get_rx_icv_err_hdl},								//0x93
+	{1, &oid_rt_set_encryption_algorithm_hdl},					//0x94
+	{1, &oid_null_function},										//0x95
+	{1, &oid_rt_get_preamble_mode_hdl},							//0x96
+	{1, &oid_null_function},										//0x97
+	{1, &oid_rt_get_ap_ip_hdl},									//0x98
+	{1, &oid_rt_get_channelplan_hdl},							//0x99	
+	{1, &oid_rt_set_preamble_mode_hdl},	 						//0x9A
+	{1, &oid_rt_set_bcn_intvl_hdl},								//0x9B
+	{1, &oid_null_function},										//0x9C
+	{1, &oid_rt_dedicate_probe_hdl},								//0x9D
+	{1, &oid_null_function},										//0x9E
+	{1, &oid_null_function},										//0x9F
+	{1, &oid_null_function},										//0xA0
+	{1, &oid_null_function},										//0xA1
+	{1, &oid_null_function},										//0xA2
+	{1, &oid_null_function},										//0xA3
+	{1, &oid_null_function},										//0xA4
+	{1, &oid_null_function},										//0xA5
+	{1, &oid_null_function},										//0xA6
+	{1, &oid_rt_get_total_tx_bytes_hdl},							//0xA7
+	{1, &oid_rt_get_total_rx_bytes_hdl},							//0xA8
+	{1, &oid_rt_current_tx_power_level_hdl},						//0xA9	
+	{1, &oid_rt_get_enc_key_mismatch_count_hdl},	 			//0xAA
+	{1, &oid_rt_get_enc_key_match_count_hdl},					//0xAB
+	{1, &oid_rt_get_channel_hdl},								//0xAC
+	{1, &oid_rt_set_channelplan_hdl},								//0xAD
+	{1, &oid_rt_get_hardware_radio_off_hdl},						//0xAE
+	{1, &oid_null_function},										//0xAF
+	{1, &oid_null_function},										//0xB0
+	{1, &oid_null_function},										//0xB1
+	{1, &oid_null_function},										//0xB2
+	{1, &oid_null_function},										//0xB3
+	{1, &oid_rt_get_key_mismatch_hdl},							//0xB4
+	{1, &oid_null_function},										//0xB5
+	{1, &oid_null_function},										//0xB6
+	{1, &oid_null_function},										//0xB7
+	{1, &oid_null_function},										//0xB8
+	{1, &oid_null_function},										//0xB9	
+	{1, &oid_null_function},	 									//0xBA
+	{1, &oid_rt_supported_wireless_mode_hdl},					//0xBB
+	{1, &oid_rt_get_channel_list_hdl},							//0xBC
+	{1, &oid_rt_get_scan_in_progress_hdl},						//0xBD
+	{1, &oid_null_function},										//0xBE
+	{1, &oid_null_function},										//0xBF
+	{1, &oid_null_function},										//0xC0
+	{1, &oid_rt_forced_data_rate_hdl},							//0xC1
+	{1, &oid_rt_wireless_mode_for_scan_list_hdl},					//0xC2
+	{1, &oid_rt_get_bss_wireless_mode_hdl},						//0xC3
+	{1, &oid_rt_scan_with_magic_packet_hdl},					//0xC4
+	{1, &oid_null_function},										//0xC5
+	{1, &oid_null_function},										//0xC6
+	{1, &oid_null_function},										//0xC7
+	{1, &oid_null_function},										//0xC8
+	{1, &oid_null_function},										//0xC9	
+	{1, &oid_null_function},	 									//0xCA
+	{1, &oid_null_function},										//0xCB
+	{1, &oid_null_function},										//0xCC
+	{1, &oid_null_function},										//0xCD
+	{1, &oid_null_function},										//0xCE
+	{1, &oid_null_function},										//0xCF
+	
+};
+
+struct oid_obj_priv oid_rtl_seg_01_03[] =
+{
+	{1, &oid_rt_ap_get_associated_station_list_hdl},				//0x00
+	{1, &oid_null_function},										//0x01
+	{1, &oid_rt_ap_switch_into_ap_mode_hdl},					//0x02
+	{1, &oid_null_function},										//0x03
+	{1, &oid_rt_ap_supported_hdl},								//0x04
+	{1, &oid_rt_ap_set_passphrase_hdl},							//0x05
+
+};
+
+struct oid_obj_priv oid_rtl_seg_01_11[] =
+{
+	{1, &oid_null_function},					//0xC0	OID_RT_PRO_RX_FILTER	
+	{1, &oid_null_function},					//0xC1	OID_CE_USB_WRITE_REGISTRY
+	{1, &oid_null_function},					//0xC2	OID_CE_USB_READ_REGISTRY
+	{1, &oid_null_function},					//0xC3	OID_RT_PRO_SET_INITIAL_GAIN
+	{1, &oid_null_function},					//0xC4	OID_RT_PRO_SET_BB_RF_STANDBY_MODE
+	{1, &oid_null_function},					//0xC5	OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE
+	{1, &oid_null_function},					//0xC6	OID_RT_PRO_SET_TX_CHARGE_PUMP
+	{1, &oid_null_function},					//0xC7	OID_RT_PRO_SET_RX_CHARGE_PUMP
+	{1, &oid_rt_pro_rf_write_registry_hdl},	//0xC8	
+	{1, &oid_rt_pro_rf_read_registry_hdl},	//0xC9	
+	{1, &oid_null_function}					//0xCA	OID_RT_PRO_QUERY_RF_TYPE
+	
+};
+
+struct oid_obj_priv oid_rtl_seg_03_00[] =
+{
+	{1, &oid_null_function},										//0x00
+	{1, &oid_rt_get_connect_state_hdl},							//0x01
+	{1, &oid_null_function},										//0x02
+	{1, &oid_null_function},										//0x03
+	{1, &oid_rt_set_default_key_id_hdl},							//0x04
+
+	
+};
+
+
+//**************  oid_rtl_seg_01_01 section start ************** 
+
+NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv)
+{
+
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL			oldirql;
+	
+	_func_enter_;
+	
+	if(poid_par_priv->type_of_oid != SET_OID) 
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+			
+	_irqlevel_changed_(&oldirql,LOWER);
+	if(poid_par_priv->information_buf_len >= sizeof(struct setdig_parm))
+	{
+		//DEBUG_ERR(("===> oid_rt_pro_set_fw_dig_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));	
+		if(!setfwdig_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))			
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+		                   
+	}
+	else{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}  
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv)
+{
+
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL			oldirql;
+	
+	_func_enter_;	
+	if(poid_par_priv->type_of_oid != SET_OID) 
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+					
+	_irqlevel_changed_(&oldirql,LOWER);
+	
+	if(poid_par_priv->information_buf_len >= sizeof(struct setra_parm))
+	{
+		//DEBUG_ERR(("===> oid_rt_pro_set_fw_ra_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));	
+		if(!setfwra_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))			
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+		                   
+	}
+	else{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}  
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	//DEBUG_ERR(("<**********************oid_rt_get_signal_quality_hdl \n"));
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+#if 0
+		if(pMgntInfo->mAssoc || pMgntInfo->mIbss)
+		{
+			ulInfo = pAdapter->RxStats.SignalQuality;
+			*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		}
+		else
+		{
+			ulInfo = 0xffffffff; // It stands for -1 in 4-byte integer.
+		}
+		break;
+#endif
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+
+NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+		
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_smallpacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_middlepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_largepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_pkts + padapter->recvpriv.rx_drop;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if(poid_par_priv->information_buf_len>= sizeof(u32))
+	{
+		//_memcpy(*(uint *)poid_par_priv->information_buf,padapter->recvpriv.rx_icv_err,sizeof(u32));
+		*(uint *)poid_par_priv->information_buf = padapter->recvpriv.rx_icv_err;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	ULONG			preamblemode = 0 ;			
+		
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{		
+		if(padapter->registrypriv.preamble == PREAMBLE_LONG)
+			preamblemode = 0;
+		else if (padapter->registrypriv.preamble == PREAMBLE_AUTO)
+			preamblemode = 1;
+		else if (padapter->registrypriv.preamble == PREAMBLE_SHORT)
+			preamblemode = 2;
+		
+			
+		*(ULONG *)poid_par_priv->information_buf = preamblemode ;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;	
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	*(u16 *)poid_par_priv->information_buf = peeprompriv->channel_plan ;
+
+	return status;
+}
+NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;	
+	
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	
+	peeprompriv->channel_plan = *(u16 *)poid_par_priv->information_buf ;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	ULONG			preamblemode = 0;
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	 
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{		
+		preamblemode = *(ULONG *)poid_par_priv->information_buf ;
+		if( preamblemode == 0)
+			padapter->registrypriv.preamble = PREAMBLE_LONG;
+		else if (preamblemode==1 )
+			padapter->registrypriv.preamble = PREAMBLE_AUTO;
+		else if ( preamblemode==2 )
+			padapter->registrypriv.preamble = PREAMBLE_SHORT;		
+			
+		*(ULONG *)poid_par_priv->information_buf = preamblemode ;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_bcn_intvl_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	return status;
+}
+NDIS_STATUS oid_rt_dedicate_probe_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->xmitpriv.tx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{
+		//_memcpy(*(uint *)poid_par_priv->information_buf,padapter->recvpriv.rx_icv_err,sizeof(u32));
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_current_tx_power_level_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	NDIS_802_11_CONFIGURATION		*pnic_Config;
+
+	ULONG   channelnum;
+
+	_func_enter_;
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+		pnic_Config = &pmlmepriv->cur_network.network.Configuration;
+	else
+		pnic_Config = &padapter->registrypriv.dev_network.Configuration;
+
+	channelnum = pnic_Config->DSConfig;
+	*(ULONG *)poid_par_priv->information_buf = channelnum;
+	
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	_func_exit_;
+
+
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	ULONG 			ulInfo = 0 ;
+	//DEBUG_ERR(("<**********************oid_rt_supported_wireless_mode_hdl \n"));	
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	if(poid_par_priv->information_buf_len >= sizeof(ULONG)){
+		ulInfo |= 0x0100; //WIRELESS_MODE_B
+		ulInfo |= 0x0200; //WIRELESS_MODE_G
+		ulInfo |= 0x0400; //WIRELESS_MODE_A
+
+		*(ULONG *) poid_par_priv->information_buf = ulInfo;		
+		//DEBUG_ERR(("<===oid_rt_supported_wireless_mode %x\n",ulInfo));	
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+
+NDIS_STATUS oid_rt_forced_data_rate_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+//**************  oid_rtl_seg_01_01 section end ************** 
+
+//**************  oid_rtl_seg_01_03 section start ************** 
+NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+//**************  oid_rtl_seg_01_03 section end ************** 
+
+//****************  oid_rtl_seg_01_11   section start ****************
+NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL			oldirql;
+	_func_enter_;
+	//DEBUG_ERR(("<**********************oid_rt_pro_rf_write_registry_hdl \n"));
+	if(poid_par_priv->type_of_oid != SET_OID) //QUERY_OID
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	
+	_irqlevel_changed_(&oldirql,LOWER);
+	if(poid_par_priv->information_buf_len== (sizeof(unsigned long)*3))
+	{      
+		//RegOffsetValue	- The offset of RF register to write.
+		//RegDataWidth	- The data width of RF register to write.
+		//RegDataValue	- The value to write. 
+		//RegOffsetValue = *((unsigned long*)InformationBuffer);
+		//RegDataWidth = *((unsigned long*)InformationBuffer+1);	   
+		//RegDataValue =  *((unsigned long*)InformationBuffer+2);	
+		if(!setrfreg_cmd(Adapter, 
+						*(unsigned char*)poid_par_priv->information_buf, 
+						(unsigned long)(*((unsigned long*)poid_par_priv->information_buf+2))))
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+	                   
+	}
+	else{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}   
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL	oldirql;
+	_func_enter_;
+
+	//DEBUG_ERR(("<**********************oid_rt_pro_rf_read_registry_hdl \n"));
+	if(poid_par_priv->type_of_oid != SET_OID) //QUERY_OID
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+	
+	_irqlevel_changed_(&oldirql,LOWER);
+	if(poid_par_priv->information_buf_len== (sizeof(unsigned long)*3))
+	{
+		if(Adapter->mppriv.act_in_progress == _TRUE)
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+		else
+		{
+			//init workparam
+			Adapter->mppriv.act_in_progress = _TRUE;
+			Adapter->mppriv.workparam.bcompleted= _FALSE;
+			Adapter->mppriv.workparam.act_type = MPT_READ_RF;
+			Adapter->mppriv.workparam.io_offset = *(unsigned long*)poid_par_priv->information_buf;		
+			Adapter->mppriv.workparam.io_value = 0xcccccccc;
+				       
+			//RegOffsetValue	- The offset of RF register to read.
+			//RegDataWidth	- The data width of RF register to read.
+			//RegDataValue	- The value to read. 
+			//RegOffsetValue = *((unsigned long*)InformationBuffer);
+			//RegDataWidth = *((unsigned long*)InformationBuffer+1);	   
+			//RegDataValue =  *((unsigned long*)InformationBuffer+2);	   	 	                   
+			if(!getrfreg_cmd(Adapter, 
+							*(unsigned char*)poid_par_priv->information_buf, 
+							(unsigned char*)&Adapter->mppriv.workparam.io_value))
+			{
+				status = NDIS_STATUS_NOT_ACCEPTED;
+			}
+		}
+				      		   
+		                   
+	}
+	else	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_01_11   section end****************	
+
+
+//**************  oid_rtl_seg_03_00 section start **************  
+enum _CONNECT_STATE_{
+	CHECKINGSTATUS,
+	ASSOCIATED,
+	ADHOCMODE,
+	NOTASSOCIATED
+};
+
+NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	ULONG ulInfo;
+		
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	// nStatus==0	CheckingStatus
+	// nStatus==1	Associated
+	// nStatus==2	AdHocMode
+	// nStatus==3	NotAssociated
+	
+	if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		ulInfo = CHECKINGSTATUS;
+	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
+		ulInfo = ASSOCIATED;
+	else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)== _TRUE)
+		ulInfo = ADHOCMODE;
+	else
+		ulInfo = NOTASSOCIATED ;
+
+	*(ULONG *)poid_par_priv->information_buf = ulInfo;
+	*poid_par_priv->bytes_rw =  poid_par_priv->information_buf_len;
+
+#if 0
+	// Rearrange the order to let the UI still shows connection when scan is in progress
+	RT_TRACE(COMP_OID_QUERY, DBG_LOUD, ("===> Query OID_RT_GET_CONNECT_STATE.\n"));
+	if(pMgntInfo->mAssoc)
+		ulInfo = 1;
+	else if(pMgntInfo->mIbss)
+		ulInfo = 2;
+	else if(pMgntInfo->bScanInProgress)
+		ulInfo = 0;
+	else
+		ulInfo = 3;
+	ulInfoLen = sizeof(ULONG);
+	RT_TRACE(COMP_OID_QUERY, DBG_LOUD, ("<=== Query OID_RT_GET_CONNECT_STATE: %d\n", ulInfo));
+#endif
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	
+	return status;
+}
+//**************  oid_rtl_seg_03_00 section end **************  
diff --git a/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_set.c b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_set.c
new file mode 100755
index 0000000..09cc22b
--- /dev/null
+++ b/drivers/net/wireless/8712u/ioctl/rtl871x_ioctl_set.c
@@ -0,0 +1,1577 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_IOCTL_SET_C_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_ioctl_set.h>
+#include <hal_init.h>
+
+#ifdef CONFIG_USB_HCI
+#include <usb_osintf.h>
+#include <usb_ops.h>
+#endif
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_osintf.h>
+#endif
+
+
+#define IS_MAC_ADDRESS_BROADCAST(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+)
+
+u8 validate_ssid(NDIS_802_11_SSID *ssid)
+{
+	u8 i;
+	u8 ret = _TRUE;
+
+_func_enter_;
+
+	if (ssid->SsidLength > 32) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
+		ret = _FALSE;
+		goto exit;
+	}
+
+	for (i = 0; i < ssid->SsidLength; i++)
+	{
+		//wifi, printable ascii code must be supported
+		if (!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
+			ret = _FALSE;
+			break;
+		}
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+u8 do_join(_adapter *padapter)
+{
+	_list *plist, *phead;
+	u8* pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+	u8 ret = _TRUE;
+
+_func_enter_;
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_, ("+do_join: phead=%p; plist=%p\n", phead, plist));
+
+	pmlmepriv->cur_network.join_res = -2;
+	pmlmepriv->fw_state |= _FW_UNDER_LINKING;
+
+	pmlmepriv->pscanned = plist;
+	pmlmepriv->to_join = _TRUE;
+
+	if (_queue_empty(queue) == _TRUE)
+	{
+		if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+	               pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+            		
+		//when set_ssid/set_bssid for do_join(), but scanning queue is empty
+		//we try to issue sitesurvey firstly
+
+		if (pmlmepriv->sitesurveyctrl.traffic_busy == _FALSE)
+		{
+			// submit site_survey_cmd
+			sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("do_join(): site survey if scanned_queue is empty\n."));
+		}
+		
+		//ret=_FALSE;
+
+		goto exit;
+	}
+	else 	
+	{	
+             int ret;
+
+	     if((ret=select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
+	     {
+		_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+	}
+#if 0
+	     else if(ret == 2)
+	{
+			DBG_8712("*****UNDER_LINKED WITH SAME NETWORK, RETURN*****\n");
+
+			if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+	               	pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+
+	}
+#endif
+	else
+	{
+		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+		{
+			// submit createbss_cmd to change to a ADHOC_MASTER
+
+			//pmlmepriv->lock has been acquired by caller...
+			WLAN_BSSID_EX *pdev_network = &(padapter->registrypriv.dev_network);
+
+			pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+
+			pibss = padapter->registrypriv.dev_network.MacAddress;
+
+			_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+			_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+	
+			update_registrypriv_dev_network(padapter);
+
+			generate_random_ibss(pibss);
+					
+				if(createbss_cmd(padapter)!=_SUCCESS)
+				{
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>do_goin: createbss_cmd status FAIL*** \n "));						
+					return _FALSE;
+			}
+
+			        pmlmepriv->to_join = _FALSE;
+
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("***Error=> select_and_join_from_scanned_queue FAIL under STA_Mode*** \n "));						
+
+		}
+		else
+		{
+			// can't associate ; reset under-linking			
+			if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+			    pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+
+#if 0
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			{
+				if(_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
+				{
+					// for funk to do roaming
+					// funk will reconnect, but funk will not sitesurvey before reconnect
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("for funk to do roaming"));
+					if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
+						sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+				}
+
+			}
+#endif
+
+			//when set_ssid/set_bssid for do_join(), but there are no desired bss in scanning queue
+			//we try to issue sitesurvey firstly
+				if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
+				{
+				//printk("do_join() when no desired bss in scanning queue\n");
+				sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+		}
+
+
+			}
+
+		}
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef CONFIG_USB_HCI
+void pnp_resume_wk(void *context)
+{
+	uint res = _SUCCESS;
+	_adapter * padapter = (_adapter *)context;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	padapter->pwrctrlpriv.pnp_bstop_trx=_FALSE;
+
+	pxmitpriv->txirp_cnt = 1;
+	precvpriv->rx_pending_cnt = 1;
+
+
+	res = rtl871x_hal_init(padapter);
+
+	if (res ==_FAIL) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n========== pnp_hw_init_thread:init 8712 fail!!!!!!!!!!\n"));
+	}
+
+	if (padapter->dvobjpriv.inirp_init !=NULL) {
+		padapter->dvobjpriv.inirp_init(padapter);
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("\n pnp_hw_init_thread:rx irp init!!\n"));
+	}
+
+	padapter->hw_init_completed = _TRUE;
+
+	NdisMSetInformationComplete(padapter->hndis_adapter, NDIS_STATUS_SUCCESS);
+}
+
+void pnp_sleep_wk(void *context)
+{
+	_irqL irqL;
+	_adapter *padapter = (_adapter *)context;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_critical(&pmlmepriv->lock, &irqL );
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+	{
+		indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL );
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("\npnp_sleep_wk:fwstate:%d\n", pmlmepriv->fw_state));
+
+	pwrctrl->pnp_bstop_trx=_TRUE;
+
+	//delay 1 second  then cancel IRP
+	//msleep_os(1000);
+
+	//cancel irp
+	// 1. tx/rx irp
+	// 2.int irp
+	// 3.reg read/write irp
+	rtl871x_intf_stop(padapter);
+
+	msleep_os(1000);
+
+	//Turn off LDO
+	rtl871x_hal_deinit(padapter);
+
+	padapter->hw_init_completed = _FALSE;
+
+	NdisMSetInformationComplete(padapter->hndis_adapter, NDIS_STATUS_SUCCESS);
+}
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#define IOCTL_CARD_STATE_NOTIFY	1000
+void pnp_resume_wk(void *context)
+{
+#ifdef CONFIG_POWER_DOWN_MODE
+	NDIS_STATUS status;
+	uint res = _SUCCESS;
+#endif
+	u8	x = 0;
+	_adapter * padapter = (_adapter *)context;
+
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("pnp_resume_wk ===>\n"));
+
+	padapter->pwrctrlpriv.pnp_bstop_trx=_FALSE;
+
+#ifdef CONFIG_POWER_DOWN_MODE
+{
+	BOOL	fRet = FALSE;
+	HANDLE	hPMU = INVALID_HANDLE_VALUE;
+	u32 stLdoData = 0;
+
+	hPMU = CreateFile(_T("SDH1:"), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+
+	if(INVALID_HANDLE_VALUE == hPMU )
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("CreateFile Error SDH1==.\n"));
+	}
+
+	 fRet=DeviceIoControl(hPMU,
+                         IOCTL_CARD_STATE_NOTIFY,
+                         NULL,
+                         0,
+                         &stLdoData,
+                         sizeof(u32),
+                         NULL,
+                         NULL);
+
+	if(!fRet)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("DeviceIoControl Error \n"));
+	}
+
+	CloseHandle(hPMU);
+}
+
+	//set 4-bit bus mode
+	attrib_read(padapter, 0x7, 1, &x);
+	x |= BIT(1);
+	attrib_write(padapter, 0x7, 1, &x);
+
+	//set Function 1 I/O Block Size to 512(0x0200)
+	x = 0x00;
+	attrib_write(padapter, 0x110, 1, &x);
+	x = 0x02;
+	attrib_write(padapter, 0x111, 1, &x);
+
+	//set  Function 1 I/O Enable
+	attrib_read(padapter, 0x2, 1, &x);
+	x |= BIT(1);
+	attrib_write(padapter, 0x2, 1, &x);
+
+	//set Function 1 Interrupt Enable
+	x = BIT(0)|BIT(1);
+	attrib_write(padapter, 0x4, 1, &x);
+
+	status=padapter->dvobj_init(padapter);
+	if (status != NDIS_STATUS_SUCCESS) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n initialize device object priv Failed!\n"));
+	}
+
+	res = rtl871x_hal_init(padapter);
+	if (res ==_FAIL) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n========== pnp_hw_init_thread:init 8712 fail!!!!!!!!!!\n"));
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("===>write SDIO_HIMR!!!\n"));
+	write16(padapter, SDIO_HIMR, 0x3ff);
+	{
+		u32 tmp32;
+		tmp32=read32(padapter, TXFF_EMPTY_TH);
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("  =====TXFF_EMPTY_TH=0x%.8x!\n",tmp32));
+		tmp32=tmp32 |0xfffff;
+		write32(padapter, TXFF_EMPTY_TH, tmp32);
+		tmp32=read32(padapter, TXFF_EMPTY_TH);
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("  =====TXFF_EMPTY_TH=0x%.8x!\n",tmp32));
+	}
+
+	padapter->hw_init_completed=_TRUE;
+
+#ifdef CONFIG_POWER_DOWN_MODE
+	if(padapter->pwrctrlpriv.pwr_mode != padapter->registrypriv.power_mgnt){
+		set_ps_mode(padapter, padapter->registrypriv.power_mgnt, padapter->registrypriv.smart_ps);
+	}
+#endif
+
+	NdisMSetInformationComplete(padapter->hndis_adapter, NDIS_STATUS_SUCCESS);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("pnp_resume_wk <===\n"));
+}
+
+void pnp_sleep_wk(void *context)
+{
+	_irqL irqL;
+	_adapter *padapter = (_adapter *)context;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("pnp_sleep_wk ===>\n"));
+
+	_enter_critical(&pmlmepriv->lock, &irqL );
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+	{
+		indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
+		free_assoc_resources(padapter);
+#ifndef CONFIG_POWER_DOWN_MODE
+		disassoc_cmd(padapter);
+#endif
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL );
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("pnp_sleep_wk:fwstate:%d\n", pmlmepriv->fw_state));
+
+#ifdef CONFIG_POWER_DOWN_MODE
+	//before enter powerdown mode, we must ensure FW in S4 state.
+	if (padapter->pwrctrlpriv.pwr_mode > PS_MODE_ACTIVE) {
+		padapter->pwrctrlpriv.pwr_mode = PS_MODE_ACTIVE;
+		_enter_pwrlock(&(padapter->pwrctrlpriv.lock));
+		set_rpwm(padapter, PS_STATE_S4);
+		_exit_pwrlock(&(padapter->pwrctrlpriv.lock));
+	}
+
+	while (pwrctrl->cpwm != PS_STATE_S4) {
+		//waiting FW to become ACTIVE.
+		msleep_os(10);
+	}
+#endif
+
+	write16(padapter, SDIO_HIMR, 0);
+
+	pwrctrl->pnp_bstop_trx = _TRUE;
+
+	padapter->hw_init_completed = _FALSE;
+
+	NdisMSetInformationComplete(padapter->hndis_adapter, NDIS_STATUS_SUCCESS);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("pnp_sleep_wk <===\n"));
+}
+#endif
+
+u8 pnp_set_power_wakeup(_adapter *padapter)
+{
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("==>pnp_set_power_wakeup!!!\n"));
+
+	res = setstandby_cmd(padapter, 0);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<==pnp_set_power_wakeup!!!\n"));
+
+_func_exit_;
+
+	return res;
+}
+
+u8 pnp_set_power_sleep(_adapter *padapter)
+{
+	u8 res = _SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("==>pnp_set_power_sleep!!!\n"));
+	//DbgPrint("+pnp_set_power_sleep\n");
+
+	res = setstandby_cmd(padapter, 1);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<==pnp_set_power_sleep!!!\n"));
+
+_func_exit_;
+
+	return res;
+}
+
+u8 set_802_11_reload_defaults(_adapter *padapter, NDIS_802_11_RELOAD_DEFAULTS reloadDefaults)
+{
+_func_enter_;
+
+	switch (reloadDefaults)
+	{
+		case Ndis802_11ReloadWEPKeys:
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("SetInfo OID_802_11_RELOAD_DEFAULTS : Ndis802_11ReloadWEPKeys\n"));
+			break;
+	}
+
+	// SecClearAllKeys(Adapter);
+	// 8711 CAM was not for En/Decrypt only
+	// so, we can't clear all keys.
+	// should we disable WPAcfg (ox0088) bit 1-2, instead of clear all CAM
+
+	//TO DO...
+
+_func_exit_;
+
+	return _TRUE;
+}
+
+u8 set_802_11_test(_adapter *padapter, NDIS_802_11_TEST *test)
+{
+	u8 ret = _TRUE;
+
+_func_enter_;
+
+	switch(test->Type)
+	{
+		case 1:
+			NdisMIndicateStatus(padapter->hndis_adapter, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, (PVOID)&test->AuthenticationEvent, test->Length - 8);
+			NdisMIndicateStatusComplete(padapter->hndis_adapter);
+			break;
+
+		case 2:
+			NdisMIndicateStatus(padapter->hndis_adapter, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, (PVOID)&test->RssiTrigger, sizeof(NDIS_802_11_RSSI));
+			NdisMIndicateStatusComplete(padapter->hndis_adapter);
+			break;
+
+		default:
+			ret=_FALSE;
+			break;
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+u8 set_802_11_pmkid(_adapter *padapter, NDIS_802_11_PMKID *pmkid)
+{
+	u8 ret = _SUCCESS;
+
+	return ret;
+}
+
+#endif
+
+u8 set_802_11_bssid(_adapter *padapter, u8 *bssid)
+{
+	_irqL irqL;
+	u8 status = _TRUE;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+set_802_11_bssid: bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]));
+
+	if ((bssid[0]==0x00 && bssid[1]==0x00 && bssid[2]==0x00 && bssid[3]==0x00 && bssid[4]==0x00 &&bssid[5]==0x00) ||
+	    (bssid[0]==0xFF && bssid[1]==0xFF && bssid[2]==0xFF && bssid[3]==0xFF && bssid[4]==0xFF &&bssid[5]==0xFF))
+	{
+		status = _FALSE;
+		return status;
+	}
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+ 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("Set BSSID is not allowed under surveying || adhoc master || under linking, fw_state=0x%08x\n",
+			  get_fwstate(pmlmepriv)));
+		status = check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_BSSID;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
+
+		if (_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == _TRUE)
+		{
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE)
+				goto _Abort_Set_BSSID;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+		} else {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("Set BSSID not the same ssid\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_bssid=%02x:%02x:%02x:%02x:%02x:%02x\n", bssid[0],bssid[1],bssid[2],bssid[3],bssid[4],bssid[5]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("cur_bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
+				pmlmepriv->cur_network.network.MacAddress[0],pmlmepriv->cur_network.network.MacAddress[1],pmlmepriv->cur_network.network.MacAddress[2],
+				pmlmepriv->cur_network.network.MacAddress[3],pmlmepriv->cur_network.network.MacAddress[4],pmlmepriv->cur_network.network.MacAddress[5]));
+
+			disassoc_cmd(padapter);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+				indicate_disconnect(padapter);
+
+			free_assoc_resources(padapter);
+
+			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+
+	_memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
+
+	pmlmepriv->assoc_by_bssid = _TRUE;
+
+	status = do_join(padapter);
+
+	goto done;
+
+_Abort_Set_BSSID:
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("set_802_11_bssid: _Abort_Set_BSSID\n"));
+
+done:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+_func_exit_;
+
+	return status;
+}
+
+u8 set_802_11_ssid(_adapter *padapter, NDIS_802_11_SSID *ssid)
+{
+	_irqL irqL;
+	u8 status = _TRUE;
+
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
+	_queue *queue = &pmlmepriv->scanned_queue;
+
+#ifdef PLATFORM_WINDOWS
+	LARGE_INTEGER sys_time;
+	u32 diff_time, cur_time;
+#endif
+
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+set_802_11_ssid: ssid=[%s] fw_state=0x%08x\n",
+		  ssid->Ssid, get_fwstate(pmlmepriv)));
+
+	if (padapter->hw_init_completed == _FALSE) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("set_ssid: hw_init_completed==_FALSE=>exit!!!\n"));
+		return _FALSE;
+	}
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("Set SSID is not allowed under surveying || adhoc master || under linking\n"));
+		status = check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_SSID;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+			 ("set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
+
+		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
+		    (_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == _TRUE))
+		{
+			if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE))
+			{
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("Set SSID is the same ssid, fw_state=0x%08x\n",
+					  get_fwstate(pmlmepriv)));
+
+				if (is_same_ibss(padapter, pnetwork) == _FALSE)
+				{				
+					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
+					disassoc_cmd(padapter);
+
+					if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+						indicate_disconnect(padapter);
+
+					free_assoc_resources(padapter);
+
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
+						_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+						set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+					}
+				}
+				else
+				{
+					goto _Abort_Set_SSID;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+				}
+			}	
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("Set SSID not the same ssid\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_ssid=[%s] len=0x%x\n", ssid->Ssid, (unsigned int)ssid->SsidLength));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("assoc_ssid=[%s] len=0x%x\n", pmlmepriv->assoc_ssid.Ssid, (unsigned int)pmlmepriv->assoc_ssid.SsidLength));
+
+			disassoc_cmd(padapter);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+				indicate_disconnect(padapter);
+
+			free_assoc_resources(padapter);
+
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+
+#ifdef PLATFORM_WINDOWS
+	if (padapter->securitypriv.btkip_countermeasure == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_ssid:padapter->securitypriv.btkip_countermeasure==_TRUE\n"));
+		NdisGetCurrentSystemTime(&sys_time);
+		cur_time=(u32)(sys_time.QuadPart/10);  // In micro-second.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_ssid:cur_time=0x%x\n",cur_time));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_ssid:psecuritypriv->last_mic_err_time=0x%x\n",padapter->securitypriv.btkip_countermeasure_time));
+		diff_time = cur_time -padapter->securitypriv.btkip_countermeasure_time; // In micro-second.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_ssid:diff_time=0x%x\n",diff_time));
+
+		if (diff_time > 60000000) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_ssid(): countermeasure time >60s.\n"));
+			padapter->securitypriv.btkip_countermeasure = _FALSE;
+			// Update MIC error time.
+			padapter->securitypriv.btkip_countermeasure_time = 0;
+		} else {
+			// can't join  in 60 seconds.
+			status = _FALSE;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_ssid(): countermeasure time <60s.\n"));
+			goto _Abort_Set_SSID;
+		}
+	}
+#endif
+
+#ifdef PLATFORM_LINUX
+	if (padapter->securitypriv.btkip_countermeasure == _TRUE) {
+		status = _FALSE;
+		goto _Abort_Set_SSID;
+	}
+#endif
+
+	#ifdef CONFIG_VALIDATE_SSID
+	if (validate_ssid(ssid) == _FALSE) {
+		status = _FALSE;
+		goto _Abort_Set_SSID;
+	}
+	#endif
+
+	_memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(NDIS_802_11_SSID));
+
+	pmlmepriv->assoc_by_bssid = _FALSE;
+
+	status = do_join(padapter);
+
+	goto done;
+
+_Abort_Set_SSID:
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+		 ("-set_802_11_ssid: _Abort_Set_SSID: status=%d\n", status));
+
+done:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+_func_exit_;
+
+	return status;
+
+}
+
+u8 set_802_11_infrastructure_mode(_adapter *padapter,
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	_irqL irqL;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE *pold_state = &(cur_network->network.InfrastructureMode);
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_notice_,
+		 ("+set_802_11_infrastructure_mode: old=%d new=%d fw_state=0x%08x\n",
+		  *pold_state, networktype, pmlmepriv->fw_state));
+
+	if (*pold_state != networktype)
+	{
+		_enter_critical(&pmlmepriv->lock, &irqL);
+
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
+		    (*pold_state == Ndis802_11IBSS))
+			disassoc_cmd(padapter);
+
+		if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+			free_assoc_resources(padapter);
+
+		if ((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) ||
+		    (*pold_state == Ndis802_11Infrastructure) ||
+		    (*pold_state == Ndis802_11IBSS))
+			indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether issue dis-assoc_cmd or not
+
+		if (*pold_state == Ndis802_11APMode)
+		{
+			//todo: change to other mode from Ndis802_11APMode
+		}
+
+		*pold_state = networktype;
+
+		// clear WIFI_STATION_STATE; WIFI_AP_STATE; WIFI_ADHOC_STATE; WIFI_ADHOC_MASTER_STATE
+		//pmlmepriv->fw_state &= 0xffffff87;
+		_clr_fwstate_(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE);
+
+		switch (networktype)
+		{
+			case Ndis802_11IBSS:
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+				break;
+
+			case Ndis802_11Infrastructure:
+				set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+				break;
+
+			case Ndis802_11APMode:
+				set_fwstate(pmlmepriv, WIFI_AP_STATE);
+				//indicate_connect(padapter);
+				break;
+
+			case Ndis802_11AutoUnknown:
+			case Ndis802_11InfrastructureMax:
+				break;
+		}
+
+		//SecClearAllKeys(adapter);
+
+		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
+		//					pmlmepriv->fw_state));
+
+		_exit_critical(&pmlmepriv->lock, &irqL);
+	}
+
+_func_exit_;
+
+	return _TRUE;
+}
+
+
+u8 set_802_11_disassociate(_adapter *padapter)
+{
+	_irqL irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_DISASSOCIATE: indicate_disconnect\n"));
+
+		disassoc_cmd(padapter);
+		indicate_disconnect(padapter);
+		free_assoc_resources(padapter);
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+_func_exit_;
+
+	return _TRUE;
+}
+
+u8 set_802_11_bssid_list_scan(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = NULL;
+
+	_irqL irqL;
+	u8 ret = _TRUE;
+
+_func_enter_;
+
+	if (padapter == NULL) {
+		ret = _FALSE;
+		goto exit;
+	}
+
+	pmlmepriv = &padapter->mlmepriv;
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_, ("+set_802_11_bssid_list_scan: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+
+	if (padapter->hw_init_completed == _FALSE) {
+		ret = _FALSE;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("!set_802_11_bssid_list_scan: hw_init_completed==_FALSE\n"));
+		goto exit;
+	}
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE))
+	{
+		// Scan or linking is in progress, do nothing.
+		ret = (u8)check_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("!set_802_11_bssid_list_scan: FAIL! fw_state=0x%08x, busy=%d, ret=%d\n",
+			  pmlmepriv->fw_state, pmlmepriv->sitesurveyctrl.traffic_busy, ret));
+	} else {
+		free_network_queue(padapter);
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("set_802_11_bssid_list_scan: flush network queue\n"));
+		ret = sitesurvey_cmd(padapter, NULL);
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+u8 set_802_11_authentication_mode(_adapter *padapter, NDIS_802_11_AUTHENTICATION_MODE authmode)
+{
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	u8 ret;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,("+set_802_11_auth_mode: mode=%d\n", authmode));
+
+	psecuritypriv->ndisauthtype = authmode;
+
+	if (psecuritypriv->ndisauthtype > 3)
+		psecuritypriv->dot11AuthAlgrthm = 2; // 802.1x
+
+	if (set_auth(padapter, psecuritypriv) == _SUCCESS)
+		ret = _TRUE;
+	else {
+		ret = _FALSE;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,("!set_802_11_auth_mode: fail!!\n"));
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+u8 set_802_11_add_wep(_adapter* padapter, NDIS_802_11_WEP *wep)
+{
+	u8	bdefaultkey;
+	u8	btransmitkey;
+	sint	keyid;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	u8	ret = _SUCCESS;
+
+_func_enter_;
+
+	bdefaultkey = (wep->KeyIndex & 0x40000000) > 0 ? _FALSE : _TRUE;	//for ???
+	btransmitkey = (wep->KeyIndex & 0x80000000) > 0 ? _TRUE : _FALSE;	//for ???
+	keyid = wep->KeyIndex & 0x3fffffff;
+
+	if (keyid >= WEP_KEYS) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("MgntActSet_802_11_ADD_WEP: keyid>4 FAIL!\n"));
+		ret = _FALSE;
+		goto exit;
+	}
+
+	switch (wep->KeyLength)
+	{
+		case 5:
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:wep->KeyLength=5\n"));
+			break;
+		case 13:
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:wep->KeyLength=13\n"));
+			break;
+		default:
+			psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:wep->KeyLength!=5 or 13\n"));
+			break;
+	}
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:befor memcpy, wep->KeyLength=0x%x wep->KeyIndex=0x%x  keyid =%x\n",wep->KeyLength,wep->KeyIndex,keyid));
+
+	_memcpy(psecuritypriv->dot11DefKey[keyid].skey, &wep->KeyMaterial, wep->KeyLength);
+	psecuritypriv->dot11DefKeylen[keyid] = wep->KeyLength;
+	psecuritypriv->dot11PrivacyKeyIndex = keyid;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:security key material: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		psecuritypriv->dot11DefKey[keyid].skey[0],psecuritypriv->dot11DefKey[keyid].skey[1],psecuritypriv->dot11DefKey[keyid].skey[2],
+		psecuritypriv->dot11DefKey[keyid].skey[3],psecuritypriv->dot11DefKey[keyid].skey[4],psecuritypriv->dot11DefKey[keyid].skey[5],
+		psecuritypriv->dot11DefKey[keyid].skey[6],psecuritypriv->dot11DefKey[keyid].skey[7],psecuritypriv->dot11DefKey[keyid].skey[8],
+		psecuritypriv->dot11DefKey[keyid].skey[9],psecuritypriv->dot11DefKey[keyid].skey[10],psecuritypriv->dot11DefKey[keyid].skey[11],
+		psecuritypriv->dot11DefKey[keyid].skey[12]));
+
+	if (set_key(padapter, psecuritypriv, keyid) == _FAIL)
+		ret = _FALSE;
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+u8 set_802_11_remove_wep(_adapter* padapter, u32 keyindex)
+{
+	u8 ret = _SUCCESS;
+
+_func_enter_;
+
+	if (keyindex >= 0x80000000 || padapter == NULL) {
+		ret=_FALSE;
+		goto exit;
+	}
+	else
+	{
+		int res;
+		struct security_priv* psecuritypriv = &padapter->securitypriv;
+
+		if (keyindex < WEP_KEYS) {
+			_memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
+			res = set_key(padapter,psecuritypriv, keyindex);
+			psecuritypriv->dot11DefKeylen[keyindex] = 0;
+			if (res == _FAIL)
+				ret=_FAIL;
+		} else {
+			ret=_FAIL;
+		}
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+
+}
+
+u8 set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
+
+	uint	encryptionalgo;
+	u8 * pbssid;
+	struct sta_info *stainfo;
+	u8	bgroup = _FALSE;
+	u8	bgrouptkey = _FALSE;//can be remove later
+	u8	ret=_SUCCESS;
+
+_func_enter_;
+
+	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
+
+		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination,
+		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_KEY: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_KEY:((key->KeyIndex & 0x40000000) > 0)[=%d]" , (int)(key->KeyIndex & 0x40000000) > 0));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_KEY: key->KeyIndex=%d \n" ,(int)key->KeyIndex));
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(key->KeyIndex & 0x40000000)
+	{
+		// Pairwise key
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));
+
+		pbssid=get_bssid(&padapter->mlmepriv);
+		stainfo=get_stainfo(&padapter->stapriv, pbssid);
+
+		if((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==2)){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:( stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==2)\n"));
+			encryptionalgo=stainfo->dot118021XPrivacy;
+		}
+		else{
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: stainfo==NULL)||(Adapter->securitypriv.dot11AuthAlgrthm!=2)\n"));
+			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (encryptionalgo ==%d)!\n",encryptionalgo ));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",padapter->securitypriv.dot11PrivacyAlgrthm));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",padapter->securitypriv.dot11AuthAlgrthm));
+
+		if((stainfo!=NULL)){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (stainfo->dot118021XPrivacy ==%d)!\n", stainfo->dot118021XPrivacy));
+		}
+
+		if(key->KeyIndex & 0x000000FF){
+			// The key index is specified in the lower 8 bits by values of zero to 255.
+			// The key index should be set to zero for a Pairwise key, and the driver should fail with
+			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" key->KeyIndex & 0x000000FF.\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// check BSSID
+		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _TRUE){
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
+			ret= _FALSE;
+			goto exit;
+		}
+
+		// Check key length for TKIP.
+		//if(encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
+		if((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
+			ret=_FAIL;
+			goto exit;
+
+		}
+
+		// Check key length for AES.
+		if((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
+			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
+			if(key->KeyLength == 32) {
+				key->KeyLength = 16;
+			} else {
+				ret= _FAIL;
+				goto exit;
+			}
+		}
+
+		// Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko.
+		if(	(encryptionalgo== _WEP40_|| encryptionalgo== _WEP104_) && (key->KeyLength != 5 || key->KeyLength != 13)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
+			ret=_FAIL;
+			goto exit;
+		}
+
+		bgroup = _FALSE;
+
+		// Check the pairwise key. Added by Annie, 2005-07-06.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Pairwise Key set]\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+
+	}
+	else
+	{
+		// Group key - KeyIndex(BIT30==0)
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
+
+
+		// when add wep key through add key and didn't assigned encryption type before
+		if((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
+		{
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
+
+			switch(key->KeyLength)
+			{
+				case 5:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u\n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
+					break;
+				case 13:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u\n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
+					break;
+				default:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u \n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
+					break;
+			}
+
+			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" Adapter->securitypriv.dot11PrivacyAlgrthm=%x\n", padapter->securitypriv.dot11PrivacyAlgrthm));
+
+		}
+		else
+		{
+			encryptionalgo=padapter->securitypriv.dot118021XGrpPrivacy;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n", padapter->securitypriv.dot11PrivacyAlgrthm,encryptionalgo,padapter->securitypriv.dot118021XGrpPrivacy,key->KeyLength));
+
+		}
+
+		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _FALSE)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" IBSS but BSSID is not Broadcast Address.\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// Check key length for TKIP
+		if((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
+			ret= _FAIL;
+			goto exit;
+
+		} else if(encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
+
+			// Check key length for AES
+			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
+		if((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
+			key->KeyLength = 16;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength) );
+		}
+
+		if(key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
+			bgrouptkey = _TRUE;
+		}
+
+		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==_TRUE))
+		{
+			bgrouptkey = _TRUE;
+		}
+
+		bgroup = _TRUE;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n") );
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Group Key set]\n") );
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n")) ;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength)) ;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+
+	}
+
+	// If WEP encryption algorithm, just call set_802_11_add_wep().
+	if((padapter->securitypriv.dot11AuthAlgrthm !=2)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
+	{
+		u8 ret;
+		u32 keyindex;
+		u32 len = FIELD_OFFSET(NDIS_802_11_KEY, KeyMaterial) + key->KeyLength;
+		NDIS_802_11_WEP *wep = &padapter->securitypriv.ndiswep;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ WEP key +++++\n"));
+
+		wep->Length = len;
+		keyindex = key->KeyIndex&0x7fffffff;
+		wep->KeyIndex = keyindex ;
+		wep->KeyLength = key->KeyLength;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:Before memcpy \n"));
+
+		_memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);
+		_memcpy(&(padapter->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);
+
+		padapter->securitypriv.dot11DefKeylen[keyindex]=key->KeyLength;
+		padapter->securitypriv.dot11PrivacyKeyIndex=keyindex;
+
+		ret = set_802_11_add_wep(padapter, wep);
+
+		goto exit;
+
+	}
+
+	if (key->KeyIndex & 0x20000000) {
+		// SetRSC
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
+		if(bgroup == _TRUE)
+		{
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			_memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);
+		}
+		else
+		{
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			_memcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);
+		}
+
+	}
+
+	// Indicate this key idx is used for TX
+	// Save the key in KeyMaterial
+	if(bgroup == _TRUE) // Group transmit key
+	{
+		int res;
+
+		if(bgrouptkey == _TRUE)
+		{
+			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
+		}
+
+		if((key->KeyIndex&0x3) == 0){
+			ret = _FAIL;
+			goto exit;
+		}
+
+		_memset(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex-1) & 0x03)], 0, 16);
+		_memset(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex-1) & 0x03)], 0, 16);
+		_memset(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)], 0, 16);
+
+		if((key->KeyIndex & 0x10000000))
+		{
+			_memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex-1) & 0x03)], key->KeyMaterial + 16, 8);
+			_memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)], key->KeyMaterial + 24, 8);
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[0],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[2],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[4],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[6],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n set_802_11_add_key:set Group mic key!!!!!!!!\n"));
+
+		}
+		else
+		{
+			_memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex-1) & 0x03)], key->KeyMaterial + 24, 8);
+			_memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)], key->KeyMaterial + 16, 8);
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[0],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[2],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[4],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
+				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[6],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n set_802_11_add_key:set Group mic key!!!!!!!!\n"));
+
+		}
+
+		//set group key by index
+		_memcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex-1) & 0x03)], key->KeyMaterial, key->KeyLength);
+
+		key->KeyIndex=key->KeyIndex & 0x03;
+
+		padapter->securitypriv.binstallGrpkey=_TRUE;
+
+		padapter->securitypriv.bcheck_grpkey=_FALSE;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("reset group key"));
+
+		res=set_key(padapter,&padapter->securitypriv, key->KeyIndex);
+
+		if(res==_FAIL)
+			ret= _FAIL;
+
+#ifdef CONFIG_PWRCTRL
+		if(padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE){
+			if(padapter->registrypriv.power_mgnt != padapter->pwrctrlpriv.pwr_mode){
+				_set_timer(&(padapter->mlmepriv.dhcp_timer), 60000);
+			}
+		}
+#endif
+		goto exit;
+
+	}
+	else // Pairwise Key
+	{
+		u8 res;
+
+		pbssid=get_bssid(&padapter->mlmepriv);
+		stainfo=get_stainfo(&padapter->stapriv , pbssid );
+
+		if(stainfo!=NULL)
+		{
+			_memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
+
+			_memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
+
+			if(encryptionalgo== _TKIP_)
+			{
+				padapter->securitypriv.busetkipkey=_FALSE;
+
+				_set_timer(&padapter->securitypriv.tkip_timer, 50);
+
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
+
+				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
+				if((key->KeyIndex & 0x10000000)){
+					_memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
+					_memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
+
+				} else {
+					_memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 24, 8);
+					_memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);
+
+				}
+
+			}
+			else if(encryptionalgo == _AES_)
+			{
+
+			}
+
+
+			//Set key to CAM through H2C command
+			if(bgrouptkey)//never go to here
+			{
+				res=setstakey_cmd(padapter, (unsigned char *)stainfo, _FALSE);
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n set_802_11_add_key:setstakey_cmd(group)\n"));
+			}
+			else{
+				res=setstakey_cmd(padapter, (unsigned char *)stainfo, _TRUE);
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n set_802_11_add_key:setstakey_cmd(unicast)\n"));
+			}
+
+			if(res ==_FALSE)
+				ret= _FAIL;
+
+		}
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+u8 set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
+
+	uint				encryptionalgo;
+	u8 * pbssid;
+	struct sta_info *stainfo;
+	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? _FALSE: _TRUE;
+	u8	keyIndex = (u8)key->KeyIndex & 0x03;
+	u8	ret=_SUCCESS;
+
+_func_enter_;
+
+	if ((key->KeyIndex & 0xbffffffc) > 0) {
+		ret=_FAIL;
+		goto exit;
+	}
+
+	if (bgroup == _TRUE) {
+		encryptionalgo= padapter->securitypriv.dot118021XGrpPrivacy;
+		// clear group key by index
+		//NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
+		//Adapter->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0;
+
+		_memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex-1], 0, 16);
+
+		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
+
+	} else {
+
+		pbssid=get_bssid(&padapter->mlmepriv);
+		stainfo=get_stainfo(&padapter->stapriv , pbssid );
+		if(stainfo !=NULL){
+			encryptionalgo=stainfo->dot118021XPrivacy;
+
+		// clear key by BSSID
+		_memset(&stainfo->dot118021x_UncstKey, 0, 16);
+
+		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
+
+		}
+		else{
+			ret= _FAIL;
+			goto exit;
+		}
+	}
+
+exit:
+
+_func_exit_;
+
+	return _TRUE;
+
+}
+
+/*
+* rtw_get_network_max_rate - 
+* @adapter: pointer to _adapter structure
+* @bss: 
+* 
+* Return 0 or Mbps
+*/
+u16 rtw_get_network_max_rate(_adapter *adapter, NDIS_WLAN_BSSID_EX *bss)
+{
+	int i =0;
+	u8 *p;
+	u16 rate = 0, max_rate = 0, ht_cap=_FALSE;
+	u32 ht_ielen = 0;	
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	u8	bw_40MHz=0, short_GI=0;
+	u16	mcs_rate=0;
+	struct registry_priv *pregpriv = &adapter->registrypriv;
+
+#ifdef CONFIG_MP_INCLUDED
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		return 0;
+#endif
+
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) 
+		&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE))
+		return 0;
+	
+
+	p = get_ie(&bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, bss->IELength-12);
+	if(p && ht_ielen>0)
+	{
+		ht_cap = _TRUE;	
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+	
+		_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+	while( (bss->SupportedRates[i]!=0) && (bss->SupportedRates[i]!=0xFF))
+	{
+		rate = bss->SupportedRates[i]&0x7F;
+		if(rate>max_rate)
+			max_rate = rate;
+		i++;
+	}
+
+	//TODO: should consider case of WEP and TKIP
+	if(ht_cap == _TRUE)
+	{
+		if(pregpriv->rf_config == RTL8712_RF_1T1R)
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);				
+		else
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+	}
+	else
+	{
+		max_rate/=2;
+	}
+
+	return max_rate;
+}
+
+/*
+* rtw_set_scan_mode - 
+* @adapter: pointer to _adapter structure
+* @scan_mode: 
+* 
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode)
+{
+	if(scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
+		return _FAIL;
+	
+	adapter->mlmepriv.passive_mode = scan_mode;
+
+	return _SUCCESS;
+}
+
+/*
+* rtw_set_channel_plan - 
+* @adapter: pointer to _adapter structure
+* @channel_plan: 
+* 
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	//handle by cmd_thread to sync with scan operation
+	return set_chplan_cmd(adapter, channel_plan);
+}
+
+/*
+* rtw_set_country - 
+* @adapter: pointer to _adapter structure
+* @country_code: string of country code
+* 
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_country(_adapter *adapter, const char *country_code)
+{
+	int channel_plan = RT_CHANNEL_DOMAIN_FCC;
+
+	//TODO: should have a table to match country code and RT_CHANNEL_DOMAIN
+	//TODO: should consider 2-character and 3-character counter code
+	if(0 == strcmp(country_code, "US"))
+		channel_plan = RT_CHANNEL_DOMAIN_FCC;
+	else if(0 == strcmp(country_code, "EU"))
+		channel_plan = RT_CHANNEL_DOMAIN_ETSI;
+	else if(0 == strcmp(country_code, "JP"))
+		channel_plan = RT_CHANNEL_DOMAIN_MKK;
+	else
+		printk("%s unknown country_code:%s\n", __FUNCTION__, country_code);
+	
+	return rtw_set_channel_plan(adapter, channel_plan);
+}
+
diff --git a/drivers/net/wireless/8712u/led/rtl8712_led.c b/drivers/net/wireless/8712u/led/rtl8712_led.c
new file mode 100755
index 0000000..5b01842
--- /dev/null
+++ b/drivers/net/wireless/8712u/led/rtl8712_led.c
@@ -0,0 +1,2822 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+******************************************************************************/
+
+#include "drv_types.h"
+
+//================================================================================
+//	Constant.
+//================================================================================
+
+//
+// Default LED behavior.
+//
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA		1000
+#define LED_BLINK_LINK_INTERVAL_ALPHA			500		//500
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180 	//150
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+//================================================================================
+// LED object.
+//================================================================================
+enum _LED_STATE_871x{
+	LED_UNKNOWN = 0,
+	LED_ON = 1,
+	LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_POWER_ON_BLINK = 5,
+	LED_SCAN_BLINK = 6, // LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
+	LED_NO_LINK_BLINK = 7, // LED is blinking during no link state.
+	LED_BLINK_StartToBlink = 8,// Customzied for Sercomm Printer Server case
+	LED_BLINK_WPS = 9,	// LED is blinkg during WPS communication
+	LED_TXRX_BLINK = 10,
+	LED_BLINK_WPS_STOP = 11,	//for ALPHA
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	//for BELKIN
+};
+
+//================================================================================
+//	Prototype of protected function.
+//================================================================================
+#ifdef PLATFORM_WINDOWS
+void BlinkTimerCallback (
+	IN PVOID	SystemSpecific1,
+	IN PVOID	FunctionContext,
+	IN PVOID	SystemSpecific2,
+	IN PVOID	SystemSpecific3
+	);
+
+void BlinkWorkItemCallback(
+	IN NDIS_WORK_ITEM	*pWorkItem,
+	IN PVOID		Context
+	);
+#endif
+
+#ifdef PLATFORM_LINUX
+static void
+BlinkTimerCallback(
+	unsigned long data
+	);
+
+static void
+BlinkWorkItemCallback(
+	struct work_struct *work
+	);
+#endif
+//================================================================================
+// LED_819xUsb routines. 
+//================================================================================
+
+//
+//	Description:
+//		Initialize an LED_871x object.
+//
+void
+InitLed871x(
+	_adapter			*padapter,
+	PLED_871x		pLed,
+	LED_PIN_871x	LedPin
+	)
+{
+	_nic_hdl nic;
+
+#ifdef PLATFORM_WINDOWS
+	nic = padapter->hndis_adapter;
+#endif
+#ifdef PLATFORM_LINUX
+	nic = padapter->pnetdev;
+#endif
+
+	pLed->padapter = padapter;
+
+	pLed->LedPin = LedPin;
+
+	pLed->CurrLedState = LED_OFF;
+	pLed->bLedOn = _FALSE;
+
+	pLed->bLedBlinkInProgress = _FALSE;
+	pLed->BlinkTimes = 0;
+	pLed->BlinkingLedState = LED_UNKNOWN;
+
+	_init_timer(&(pLed->BlinkTimer), nic, BlinkTimerCallback, pLed);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
+#endif
+}
+
+
+//
+//	Description:
+//		DeInitialize an LED_871x object.
+//
+void
+DeInitLed871x(
+	PLED_871x			pLed
+	)
+{
+	_cancel_timer_ex(&(pLed->BlinkTimer));
+
+	// We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko.
+	pLed->bLedBlinkInProgress = _FALSE;
+}
+
+
+//
+//	Description:
+//		Turn on LED according to LedPin specified.
+//
+void
+SwLedOn(
+	_adapter			*padapter, 
+	PLED_871x		pLed
+)
+{
+	u8	LedCfg;
+
+	if ( ( padapter->bSurpriseRemoved == _TRUE ) || ( padapter->bDriverStopped == _TRUE ) )
+	{
+             return;
+	}
+
+	LedCfg = read8(padapter, LEDCFG);
+	
+	switch(pLed->LedPin)
+	{
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+			write8(padapter, LEDCFG, LedCfg&0xf0); // SW control led0 on.
+			break;
+
+		case LED_PIN_LED1:
+			write8(padapter, LEDCFG, LedCfg&0x0f); // SW control led1 on.
+			break;
+
+		default:
+			break;
+	}
+
+	pLed->bLedOn = _TRUE;
+}
+
+
+//
+//	Description:
+//		Turn off LED according to LedPin specified.
+//
+void
+SwLedOff(
+	_adapter			*padapter, 
+	PLED_871x		pLed
+)
+{
+	u8	LedCfg;
+
+	if ( ( padapter->bSurpriseRemoved == _TRUE ) || ( padapter->bDriverStopped == _TRUE ) )
+       {
+             return;
+       }
+
+	LedCfg = read8(padapter, LEDCFG);
+
+	switch(pLed->LedPin)
+	{
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+			LedCfg &= 0xf0; // Set to software control.
+			write8(padapter, LEDCFG, (LedCfg|BIT(3)));
+			break;
+
+		case LED_PIN_LED1:
+			LedCfg &= 0x0f; // Set to software control.
+			write8(padapter, LEDCFG, (LedCfg|BIT(7)));
+			break;
+
+		default:
+			break;
+	}
+
+	pLed->bLedOn = _FALSE;
+}
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+
+//
+//	Description:
+//		Initialize all LED_871x objects.
+//
+void
+InitSwLeds(
+	_adapter	*padapter
+	)
+{
+	struct led_priv	*pledpriv = &(padapter->ledpriv);
+
+	pledpriv->LedControlHandler = LedControl871x;
+
+	InitLed871x(padapter, &(pledpriv->SwLed0), LED_PIN_LED0);
+
+	InitLed871x(padapter,&(pledpriv->SwLed1), LED_PIN_LED1);
+}
+
+
+//
+//	Description:
+//		DeInitialize all LED_819xUsb objects.
+//
+void
+DeInitSwLeds(
+	_adapter	*padapter
+	)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	DeInitLed871x( &(ledpriv->SwLed0) );
+	DeInitLed871x( &(ledpriv->SwLed1) );
+}
+
+
+//
+//	Description:
+//		Implementation of LED blinking behavior.
+//		It toggle off LED and schedule corresponding timer if necessary.
+//
+void
+SwLedBlink(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 			bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	// Determine if we shall change LED state again.
+	pLed->BlinkTimes--;
+	switch(pLed->CurrLedState)
+	{
+
+	case LED_BLINK_NORMAL: 
+		if(pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = _TRUE;
+		}
+		break;
+		
+	case LED_BLINK_StartToBlink:
+		if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)&&(pmlmepriv->fw_state & WIFI_STATION_STATE) )
+		{
+			bStopBlinking = _TRUE;
+		}
+		if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)&&
+			((pmlmepriv->fw_state & WIFI_ADHOC_STATE) || (pmlmepriv->fw_state & WIFI_ADHOC_MASTER_STATE)) )
+		{
+			bStopBlinking = _TRUE;
+		}
+		else if(pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = _TRUE;
+		}
+		break;
+
+	case LED_BLINK_WPS:
+		if( pLed->BlinkTimes == 0 )
+		{
+			bStopBlinking = _TRUE;
+		}
+		break;
+
+
+	default:
+		bStopBlinking = _TRUE;
+		break;
+			
+	}
+	
+	if(bStopBlinking)
+	{
+		//if( padapter->pwrctrlpriv.cpwm >= PS_STATE_S2)
+		if(0)
+		{
+			SwLedOff(padapter, pLed);
+		}
+		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (pLed->bLedOn == _FALSE))
+		{
+			SwLedOn(padapter, pLed);
+		}
+		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) &&  pLed->bLedOn == _TRUE)
+		{
+			SwLedOff(padapter, pLed);
+		}
+
+		pLed->BlinkTimes = 0;
+		pLed->bLedBlinkInProgress = _FALSE;
+	}
+	else
+	{
+		// Assign LED state to toggle.
+		if( pLed->BlinkingLedState == LED_ON ) 
+			pLed->BlinkingLedState = LED_OFF;
+		else 
+			pLed->BlinkingLedState = LED_ON;
+
+		// Schedule a timer to toggle LED state. 
+		switch( pLed->CurrLedState )
+		{
+		case LED_BLINK_NORMAL:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			break;
+		
+		case LED_BLINK_SLOWLY:
+		case LED_BLINK_StartToBlink:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			break;
+
+		case LED_BLINK_WPS:
+			{
+				if( pLed->BlinkingLedState == LED_ON )
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				else
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+			break;
+
+		default:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		}
+	}
+}
+
+
+void
+SwLedBlink1(
+	PLED_871x			pLed
+	)
+{
+	_adapter				*padapter = pLed->padapter;
+	struct led_priv		*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	struct eeprom_priv	*peeprompriv = &(padapter->eeprompriv);
+	PLED_871x 			pLed1 = &(ledpriv->SwLed1);	
+	u8 				bStopBlinking = _FALSE;
+
+	if(peeprompriv->CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);	
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+
+	if(peeprompriv->CustomerID == RT_CID_DEFAULT)
+	{
+		if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+		{
+			if(!pLed1->bSWLedCtrl)
+			{
+				SwLedOn(padapter, pLed1); 	
+				pLed1->bSWLedCtrl = _TRUE;
+			}
+			else if(!pLed1->bLedOn)	
+				SwLedOn(padapter, pLed1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
+		}
+		else 
+		{
+			if(!pLed1->bSWLedCtrl)
+			{
+				SwLedOff(padapter, pLed1);
+				pLed1->bSWLedCtrl = _TRUE;
+			}
+			else if(pLed1->bLedOn)
+				SwLedOff(padapter, pLed1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));		
+		}
+	}
+
+	switch(pLed->CurrLedState)
+	{
+		case LED_BLINK_SLOWLY:			
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_NORMAL:
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			break;
+			
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF;
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF;
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->BlinkTimes = 0;
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_WPS_STOP:	//WPS success
+			if(pLed->BlinkingLedState == LED_ON)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				bStopBlinking = _FALSE;
+			}
+			else
+			{
+				bStopBlinking = _TRUE;				
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedWPSBlinkInProgress = _FALSE;	
+			}		
+			break;
+					
+		default:
+			break;
+	}
+
+}
+
+void
+SwLedBlink2(
+	PLED_871x			pLed
+	)
+{
+	_adapter				*padapter = pLed->padapter;
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	u8 				bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch(pLed->CurrLedState)
+	{	
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 
+					SwLedOff(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 
+					SwLedOff(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+					
+		default:
+			break;
+	}
+
+}
+
+void
+SwLedBlink3(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		if(pLed->CurrLedState != LED_BLINK_WPS_STOP)
+			SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}	
+
+	switch(pLed->CurrLedState)
+	{			
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON;				
+					if( !pLed->bLedOn )
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF;									
+					if( pLed->bLedOn )
+						SwLedOff(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+				 	if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON;
+				
+					if( !pLed->bLedOn )
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF;					
+				
+					if( pLed->bLedOn )
+						SwLedOff(padapter, pLed);
+
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_WPS_STOP:	//WPS success
+			if(pLed->BlinkingLedState == LED_ON)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				bStopBlinking = _FALSE;
+			}
+			else
+			{
+				bStopBlinking = _TRUE;				
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedWPSBlinkInProgress = _FALSE;	
+			}		
+			break;
+			
+					
+		default:
+			break;
+	}
+
+}
+
+
+void
+SwLedBlink4(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	PLED_871x 		pLed1 = &(ledpriv->SwLed1);	
+	u8				bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}	
+
+	if(!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
+	{
+		pLed1->BlinkingLedState = LED_OFF;
+		pLed1->CurrLedState = LED_OFF;
+		SwLedOff(padapter, pLed1);
+	}	
+
+	switch(pLed->CurrLedState)
+	{
+		case LED_BLINK_SLOWLY:			
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_StartToBlink:
+			if( pLed->bLedOn )
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;			
+			
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				}
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if( pLed->bLedOn )
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+		case LED_BLINK_WPS_STOP:	//WPS authentication fail
+			if( pLed->bLedOn )			
+				pLed->BlinkingLedState = LED_OFF; 			
+			else			
+				pLed->BlinkingLedState = LED_ON;
+
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			break;
+
+		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap		
+			pLed->BlinkTimes--;
+			if(pLed->BlinkTimes == 0)
+			{
+				if(pLed->bLedOn)
+				{
+					pLed->BlinkTimes = 1;							
+				}
+				else
+				{
+					bStopBlinking = _TRUE;
+				}
+			}
+
+			if(bStopBlinking)
+			{				
+				pLed->BlinkTimes = 10;			
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			}
+			else
+			{
+				if( pLed->bLedOn )			
+					pLed->BlinkingLedState = LED_OFF;			
+				else			
+					pLed->BlinkingLedState = LED_ON;
+
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+					
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 CurrLedState %d\n", pLed->CurrLedState));
+
+
+}
+
+void
+SwLedBlink5(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch(pLed->CurrLedState)
+	{
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 									
+					if(pLed->bLedOn)				
+						SwLedOff(padapter, pLed);
+				}
+				else 
+				{		pLed->CurrLedState = LED_ON;
+						pLed->BlinkingLedState = LED_ON;					
+						if(!pLed->bLedOn)
+							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+	
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 									
+					if(pLed->bLedOn)
+						SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 					
+					if(!pLed->bLedOn)
+						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+					
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 CurrLedState %d\n", pLed->CurrLedState));
+
+
+}
+
+void
+SwLedBlink6(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 			bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}	
+
+	switch(pLed->CurrLedState)
+	{			
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON;
+				
+					if( !pLed->bLedOn )
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			//if( priv->rtllib->eRFPowerState != eRfOn )
+			if(0)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else
+			{
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;			
+					
+		default:
+			break;
+	}
+
+}
+
+
+#ifdef PLATFORM_WINDOWS
+//
+//	Description:
+//		Callback function of LED BlinkTimer, 
+//		it just schedules to corresponding BlinkWorkItem.
+//
+void BlinkTimerCallback (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	)
+{
+	PLED_871x	 pLed = (PLED_871x)FunctionContext;
+
+	_set_workitem(&(pLed->BlinkWorkItem));
+}
+
+
+//
+//	Description:
+//		Callback function of LED BlinkTimer, 
+//		it just schedules to corresponding BlinkWorkItem.
+//
+void BlinkWorkItemCallback(
+	IN NDIS_WORK_ITEM*	pWorkItem,
+	IN PVOID			Context
+	)
+{
+	PLED_871x	 pLed = (PLED_871x)Context;
+	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
+
+	switch(ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			SwLedBlink(pLed);
+			break;
+		
+		case SW_LED_MODE1:
+			SwLedBlink1(pLed);
+			break;
+		
+		case SW_LED_MODE2:
+			SwLedBlink2(pLed);
+			break;
+			
+		case SW_LED_MODE3:
+			SwLedBlink3(pLed);
+			break;
+
+		case SW_LED_MODE4:
+			SwLedBlink4(pLed);
+			break;			
+
+		case SW_LED_MODE5:
+			SwLedBlink5(pLed);
+			break;
+
+		case SW_LED_MODE6:
+			SwLedBlink6(pLed);
+			break;
+
+		default:
+			SwLedBlink(pLed);
+			break;
+	}	
+}
+#endif
+
+#ifdef PLATFORM_LINUX
+//
+//	Description:
+//		Callback function of LED BlinkTimer, 
+//		it just schedules to corresponding BlinkWorkItem.
+//
+void
+BlinkTimerCallback(
+	unsigned long data
+	)
+{
+	PLED_871x	 pLed = (PLED_871x)data;
+
+	//	Added by Albert 2010/04/20
+	//	This will fixed the crash problem on Fedora 12 when trying to do the insmod;ifconfig up;rmmod commands.
+	if ( ( pLed->padapter->bSurpriseRemoved == _TRUE ) || ( pLed->padapter->bDriverStopped == _TRUE ) )
+	{
+		return;
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+	_set_workitem(&(pLed->BlinkWorkItem));
+#endif
+}
+
+
+//
+//	Description:
+//		Callback function of LED BlinkWorkItem.
+//		We dispatch acture LED blink action according to LedStrategy.
+//
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
+void BlinkWorkItemCallback(struct work_struct *work)
+{
+	PLED_871x	 pLed = container_of(work, LED_871x, BlinkWorkItem);
+	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
+
+	switch(ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			SwLedBlink(pLed);
+			break;
+		
+		case SW_LED_MODE1:
+			SwLedBlink1(pLed);
+			break;
+		
+		case SW_LED_MODE2:
+			SwLedBlink2(pLed);
+			break;
+			
+		case SW_LED_MODE3:
+			SwLedBlink3(pLed);
+			break;
+
+		case SW_LED_MODE4:
+			SwLedBlink4(pLed);
+			break;			
+
+		case SW_LED_MODE5:
+			SwLedBlink5(pLed);
+			break;
+
+		case SW_LED_MODE6:
+			SwLedBlink6(pLed);
+			break;
+
+		default:
+			SwLedBlink(pLed);
+			break;
+	}
+}
+#endif
+#endif
+
+
+//================================================================================
+// Default LED behavior.
+//================================================================================
+
+//
+//	Description:	
+//		Implement each led action for SW_LED_MODE0.
+//		This is default strategy.
+//
+void
+SwLedControlMode0(
+	_adapter		*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	PLED_871x	pLed = &(ledpriv->SwLed1);
+
+	// Decide led state
+	switch(LedAction)
+	{
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			pLed->bLedBlinkInProgress = _TRUE;
+
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			pLed->BlinkTimes = 2;
+
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+
+	case LED_CTL_START_TO_LINK:
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			pLed->bLedBlinkInProgress = _TRUE;
+
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+			pLed->BlinkTimes = 24;
+
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+		}
+		else
+		{
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+		}	
+		break;
+		
+	case LED_CTL_LINK:
+		pLed->CurrLedState = LED_ON;
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			SwLedOn(padapter, pLed);
+		}
+		break;
+
+	case LED_CTL_NO_LINK:
+		pLed->CurrLedState = LED_OFF;
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			SwLedOff(padapter, pLed);
+		}
+		break;
+	
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		if(pLed->bLedBlinkInProgress)
+		{
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = _FALSE;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+
+	case LED_CTL_START_WPS:
+		if( pLed->bLedBlinkInProgress == _FALSE || pLed->CurrLedState == LED_ON)
+		{
+			pLed->bLedBlinkInProgress = _TRUE;
+
+			pLed->CurrLedState = LED_BLINK_WPS;
+			pLed->BlinkTimes = 20;
+
+			if( pLed->bLedOn )
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+		}
+		break;
+
+	case LED_CTL_STOP_WPS:
+		if(pLed->bLedBlinkInProgress)
+		{
+			pLed->CurrLedState = LED_OFF;
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = _FALSE;
+		}
+		break;
+		
+
+	default:
+		break;
+	}
+	
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+	
+}
+
+ //ALPHA, added by chiyoko, 20090106
+void
+SwLedControlMode1(
+	_adapter		*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv		*ledpriv = &(padapter->ledpriv);
+	PLED_871x			pLed = &(ledpriv->SwLed0);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	struct sitesurvey_ctrl	*psitesurveyctrl = &(pmlmepriv->sitesurveyctrl);
+
+	if(padapter->eeprompriv.CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_START_TO_LINK:	
+		case LED_CTL_NO_LINK:
+			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedLinkBlinkInProgress = _FALSE;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{	
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+				
+				pLed->bLedNoLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			break;		
+
+		case LED_CTL_LINK:
+			if( pLed->bLedLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{	
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+				pLed->bLedLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			 if((psitesurveyctrl->traffic_busy) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			 	;		 
+			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			 {
+			 	if(IS_LED_WPS_BLINKING(pLed))
+					return;
+				
+	  			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					 pLed->bLedLinkBlinkInProgress = _FALSE;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+                            if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+                            {
+								// Marked by Albert 2010/04/07
+                                return; //FIXLZM
+                            }
+                            if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+                            {
+                                _cancel_timer_ex(&(pLed->BlinkTimer));
+                                pLed->bLedNoLinkBlinkInProgress = _FALSE;
+                            }
+                            if( pLed->bLedLinkBlinkInProgress == _TRUE )
+                            {
+                                _cancel_timer_ex(&(pLed->BlinkTimer));
+                                pLed->bLedLinkBlinkInProgress = _FALSE;
+                            }
+                            pLed->bLedBlinkInProgress = _TRUE;
+                            pLed->CurrLedState = LED_TXRX_BLINK;
+                            pLed->BlinkTimes = 2;
+                            if( pLed->bLedOn )
+                                pLed->BlinkingLedState = LED_OFF; 
+                            else
+                                pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:
+			 if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			 {
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					 pLed->bLedLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+
+		
+		case LED_CTL_STOP_WPS:
+			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedLinkBlinkInProgress == _TRUE )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = _FALSE;
+			}
+			if(pLed->bLedBlinkInProgress ==_TRUE)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if(pLed->bLedScanBlinkInProgress ==_TRUE)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+			}
+			else
+			{
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+			}
+			
+			pLed->CurrLedState = LED_BLINK_WPS_STOP;
+			if(pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}					
+			break;		
+
+		case LED_CTL_STOP_WPS_FAIL:			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
+
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;				
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+			if( pLed->bLedNoLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			//SwLedOff(padapter, pLed);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+ //Arcadyan/Sitecom , added by chiyoko, 20090216
+void
+SwLedControlMode2(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	 *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x 		pLed = &(ledpriv->SwLed0);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_SITE_SURVEY:
+			 if(pmlmepriv->sitesurveyctrl.traffic_busy)
+			 	;		 
+			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			 {
+			 	if(IS_LED_WPS_BLINKING(pLed))
+					return;
+			 
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;			
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:		
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			 }			
+			break;
+			
+		case LED_CTL_STOP_WPS:
+			pLed->bLedWPSBlinkInProgress = _FALSE;			
+			//if( priv->rtllib->eRFPowerState != eRfOn )
+			if(0)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else
+			{
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+			}
+			break;
+			
+		case LED_CTL_STOP_WPS_FAIL:			
+			pLed->bLedWPSBlinkInProgress = _FALSE;			
+			//if( priv->rtllib->eRFPowerState != eRfOn )
+			if(0)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else 
+			{
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState)); 				
+			}	
+			break;				
+
+		case LED_CTL_START_TO_LINK: 
+		case LED_CTL_NO_LINK:
+			if(!IS_LED_BLINKING(pLed))
+			{
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+			
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+}
+
+  //COREGA, added by chiyoko, 20090316
+ void
+ SwLedControlMode3(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x		pLed = &(ledpriv->SwLed0);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_SITE_SURVEY:
+			if(pmlmepriv->sitesurveyctrl.traffic_busy)
+				;		 
+			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			{
+				if(IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			if(IS_LED_WPS_BLINKING(pLed))
+				return;
+			
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;			
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:		
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}			
+			break;
+			
+		case LED_CTL_STOP_WPS:			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}						
+			else
+			{
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+			}
+				
+			pLed->CurrLedState = LED_BLINK_WPS_STOP;
+			if(pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}					
+
+			break;
+			
+		case LED_CTL_STOP_WPS_FAIL:			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
+
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;				
+
+		case LED_CTL_START_TO_LINK: 
+		case LED_CTL_NO_LINK:
+			if(!IS_LED_BLINKING(pLed))
+			{
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+			
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+}
+
+
+ //Edimax-Belkin, added by chiyoko, 20090413
+void
+SwLedControlMode4(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x		pLed = &(ledpriv->SwLed0);
+	PLED_871x		pLed1 = &(ledpriv->SwLed1);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_START_TO_LINK:	
+			if(pLed1->bLedWPSBlinkInProgress)
+			{
+				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+		
+				pLed1->BlinkingLedState = LED_OFF;
+				pLed1->CurrLedState = LED_OFF;
+
+				if(pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+				
+			if( pLed->bLedStartToLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+	 			if(pLed->bLedNoLinkBlinkInProgress ==_TRUE)
+				{	
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+	 			}				
+				
+				pLed->bLedStartToLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_StartToBlink;
+				if( pLed->bLedOn )
+				{
+					pLed->BlinkingLedState = LED_OFF;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				}
+				else
+				{
+					pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				}
+			}
+			break;		
+
+		case LED_CTL_LINK:			
+		case LED_CTL_NO_LINK:
+			//LED1 settings
+			if(LedAction == LED_CTL_LINK)
+			{
+				if(pLed1->bLedWPSBlinkInProgress)
+				{
+					pLed1->bLedWPSBlinkInProgress = _FALSE;
+					_cancel_timer_ex(&(pLed1->BlinkTimer));
+			
+					pLed1->BlinkingLedState = LED_OFF;
+					pLed1->CurrLedState = LED_OFF;
+
+					if(pLed1->bLedOn)
+						_set_timer(&(pLed->BlinkTimer), 0);
+				}				
+			}
+			
+			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+				
+				pLed->bLedNoLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			break;		
+
+		case LED_CTL_SITE_SURVEY:
+			if((pmlmepriv->sitesurveyctrl.traffic_busy) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+				;		 
+			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			{
+				if(IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+	  		  	if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:
+			if(pLed1->bLedWPSBlinkInProgress)
+			{
+				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			
+				pLed1->BlinkingLedState = LED_OFF;
+				pLed1->CurrLedState = LED_OFF;
+
+				if(pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+				
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+				{
+					pLed->BlinkingLedState = LED_OFF;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				}
+				else
+				{
+					pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				}
+			}
+			break;
+		
+		case LED_CTL_STOP_WPS:	//WPS connect success		
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;								
+			}
+
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			break;		
+
+		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
+
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			//LED1 settings
+			if(pLed1->bLedWPSBlinkInProgress)
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			else	
+				pLed1->bLedWPSBlinkInProgress = _TRUE;				
+
+			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
+			if( pLed1->bLedOn )
+				pLed1->BlinkingLedState = LED_OFF; 
+			else
+				pLed1->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+
+			break;				
+
+		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap		
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;								
+			}
+			
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			//LED1 settings
+			if(pLed1->bLedWPSBlinkInProgress)
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			else	
+				pLed1->bLedWPSBlinkInProgress = _TRUE;				
+
+			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
+			pLed1->BlinkTimes = 10;
+			if( pLed1->bLedOn )
+				pLed1->BlinkingLedState = LED_OFF; 
+			else
+				pLed1->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+			
+			if( pLed->bLedNoLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}	
+			if( pLed->bLedStartToLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedStartToLinkBlinkInProgress = _FALSE;
+			}			
+
+			if( pLed1->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pLed1->bLedWPSBlinkInProgress = _FALSE;
+			}
+
+			pLed1->BlinkingLedState = LED_UNKNOWN;				
+			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pLed1);			
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+
+
+ //Sercomm-Belkin, added by chiyoko, 20090415
+void
+SwLedControlMode5(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x		pLed = &(ledpriv->SwLed0);
+
+	if(padapter->eeprompriv.CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_POWER_ON:
+		case LED_CTL_NO_LINK:
+		case LED_CTL_LINK: 	//solid blue
+			if(pLed->CurrLedState == LED_SCAN_BLINK)
+			{
+				return;
+			}		
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON; 
+			pLed->bLedBlinkInProgress = _FALSE;
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			if((pmlmepriv->sitesurveyctrl.traffic_busy) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+				;		 
+			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			{				
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK)
+				{
+					return;
+				}			
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;				
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}			
+				
+			SwLedOff(padapter, pLed);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+ //WNC-Corega, added by chiyoko, 20090902
+void
+SwLedControlMode6(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x pLed = &(ledpriv->SwLed0);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_POWER_ON:
+		case LED_CTL_NO_LINK:
+		case LED_CTL_LINK: 	//solid blue
+		case LED_CTL_SITE_SURVEY:	
+  		  	if(IS_LED_WPS_BLINKING(pLed))
+			{
+				return;
+			}			
+			
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			pLed->bLedBlinkInProgress = _FALSE;
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{			
+	  		  	if(IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+			
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;	
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:		
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+			
+		case LED_CTL_STOP_WPS_FAIL:	
+		case LED_CTL_STOP_WPS:						
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}			
+
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;							
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}				
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}			
+				
+			SwLedOff(padapter, pLed);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("ledcontrol 6 Led %d\n", pLed->CurrLedState));
+}
+
+
+//
+//	Description:	
+//		Dispatch LED action according to pHalData->LedStrategy. 
+//
+void
+LedControl871x(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+	)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	if( ledpriv->bRegUseLed == _FALSE)
+		return;
+
+	//if (!priv->up)
+	//	return;
+
+	//if(priv->bInHctTest)
+	//	return;
+	
+	/*if(	priv->rtllib->eRFPowerState != eRfOn && 
+		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX || 
+		 LedAction == LED_CTL_SITE_SURVEY || 
+		 LedAction == LED_CTL_LINK || 
+		 LedAction == LED_CTL_NO_LINK ||
+		 LedAction == LED_CTL_POWER_ON) )*/
+	if(0)
+	{
+		return;
+	}
+	
+	switch(ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			//SwLedControlMode0(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE1:
+			SwLedControlMode1(padapter, LedAction);
+			break;
+		case SW_LED_MODE2:
+			SwLedControlMode2(padapter, LedAction);
+                	break;
+
+		case SW_LED_MODE3:
+			SwLedControlMode3(padapter, LedAction);
+			break;	
+
+		case SW_LED_MODE4:
+			SwLedControlMode4(padapter, LedAction);
+			break;			
+
+		case SW_LED_MODE5:
+			SwLedControlMode5(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE6:
+			SwLedControlMode6(padapter, LedAction);
+			break;
+
+		default:
+			break;
+	}
+	
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("LedStrategy:%d, LedAction %d\n", ledpriv->LedStrategy,LedAction));
+}
+
+
diff --git a/drivers/net/wireless/8712u/mlme/ieee80211.c b/drivers/net/wireless/8712u/mlme/ieee80211.c
new file mode 100755
index 0000000..aed02ff
--- /dev/null
+++ b/drivers/net/wireless/8712u/mlme/ieee80211.c
@@ -0,0 +1,643 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _IEEE80211_C
+
+#include <drv_types.h>
+#include <ieee80211.h>
+#include <wifi.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+
+
+//-----------------------------------------------------------
+// for adhoc-master to generate ie and provide supported-rate to fw 
+//-----------------------------------------------------------
+
+u8 	WIFI_CCKRATES[] = 
+{(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)};
+
+u8 	WIFI_OFDMRATES[] = 
+{(IEEE80211_OFDM_RATE_6MB),
+ (IEEE80211_OFDM_RATE_9MB),
+ (IEEE80211_OFDM_RATE_12MB),
+ (IEEE80211_OFDM_RATE_18MB),
+ (IEEE80211_OFDM_RATE_24MB),
+ IEEE80211_OFDM_RATE_36MB,
+ IEEE80211_OFDM_RATE_48MB,
+ IEEE80211_OFDM_RATE_54MB};
+
+
+int get_bit_value_from_ieee_value(u8 val)
+{
+	unsigned char dot11_rate_table[]={2,4,11,22,12,18,24,36,48,72,96,108,0}; // last element must be zero!!
+
+	int i=0;
+	while(dot11_rate_table[i] != 0) {
+		if (dot11_rate_table[i] == val)
+			return BIT(i);
+		i++;
+	}
+	return 0;
+}
+
+uint	is_cckrates_included(u8 *rate)
+{	
+		u32	i = 0;			
+
+		while(rate[i]!=0)
+		{		
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||		
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )		
+			return _TRUE;	
+			i++;
+		}
+		
+		return _FALSE;
+}
+
+uint	is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+
+	while(rate[i]!=0)
+	{
+			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+
+			return _FALSE;		
+
+			i++;
+	}
+	
+	return _TRUE;
+
+}
+
+int check_network_type(unsigned char *rate, int ratelen, int channel)
+{
+	if (channel > 14)
+	{
+		if ((is_cckrates_included(rate)) == _TRUE)
+			return WIRELESS_INVALID;
+		else
+			return WIRELESS_11A;
+	}	
+	else  // could be pure B, pure G, or B/G
+	{
+		if ((is_cckratesonly_included(rate)) == _TRUE)	
+			return WIRELESS_11B;
+		else if((is_cckrates_included(rate)) == _TRUE)
+			return 	WIRELESS_11BG;
+		else
+			return WIRELESS_11G;
+	}
+	
+}
+
+u8 *set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source,
+				unsigned int *frlen)
+{
+	_memcpy((void *)pbuf, (void *)source, len);
+	*frlen = *frlen + len;
+	return (pbuf + len);
+}
+
+// set_ie will update frame length
+u8 *set_ie
+(
+	u8 *pbuf, 
+	sint index, 
+	uint len,
+	u8 *source, 
+	uint *frlen //frame length
+)
+{
+_func_enter_;
+	*pbuf = (u8)index;
+
+	*(pbuf + 1) = (u8)len;
+
+	if (len > 0)
+		_memcpy((void *)(pbuf + 2), (void *)source, len);
+	
+	*frlen = *frlen + (len + 2);
+	
+	return (pbuf + len + 2);
+_func_exit_;	
+}
+
+
+
+/*----------------------------------------------------------------------------
+index: the information element id index, limit is the limit for search
+-----------------------------------------------------------------------------*/
+u8 *get_ie(u8 *pbuf, sint index, sint *len, sint limit)
+{
+	sint tmp,i;
+	u8 *p;
+_func_enter_;
+	if (limit < 1){
+		_func_exit_;	
+		return NULL;
+	}
+
+	p = pbuf;
+	i = 0;
+	*len = 0;
+	while(1)
+	{
+		if (*p == index)
+		{
+			*len = *(p + 1);
+			return (p);
+		}
+		else
+		{
+			tmp = *(p + 1);
+			p += (tmp + 2);
+			i += (tmp + 2);
+		}
+		if (i >= limit)
+			break;
+	}
+_func_exit_;		
+	return NULL;
+}
+
+void set_supported_rate(u8* SupportedRates, uint mode) 
+{
+_func_enter_;
+
+	_memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+	
+	switch (mode)
+	{
+		case WIRELESS_11B:
+			_memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+			break;
+		
+		case WIRELESS_11G:
+		case WIRELESS_11A:	
+			_memcpy(SupportedRates, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+			break;
+		
+		case WIRELESS_11BG:
+			_memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+			_memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+			break;
+	
+	}
+_func_exit_;	
+}
+
+uint	get_rateset_len(u8	*rateset)
+{
+	uint i = 0;
+_func_enter_;	
+	while(1)
+	{
+		if ((rateset[i]) == 0)
+			break;
+			
+		if (i > 12)
+			break;
+			
+		i++;			
+	}
+_func_exit_;		
+	return i;
+}
+
+int generate_ie(struct registry_priv *pregistrypriv)
+{
+	int 	sz = 0, rateLen;
+	WLAN_BSSID_EX*	pdev_network = &pregistrypriv->dev_network;
+	u8*	ie = pdev_network->IEs;
+	
+_func_enter_;		
+
+	//timestamp will be inserted by hardware
+	sz += 8;	
+	ie += sz;
+	
+	//beacon interval : 2bytes
+	*(u16*)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);//BCN_INTERVAL;
+	sz += 2; 
+	ie += 2;
+	
+	//capability info
+	*(u16*)ie = 0;
+	
+	*(u16*)ie |= cpu_to_le16(cap_IBSS);
+
+	if(pregistrypriv->preamble == PREAMBLE_SHORT)
+		*(u16*)ie |= cpu_to_le16(cap_ShortPremble);
+	
+	if (pdev_network->Privacy)
+		*(u16*)ie |= cpu_to_le16(cap_Privacy);
+	
+	sz += 2;
+	ie += 2;
+	
+	//SSID
+	ie = set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength, pdev_network->Ssid.Ssid, &sz);
+	
+	//supported rates
+	set_supported_rate(pdev_network->SupportedRates, pregistrypriv->wireless_mode) ;
+	
+	rateLen = get_rateset_len(pdev_network->SupportedRates);
+
+	if (rateLen > 8)
+	{
+		ie = set_ie(ie, _SUPPORTEDRATES_IE_, 8, pdev_network->SupportedRates, &sz);
+		ie = set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);
+	}
+	else
+	{
+		ie = set_ie(ie, _SUPPORTEDRATES_IE_, rateLen, pdev_network->SupportedRates, &sz);
+	}
+
+	//DS parameter set
+	ie = set_ie(ie, _DSSET_IE_, 1, (u8 *)&(pdev_network->Configuration.DSConfig), &sz);
+
+
+	//IBSS Parameter Set
+	
+	ie = set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
+
+	//pdev_network->IELength =  sz; //update IELength
+
+_func_exit_;		
+
+	//return _SUCCESS;
+	return sz;
+	
+}
+
+unsigned char *get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
+{	
+	int len;
+	u16 val16;
+	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};		
+	u8 *pbuf = pie;
+
+	while(1) 
+	{
+		pbuf = get_ie(pbuf, _WPA_IE_ID_, &len, limit);
+
+		if (pbuf) {
+
+			//check if oui matches...
+			if (_memcmp((pbuf + 2), wpa_oui_type, sizeof (wpa_oui_type)) == _FALSE) {
+
+				goto check_next_ie;
+			}
+
+			//check version...
+			_memcpy((u8 *)&val16, (pbuf + 6), sizeof(val16));
+
+			val16 = le16_to_cpu(val16);
+			if (val16 != 0x0001)
+				goto check_next_ie;	
+
+			*wpa_ie_len = *(pbuf + 1);
+
+			return pbuf;
+
+		}
+		else {
+
+			*wpa_ie_len = 0;			
+			return NULL;
+		}
+
+check_next_ie:
+
+		limit = limit - (pbuf - pie) - 2 - len;
+
+		if (limit <= 0)
+			break;
+
+		pbuf += (2 + len);
+		
+	}
+	
+	*wpa_ie_len = 0;
+	
+	return NULL;
+
+}
+
+unsigned char *get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
+{	
+
+	return get_ie(pie, _WPA2_IE_ID_,rsn_ie_len, limit);
+
+}
+
+int get_wpa_cipher_suite(u8 *s)
+{
+	if (_memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_NONE;
+	if (_memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP40;
+	if (_memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_TKIP;
+	if (_memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_CCMP;
+	if (_memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+int get_wpa2_cipher_suite(u8 *s)
+{
+	if (_memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_NONE;
+	if (_memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP40;
+	if (_memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_TKIP;
+	if (_memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_CCMP;
+	if (_memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+
+int parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher)
+{
+	int i, ret=_SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (wpa_ie_len <= 0) {
+		/* No WPA IE - fail silently */
+		return _FAIL;
+	}
+
+	
+	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
+	   (_memcmp(wpa_ie+2, WPA_OUI_TYPE, WPA_SELECTOR_LEN) != _TRUE) )
+	{		
+		return _FAIL;
+	}
+
+	pos = wpa_ie;
+
+	pos += 8;
+	left = wpa_ie_len - 8;	
+
+
+	//group_cipher
+	if (left >= WPA_SELECTOR_LEN) {
+
+		*group_cipher = get_wpa_cipher_suite(pos);
+		
+		pos += WPA_SELECTOR_LEN;
+		left -= WPA_SELECTOR_LEN;
+		
+	} 
+	else if (left > 0)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie length mismatch, %u too much", __FUNCTION__, left));
+		
+		return _FAIL;
+	}
+
+
+	//pairwise_cipher
+	if (left >= 2)
+	{		
+		count = le16_to_cpu(*(u16*)pos);//			
+		pos += 2;
+		left -= 2;
+		
+		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie count botch (pairwise), "
+				   		"count %u left %u", __FUNCTION__, count, left));
+			return _FAIL;
+		}
+		
+		for (i = 0; i < count; i++)
+		{
+			*pairwise_cipher |= get_wpa_cipher_suite(pos);
+			
+			pos += WPA_SELECTOR_LEN;
+			left -= WPA_SELECTOR_LEN;
+		}
+		
+	} 
+	else if (left == 1)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie too short (for key mgmt)",   __FUNCTION__));
+		return _FAIL;
+	}
+
+	
+	return ret;
+	
+}
+
+int parse_wpa2_ie(u8* rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher)
+{
+	int i, ret=_SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (rsn_ie_len <= 0) {
+		/* No RSN IE - fail silently */
+		return _FAIL;
+	}
+
+
+	if ((*rsn_ie!= _WPA2_IE_ID_) || (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
+	{		
+		return _FAIL;
+	}
+	
+	pos = rsn_ie;
+	pos += 4;
+	left = rsn_ie_len - 4;	
+
+	//group_cipher
+	if (left >= RSN_SELECTOR_LEN) {
+
+		*group_cipher = get_wpa2_cipher_suite(pos);
+		
+		pos += RSN_SELECTOR_LEN;
+		left -= RSN_SELECTOR_LEN;
+		
+	} else if (left > 0) {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie length mismatch, %u too much", __FUNCTION__, left));
+		return _FAIL;
+	}
+
+	//pairwise_cipher
+	if (left >= 2)
+	{		
+		count = le16_to_cpu(*(u16*)pos);//			
+		pos += 2;
+		left -= 2;
+
+		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie count botch (pairwise), "
+				  		 "count %u left %u", __FUNCTION__, count, left));
+			return _FAIL;
+		}
+		
+		for (i = 0; i < count; i++)
+		{			
+			*pairwise_cipher |= get_wpa2_cipher_suite(pos);
+			
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+
+	} 
+	else if (left == 1)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie too short (for key mgmt)",  __FUNCTION__));
+		
+		return _FAIL;
+	}
+
+
+	return ret;
+	
+}
+
+int get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len)
+{
+	u8 authmode, sec_idx, i;
+	u8 wpa_oui[4]={0x0,0x50,0xf2,0x01};
+	uint 	cnt;
+	
+_func_enter_;
+
+	//Search required WPA or WPA2 IE and copy to sec_ie[ ]
+	
+	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
+	
+	sec_idx=0;
+		
+	while(cnt<in_len)
+	{
+		authmode=in_ie[cnt];
+		
+		if((authmode==_WPA_IE_ID_)&&(_memcmp(&in_ie[cnt+2], &wpa_oui[0],4)==_TRUE))
+		{	
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n get_wpa_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));		
+
+				_memcpy(wpa_ie, &in_ie[cnt],in_ie[cnt+1]+2);
+
+				for(i=0;i<(in_ie[cnt+1]+2);i=i+8){
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",wpa_ie[i],wpa_ie[i+1],wpa_ie[i+2],wpa_ie[i+3],wpa_ie[i+4],wpa_ie[i+5],wpa_ie[i+6],wpa_ie[i+7]));
+				}
+
+				*wpa_len=in_ie[cnt+1]+2;
+				cnt+=in_ie[cnt+1]+2;  //get next
+		}
+		else
+		{
+			if(authmode==_WPA2_IE_ID_)
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n get_rsn_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));		
+
+				_memcpy(rsn_ie, &in_ie[cnt],in_ie[cnt+1]+2);
+
+				for(i=0;i<(in_ie[cnt+1]+2);i=i+8){
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",rsn_ie[i],rsn_ie[i+1],rsn_ie[i+2],rsn_ie[i+3],rsn_ie[i+4],rsn_ie[i+5],rsn_ie[i+6],rsn_ie[i+7]));
+				}
+
+				*rsn_len=in_ie[cnt+1]+2;
+				cnt+=in_ie[cnt+1]+2;  //get next
+			}
+			else
+			{
+				cnt+=in_ie[cnt+1]+2;   //get next
+			}	
+		}
+		
+	}
+	
+_func_exit_;
+
+	return (*rsn_len+*wpa_len);
+	
+}
+
+/**
+ * rtw_get_wps_ie - Search WPS IE from a series of IEs
+ * @in_ie: Address of IEs to search
+ * @in_len: Length limit from in_ie
+ * @wps_ie: If not NULL and WPS IE is found, WPS IE will be copied to the buf starting from wps_ie
+ * @wps_ielen: If not NULL and WPS IE is found, will set to the length of the entire WPS IE
+ *
+ * Returns: The address of the WPS IE found, or NULL
+ */
+u8 *get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
+{
+	uint cnt;
+	u8 *wpsie_ptr=NULL;
+	u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+
+	if(wps_ielen)
+		*wps_ielen = 0;
+
+	if(!in_ie || in_len<=0)
+		return wpsie_ptr;
+
+	cnt = 0;
+
+	while(cnt<in_len)
+	{
+		eid = in_ie[cnt];
+
+		if((eid==_WPA_IE_ID_)&&(_memcmp(&in_ie[cnt+2], wps_oui, 4)==_TRUE))
+		{
+			wpsie_ptr = &in_ie[cnt];
+
+			if(wps_ie)
+				_memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+			
+			if(wps_ielen)
+				*wps_ielen = in_ie[cnt+1]+2;
+			
+			cnt+=in_ie[cnt+1]+2;
+
+			break;
+		}
+		else
+		{
+			cnt+=in_ie[cnt+1]+2; //goto next	
+		}		
+
+	}	
+
+	return wpsie_ptr;
+}
diff --git a/drivers/net/wireless/8712u/mlme/rtl871x_mlme.c b/drivers/net/wireless/8712u/mlme/rtl871x_mlme.c
new file mode 100755
index 0000000..8101546
--- /dev/null
+++ b/drivers/net/wireless/8712u/mlme/rtl871x_mlme.c
@@ -0,0 +1,3201 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_MLME_C_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <hal_init.h>
+#include <mlme_osdep.h>
+#include <sta_info.h>
+#include <wifi.h>
+#include <wlan_bssdef.h>
+
+
+extern void indicate_wx_scan_complete_event(_adapter *padapter);
+
+sint _init_mlme_priv(_adapter* padapter)
+{
+	sint	i;
+	u8	*pbuf;
+	struct wlan_network	*pnetwork;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	sint	res=_SUCCESS;
+
+_func_enter_;
+
+	_memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));
+	pmlmepriv->nic_hdl = (u8 *)padapter;
+
+	pmlmepriv->pscanned = NULL;
+	pmlmepriv->fw_state = 0;
+	pmlmepriv->cur_network.network.InfrastructureMode = Ndis802_11AutoUnknown;
+	pmlmepriv->passive_mode=1; // 1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff)
+
+	_spinlock_init(&(pmlmepriv->lock));
+	_init_queue(&(pmlmepriv->free_bss_pool));
+	_init_queue(&(pmlmepriv->scanned_queue));
+
+	set_scanned_network_val(pmlmepriv, 0);
+
+	_memset(&pmlmepriv->assoc_ssid,0,sizeof(NDIS_802_11_SSID));
+
+	pbuf = _vmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+
+	if (pbuf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	pmlmepriv->free_bss_buf = pbuf;
+
+	pnetwork = (struct wlan_network *)pbuf;
+
+	for (i = 0; i < MAX_BSS_CNT; i++)
+	{
+		_init_listhead(&(pnetwork->list));
+
+		list_insert_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.queue));
+
+		pnetwork++;
+	}
+
+	pmlmepriv->sitesurveyctrl.last_rx_pkts = 0;
+	pmlmepriv->sitesurveyctrl.last_tx_pkts = 0;
+	pmlmepriv->sitesurveyctrl.traffic_busy = _FALSE;
+
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+
+	init_mlme_timer(padapter);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+void mfree_mlme_priv_lock (struct mlme_priv *pmlmepriv)
+{
+	_spinlock_free(&pmlmepriv->lock);
+	_spinlock_free(&(pmlmepriv->free_bss_pool.lock));
+	_spinlock_free(&(pmlmepriv->scanned_queue.lock));
+}
+
+void _free_mlme_priv (struct mlme_priv *pmlmepriv)
+{
+_func_enter_;
+
+	if (pmlmepriv) {
+		mfree_mlme_priv_lock (pmlmepriv);
+
+		if (pmlmepriv->free_bss_buf)
+			_vmfree(pmlmepriv->free_bss_buf, MAX_BSS_CNT * sizeof(struct wlan_network));
+	}
+_func_exit_;
+}
+
+sint _enqueue_network(_queue *queue, struct wlan_network *pnetwork)
+{
+	_irqL irqL;
+
+_func_enter_;
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	_enter_critical(&queue->lock, &irqL);
+
+	list_insert_tail(&pnetwork->list, &queue->queue);
+
+	_exit_critical(&queue->lock, &irqL);
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+struct wlan_network* _dequeue_network(_queue *queue)
+{
+	_irqL irqL;
+
+	struct wlan_network *pnetwork;
+
+_func_enter_;
+
+	_enter_critical(&queue->lock, &irqL);
+
+	if (_queue_empty(queue) == _TRUE)
+
+		pnetwork = NULL;
+
+	else
+	{
+		pnetwork = LIST_CONTAINOR(get_next(&queue->queue), struct wlan_network, list);
+
+		list_delete(&(pnetwork->list));
+	}
+
+	_exit_critical(&queue->lock, &irqL);
+
+_func_exit_;
+
+	return pnetwork;
+}
+
+struct wlan_network* _alloc_network(struct mlme_priv *pmlmepriv)//(_queue *free_queue)
+{
+	_irqL irqL;
+	struct wlan_network *pnetwork;
+	_queue *free_queue = &pmlmepriv->free_bss_pool;
+	_list *plist = NULL;
+
+_func_enter_;
+
+	_enter_critical(&free_queue->lock, &irqL);
+
+	if (_queue_empty(free_queue) == _TRUE) {
+		pnetwork = NULL;
+		goto exit;
+	}
+	plist = get_next(&(free_queue->queue));
+
+	pnetwork = LIST_CONTAINOR(plist , struct wlan_network, list);
+
+	list_delete(&pnetwork->list);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("_alloc_network: ptr=%p\n", plist));
+
+	pnetwork->last_scanned = get_current_time();
+	pmlmepriv->num_of_scanned++;
+
+	_exit_critical(&free_queue->lock, &irqL);
+exit:
+
+_func_exit_;
+
+	return pnetwork;
+}
+
+void _free_network(struct mlme_priv *pmlmepriv ,struct wlan_network *pnetwork)
+{
+	u32 curr_time, delta_time;
+	_irqL irqL;
+	_queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+_func_enter_;
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	if (pnetwork->fixed == _TRUE)
+		goto exit;
+
+	curr_time = get_current_time();
+
+#ifdef PLATFORM_WINDOWS
+
+	delta_time = (curr_time - pnetwork->last_scanned) / 10;
+
+	if (delta_time  < SCANQUEUE_LIFETIME*1000000)// unit:usec
+	{
+		goto exit;
+	}
+
+#endif
+
+#ifdef PLATFORM_LINUX
+
+	delta_time = (curr_time - pnetwork->last_scanned) / HZ;
+
+	if (delta_time < SCANQUEUE_LIFETIME)// unit:sec
+	{
+		goto exit;
+	}
+
+#endif
+
+	_enter_critical(&free_queue->lock, &irqL);
+
+	list_delete(&pnetwork->list);
+
+	list_insert_tail(&pnetwork->list, &free_queue->queue);
+
+	pmlmepriv->num_of_scanned--;
+
+	//DBG_8712("_free_network:SSID=%s\n", pnetwork->network.Ssid.Ssid);
+
+	_exit_critical(&free_queue->lock, &irqL);
+
+exit:
+
+_func_exit_;
+
+}
+
+void _free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork)
+{
+	_queue *free_queue = &pmlmepriv->free_bss_pool;
+
+_func_enter_;
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	if (pnetwork->fixed == _TRUE)
+		goto exit;
+
+	//_enter_critical(&free_queue->lock, &irqL);
+
+	list_delete(&pnetwork->list);
+
+	list_insert_tail(&pnetwork->list, get_list_head(free_queue));
+
+	pmlmepriv->num_of_scanned--;
+
+	//_exit_critical(&free_queue->lock, &irqL);
+
+exit:
+
+_func_exit_;
+
+}
+
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context... to avoid possible racing condition...
+*/
+struct wlan_network* _find_network(_queue *scanned_queue, u8 *addr)
+{
+	_irqL irqL;
+	_list *phead, *plist;
+	struct wlan_network *pnetwork = NULL;
+	u8 zero_addr[ETH_ALEN] = {0,0,0,0,0,0};
+
+_func_enter_;
+
+	if (_memcmp(zero_addr, addr, ETH_ALEN)) {
+		pnetwork = NULL;
+		goto exit;
+	}
+
+	_enter_critical(&scanned_queue->lock, &irqL);
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (plist != phead)
+	{
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		plist = get_next(plist);
+		if (_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)
+			break;
+	}
+
+	_exit_critical(&scanned_queue->lock, &irqL);
+
+exit:
+
+_func_exit_;
+
+	return pnetwork;
+
+}
+
+void _free_network_queue(_adapter *padapter)
+{
+	_irqL irqL;
+	_list *phead, *plist;
+	struct wlan_network *pnetwork;
+	struct mlme_priv* pmlmepriv = &padapter->mlmepriv;
+	_queue *scanned_queue = &pmlmepriv->scanned_queue;
+	_queue	*free_queue = &pmlmepriv->free_bss_pool;
+	u8 *mybssid = get_bssid(pmlmepriv);
+
+_func_enter_;
+
+	_enter_critical(&scanned_queue->lock, &irqL);
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (end_of_queue_search(phead, plist) == _FALSE)
+	{
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		plist = get_next(plist);
+
+		_free_network(pmlmepriv, pnetwork);
+
+	}
+
+	_exit_critical(&scanned_queue->lock, &irqL);
+
+_func_exit_;
+
+}
+
+sint if_up(_adapter *padapter)
+{
+	sint res;
+
+_func_enter_;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+	    (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == _FALSE)) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("if_up: bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		res = _FALSE;
+	} else
+		res = _TRUE;
+
+_func_exit_;
+
+	return res;
+}
+
+void generate_random_ibss(u8* pibss)
+{
+	u32 curtime = get_current_time();
+
+_func_enter_;
+
+	pibss[0] = 0x02; //in ad-hoc mode bit1 must set to 1
+	pibss[1] = 0x11;
+	pibss[2] = 0x87;
+	pibss[3] = (u8)(curtime & 0xff) ;//p[0];
+	pibss[4] = (u8)((curtime>>8) & 0xff) ;//p[1];
+	pibss[5] = (u8)((curtime>>16) & 0xff) ;//p[2];
+
+_func_exit_;
+
+	return;
+}
+
+uint get_NDIS_WLAN_BSSID_EX_sz (NDIS_WLAN_BSSID_EX *bss)
+{
+	uint t_len;
+
+_func_enter_;
+
+	t_len = sizeof (ULONG) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 +
+			sizeof (NDIS_802_11_SSID) + sizeof (ULONG) +
+			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) +
+			sizeof (NDIS_802_11_CONFIGURATION) +
+			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof (NDIS_802_11_RATES_EX)+ sizeof (ULONG) + bss->IELength;
+
+_func_exit_;
+
+	return t_len;
+}
+
+u8 *get_capability_from_ie(u8 *ie)
+{
+	return (ie + 8 + 2);
+}
+
+
+u16 get_capability(NDIS_WLAN_BSSID_EX *bss)
+{
+	u16	val;
+_func_enter_;
+	_memcpy((u8 *)&val, get_capability_from_ie(bss->IEs), 2);
+_func_exit_;
+	return val;
+}
+
+u8 *get_timestampe_from_ie(u8 *ie)
+{
+	return (ie + 0);
+}
+
+u8 *get_beacon_interval_from_ie(u8 *ie)
+{
+	return (ie + 8);
+}
+
+
+int	init_mlme_priv (_adapter *padapter)//(struct	mlme_priv *pmlmepriv)
+{
+	int	res;
+_func_enter_;
+	res = _init_mlme_priv(padapter);// (pmlmepriv);
+_func_exit_;
+	return res;
+}
+
+void free_mlme_priv (struct mlme_priv *pmlmepriv)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("free_mlme_priv\n"));
+	_free_mlme_priv (pmlmepriv);
+_func_exit_;
+}
+
+int	enqueue_network(_queue *queue, struct wlan_network *pnetwork)
+{
+	int	res;
+_func_enter_;
+	res = _enqueue_network(queue, pnetwork);
+_func_exit_;
+	return res;
+}
+
+
+
+struct	wlan_network *dequeue_network(_queue *queue)
+{
+	struct wlan_network *pnetwork;
+_func_enter_;
+	pnetwork = _dequeue_network(queue);
+_func_exit_;
+	return pnetwork;
+}
+
+
+struct	wlan_network *alloc_network(struct	mlme_priv *pmlmepriv )//(_queue	*free_queue)
+{
+	struct	wlan_network	*pnetwork;
+_func_enter_;
+	pnetwork = _alloc_network(pmlmepriv);
+_func_exit_;
+	return pnetwork;
+}
+
+void free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork )//(struct	wlan_network *pnetwork, _queue	*free_queue)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
+	_free_network(pmlmepriv, pnetwork);
+_func_exit_;
+}
+
+
+void free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork )
+{
+_func_enter_;
+	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
+	_free_network_nolock(pmlmepriv, pnetwork);
+_func_exit_;
+}
+
+
+void free_network_queue(_adapter* dev)
+{
+_func_enter_;
+	_free_network_queue(dev);
+_func_exit_;
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context... to avoid possible racing condition...
+*/
+struct wlan_network* find_network(_queue *scanned_queue, u8 *addr)
+{
+	struct wlan_network *pnetwork = _find_network(scanned_queue, addr);
+
+	return pnetwork;
+}
+
+int is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork)
+{
+	int ret=_TRUE;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if ( (psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_ ) &&
+		    ( pnetwork->network.Privacy == 0 ) )
+	{
+		ret=_FALSE;
+	}
+	else if((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
+		 ( pnetwork->network.Privacy == 1 ) )
+	{
+		ret=_FALSE;
+	}
+	else
+	{
+		ret=_TRUE;
+	}
+
+	return ret;
+
+}
+
+static int is_same_network(NDIS_WLAN_BSSID_EX *src, NDIS_WLAN_BSSID_EX *dst)
+{
+	 u16 s_cap, d_cap;
+
+_func_enter_;
+
+#ifdef PLATFORM_OS_XP
+	 if ( ((uint)dst) <= 0x7fffffff ||
+		((uint)src) <= 0x7fffffff ||
+		((uint)&s_cap) <= 0x7fffffff ||
+		((uint)&d_cap) <= 0x7fffffff)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n@@@@ error address of dst\n"));
+
+		KeBugCheckEx(0x87110000, (ULONG_PTR)dst, (ULONG_PTR)src,(ULONG_PTR)&s_cap, (ULONG_PTR)&d_cap);
+
+		return _FALSE;
+	}
+#endif
+
+	_memcpy((u8 *)&s_cap, get_capability_from_ie(src->IEs), 2);
+	_memcpy((u8 *)&d_cap, get_capability_from_ie(dst->IEs), 2);
+
+_func_exit_;
+
+	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
+			(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
+			( (_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == _TRUE) &&
+			( (_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == _TRUE) &&
+			((s_cap & WLAN_CAPABILITY_IBSS) ==
+			(d_cap & WLAN_CAPABILITY_IBSS)) &&
+			((s_cap & WLAN_CAPABILITY_BSS) ==
+			(d_cap & WLAN_CAPABILITY_BSS)));
+
+}
+
+struct	wlan_network	* get_oldest_wlan_network(_queue *scanned_queue)
+{
+	_list	*plist, *phead;
+
+
+	struct	wlan_network	*pwlan = NULL;
+	struct	wlan_network	*oldest = NULL;
+_func_enter_;
+	phead = get_list_head(scanned_queue);
+
+	plist = get_next(phead);
+
+	while(1)
+	{
+
+		if (end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pwlan= LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		if(pwlan->fixed!=_TRUE)
+		{
+			if (oldest == NULL ||time_after(oldest->last_scanned, pwlan->last_scanned))
+				oldest = pwlan;
+		}
+
+		plist = get_next(plist);
+	}
+_func_exit_;
+	return oldest;
+
+}
+
+static void update_network(NDIS_WLAN_BSSID_EX *dst, NDIS_WLAN_BSSID_EX *src, _adapter *padapter)
+{
+	u32 last_evm = 0, tmpVal;
+
+_func_enter_;
+
+	//printk("update_network: rssi=0x%lx dst->Rssi=%d ,dst->Rssi=0x%lx , src->Rssi=0x%lx",(dst->Rssi+src->Rssi)/2,dst->Rssi,dst->Rssi,src->Rssi);
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src))
+	{
+		//printk("b:ssid=%s update_network: src->rssi=0x%d padapter->recvpriv.ui_rssi=%d\n",src->Ssid.Ssid,src->Rssi,padapter->recvpriv.signal);
+		if (padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
+		{
+			padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
+			last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
+			padapter->recvpriv.signal_qual_data.total_val -= last_evm;
+		}
+		padapter->recvpriv.signal_qual_data.total_val += src->Rssi;
+
+		padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = src->Rssi;
+		if (padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
+			padapter->recvpriv.signal_qual_data.index = 0;
+
+		//printk("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, src->Rssi);
+
+		// <1> Showed on UI for user, in percentage.
+		tmpVal = padapter->recvpriv.signal_qual_data.total_val / padapter->recvpriv.signal_qual_data.total_num;
+		padapter->recvpriv.signal = (u8)tmpVal;
+
+		src->Rssi = padapter->recvpriv.signal;
+	}
+	else {
+		//printk("ELSE:ssid=%s update_network: src->rssi=0x%d dst->rssi=%d\n",src->Ssid.Ssid,src->Rssi,dst->Rssi);
+		src->Rssi = (src->Rssi + dst->Rssi) / 2;
+	}
+
+	//printk("a:update_network: src->rssi=0x%d padapter->recvpriv.ui_rssi=%d\n",src->Rssi,padapter->recvpriv.signal);
+	_memcpy((u8*)dst, (u8*)src, get_NDIS_WLAN_BSSID_EX_sz(src));
+
+_func_exit_;
+}
+
+static void update_current_network(_adapter *adapter, NDIS_WLAN_BSSID_EX *pnetwork)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+_func_enter_;
+
+#ifdef PLATFORM_OS_XP
+	if ((unsigned long)(&(pmlmepriv->cur_network.network)) < 0x7ffffff)
+	{
+		KeBugCheckEx(0x87111c1c, (ULONG_PTR)(&(pmlmepriv->cur_network.network)), 0, 0,0);
+	}
+#endif
+
+	if (is_same_network(&(pmlmepriv->cur_network.network), pnetwork))
+	{
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
+		update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter);
+		update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+							pmlmepriv->cur_network.network.IELength);
+	}
+
+_func_exit_;
+
+}
+
+/*
+
+Caller must hold pmlmepriv->lock first.
+
+
+*/
+void update_scanned_network(_adapter *adapter, NDIS_WLAN_BSSID_EX *target)
+{
+	_list	*plist, *phead;
+
+	ULONG bssid_ex_sz;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *oldest = NULL;
+
+_func_enter_;
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while(1)
+	{
+		if (end_of_queue_search(phead,plist) == _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		if ((unsigned long)(pnetwork) < 0x7ffffff)
+		{
+#ifdef PLATFORM_OS_XP
+			KeBugCheckEx(0x87111c1c, (ULONG_PTR)pnetwork, 0, 0,0);
+#endif
+		}
+
+		if (is_same_network(&pnetwork->network, target))
+			break;
+
+		if ((oldest == ((struct wlan_network *)0)) ||
+		    time_after(oldest->last_scanned, pnetwork->last_scanned))
+			oldest = pnetwork;
+
+		plist = get_next(plist);
+	}
+
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (end_of_queue_search(phead,plist) == _TRUE)
+	{
+		if (_queue_empty(&pmlmepriv->free_bss_pool) == _TRUE) {
+			/* If there are no more slots, expire the oldest */
+			//list_del_init(&oldest->list);
+			pnetwork = oldest;
+
+			//printk("update_network: rssi=0x%lx ,pnetwork->network.Rssi=0x%lx , target->Rssi=0x%lx",(pnetwork->network.Rssi+target->Rssi)/2,pnetwork->network.Rssi,target->Rssi);
+			target->Rssi = (pnetwork->network.Rssi + target->Rssi) / 2;
+			_memcpy(&pnetwork->network, target, get_NDIS_WLAN_BSSID_EX_sz(target));
+			pnetwork->last_scanned = get_current_time();
+		} else {
+			/* Otherwise just pull from the free list */
+
+			pnetwork = alloc_network(pmlmepriv); // will update scan_time
+			if (pnetwork == NULL) {
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("!update_scanned_network: something wrong here!!\n"));
+				goto exit;
+			}
+
+			bssid_ex_sz = get_NDIS_WLAN_BSSID_EX_sz(target);
+			target->Length = bssid_ex_sz;
+
+			_memcpy(&pnetwork->network, target, bssid_ex_sz);
+
+			list_insert_tail(&pnetwork->list, &queue->queue);
+		}
+	} else {
+		/* we have an entry and we are going to update it. But this entry may
+		 * be already expired. In this case we do the same as we found a new
+		 * net and call the new_net handler
+		 */
+		update_network(&pnetwork->network, target, adapter);
+
+		pnetwork->last_scanned = get_current_time();
+	}
+
+exit:
+
+_func_exit_;
+
+}
+
+void rtl8711_add_network(_adapter *adapter, NDIS_WLAN_BSSID_EX *pnetwork)
+{
+	_irqL irqL;
+	struct mlme_priv *pmlmepriv = &(((_adapter *)adapter)->mlmepriv);
+	_queue *queue = &pmlmepriv->scanned_queue;
+
+_func_enter_;
+
+	_enter_critical(&queue->lock, &irqL);
+
+	update_current_network(adapter, pnetwork);
+
+	update_scanned_network(adapter, pnetwork);
+
+	_exit_critical(&queue->lock, &irqL);
+
+_func_exit_;
+}
+
+//select the desired network based on the capability of the (i)bss.
+// check items: (1) security
+//			   (2) network_type
+//			   (3) WMM
+//			   (4) HT
+//			   (5) others
+int is_desired_network(_adapter *adapter, struct wlan_network *pnetwork)
+{
+	u8 wps_ie[512];
+	uint wps_ielen;
+	int bselected = _TRUE;
+	struct	security_priv*	 psecuritypriv = &adapter->securitypriv;
+
+
+	if(psecuritypriv->wps_phase == _TRUE)
+	{
+		if(get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen)!=NULL)
+		{
+			return _TRUE;
+		}
+		else
+		{
+			return _FALSE;
+		}
+	}
+
+/*	//for wep,  join bss before setting key
+
+	if (( psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
+	    ( pnetwork->network.Privacy))
+	{
+		bselected = _FALSE;
+	}
+*/
+	if ( (psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_ ) &&
+		    ( pnetwork->network.Privacy == 0 ) )
+	{
+		bselected = _FALSE;
+	}
+
+	if ( check_fwstate( &adapter->mlmepriv, WIFI_ADHOC_STATE ) == _TRUE )
+	{
+		if ( pnetwork->network.InfrastructureMode != adapter->mlmepriv.cur_network.network.InfrastructureMode )
+			bselected = _FALSE;
+	}
+
+	return bselected;
+}
+
+/* TODO: Perry : For Power Management */
+void atimdone_event_callback(_adapter *adapter , u8 *pbuf)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("receive atimdone_evet\n"));
+_func_exit_;
+	return;
+}
+
+void survey_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL;
+	u32 len;
+	NDIS_WLAN_BSSID_EX *pnetwork;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+_func_enter_;
+
+	pnetwork = (NDIS_WLAN_BSSID_EX *)pbuf;
+
+	//endian_convert
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("survey_event_callback, ssid=%s\n", pnetwork->Ssid.Ssid));
+
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig = le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length = le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+
+	len = get_NDIS_WLAN_BSSID_EX_sz(pnetwork);
+	if (len > sizeof(WLAN_BSSID_EX)) {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("!survey_event_callback: return a wrong bss!\n"));
+		goto exit;
+	}
+
+#ifdef CONFIG_DRVEXT_MODULE
+	update_random_seed((void *)(adapter), pnetwork->IEs);
+#endif
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	// update IBSS_network 's timestamp
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"survey_event_callback : WIFI_ADHOC_MASTER_STATE \n\n");
+		if(_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN))
+		{
+			struct wlan_network* ibss_wlan = NULL;
+
+			_memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
+
+			ibss_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->MacAddress);
+			if (!ibss_wlan) {
+				_memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);
+				goto exit;
+			}
+		}
+	}
+
+	// lock pmlmepriv->lock when you accessing network_q
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _FALSE)
+	{
+		if (pnetwork->Ssid.Ssid[0] != 0) {
+			rtl8711_add_network(adapter, pnetwork);
+		} else {
+			pnetwork->Ssid.SsidLength = 8;
+			_memcpy(pnetwork->Ssid.Ssid, "<hidden>", 8);
+			rtl8711_add_network(adapter, pnetwork);
+		}
+	}
+
+exit:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+_func_exit_;
+
+	return;
+}
+
+void surveydone_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+#ifdef CONFIG_MLME_EXT
+
+	mlmeext_surveydone_event_callback(adapter);
+
+#endif
+
+_func_enter_;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+surveydone_event_callback: fw_state=0x%08x\n", pmlmepriv->fw_state));
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
+	{
+		u8 timer_cancelled;
+
+		_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	} else {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("!surveydone_event_callback: too late! fw_status=0x%08x\n", pmlmepriv->fw_state));
+	}
+
+	if (pmlmepriv->to_join == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+surveydone_event_callback: to_join == _TRUE\n"));
+
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		{
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+			{
+				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+				if (select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS) {
+					_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+				}
+				else
+				{
+					WLAN_BSSID_EX *pdev_network = &(adapter->registrypriv.dev_network);
+					u8 *pibss = adapter->registrypriv.dev_network.MacAddress;
+
+					pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;//because don't set assoc_timer
+
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("switching to adhoc master\n"));
+
+					_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+					_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+
+					update_registrypriv_dev_network(adapter);
+					generate_random_ibss(pibss);
+
+					pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+
+					if(createbss_cmd(adapter)!=_SUCCESS)
+					{
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error=>createbss_cmd status FAIL\n"));
+					}
+
+					pmlmepriv->to_join = _FALSE;
+				}
+			}
+		}
+		else
+		{
+			pmlmepriv->to_join = _FALSE;
+			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+			if (select_and_join_from_scanned_queue(pmlmepriv) == _SUCCESS) {
+				_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+			} else {
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("try_to_join, but select scanning queue fail\n"));
+			}
+		}
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+	indicate_wx_scan_complete_event(adapter);
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_surveydone_event_callback(adapter);
+#endif //CONFIG_IOCTL_CFG80211
+
+_func_exit_;
+}
+
+void free_scanqueue(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+	_queue *free_queue = &pmlmepriv->free_bss_pool;
+	_queue *scan_queue = &pmlmepriv->scanned_queue;
+	_list *plist, *phead, *ptemp;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
+
+	_enter_critical(&free_queue->lock, &irqL);
+
+	phead = get_list_head(scan_queue);
+	plist = get_next(phead);
+
+	while (plist != phead)
+	{
+		ptemp = get_next(plist);
+		list_delete(plist);
+		list_insert_tail(plist, &free_queue->queue);
+		plist = ptemp;
+		pmlmepriv->num_of_scanned--;
+	}
+
+	_exit_critical(&free_queue->lock, &irqL);
+
+_func_exit_;
+}
+
+/*
+ *free_assoc_resources: the caller has to lock pmlmepriv->lock
+ */
+void free_assoc_resources(_adapter *adapter)
+{
+	_irqL irqL;
+	struct wlan_network *pwlan = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_assoc_resources\n"));
+
+	pwlan = find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("tgt_network->network.MacAddress=%02x:%02x:%02x:%02x:%02x:%02x ssid=%s\n",
+		tgt_network->network.MacAddress[0],tgt_network->network.MacAddress[1],
+		tgt_network->network.MacAddress[2],tgt_network->network.MacAddress[3],
+		tgt_network->network.MacAddress[4],tgt_network->network.MacAddress[5],
+		tgt_network->network.Ssid.Ssid));
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE) == _TRUE)
+	{
+		struct sta_info* psta;
+
+		psta = get_stainfo(&adapter->stapriv, tgt_network->network.MacAddress);
+
+		_enter_critical(&pstapriv->sta_hash_lock, &irqL);
+		free_stainfo(adapter,  psta);
+		_exit_critical(&pstapriv->sta_hash_lock, &irqL);
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE) == _TRUE)
+	{
+		free_all_stainfo(adapter);
+	}
+
+	if (pwlan) {
+		pwlan->fixed = _FALSE;
+	} else {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("free_assoc_resources: pwlan== NULL\n"));
+	}
+
+	if (((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) && (adapter->stapriv.asoc_sta_count== 1))
+		/*|| (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)*/)
+	{
+		free_network_nolock(pmlmepriv, pwlan);
+	}
+
+_func_exit_;
+}
+
+/*
+*indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void indicate_connect(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+indicate_connect\n"));
+
+	pmlmepriv->to_join = _FALSE;
+
+	set_fwstate(pmlmepriv, _FW_LINKED);
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_LINK);
+
+	os_indicate_connect(padapter);
+
+#ifdef CONFIG_PWRCTRL
+	if (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE) {
+		_set_timer(&pmlmepriv->dhcp_timer, 60000);
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-indicate_connect: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+
+_func_exit_;
+}
+
+
+/*
+*indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void indicate_disconnect( _adapter *padapter )
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+indicate_disconnect\n"));
+
+	
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	{
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+
+		padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+
+		os_indicate_disconnect(padapter);
+	}
+
+	_cancel_timer_ex(&pmlmepriv->survey_timer);
+
+#ifdef CONFIG_PWRCTRL
+	if(padapter->pwrctrlpriv.pwr_mode != padapter->registrypriv.power_mgnt){
+		_cancel_timer_ex(&pmlmepriv->dhcp_timer);
+		set_ps_mode(padapter, padapter->registrypriv.power_mgnt, padapter->registrypriv.smart_ps);
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-indicate_disconnect: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+
+_func_exit_;
+}
+
+inline void rtw_indicate_scan_done( _adapter *padapter, bool aborted)
+{
+	rtw_os_indicate_scan_done(padapter, aborted);
+}
+
+#if 0
+void joinbss_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL,irqL2;
+	int	res;
+	u8 timer_cancelled;
+	struct sta_info *ptarget_sta= NULL, *pcur_sta = NULL;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	struct wlan_network 	*pnetwork	= (struct wlan_network *)pbuf;
+	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int 		the_same_macaddr = _FALSE;
+
+_func_enter_;
+
+	//endian_convert
+	pnetwork->join_res = le32_to_cpu(pnetwork->join_res);
+	pnetwork->network_type = le32_to_cpu(pnetwork->network_type);
+	pnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);
+	pnetwork->network.Ssid.SsidLength = le32_to_cpu(pnetwork->network.Ssid.SsidLength);
+	pnetwork->network.Privacy =le32_to_cpu( pnetwork->network.Privacy);
+	pnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);
+	pnetwork->network.NetworkTypeInUse =le32_to_cpu(pnetwork->network.NetworkTypeInUse) ;
+	pnetwork->network.Configuration.ATIMWindow = le32_to_cpu(pnetwork->network.Configuration.ATIMWindow);
+	pnetwork->network.Configuration.BeaconPeriod = le32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);
+	pnetwork->network.Configuration.DSConfig =le32_to_cpu(pnetwork->network.Configuration.DSConfig);
+	pnetwork->network.Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->network.Configuration.FHConfig.DwellTime);
+	pnetwork->network.Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopPattern);
+	pnetwork->network.Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);
+	pnetwork->network.Configuration.FHConfig.Length=le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);
+	pnetwork->network.Configuration.Length = le32_to_cpu(pnetwork->network.Configuration.Length);
+	pnetwork->network.InfrastructureMode = le32_to_cpu(pnetwork->network.InfrastructureMode);
+	pnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength );
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("joinbss event call back received with res=%d\n", pnetwork->join_res));
+
+	get_encrypt_decrypt_from_registrypriv(adapter);
+
+#ifdef CONFIG_MLME_EXT
+
+	if(pnetwork->join_res > 0)
+	{
+		mlmeext_joinbss_event_callback(adapter, pnetwork);
+	}
+
+#endif
+
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss event call back  for Any SSid\n"));
+	}
+	else
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss_event_callback for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	the_same_macaddr = _memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n joinbss_event_callback !! remove spinlock \n"));
+
+	if (pnetwork->join_res > 0)
+	{
+		cur_network->join_res = pnetwork->join_res;
+
+		if ((pmlmepriv->fw_state) & _FW_UNDER_LINKING)
+		{
+
+			pnetwork->network.Length = get_NDIS_WLAN_BSSID_EX_sz(&pnetwork->network);
+			if(pnetwork->network.Length > sizeof(WLAN_BSSID_EX))
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));
+				goto ignore_joinbss_callback;
+			}
+
+			if((pmlmepriv->fw_state) & _FW_LINKED)
+			{
+				if(the_same_macaddr == _TRUE)
+				{
+					ptarget_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+
+					//update network in pscanned_q
+					//_memcpy(&(ptarget_wlan->network), &pnetwork->network, pnetwork->network.Length);//removed
+					ptarget_sta = get_stainfo(pstapriv, pnetwork->network.MacAddress);
+				}
+				else
+				{
+					pcur_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+					pcur_wlan->fixed = _FALSE;
+
+					ptarget_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+
+					// update network in pscanned_q
+					//_memcpy(&(ptarget_wlan->network), &pnetwork->network, pnetwork->network.Length);//removed
+					ptarget_wlan->fixed = _TRUE;
+
+					pcur_sta = get_stainfo(pstapriv, cur_network->network.MacAddress);
+					_enter_critical(&(pstapriv->sta_hash_lock), &irqL2);
+					free_stainfo(adapter,  pcur_sta);
+					_exit_critical(&(pstapriv->sta_hash_lock), &irqL2);
+
+					ptarget_sta = alloc_stainfo(&adapter->stapriv, pnetwork->network.MacAddress);
+				}
+
+			}
+			else
+			{
+				ptarget_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+				if(ptarget_wlan)
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\nfw_state:%x, BSSID:%x:%x:%x:%x:%x:%x (fw_state=%d)\n",
+						pnetwork->network.MacAddress[0], pnetwork->network.MacAddress[1],
+						pnetwork->network.MacAddress[2], pnetwork->network.MacAddress[3],
+						pnetwork->network.MacAddress[4], pnetwork->network.MacAddress[5],
+						pmlmepriv->fw_state));
+				}
+
+				//update network in pscanned_q
+				ptarget_wlan->fixed = _TRUE;
+				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+				{
+					ptarget_sta = alloc_stainfo(&adapter->stapriv, pnetwork->network.MacAddress);
+					if(ptarget_sta == NULL)
+					{
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("#########Can't allocate  network when joinbss_event callback\n"));
+						goto ignore_joinbss_callback;
+					}
+
+					if(adapter->securitypriv.dot11AuthAlgrthm== 2)
+					{
+						ptarget_sta->ieee8021x_blocked=_TRUE;
+						ptarget_sta->dot118021XPrivacy=adapter->securitypriv.dot11PrivacyAlgrthm;
+						adapter->securitypriv.binstallGrpkey=_FALSE;
+						adapter->securitypriv.busetkipkey=_FALSE;
+
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n=====adapter->securitypriv.busetkipkey=_FALSE=====\n"));
+						adapter->securitypriv.bgrpkey_handshake=_FALSE;
+						_memset((u8 *)&ptarget_sta->dot118021x_UncstKey, 0, sizeof (union Keytype));
+						_memset((u8 *)&ptarget_sta->dot11tkiprxmickey, 0, sizeof (union pn48));
+						_memset((u8 *)&ptarget_sta->dot11tkiptxmickey, 0, sizeof (union pn48));
+					}
+
+				}
+			}
+
+			if(ptarget_sta)
+			{
+				ptarget_sta->aid  = pnetwork->join_res;
+
+				ptarget_sta->qos_option = 1;//?
+
+				if(check_fwstate( pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+					ptarget_sta->mac_id = 5;
+			}
+			else
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("ptarget_sta==NULL\n\n"));
+			}
+
+
+			if(ptarget_wlan == NULL){
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't allocate  network when joinbss_event callback\n"));
+				goto ignore_joinbss_callback;
+			}
+
+			if(check_fwstate( pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			{
+				if(ptarget_sta == NULL)
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't allocate  stainfo when joinbss_event callback\n"));
+					goto ignore_joinbss_callback;
+				}
+			}
+
+			//update cur_network
+			_memcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);
+			cur_network->aid = pnetwork->join_res;
+
+			// update fw_state //will clr _FW_UNDER_LINKING here indirectly
+			switch(pnetwork->network.InfrastructureMode)
+			{
+				case Ndis802_11Infrastructure:
+					pmlmepriv->fw_state = WIFI_STATION_STATE;
+					break;
+
+				case Ndis802_11IBSS:
+					pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+					break;
+
+				default:
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Invalid network_mode\n"));
+					break;
+			}
+
+
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("before indicate connect fw_state:%x",pmlmepriv->fw_state));
+
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n BSSID=0x%02x:0x%2x:0x%2x:0x%2x:0x%2x:0x%2x\n",
+						pmlmepriv->cur_network.network.MacAddress[0],pmlmepriv->cur_network.network.MacAddress[1],
+						pmlmepriv->cur_network.network.MacAddress[2],pmlmepriv->cur_network.network.MacAddress[3],
+						pmlmepriv->cur_network.network.MacAddress[4],pmlmepriv->cur_network.network.MacAddress[5]));
+
+			if(check_fwstate( pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n joinbss_event_callback:indicate_connect  \n"));
+
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n joinbss_event_callback:adapter->securitypriv.dot11AuthAlgrthm = %d adapter->securitypriv.ndisauthtype=%d\n",
+							adapter->securitypriv.dot11AuthAlgrthm, adapter->securitypriv.ndisauthtype));
+
+				if(adapter->securitypriv.dot11AuthAlgrthm== 2)
+				{
+					if(ptarget_sta!=NULL)
+					{
+						u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
+						ptarget_sta->ieee8021x_blocked = _TRUE;
+						ptarget_sta->dot118021XPrivacy =adapter->securitypriv.dot11PrivacyAlgrthm;
+						_memcpy(&ptarget_sta->dot11tkiptxmickey.skey[0], null_key, 16);
+
+					}
+
+					adapter->securitypriv.binstallGrpkey=_FALSE;
+					adapter->securitypriv.bgrpkey_handshake=_FALSE;
+				}
+
+				indicate_connect(adapter);
+
+				update_protection(adapter, (cur_network->network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+									(cur_network->network.IELength));
+
+				//TODO: update HT_Capability
+
+
+			}
+
+			//adhoc mode will indicate_connect when stassoc_event_callback
+
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("joinbss_event_callback err: fw_state:%x", pmlmepriv->fw_state));
+			goto ignore_joinbss_callback;
+		}
+
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("Cancle assoc_timer \n"));
+		_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+
+
+	}
+	else //if join_res < 0 (join fails), then try again
+	{
+		res = select_and_join_from_scanned_queue(pmlmepriv);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("select_and_join_from_scanned_queue again! res:%d\n",res));
+		if (res != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Set Assoc_Timer = 1; can't find match ssid in scanned_q \n"));
+
+			_set_timer(&pmlmepriv->assoc_timer, 1);
+
+			//free_assoc_resources(adapter);
+
+			if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _TRUE)
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", pmlmepriv->fw_state));
+				pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+			}
+
+		}
+		else
+		{
+			//todo: extend time of assoc_timer
+		}
+
+	}
+
+ignore_joinbss_callback:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+_func_exit_;
+
+}
+#else
+//Notes:
+//pnetwork : returns from joinbss_event_callback
+//ptarget_wlan: found from scanned_queue
+//if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist.
+//if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist.
+//if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL).
+//
+void joinbss_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL, irqL2;
+	int res;
+	u8 timer_cancelled;
+	struct sta_info	*ptarget_sta = NULL, *pcur_sta = NULL;
+	struct sta_priv	*pstapriv = &adapter->stapriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct wlan_network	*pnetwork = (struct wlan_network *)pbuf;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int		the_same_macaddr = _FALSE;
+#ifdef CONFIG_DRVEXT_MODULE
+	int enable_wpa = 0, enable_wsc = 0;
+	struct drvext_priv *pdrvext = &adapter->drvextpriv;
+#endif
+
+_func_enter_;
+
+	//endian_convert
+	pnetwork->join_res = le32_to_cpu(pnetwork->join_res);
+	pnetwork->network_type = le32_to_cpu(pnetwork->network_type);
+	pnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);
+	pnetwork->network.Ssid.SsidLength = le32_to_cpu(pnetwork->network.Ssid.SsidLength);
+	pnetwork->network.Privacy = le32_to_cpu(pnetwork->network.Privacy);
+	pnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);
+	pnetwork->network.NetworkTypeInUse = le32_to_cpu(pnetwork->network.NetworkTypeInUse);
+	pnetwork->network.Configuration.ATIMWindow = le32_to_cpu(pnetwork->network.Configuration.ATIMWindow);
+	pnetwork->network.Configuration.BeaconPeriod = le32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);
+	pnetwork->network.Configuration.DSConfig = le32_to_cpu(pnetwork->network.Configuration.DSConfig);
+	pnetwork->network.Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->network.Configuration.FHConfig.DwellTime);
+	pnetwork->network.Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopPattern);
+	pnetwork->network.Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);
+	pnetwork->network.Configuration.FHConfig.Length = le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);
+	pnetwork->network.Configuration.Length = le32_to_cpu(pnetwork->network.Configuration.Length);
+	pnetwork->network.InfrastructureMode = le32_to_cpu(pnetwork->network.InfrastructureMode);
+	pnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength);
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("+joinbss event call back: received with res=%d\n", pnetwork->join_res));
+
+	get_encrypt_decrypt_from_registrypriv(adapter);
+
+#ifdef CONFIG_MLME_EXT
+
+	if (pnetwork->join_res > 0) {
+		mlmeext_joinbss_event_callback(adapter, pnetwork);
+	}
+
+#endif
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss event call back for Any SSid\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss_event_callback for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	the_same_macaddr = _memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);
+
+	pnetwork->network.Length = get_NDIS_WLAN_BSSID_EX_sz(&pnetwork->network);
+	if (pnetwork->network.Length > sizeof(WLAN_BSSID_EX))
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("***joinbss_evt_callback return a wrong bss ***\n"));
+		goto ignore_joinbss_callback;
+	}
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("joinbss_event_callback: _enter_critical\n"));
+
+	if (pnetwork->join_res > 0)
+	{
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		{
+			//s1. find ptarget_wlan
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+			{
+				if (the_same_macaddr == _TRUE) {
+					ptarget_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+				} else {
+					pcur_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+					pcur_wlan->fixed = _FALSE;
+
+					pcur_sta = get_stainfo(pstapriv, cur_network->network.MacAddress);
+					_enter_critical(&pstapriv->sta_hash_lock, &irqL2);
+					free_stainfo(adapter, pcur_sta);
+					_exit_critical(&(pstapriv->sta_hash_lock), &irqL2);
+
+					ptarget_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+					if (ptarget_wlan) ptarget_wlan->fixed = _TRUE;
+				}
+			} else {
+				ptarget_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+				if (ptarget_wlan) ptarget_wlan->fixed = _TRUE;
+			}
+
+			if (ptarget_wlan == NULL)
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't find ptarget_wlan when joinbss_event callback\n"));
+
+				if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+					RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("joinbss_event_callback: clear _FW_UNDER_LINKING fw_state=%x\n", pmlmepriv->fw_state));
+					pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+				}
+
+				goto ignore_joinbss_callback;
+			}
+
+			//s2. find ptarget_sta & update ptarget_sta
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			{
+				if (the_same_macaddr == _TRUE) {
+					ptarget_sta = get_stainfo(pstapriv, pnetwork->network.MacAddress);
+					if (ptarget_sta == NULL) {
+						ptarget_sta = alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
+					}
+				} else {
+					ptarget_sta = alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
+				}
+
+				if (ptarget_sta) //update ptarget_sta
+				{
+					ptarget_sta->aid = pnetwork->join_res;
+					ptarget_sta->qos_option = 1;//?
+					ptarget_sta->mac_id = 5;
+
+					if (adapter->securitypriv.dot11AuthAlgrthm == 2)
+					{
+						adapter->securitypriv.binstallGrpkey = _FALSE;
+						adapter->securitypriv.busetkipkey = _FALSE;
+						adapter->securitypriv.bgrpkey_handshake = _FALSE;
+
+						ptarget_sta->ieee8021x_blocked = _TRUE;
+						ptarget_sta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
+
+						_memset((u8 *)&ptarget_sta->dot118021x_UncstKey, 0, sizeof (union Keytype));
+
+						_memset((u8 *)&ptarget_sta->dot11tkiprxmickey, 0, sizeof (union Keytype));
+						_memset((u8 *)&ptarget_sta->dot11tkiptxmickey, 0, sizeof (union Keytype));
+
+						_memset((u8 *)&ptarget_sta->dot11txpn, 0, sizeof (union pn48));
+						_memset((u8 *)&ptarget_sta->dot11rxpn, 0, sizeof (union pn48));
+					}
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't allocate stainfo when joinbss_event callback\n"));
+
+					if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+						RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("joinbss_event_callback: clear _FW_UNDER_LINKING fw_state=%x\n", pmlmepriv->fw_state));
+						pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+					}
+
+					goto ignore_joinbss_callback;
+				}
+			}
+
+			//s3. update cur_network & indicate connect
+			//if (ptarget_wlan)	// check above
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+					 ("fw_state:%x, BSSID:%02x:%02x:%02x:%02x:%02x:%02x\n",
+						pmlmepriv->fw_state,
+						pnetwork->network.MacAddress[0], pnetwork->network.MacAddress[1],
+						pnetwork->network.MacAddress[2], pnetwork->network.MacAddress[3],
+						pnetwork->network.MacAddress[4], pnetwork->network.MacAddress[5]));
+
+				_memcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);
+				cur_network->aid = pnetwork->join_res;
+
+				//update fw_state //will clr _FW_UNDER_LINKING here indirectly
+				switch (pnetwork->network.InfrastructureMode)
+				{
+					case Ndis802_11Infrastructure:
+							pmlmepriv->fw_state = WIFI_STATION_STATE;
+							break;
+					case Ndis802_11IBSS:
+							pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+							break;
+					default:
+							pmlmepriv->fw_state = WIFI_NULL_STATE;
+							RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Invalid network_mode\n"));
+							break;
+				}
+
+				update_protection(adapter, (cur_network->network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+									(cur_network->network.IELength));
+
+#ifdef CONFIG_80211N_HT
+				//TODO: update HT_Capability
+				update_ht_cap(adapter, cur_network->network.IEs, cur_network->network.IELength);
+#endif
+
+				//indicate connect
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+				{
+#ifdef CONFIG_DRVEXT_MODULE
+					if (pdrvext->enable_wpa)
+					{
+						//Added by Albert 2008/10/16 for TKIP countermeasure.
+						pdrvext->wpa_tkip_mic_error_occur_time = 0;
+						pdrvext->wpa_tkip_countermeasure_enable = 0;
+						_memset(pdrvext->wpa_tkip_countermeasure_blocked_bssid, 0x00, ETH_ALEN );
+
+						res = drvext_l2_connect_callback(adapter);
+
+						if (res == L2_CONNECTED)
+						{
+							indicate_connect(adapter);
+						}
+						else if (res == L2_DISCONNECTED)
+						{
+							goto select_and_join_new_bss;
+						}
+						else if (res == L2_PENDING)
+						{
+							//DEBUG_ERR(("Going for WPA module\n"));
+							pdrvext->wpasm.rx_replay_counter_set = 0;
+							enable_wpa = 1;
+						}
+						else if (res == L2_WSC_PENDING)
+						{
+							//DEBUG_ERR(("Going for WSC module\n"));
+							enable_wsc = 1;
+						}
+					}
+					else
+#endif
+					{
+						indicate_connect(adapter);
+					}
+				}
+				else
+				{
+					//adhoc mode will indicate_connect when stassoc_event_callback
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("adhoc mode, fw_state:%x", pmlmepriv->fw_state));
+				}
+			}
+
+#ifdef CONFIG_DRVEXT_MODULE
+			if (enable_wpa)
+			{
+				_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+				//DEBUG_ERR(("@@ Set Assoc Timer [%x] for WPA@@\n"));
+			}
+			else
+#endif
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("Cancle assoc_timer\n"));
+				_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+			}
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("joinbss_event_callback: ERROR! fw_state=0x%08x\n",
+				  pmlmepriv->fw_state));
+			goto ignore_joinbss_callback;
+		}
+
+	}
+	else //if join_res < 0 (join fails)
+	{
+
+#ifdef CONFIG_DRVEXT_MODULE
+
+select_and_join_new_bss:
+
+		//drvext_assoc_fail_indicate(adapter);
+#endif
+
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		{
+				_set_timer(&pmlmepriv->assoc_timer, 1);
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+	}
+
+ignore_joinbss_callback:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+#ifdef CONFIG_DRVEXT_MODULE_WSC
+
+	if (enable_wsc)
+	{
+		// here we start registration protocol
+		start_reg_protocol(adapter);
+	}
+
+#endif
+
+_func_exit_;
+
+}
+#endif
+
+void stassoc_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL;
+	struct sta_info *psta;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct stassoc_event *pstassoc	= (struct stassoc_event*)pbuf;
+
+_func_enter_;
+
+	// to do:
+	if(access_ctrl(&adapter->acl_list, pstassoc->macaddr) == _FALSE)
+		return;
+
+	psta = get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if( psta != NULL)
+	{
+		//the sta have been in sta_info_queue => do nothing
+
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error: stassoc_event_callback: sta has been in sta_hash_queue \n"));
+
+		goto exit; //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
+	}
+
+	psta = alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't alloc sta_info when stassoc_event_callback\n"));
+		goto exit;
+	}
+
+	//to do : init sta_info variable
+	psta->qos_option = 0;
+	psta->mac_id = le32_to_cpu((uint)pstassoc->cam_id);
+	//psta->aid = (uint)pstassoc->cam_id;
+
+	if(adapter->securitypriv.dot11AuthAlgrthm==2)
+		psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
+
+	psta->ieee8021x_blocked = _FALSE;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
+	{
+		if(adapter->stapriv.asoc_sta_count== 2)
+		{
+			// a sta + bc/mc_stainfo (not Ibss_stainfo)
+			indicate_connect(adapter);
+		}
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+#ifdef CONFIG_RTL8711
+	//submit SetStaKey_cmd to tell fw, fw will allocate an CAM entry for this sta
+	setstakey_cmd(adapter, (unsigned char*)psta, _FALSE);
+#endif
+
+exit:
+
+_func_exit_;
+
+}
+
+void stadel_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL,irqL2;
+	struct sta_info *psta;
+	struct wlan_network *pwlan = NULL;
+	WLAN_BSSID_EX *pdev_network = NULL;
+	u8 *pibss = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct stadel_event *pstadel = (struct stadel_event*)pbuf;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+_func_enter_;
+
+	_enter_critical(&pmlmepriv->lock, &irqL2);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{
+		indicate_disconnect(adapter);
+		free_assoc_resources(adapter);
+
+		pwlan = find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+		if (pwlan)
+		{
+			pwlan->fixed = _FALSE;
+			free_network_nolock(pmlmepriv, pwlan);
+		}		
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE) == _TRUE)
+	{
+		psta = get_stainfo(&adapter->stapriv, pstadel->macaddr);
+
+		_enter_critical(&pstapriv->sta_hash_lock, &irqL);
+
+		free_stainfo(adapter, psta);
+
+		_exit_critical(&pstapriv->sta_hash_lock, &irqL);
+
+		if (adapter->stapriv.asoc_sta_count == 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
+		{
+			//indicate_disconnect(adapter);//removed@20091105
+
+			//free old ibss network
+			//pwlan = find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
+			pwlan = find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+			if (pwlan)
+			{
+				pwlan->fixed = _FALSE;
+				free_network_nolock(pmlmepriv, pwlan);
+			}
+
+			//re-create ibss
+			pdev_network = &(adapter->registrypriv.dev_network);
+			pibss = adapter->registrypriv.dev_network.MacAddress;
+
+			_memcpy(pdev_network, &tgt_network->network, get_NDIS_WLAN_BSSID_EX_sz(&tgt_network->network));
+
+			_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+			_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+
+			update_registrypriv_dev_network(adapter);
+
+			generate_random_ibss(pibss);
+
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+			{
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+			}
+
+			if (createbss_cmd(adapter) != _SUCCESS)
+			{
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("***Error=>stadel_event_callback: createbss_cmd status FAIL*** \n "));
+			}
+		}
+	}
+
+	_exit_critical(&pmlmepriv->lock, &irqL2);
+
+_func_exit_;
+
+}
+
+
+void cpwm_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	struct reportpwrstate_parm *preportpwrstate = (struct reportpwrstate_parm *)pbuf;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("cpwm_event_callback !!!\n"));
+#ifdef CONFIG_PWRCTRL
+	preportpwrstate->state |= (u8)(adapter->pwrctrlpriv.cpwm_tog + 0x80);
+	cpwm_int_hdl(adapter, preportpwrstate);
+#endif
+
+_func_exit_;
+
+}
+
+//	Commented by Albert 20100527
+//	When the Netgear 3500 AP is with WPA2PSK-AES mode, it will send the ADDBA req frame with 
+//	start seq control = 0 to wifi client after the WPA handshake and the seqence number of following data packet will be 0. 
+//	In this case, the Rx reorder sequence is not longer than 0 and the WiFi client will drop the data with seq number 0.
+//	So, the 8712 firmware has to inform driver with receiving the ADDBA-Req frame so that the driver can reset the 
+//	sequence value of Rx reorder contorl.
+
+void got_addbareq_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	struct		ADDBA_Req_Report_parm*	pAddbareq_pram = ( struct ADDBA_Req_Report_parm* ) pbuf;
+	struct		sta_info*					psta;
+	struct		sta_priv*					pstapriv = &adapter->stapriv;
+	struct		recv_reorder_ctrl*			precvreorder_ctrl = NULL;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+_func_enter_;	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("got_addbareq_event_callback!!!\n"));
+	printk( "[%s] mac = %X %X %X %X %X %X, seq = %d, tid = %d\n", __FUNCTION__,
+			pAddbareq_pram->MacAddress[0], pAddbareq_pram->MacAddress[1], pAddbareq_pram->MacAddress[2],
+			pAddbareq_pram->MacAddress[3], pAddbareq_pram->MacAddress[4], pAddbareq_pram->MacAddress[5], 
+			pAddbareq_pram->StartSeqNum, pAddbareq_pram->tid);
+	
+	psta = get_stainfo(pstapriv, pAddbareq_pram->MacAddress);
+	if ( psta )
+	{
+		precvreorder_ctrl = &psta->recvreorder_ctrl[pAddbareq_pram->tid];	
+		// set the indicate_seq to 0xffff so that the rx reorder can store any following data packet.
+		if (pregistrypriv->wifi_test == 1)
+		{
+			precvreorder_ctrl->enable = _FALSE;
+		}
+		else
+		{
+			precvreorder_ctrl->enable = _TRUE;
+		}
+		precvreorder_ctrl->indicate_seq = 0xffff;
+	}
+_func_exit_;
+}
+
+void wpspbc_event_callback(_adapter *adapter, u8 *pbuf)
+{
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("wpspbc_event_callback !!!\n"));
+
+	if(adapter->securitypriv.wps_hw_pbc_pressed == _FALSE){
+
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("wpspbc_event_callback - PBC is pressed !!!\n"));
+
+		adapter->securitypriv.wps_hw_pbc_pressed = _TRUE;
+		//_set_workitem(&adapter->mlmepriv.hw_pbc_workitem);
+	}
+
+_func_exit_;
+}
+
+void survey_timer_event_callback(PADAPTER padapter, u8 *pbuf)
+{
+	struct survey_timer_event *ptimer = (struct survey_timer_event*)pbuf;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+
+	pmlmepriv->survey_interval = ptimer->timeout * 1000;
+
+	if (pmlmepriv->survey_interval == 0)
+		_cancel_timer_ex(&pmlmepriv->survey_timer);
+	else
+		_set_timer(&pmlmepriv->survey_timer, pmlmepriv->survey_interval);
+}
+
+void _sitesurvey_ctrl_handler(_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sitesurvey_ctrl	*psitesurveyctrl = &pmlmepriv->sitesurveyctrl;
+	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
+	u64 current_tx_pkts;
+	uint current_rx_pkts;
+
+_func_enter_;
+
+	current_tx_pkts = (adapter->xmitpriv.tx_pkts)-(psitesurveyctrl->last_tx_pkts);
+	current_rx_pkts = (adapter->recvpriv.rx_pkts)-(psitesurveyctrl->last_rx_pkts);
+
+	psitesurveyctrl->last_tx_pkts = adapter->xmitpriv.tx_pkts;
+	psitesurveyctrl->last_rx_pkts = adapter->recvpriv.rx_pkts;
+
+	if ((current_tx_pkts > pregistrypriv->busy_thresh) ||
+	    (current_rx_pkts > pregistrypriv->busy_thresh))
+	{
+		psitesurveyctrl->traffic_busy = _TRUE;
+	}
+	else
+	{
+		psitesurveyctrl->traffic_busy = _FALSE;
+	}
+
+_func_exit_;
+
+}
+
+void _join_timeout_handler(_adapter *adapter)
+{
+	_irqL irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+#if 0
+	if (adapter->bDriverStopped == _TRUE){
+		_up_sema(&pmlmepriv->assoc_terminate);
+		return;
+	}
+#endif
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+join_timeout_handler: fw_state=0x%08x\n", pmlmepriv->fw_state));
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+		return;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	pmlmepriv->to_join = _FALSE;
+
+//	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+		os_indicate_disconnect(adapter);
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+//	}
+
+//	free_scanqueue(pmlmepriv);// for join fail, don't join again
+
+#ifdef CONFIG_PWRCTRL
+	if (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt) {
+		set_ps_mode(adapter, adapter->registrypriv.power_mgnt, adapter->registrypriv.smart_ps);
+	}
+#endif
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("-join_timeout_handler: fw_state=0x%08x\n", pmlmepriv->fw_state));
+
+_func_exit_;
+
+}
+
+void scan_timeout_handler (_adapter *adapter)
+{
+	_irqL irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+scan_timeout_handler: fw_state=0x%08x\n", pmlmepriv->fw_state));
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _FALSE) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-scan_timeout_handler: too late! fw_status=0x%08x\n", pmlmepriv->fw_state));
+	}
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+
+	pmlmepriv->to_join = _FALSE;	// scan fail, so clear to_join flag
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+}
+
+void _dhcp_timeout_handler (_adapter *adapter)
+{
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("+_dhcp_timeout_handler\n"));
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved) {
+		return;
+	}
+#ifdef CONFIG_PWRCTRL
+	if (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt) {
+		set_ps_mode(adapter, adapter->registrypriv.power_mgnt, adapter->registrypriv.smart_ps);
+	}
+#endif
+_func_exit_;
+}
+
+void _regular_site_survey_handler (PADAPTER padapter)
+{
+	_irqL irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+
+	if ((padapter->bDriverStopped == _TRUE) ||
+	    (padapter->bSurpriseRemoved == _TRUE) ||
+	    (padapter->bup == _FALSE))
+	{
+		pmlmepriv->survey_interval = 0;
+		return;
+	}
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _FALSE) &&
+	    (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _FALSE) &&
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == _FALSE))
+	{
+		sitesurvey_cmd(padapter, NULL);
+	}
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	if (pmlmepriv->survey_interval)
+		_set_timer(&pmlmepriv->survey_timer, pmlmepriv->survey_interval);
+}
+
+void _wdg_timeout_handler(_adapter *adapter)
+{
+	wdg_wk_cmd(adapter);
+}
+
+/*void _hw_pbc_timeout_handler(_adapter *adapter)
+{
+	// cancel flag for next push button event
+	adapter->securitypriv.wps_hw_pbc_pressed = _FALSE;
+}*/
+
+/*
+Calling context:
+The caller of the sub-routine will be in critical section...
+
+The caller must hold the following spinlock
+
+pmlmepriv->lock
+
+*/
+int select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv)
+{
+	_list *phead;
+	unsigned char *dst_ssid, *src_ssid;
+	_adapter *adapter;
+	_queue *queue = NULL;
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *pnetwork_max_rssi = NULL;
+
+_func_enter_;
+
+	adapter = (_adapter*)pmlmepriv->nic_hdl;
+	queue = &pmlmepriv->scanned_queue;
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+
+	while (1)
+	{
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+		{
+			if ((pmlmepriv->assoc_by_rssi == _TRUE) &&
+			    (pnetwork_max_rssi != NULL))
+			{
+				pnetwork = pnetwork_max_rssi;
+				goto ask_for_joinbss;
+			}
+
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("!select_and_join_from_scanned_queue: FAIL(end of queue)\n"));
+			return _FAIL;
+		}
+
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+		if (pnetwork == NULL) {
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("select_and_join_from_scanned_queue: FAIL(pnetwork==NULL)\n"));
+			return _FAIL;
+		}
+
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		if (pmlmepriv->assoc_by_bssid == _TRUE)
+		{
+			dst_ssid = pnetwork->network.MacAddress;
+			src_ssid = pmlmepriv->assoc_bssid;
+
+			if (_memcmp(dst_ssid, src_ssid, ETH_ALEN) == _TRUE)
+			{
+				//remove the condition @ 20081125
+				//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
+				//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
+				//		goto ask_for_joinbss;
+
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+				{
+					if (is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
+					{
+						//DBG_8712("select_and_join(1): _FW_LINKED and is same network, it needn't join again\n");
+
+						_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+						indicate_connect(adapter);//indicate_connect again
+
+						return 2;
+					}
+
+					disassoc_cmd(adapter);
+					indicate_disconnect(adapter);
+					free_assoc_resources(adapter);
+				}
+
+				goto ask_for_joinbss;
+			}
+		}
+		else if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+			goto ask_for_joinbss;//anyway, join first selected(dequeued) pnetwork if ssid_len=0
+		}
+
+		dst_ssid = pnetwork->network.Ssid.Ssid;
+		src_ssid = pmlmepriv->assoc_ssid.Ssid;
+
+		if ((pnetwork->network.Ssid.SsidLength == pmlmepriv->assoc_ssid.SsidLength) &&
+		    (_memcmp(dst_ssid, src_ssid, pmlmepriv->assoc_ssid.SsidLength) == _TRUE))
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+				 ("select_and_join_from_scanned_queue: dst=[%s] src=[%s]\n",
+				  dst_ssid, src_ssid));
+
+			//remove the condition @ 20081125
+			//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
+			//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
+			//{
+			//	_memcpy(pmlmepriv->assoc_bssid, pnetwork->network.MacAddress, ETH_ALEN);
+			//	goto ask_for_joinbss;
+			//}
+
+			if (pmlmepriv->assoc_by_rssi == _TRUE)//if the ssid is the same, select the bss which has the max rssi
+			{
+				if (pnetwork_max_rssi) {
+					if (pnetwork->network.Rssi > pnetwork_max_rssi->network.Rssi)
+						pnetwork_max_rssi = pnetwork;
+				} else {
+					pnetwork_max_rssi = pnetwork;
+				}
+			}
+			else if (is_desired_network(adapter, pnetwork) == _TRUE)
+			{
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+				{
+#if 0
+					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
+					{
+						DBG_8712("select_and_join(2): _FW_LINKED and is same network, it needn't join again\n");
+
+						indicate_connect(adapter);//indicate_connect again
+
+						return 2;
+					}
+					else
+#endif
+					{
+						disassoc_cmd(adapter);
+						//indicate_disconnect(adapter);
+						free_assoc_resources(adapter);
+					}
+				}
+
+				goto ask_for_joinbss;
+			}
+		}
+ 	}
+
+_func_exit_;
+
+	return _FAIL;
+
+ask_for_joinbss:
+
+_func_exit_;
+	return joinbss_cmd(adapter, pnetwork);
+}
+
+sint set_auth(_adapter *adapter, struct security_priv *psecuritypriv)
+{
+	struct cmd_priv	*pcmdpriv = &adapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct setauth_parm *psetauthparm;
+	sint ret = _SUCCESS;
+
+_func_enter_;
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	psetauthparm = (struct setauth_parm*)_malloc(sizeof(struct setauth_parm));
+	if (psetauthparm == NULL) {
+		_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
+		ret = _FAIL;
+		goto exit;
+	}
+
+	_memset(psetauthparm, 0, sizeof(struct setauth_parm));
+	psetauthparm->mode = (u8)psecuritypriv->dot11AuthAlgrthm;
+
+	pcmd->cmdcode = _SetAuth_CMD_;
+	pcmd->parmbuf = (unsigned char *)psetauthparm;
+	pcmd->cmdsz = sizeof(struct setauth_parm);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	_init_listhead(&pcmd->list);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("set_auth: after enqueue, auth_mode=%d\n", psecuritypriv->dot11AuthAlgrthm));
+
+	enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+sint set_key(_adapter *adapter, struct security_priv *psecuritypriv, sint keyid)
+{
+	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct setkey_parm *psetkeyparm;
+	u8 keylen;
+	sint res = _SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("+set_key: dot11AuthAlgrthm=%d dot11PrivacyAlgrthm=%d dot118021XGrpPrivacy=%d\n",
+		  psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy));
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetkeyparm = (struct setkey_parm*)_malloc(sizeof(struct setkey_parm));
+	if (psetkeyparm == NULL) {
+		_mfree((unsigned char*)pcmd, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+	_memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	if (psecuritypriv->dot11AuthAlgrthm == 2) { // 802.1X
+		psetkeyparm->algorithm = (u8)psecuritypriv->dot118021XGrpPrivacy;
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("set_key: algorithm=dot118021XGrpPrivacy=%d\n", psetkeyparm->algorithm));
+	} else { // WEP
+		psetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm;
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("set_key: algorithm=dot11PrivacyAlgrthm=%d\n", psetkeyparm->algorithm));
+	}
+	psetkeyparm->keyid = (u8)keyid;
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("set_key: algorithm=[%d](1(WEP)/2(TKIP)/4(AES)/5(WEP104) keyid=%d\n", psetkeyparm->algorithm, keyid));
+
+	switch (psetkeyparm->algorithm)
+	{
+		case _WEP40_:
+			keylen = 5;
+			_memcpy(psetkeyparm->key, psecuritypriv->dot11DefKey[keyid].skey, keylen);
+			break;
+		case _WEP104_:
+			keylen = 13;
+			_memcpy(psetkeyparm->key, psecuritypriv->dot11DefKey[keyid].skey, keylen);
+			break;
+		case _TKIP_:
+			keylen = 16;
+			_memcpy(psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid-1], keylen);
+			psetkeyparm->grpkey = 1;
+			break;
+		case _AES_:
+			keylen = 16;
+			_memcpy(psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid-1], keylen);
+			psetkeyparm->grpkey = 1;
+			break;
+		default:
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("set_key: algoritm=%d Error!)\n", psetkeyparm->algorithm));
+			res = _FAIL;
+			goto exit;
+	}
+
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	_init_listhead(&pcmd->list);
+
+	//_init_sema(&(pcmd->cmd_sem), 0);
+
+	enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+//adjust IEs for joinbss_cmd in WMM
+int restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len)
+{
+	unsigned int ielength = 0;
+	unsigned int i, j;
+
+	i = 12; //after the fixed IE
+	while(i<in_len)
+	{
+		ielength = initial_out_len;
+
+		if(in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
+		{
+
+			//Append WMM IE to the last index of out_ie
+			/*
+			for(j=i; j< i+(in_ie[i+1]+2); j++)
+			{
+				out_ie[ielength] = in_ie[j];
+				ielength++;
+			}
+			out_ie[initial_out_len+8] = 0x00; //force the QoS Info Field to be zero
+			*/
+
+			for ( j = i; j < i + 9; j++ )
+			{
+				out_ie[ ielength] = in_ie[ j ];
+				ielength++;
+			}
+			out_ie[ initial_out_len + 1 ] = 0x07;
+			out_ie[ initial_out_len + 6 ] = 0x00;
+			out_ie[ initial_out_len + 8 ] = 0x00;
+
+			break;
+		}
+
+		i+=(in_ie[i+1]+2); // to the next IE element
+	}
+
+	return ielength;
+}
+
+//
+// Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.)
+// Added by Annie, 2006-05-07.
+//
+// Search by BSSID,
+// Return Value:
+//		-1		:if there is no pre-auth key in the  table
+//		>=0		:if there is pre-auth key, and   return the entry id
+//
+//
+int SecIsInPMKIDList(_adapter *Adapter, u8 *bssid)
+{
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	int i = 0;
+
+	do {
+		if (psecuritypriv->PMKIDList[i].bUsed &&
+		    (_memcmp(psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN) == _TRUE)) {
+			break;
+		} else {
+			i++;
+			//continue;
+		}
+	} while (i < NUM_PMKID_CACHE);
+
+	if (i == NUM_PMKID_CACHE) {
+		i = -1;// Could not find.
+	} else {
+		// There is one Pre-Authentication Key for the specific BSSID.
+	}
+
+	return i;
+}
+
+sint restruct_sec_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len)
+{
+	u8 authmode = 0, securitytype, match;
+	u8 sec_ie[255], uncst_oui[4], bkup_ie[255];
+	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
+	uint ielength, cnt, remove_cnt;
+	int iEntry;
+
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	uint ndisauthmode = psecuritypriv->ndisauthtype;
+	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("+restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",
+		  ndisauthmode, ndissecuritytype));
+
+	if ((ndisauthmode==Ndis802_11AuthModeWPA)||(ndisauthmode==Ndis802_11AuthModeWPAPSK))
+	{
+		authmode = _WPA_IE_ID_;
+		uncst_oui[0] = 0x0;
+		uncst_oui[1] = 0x50;
+		uncst_oui[2] = 0xf2;
+	}
+	if ((ndisauthmode==Ndis802_11AuthModeWPA2)||(ndisauthmode==Ndis802_11AuthModeWPA2PSK))
+	{
+		authmode = _WPA2_IE_ID_;
+		uncst_oui[0] = 0x0;
+		uncst_oui[1] = 0x0f;
+		uncst_oui[2] = 0xac;
+	}
+
+	switch (ndissecuritytype)
+	{
+		case Ndis802_11Encryption1Enabled:
+		case Ndis802_11Encryption1KeyAbsent:
+			securitytype = _WEP40_;
+			uncst_oui[3] = 0x1;
+			break;
+		case Ndis802_11Encryption2Enabled:
+		case Ndis802_11Encryption2KeyAbsent:
+			securitytype = _TKIP_;
+			uncst_oui[3] = 0x2;
+			break;
+		case Ndis802_11Encryption3Enabled:
+		case Ndis802_11Encryption3KeyAbsent:
+			securitytype = _AES_;
+			uncst_oui[3] = 0x4;
+			break;
+		default:
+			securitytype = _NO_PRIVACY_;
+			break;
+	}
+
+	//Search required WPA or WPA2 IE and copy to sec_ie[ ]
+	cnt = 12;
+	match = _FALSE;
+	while (cnt < in_len)
+	{
+		if (in_ie[cnt] == authmode)
+		{
+			if ((authmode==_WPA_IE_ID_)&&(_memcmp(&in_ie[cnt+2], &wpa_oui[0], 4)==_TRUE))
+			{
+				_memcpy(&sec_ie[0], &in_ie[cnt], in_ie[cnt+1]+2);
+				match = _TRUE;
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("restruct_sec_ie: Get WPA IE from %d in_len=%d \n",cnt,in_len));
+				break;
+			}
+			if (authmode == _WPA2_IE_ID_)
+			{
+				_memcpy(&sec_ie[0], &in_ie[cnt], in_ie[cnt+1]+2);
+				match = _TRUE;
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("restruct_sec_ie: Get WPA2 IE from %d in_len=%d \n",cnt,in_len));
+				break;
+			}
+			if (((authmode==_WPA_IE_ID_)&&(_memcmp(&in_ie[cnt+2], &wpa_oui[0], 4)==_TRUE))||(authmode==_WPA2_IE_ID_))
+			{
+				_memcpy(&bkup_ie[0], &in_ie[cnt], in_ie[cnt+1]+2);
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("restruct_sec_ie: cnt=%d in_len=%d \n",cnt,in_len));
+			}
+		}
+
+		cnt += in_ie[cnt+1] + 2; //get next
+	}
+
+	//restruct WPA IE or WPA2 IE in sec_ie[ ]
+	if (match == _TRUE)
+	{
+		if(sec_ie[0]==_WPA_IE_ID_)
+		{
+			// parsing SSN IE to select required encryption algorithm, and set the bc/mc encryption algorithm
+			while (_TRUE)
+			{
+				if(_memcmp(&sec_ie[2], &wpa_oui[0], 4) !=_TRUE)//check wpa_oui tag
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE but doesn't has wpa_oui tag! \n"));
+					match=_FALSE;
+					break;
+				}
+
+				if((sec_ie[6]!=0x01) ||(sec_ie[7]!= 0x0))
+				{
+					//IE Ver error
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :IE version error (%.2x %.2x != 01 00 )! \n",sec_ie[6],sec_ie[7]));
+					match=_FALSE;
+					break;
+				}
+
+				if(_memcmp(&sec_ie[8], &wpa_oui[0], 3) ==_TRUE)
+				{
+					//get bc/mc encryption type (group key tyep)
+					switch(sec_ie[11])
+					{
+						case 0x0: //none
+							psecuritypriv->dot118021XGrpPrivacy=_NO_PRIVACY_;
+							break;
+						case 0x1: //WEP_40
+							psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+							break;
+						case 0x2: //TKIP
+							psecuritypriv->dot118021XGrpPrivacy=_TKIP_;
+							break;
+						case 0x3: //AESCCMP
+						case 0x4:
+							psecuritypriv->dot118021XGrpPrivacy=_AES_;
+							break;
+						case 0x5: //WEP_104
+							psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+							break;
+					}
+
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :Multicast error (%.2x %.2x %.2x %.2x != 00 50 F2 xx )! \n",
+									sec_ie[8],sec_ie[9],sec_ie[10],sec_ie[11]));
+					match =_FALSE;
+					break;
+				}
+
+				if(sec_ie[12]==0x01)
+				{
+					//check the unicast encryption type
+					if(_memcmp(&sec_ie[14], &uncst_oui[0], 4) !=_TRUE)
+					{
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :Unicast error (%.2x %.2x %.2x %.2x != 00 50 F2 %.2x )! \n",
+										sec_ie[14],sec_ie[15],sec_ie[16],sec_ie[17],uncst_oui[3]));
+						match =_FALSE;
+
+						break;
+
+					} //else the uncst_oui is match
+				}
+				else//mixed mode, unicast_enc_type > 1
+				{
+					//select the uncst_oui and remove the other uncst_oui
+					cnt=sec_ie[12];
+					remove_cnt=(cnt-1)*4;
+					sec_ie[12]=0x01;
+					_memcpy(&sec_ie[14], &uncst_oui[0], 4);
+
+					//remove the other unicast suit
+					_memcpy(&sec_ie[18], &sec_ie[18+remove_cnt],(sec_ie[1]-18+2-remove_cnt));
+					sec_ie[1]=sec_ie[1]-remove_cnt;
+				}
+
+				break;
+			}
+		}
+
+		if (authmode == _WPA2_IE_ID_)
+		{
+			// parsing RSN IE to select required encryption algorithm, and set the bc/mc encryption algorithm
+			while (_TRUE)
+			{
+				if((sec_ie[2]!=0x01)||(sec_ie[3]!= 0x0))
+				{
+					//IE Ver error
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n RSN IE :IE version error (%.2x %.2x != 01 00 )! \n",sec_ie[2],sec_ie[3]));
+					match=_FALSE;
+					break;
+				}
+
+				if(_memcmp(&sec_ie[4], &uncst_oui[0], 3) ==_TRUE)
+				{
+					//get bc/mc encryption type
+					switch(sec_ie[7])
+					{
+						case 0x1: //WEP_40
+							psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+							break;
+						case 0x2: //TKIP
+							psecuritypriv->dot118021XGrpPrivacy=_TKIP_;
+							break;
+						case 0x4: //AESWRAP
+							psecuritypriv->dot118021XGrpPrivacy=_AES_;
+							break;
+						case 0x5: //WEP_104
+							psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+							break;
+						default: //none
+							psecuritypriv->dot118021XGrpPrivacy=_NO_PRIVACY_;
+							break;
+					}
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n RSN IE :Multicast error (%.2x %.2x %.2x %.2x != 00 50 F2 xx )! \n",
+								sec_ie[4],sec_ie[5],sec_ie[6],sec_ie[7]));
+					match=_FALSE;
+					break;
+				}
+
+				if(sec_ie[8]==0x01)
+				{
+					//check the unicast encryption type
+					if(_memcmp(&sec_ie[10], &uncst_oui[0],4) !=_TRUE)
+					{
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :Unicast error (%.2x %.2x %.2x %.2x != 00 50 F2 xx )! \n",
+									sec_ie[10],sec_ie[11],sec_ie[12],sec_ie[13]));
+
+						match =_FALSE;
+						break;
+
+					} //else the uncst_oui is match
+				}
+				else //mixed mode, unicast_enc_type > 1
+				{
+					//select the uncst_oui and remove the other uncst_oui
+					cnt=sec_ie[8];
+					remove_cnt=(cnt-1)*4;
+					sec_ie[8]=0x01;
+					_memcpy( &sec_ie[10] , &uncst_oui[0],4 );
+
+					//remove the other unicast suit
+					_memcpy(&sec_ie[14],&sec_ie[14+remove_cnt],(sec_ie[1]-14+2-remove_cnt));
+					sec_ie[1]=sec_ie[1]-remove_cnt;
+				}
+
+				break;
+			}
+		}
+
+	}
+
+	if(psecuritypriv->wps_phase == _TRUE)
+	{
+		//DBG_8712("wps_phase == _TRUE\n");
+		_memcpy(out_ie, in_ie, 12);
+		ielength=12;
+
+		//Commented by Kurt 20110629
+		//In some older APs, WPS handshake
+		//would be failed if we append vender extensions informations to AP
+		_memcpy(out_ie+ielength, psecuritypriv->wps_ie, 14+2);
+		*( out_ie + ielength + 1 ) = 14;
+		ielength += 14+2;
+
+		psecuritypriv->wps_phase == _FALSE;
+	}
+	else if((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
+	{
+		//copy fixed ie
+		_memcpy(out_ie, in_ie,12);
+		ielength=12;
+
+		//copy RSN or SSN
+		if(match ==_TRUE)
+		{
+#ifdef CONFIG_IOCTL_CFG80211
+			//Commented by Kurt 20120308
+			//In nl80211, WPA IE length in EAPOL_KEY data would only be 22
+			//So we tailored the last two byte when WPA IE length is 24
+			if( ( authmode==_WPA_IE_ID_ ) && ( sec_ie[1] == 24 ) )
+			{
+				out_ie[ielength] = sec_ie[0];
+				out_ie[ielength+1] = sec_ie[1]-2;
+				_memcpy(&out_ie[ielength+2], &sec_ie[2], sec_ie[1]-2);
+				ielength+=sec_ie[1];
+			}
+			else
+#endif //CONFIG_IOCTL_CFG80211
+			{
+				_memcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1]+2);
+				ielength+=sec_ie[1]+2;
+
+				if(authmode==_WPA2_IE_ID_)
+				{
+					//the Pre-Authentication bit should be zero, john
+					out_ie[ielength-1]= 0;
+					out_ie[ielength-2]= 0;
+				}
+			}
+
+			report_sec_ie(adapter, authmode, sec_ie);
+
+#ifdef CONFIG_DRVEXT_MODULE
+			drvext_report_sec_ie(&adapter->drvextpriv, authmode, sec_ie);
+#endif
+
+		}
+
+	}
+	else
+	{
+		//_memcpy(&out_ie[0], &in_ie[0], in_len);
+		//ielength=in_len;
+
+		//copy fixed ie only
+		_memcpy(out_ie, in_ie, 12);
+		ielength=12;
+
+		if(psecuritypriv->wps_phase == _TRUE)
+		{
+			//DBG_8712("wps_phase == _TRUE\n");
+
+			_memcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);
+
+			ielength += psecuritypriv->wps_ie_len;
+		}
+	}
+
+	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
+	if(iEntry<0)
+	{
+		return ielength;
+	}
+	else
+	{
+		if (authmode == _WPA2_IE_ID_)
+		{
+			out_ie[ielength]=1;
+			ielength++;
+			out_ie[ielength]=0;	//PMKID count = 0x0100
+			ielength++;
+			_memcpy(&out_ie[ielength], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
+
+			ielength += 16;
+			out_ie[13] += 18;//PMKID length = 2+16
+		}
+	}
+
+	//report_sec_ie(adapter, authmode, sec_ie);
+
+_func_exit_;
+
+	return ielength;
+}
+
+void init_registrypriv_dev_network(_adapter *adapter)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct eeprom_priv *peepriv = &adapter->eeprompriv;
+	WLAN_BSSID_EX *pdev_network = &pregistrypriv->dev_network;
+	u8 *myhwaddr = myid(peepriv);
+
+_func_enter_;
+
+	_memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
+
+	_memcpy(&pdev_network->Ssid, &pregistrypriv->ssid, sizeof(NDIS_802_11_SSID));
+
+	pdev_network->Configuration.Length=sizeof(NDIS_802_11_CONFIGURATION);
+	pdev_network->Configuration.BeaconPeriod = 100;
+	pdev_network->Configuration.FHConfig.Length = 0;
+	pdev_network->Configuration.FHConfig.HopPattern = 0;
+	pdev_network->Configuration.FHConfig.HopSet = 0;
+	pdev_network->Configuration.FHConfig.DwellTime = 0;
+
+
+_func_exit_;
+
+}
+
+void update_registrypriv_dev_network(_adapter* adapter)
+{
+	int sz = 0;
+	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
+	WLAN_BSSID_EX		*pdev_network = &pregistrypriv->dev_network;
+	struct security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
+	struct xmit_priv	*pxmitpriv = &adapter->xmitpriv;
+
+_func_enter_;
+
+#if 0
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+
+	adapter->qospriv.qos_option = pregistrypriv->wmm_enable;
+#endif
+
+	pdev_network->Privacy = cpu_to_le32(psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ; // adhoc no 802.1x
+
+	pdev_network->Rssi = 0;
+
+	switch (pregistrypriv->wireless_mode)
+	{
+		case WIRELESS_11B:
+			pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11DS);
+			break;
+		case WIRELESS_11G:
+		case WIRELESS_11BG:
+			pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11OFDM24);
+			break;
+		case WIRELESS_11A:
+			pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11OFDM5);
+			break;
+		default :
+			// TODO
+			break;
+	}
+
+	pdev_network->Configuration.DSConfig = cpu_to_le32(pregistrypriv->channel);
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n", pregistrypriv->channel, pdev_network->Configuration.DSConfig));
+
+	if (cur_network->network.InfrastructureMode == Ndis802_11IBSS)
+		pdev_network->Configuration.ATIMWindow = cpu_to_le32(3);
+
+	pdev_network->InfrastructureMode = cpu_to_le32(cur_network->network.InfrastructureMode);
+
+	// 1. Supported rates
+	// 2. IE
+
+	//set_supported_rate(pdev_network->SupportedRates, pregistrypriv->wireless_mode) ; // will be called in generate_ie
+	sz = generate_ie(pregistrypriv);
+
+	pdev_network->IELength = sz;
+
+	pdev_network->Length = get_NDIS_WLAN_BSSID_EX_sz((NDIS_WLAN_BSSID_EX *)pdev_network);
+
+	//notes: translate IELength & Length after assign the Length to cmdsz in createbss_cmd();
+	//pdev_network->IELength = cpu_to_le32(sz);
+
+_func_exit_;
+
+}
+
+void get_encrypt_decrypt_from_registrypriv(	_adapter* adapter)
+{
+	u16	wpaconfig=0;
+	struct registry_priv* pregistrypriv = &adapter->registrypriv;
+	struct security_priv* psecuritypriv= &adapter->securitypriv;
+_func_enter_;
+
+
+_func_exit_;
+
+}
+
+//the fucntion is at passive_level
+void joinbss_reset(_adapter *padapter)
+{
+	int i;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+
+#ifdef CONFIG_80211N_HT
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+#endif
+
+	//todo: if you want to do something io/reg/hw setting before join_bss, please add code here
+
+
+
+
+#ifdef CONFIG_80211N_HT
+
+	phtpriv->ampdu_enable = _FALSE;//reset to disabled
+
+	for(i=0; i<16; i++)
+	{
+		phtpriv->baddbareq_issued[i] = _FALSE;//reset it
+	}
+
+	if(phtpriv->ht_option)
+	{
+
+#ifdef CONFIG_USB_HCI
+		//validate  usb rx aggregation
+		//printk("joinbss_reset():validate  usb rx aggregation\n");
+		if (pregistrypriv->wifi_test == 1)
+		{
+			write8(padapter, 0x102500D9, 1);// TH=1 => means that invalidate usb rx aggregation
+		}
+		else
+		{
+		write8(padapter, 0x102500D9, 48);//TH = 48 pages, 6k
+		}
+#endif
+
+	}
+	else
+	{
+
+#ifdef CONFIG_USB_HCI
+	//invalidate  usb rx aggregation
+	write8(padapter, 0x102500D9, 1);// TH=1 => means that invalidate usb rx aggregation
+#endif
+
+	}
+
+#endif
+
+}
+
+
+#ifdef CONFIG_80211N_HT
+
+//the fucntion is >= passive_level
+unsigned int restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len)
+{
+	u32 ielen, out_len;
+	unsigned char *p, *pframe;
+	struct rtw_ieee80211_ht_cap ht_capie;
+	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv   	*pqospriv= &pmlmepriv->qospriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+
+	phtpriv->ht_option = 0;
+
+	p = get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
+
+	if (p && (ielen>0))
+	{
+		if (pqospriv->qos_option == 0)
+		{
+			out_len = *pout_len;
+			pframe = set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_,
+								_WMM_IE_Length_, WMM_IE, pout_len);
+
+			pqospriv->qos_option = 1;
+		}
+
+		out_len = *pout_len;
+
+		_memset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));
+
+		ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |IEEE80211_HT_CAP_SGI_20 |
+							IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_TX_STBC |
+							IEEE80211_HT_CAP_MAX_AMSDU | IEEE80211_HT_CAP_DSSSCCK40;
+
+		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03) |
+										(IEEE80211_HT_CAP_AMPDU_DENSITY&0x00) ;
+
+		pframe = set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,
+							sizeof(struct rtw_ieee80211_ht_cap), (unsigned char*)&ht_capie, pout_len);
+
+		//_memcpy(out_ie+out_len, p, ielen+2);//gtest
+		//*pout_len = *pout_len + (ielen+2);
+
+		phtpriv->ht_option = 1;
+	}
+
+	return (phtpriv->ht_option);
+}
+
+//the fucntion is > passive_level (in critical_section)
+void update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len)
+{
+	u8 *p, max_ampdu_sz;
+	int i, len;
+	struct sta_info *bmc_sta, *psta;
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	struct ieee80211_ht_addt_info *pht_addtinfo;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct wlan_network *pcur_network = &(pmlmepriv->cur_network);
+
+
+	if(!phtpriv->ht_option)
+		return;
+
+
+	//printk("+update_ht_cap()\n");
+
+	//maybe needs check if ap supports rx ampdu.
+	if((phtpriv->ampdu_enable==_FALSE) &&(pregistrypriv->ampdu_enable==1))
+	{
+		if (pregistrypriv->wifi_test == 1)
+		{
+			phtpriv->ampdu_enable = _FALSE;
+		}
+		else
+		{	
+			phtpriv->ampdu_enable = _TRUE;
+		}
+	}
+
+
+	//check Max Rx A-MPDU Size
+	len = 0;
+	p = get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_CAPABILITY_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
+	if(p && len>0)
+	{
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		max_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
+		max_ampdu_sz = 1 << (max_ampdu_sz+3); // max_ampdu_sz (kbytes);
+
+		//printk("update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz);
+		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
+
+	}
+
+	//for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
+	//if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff
+	//todo: check if AP can send A-MPDU packets
+	bmc_sta = get_bcmc_stainfo(padapter);
+	if(bmc_sta)
+	{
+		for(i=0; i < 16 ; i++)
+		{
+			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+			preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;
+			preorder_ctrl->enable = _FALSE;
+			//preorder_ctrl->wsize_b = max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+		}
+	}
+
+	psta = get_stainfo(&padapter->stapriv, pcur_network->network.MacAddress);
+	if(psta)
+	{
+		for(i=0; i < 16 ; i++)
+		{
+			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;
+			preorder_ctrl->enable = _FALSE;
+			//preorder_ctrl->wsize_b = max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+		}
+	}
+
+	len=0;
+	p = get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_ADD_INFO_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
+	if(p && len>0)
+	{
+		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p+2);
+	}
+
+}
+
+void issue_addbareq_cmd(_adapter *padapter, int priority)
+{
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv	 *phtpriv = &pmlmepriv->htpriv;
+
+	if((phtpriv->ht_option==1) && (phtpriv->ampdu_enable==_TRUE))
+	{
+		if(phtpriv->baddbareq_issued[priority] == _FALSE)
+		{
+			addbareq_cmd(padapter,(u8) priority);
+
+			phtpriv->baddbareq_issued[priority] = _TRUE;
+		}
+	}
+
+}
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/mp/rtl871x_mp.c b/drivers/net/wireless/8712u/mp/rtl871x_mp.c
new file mode 100755
index 0000000..f45bc01
--- /dev/null
+++ b/drivers/net/wireless/8712u/mp/rtl871x_mp.c
@@ -0,0 +1,1523 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_MP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <rtl871x_mp_phy_regdef.h>
+#include <rtl8712_cmd.h>
+
+#ifdef CONFIG_MP_INCLUDED
+
+static void _init_mp_priv_(struct mp_priv *pmp_priv)
+{
+	pmp_priv->mode = _LOOPBOOK_MODE_;
+
+	pmp_priv->curr_ch = 1;
+	pmp_priv->curr_modem = MIXED_PHY;
+	pmp_priv->curr_rateidx = 0;
+	pmp_priv->curr_txpoweridx = 0x14;
+
+	pmp_priv->antenna_tx = ANTENNA_A;
+	pmp_priv->antenna_rx = ANTENNA_AB;
+
+	pmp_priv->check_mp_pkt = 0;
+
+	pmp_priv->tx_pktcount = 0;
+
+	pmp_priv->rx_pktcount = 0;
+	pmp_priv->rx_crcerrpktcount = 0;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+/*
+void mp_wi_callback(
+	IN NDIS_WORK_ITEM*	pwk_item,
+	IN PVOID			cntx
+	)
+{
+	_adapter* padapter =(_adapter *)cntx;
+	struct mp_priv *pmppriv=&padapter->mppriv;
+	struct mp_wi_cntx	*pmp_wi_cntx=&pmppriv->wi_cntx;
+
+	// Execute specified action.
+	if(pmp_wi_cntx->curractfunc != NULL)
+	{
+		LARGE_INTEGER	cur_time;
+		ULONGLONG start_time, end_time;
+		NdisGetCurrentSystemTime(&cur_time);	// driver version
+		start_time = cur_time.QuadPart/10; // The return value is in microsecond
+
+		pmp_wi_cntx->curractfunc(padapter);
+
+		NdisGetCurrentSystemTime(&cur_time);	// driver version
+		end_time = cur_time.QuadPart/10; // The return value is in microsecond
+
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+			 ("WorkItemActType: %d, time spent: %I64d us\n",
+			  pmp_wi_cntx->param.act_type, (end_time-start_time)));
+	}
+
+	NdisAcquireSpinLock(&(pmp_wi_cntx->mp_wi_lock));
+	pmp_wi_cntx->bmp_wi_progress= _FALSE;
+	NdisReleaseSpinLock(&(pmp_wi_cntx->mp_wi_lock));
+
+	if (pmp_wi_cntx->bmpdrv_unload)
+	{
+		NdisSetEvent(&(pmp_wi_cntx->mp_wi_evt));
+	}
+
+}
+*/
+
+int init_mp_priv (struct mp_priv *pmp_priv)
+{
+	struct wlan_network *pnetwork = &pmp_priv->mp_network;
+	struct mp_wi_cntx *pmp_wi_cntx = &pmp_priv->wi_cntx;
+
+	_init_mp_priv_(pmp_priv);
+
+	pmp_priv->network_macaddr[0] = 0x00;
+	pmp_priv->network_macaddr[1] = 0xE0;
+	pmp_priv->network_macaddr[2] = 0x4C;
+	pmp_priv->network_macaddr[3] = 0x87;
+	pmp_priv->network_macaddr[4] = 0x66;
+	pmp_priv->network_macaddr[5] = 0x55;
+
+	pnetwork->network.MacAddress[0] = 0x00;
+	pnetwork->network.MacAddress[1] = 0xE0;
+	pnetwork->network.MacAddress[2] = 0x4C;
+	pnetwork->network.MacAddress[3] = 0x87;
+	pnetwork->network.MacAddress[4] = 0x66;
+	pnetwork->network.MacAddress[5] = 0x55;
+
+	pnetwork->network.Ssid.SsidLength = 8;
+	_memcpy(pnetwork->network.Ssid.Ssid, "mp_871x", pnetwork->network.Ssid.SsidLength);
+
+	pmp_priv->rx_testcnt = 0;
+	pmp_priv->rx_testcnt1 = 0;
+	pmp_priv->rx_testcnt2 = 0;
+
+	pmp_priv->tx_testcnt = 0;
+	pmp_priv->tx_testcnt1 = 0;
+
+	pmp_wi_cntx->bmpdrv_unload = _FALSE;
+	pmp_wi_cntx->bmp_wi_progress = _FALSE;
+	pmp_wi_cntx->curractfunc = NULL;
+
+	return _SUCCESS;
+}
+#endif
+
+#ifdef PLATFORM_LINUX
+int init_mp_priv(struct mp_priv *pmp_priv)
+{
+	int i, res;
+	struct mp_xmit_frame *pmp_xmitframe;
+
+	//MSG_8712("+_init_mp_priv\n");
+
+	_init_mp_priv_(pmp_priv);
+
+	_init_queue(&pmp_priv->free_mp_xmitqueue);
+
+	pmp_priv->pallocated_mp_xmitframe_buf = NULL;
+	pmp_priv->pallocated_mp_xmitframe_buf = _vmalloc(NR_MP_XMITFRAME * sizeof(struct mp_xmit_frame) + 4);
+	if (pmp_priv->pallocated_mp_xmitframe_buf == NULL) {
+		//ERR_8712("_init_mp_priv, alloc mp_xmitframe_buf fail\n");
+		res = _FAIL;
+		goto _exit_init_mp_priv;
+	}
+
+	pmp_priv->pmp_xmtframe_buf = pmp_priv->pallocated_mp_xmitframe_buf + 4 - ((uint) (pmp_priv->pallocated_mp_xmitframe_buf) & 3);
+
+	pmp_xmitframe = (struct mp_xmit_frame*)pmp_priv->pmp_xmtframe_buf;
+
+	for (i = 0; i < NR_MP_XMITFRAME; i++)
+	{
+		_init_listhead(&(pmp_xmitframe->list));
+		list_insert_tail(&(pmp_xmitframe->list), &(pmp_priv->free_mp_xmitqueue.queue));
+
+		pmp_xmitframe->pkt = NULL;
+		pmp_xmitframe->frame_tag = MP_FRAMETAG;
+		pmp_xmitframe->padapter = pmp_priv->papdater;
+
+		pmp_xmitframe++;
+	}
+
+	pmp_priv->free_mp_xmitframe_cnt = NR_MP_XMITFRAME;
+
+	res = _SUCCESS;
+
+_exit_init_mp_priv:
+
+	return res;
+}
+
+int free_mp_priv(struct mp_priv *pmp_priv)
+{
+	int res = 0;
+
+	//MSG_8712("+_free_mp_priv\n");
+
+	if (pmp_priv->pallocated_mp_xmitframe_buf)
+		_vmfree(pmp_priv->pallocated_mp_xmitframe_buf, NR_MP_XMITFRAME * sizeof(struct mp_xmit_frame) + 4);
+
+	return res;
+}
+#endif
+
+void mp871xinit(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	pmppriv->papdater = padapter;
+
+	init_mp_priv(pmppriv);
+}
+
+
+void mp871xdeinit(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+
+	free_mp_priv(pmppriv);
+}
+
+
+void _irqlevel_changed_(_irqL *irqlevel, u8 bLower)
+{
+
+#ifdef PLATFORM_OS_XP
+
+	if (bLower == LOWER) {
+		*irqlevel = KeGetCurrentIrql();
+
+		if (*irqlevel > PASSIVE_LEVEL) {
+				KeLowerIrql(PASSIVE_LEVEL);
+			//DEBUG_ERR(("\n <=== KeLowerIrql.\n"));
+		}
+	} else {
+		if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
+			KeRaiseIrql(DISPATCH_LEVEL, irqlevel);
+			//DEBUG_ERR(("\n <=== KeRaiseIrql.\n"));
+		}
+	}
+
+#endif
+
+}
+
+/*
+ * Special for bb and rf reg read/write
+ */
+static u32 fw_iocmd_read(PADAPTER pAdapter, IOCMD_STRUCT iocmd)
+{
+	u32 cmd32 = 0, val32 = 0;
+
+	u8 iocmd_class	= iocmd.cmdclass;
+	u16 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+//	RT_TRACE(_module_rtl871x_mp_c_, _drv_alert_, ("fw_iocmd_read = cmd32:%x ........\n",cmd32));
+
+	if (fw_cmd(pAdapter, cmd32))
+		fw_cmd_data(pAdapter, &val32, 1);
+	else
+		val32 = 0;
+
+	return val32;
+}
+
+static u8 fw_iocmd_write(PADAPTER pAdapter, IOCMD_STRUCT iocmd, u32 value)
+{
+	u32 cmd32 = 0;
+
+	u8 iocmd_class	= iocmd.cmdclass;
+	u32 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	fw_cmd_data(pAdapter, &value, 0);
+	usleep_os(100);
+
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+	return fw_cmd(pAdapter, cmd32);
+}
+
+u32 bb_reg_read(PADAPTER pAdapter, u16 offset)// offset : 0X800~0XFFF
+{
+	u8 shift = offset & 0x0003;	// 4 byte access
+	u16 bb_addr = offset & 0x0FFC;	// 4 byte access
+	u32 bb_val = 0;
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_READ_IDX;
+	bb_val = fw_iocmd_read(pAdapter, iocmd);
+
+	if (shift != 0) {
+		u32 bb_val2 = 0;
+		bb_val >>= (shift * 8);
+		iocmd.value += 4;
+		bb_val2 = fw_iocmd_read(pAdapter, iocmd);
+		bb_val2 <<= ((4 - shift) * 8);
+		bb_val |= bb_val2;
+	}
+
+	return bb_val;
+}
+
+u8 bb_reg_write(PADAPTER pAdapter, u16 offset, u32 value)// offset : 0X800~0XFFF
+{
+	u8 shift = offset & 0x0003;	// 4 byte access
+	u16 bb_addr = offset & 0x0FFC;	// 4 byte access
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_WRITE_IDX;
+
+	if (shift != 0) {
+		u32 oldValue = 0;
+		u32 newValue = value;
+
+		oldValue = bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF >> ((4 - shift) * 8));
+		value = oldValue | (newValue << (shift * 8));
+		if (fw_iocmd_write(pAdapter, iocmd, value) == _FALSE)
+			return _FALSE;
+
+		iocmd.value += 4;
+		oldValue = bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF << (shift * 8));
+		value = oldValue | (newValue >> ((4 - shift) * 8));
+	}
+
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+u32 rf_reg_read(PADAPTER pAdapter, u8 path, u8 offset) // offset : 0x00 ~ 0xFF
+{
+	u16 rf_addr = (path << 8) | offset;
+	u32 rf_data;
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF ;
+	iocmd.value	= rf_addr ;
+	iocmd.index	= IOCMD_RF_READ_IDX;
+
+	rf_data = fw_iocmd_read(pAdapter,iocmd);
+
+	return rf_data;
+}
+
+u8 rf_reg_write(PADAPTER pAdapter, u8 path, u8 offset, u32 value)
+{
+	u16 rf_addr = (path << 8) | offset;
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= rf_addr;
+	iocmd.index	= IOCMD_RF_WRIT_IDX;
+
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1) break;
+
+	return i;
+}
+
+u32 get_bb_reg(PADAPTER pAdapter, u16 offset, u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+
+	org_value = bb_reg_read(pAdapter ,offset);
+	bit_shift = bitshift(bitmask);
+//	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("get_bb_reg: org=0x%08x\n", org_value));
+	new_value = (org_value & bitmask) >> bit_shift;
+
+	return new_value;
+}
+
+u8 set_bb_reg(PADAPTER pAdapter, u16 offset, u32 bitmask, u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = bb_reg_read(pAdapter ,offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_,
+			 ("set_bb_reg: offset=0x%04x org=0x%08x new=0x%08x\n",
+			  offset, org_value, new_value));
+	} else {
+		new_value = value;
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_,
+			 ("set_bb_reg: offset=0x%04x value=0x%08x\n",
+			  offset, new_value));
+	}
+
+	return bb_reg_write(pAdapter,offset,new_value);
+}
+
+u32 get_rf_reg(PADAPTER pAdapter, u8 path, u8 offset, u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+	org_value = rf_reg_read(pAdapter, path, offset);
+	bit_shift = bitshift(bitmask);
+	new_value = (org_value & bitmask) >> bit_shift;
+
+	return new_value;
+}
+
+u8 set_rf_reg(PADAPTER pAdapter, u8 path, u8 offset, u32 bitmask, u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = rf_reg_read(pAdapter, path, offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("set_rf_reg: v=0x%08x org=0x%08x new=0x%08x\n", value, org_value, new_value));
+	} else {
+		new_value = value;
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("set_rf_reg: v=0x%08x new=0x%08x\n", value, new_value));
+	}
+
+	return rf_reg_write(pAdapter, path, offset, new_value);
+}
+
+/*
+ * SetChannel
+ * Description
+ *	Use H2C command to change channel,
+ *	not only modify rf register, but also other setting need to be done.
+ */
+void SetChannel(PADAPTER pAdapter)
+{
+#if 1
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetChannel_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetChannel);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+SetChannel: %d\n", pAdapter->mppriv.curr_ch));
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetChannel: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetChannel_parm*)_malloc(sizeof(struct SetChannel_parm));
+ 	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetChannel: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_ch = pAdapter->mppriv.curr_ch;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+#else
+	u32 curr_ch = pAdapter->mppriv.curr_ch;
+	u8 eRFPath;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("+SetChannel: %d\n", curr_ch));
+	for (eRFPath = 0; eRFPath < MAX_RF_PATH_NUMS; eRFPath++) {
+		set_rf_reg(pAdapter, eRFPath, rRfChannel, 0x3FF, curr_ch);
+		usleep_os(100);
+	}
+#endif
+}
+
+void SetCCKTxPower(PADAPTER pAdapter, u8 TxPower)
+{
+	u16 TxAGC = 0;
+
+	TxAGC = TxPower;
+	set_bb_reg(pAdapter, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-SetCCKTxPower: %d\n", TxPower));
+}
+
+void SetOFDMTxPower(PADAPTER pAdapter, u8 TxPower)
+{
+	u32 TxAGC = 0;
+
+	TxAGC |= ((TxPower<<24)|(TxPower<<16)|(TxPower<<8)|TxPower);
+
+	set_bb_reg(pAdapter, rTxAGC_Rate18_06, bTxAGCRate18_06, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Rate54_24, bTxAGCRate54_24, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs03_Mcs00, bTxAGCRateMCS3_MCS0, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs07_Mcs04, bTxAGCRateMCS7_MCS4, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs11_Mcs08, bTxAGCRateMCS11_MCS8, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs15_Mcs12, bTxAGCRateMCS15_MCS12, TxAGC);
+	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("-SetOFDMTxPower: %d\n", TxPower));
+}
+
+void SetTxPower(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetTxPower_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetTxPower);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("-SetTxPower: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetTxPower_parm*)_malloc(sizeof(struct SetTxPower_parm));
+ 	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("-SetTxPower: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->TxPower = pAdapter->mppriv.curr_txpoweridx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+#else
+
+	u8 TxPower = pAdapter->mppriv.curr_txpoweridx;
+#if 0
+	if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M)
+	{
+		SetCCKTxPower( pAdapter,TxPower);
+	}
+	else if ((pAdapter->mppriv.curr_rateidx>= MPT_RATE_6M) &&
+		 (pAdapter->mppriv.curr_rateidx<= MPT_RATE_MCS15))
+	{
+		SetOFDMTxPower(pAdapter,TxPower);
+	}
+#else
+	SetCCKTxPower(pAdapter, TxPower);
+	SetOFDMTxPower(pAdapter, TxPower);
+#endif
+#endif
+}
+
+void SetTxAGCOffset(PADAPTER pAdapter, u32 ulTxAGCOffset)
+{
+	u32 TxAGCOffset_B, TxAGCOffset_C, TxAGCOffset_D,tmpAGC;
+
+	TxAGCOffset_B = (ulTxAGCOffset&0x000000ff);
+	TxAGCOffset_C = ((ulTxAGCOffset&0x0000ff00)>>8);
+	TxAGCOffset_D = ((ulTxAGCOffset&0x00ff0000)>>16);
+
+	tmpAGC = (TxAGCOffset_D<<8 | TxAGCOffset_C<<4 | TxAGCOffset_B);
+	set_bb_reg(pAdapter, rFPGA0_TxGainStage,
+			(bXBTxAGC|bXCTxAGC|bXDTxAGC), tmpAGC);
+}
+
+void SetDataRate(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+#if 1
+	setdatarate_cmd(pAdapter, &pAdapter->mppriv.curr_rateidx)
+#else
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct setdatarate_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetDataRate);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetDataRate: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct setdatarate_parm*)_malloc(sizeof(struct setdatarate_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetDataRate: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_rateidx = pAdapter->mppriv.curr_rateidx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+#endif
+#else
+	u8 path = RF_PATH_A;
+	u8 offset = 0x26;
+	u32 value;
+	value = (pAdapter->mppriv.curr_rateidx < 4) ? 0x4440 : 0xF200;
+
+	rf_reg_write(pAdapter, path, offset, value);
+#endif
+}
+
+void SwitchBandwidth(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SwitchBandwidth_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SwitchBandwidth);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchBandwidth: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SwitchBandwidth_parm*)_malloc(sizeof(struct SwitchBandwidth_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchBandwidth: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_bandwidth = pAdapter->mppriv.curr_bandwidth;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+	//3 1.Set MAC register : BWOPMODE  bit2:1 20MhzBW
+	u8 regBwOpMode = 0;
+	u8 Bandwidth = pAdapter->mppriv.curr_bandwidth;
+
+	regBwOpMode = read8(pAdapter, 0x10250203);
+
+	if (Bandwidth == HT_CHANNEL_WIDTH_20) {
+		regBwOpMode |= BIT(2);
+	} else {
+		regBwOpMode &= ~(BIT(2));
+	}
+	write8(pAdapter, 0x10250203, regBwOpMode);
+
+	//3 2.Set PHY related register
+	switch (Bandwidth)
+	{
+		/* 20 MHz channel*/
+		case HT_CHANNEL_WIDTH_20:
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+			set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+
+			// Use PHY_REG.txt default value. Do not need to change.
+			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
+			// It is set in Tx descriptor for 8192x series
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter1, bMaskDWord, 0x1a1b0000);
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter2, bMaskDWord, 0x090e1317);
+			//PHY_SetBBReg(Adapter, rCCK0_DebugPort, bMaskDWord, 0x00000204);
+			// From SD3 WHChang
+			//PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter1, 0x00300000, 3);
+			set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x58);
+
+			break;
+
+		/* 40 MHz channel*/
+		case HT_CHANNEL_WIDTH_40:
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+			set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+
+			// Use PHY_REG.txt default value. Do not need to change.
+			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter1, bMaskDWord, 0x35360000);
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter2, bMaskDWord, 0x121c252e);
+			//PHY_SetBBReg(Adapter, rCCK0_DebugPort, bMaskDWord, 0x00000409);
+			// From SD3 WHChang
+			//PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter1, 0x00300000, 3);
+
+			// Set Control channel to upper or lower. These settings are required only for 40MHz
+			set_bb_reg(pAdapter, rCCK0_System, bCCKSideBand, (HAL_PRIME_CHNL_OFFSET_DONT_CARE>>1));
+			set_bb_reg(pAdapter, rOFDM1_LSTF, 0xC00, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+
+			set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x18);
+
+			break;
+		default:
+			break;
+	}
+
+	//3 3.Set RF related register
+	switch (Bandwidth)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW, BIT(10)|BIT(11), 0x01);
+			break;
+
+		case HT_CHANNEL_WIDTH_40:
+			set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW, BIT(10)|BIT(11), 0x00);
+			break;
+
+		default:
+			break;
+	}
+#endif
+}
+/*------------------------------Define structure----------------------------*/
+typedef struct _R_ANTENNA_SELECT_OFDM {
+	u32	r_tx_antenna:4;
+	u32	r_ant_l:4;
+	u32	r_ant_non_ht:4;
+	u32	r_ant_ht1:4;
+	u32	r_ant_ht2:4;
+	u32	r_ant_ht_s1:4;
+	u32	r_ant_non_ht_s1:4;
+	u32	OFDM_TXSC:2;
+	u32	Reserved:2;
+}R_ANTENNA_SELECT_OFDM;
+
+typedef struct _R_ANTENNA_SELECT_CCK {
+	u8	r_cckrx_enable_2:2;
+	u8	r_cckrx_enable:2;
+	u8	r_ccktx_enable:4;
+}R_ANTENNA_SELECT_CCK;
+
+void SwitchAntenna(PADAPTER pAdapter)
+{
+//#ifdef MP_FIRMWARE_OFFLOAD
+#if 0
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SwitchAntenna_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SwitchAntenna);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchAntenna: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SwitchAntenna_parm*)_malloc(sizeof(struct SwitchAntenna_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchAntenna: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->antenna_tx = pAdapter->mppriv.antenna_tx;
+	pparm->antenna_rx = pAdapter->mppriv.antenna_rx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+#else
+	u32	ofdm_tx_en_val = 0, ofdm_tx_ant_sel_val = 0;
+	u8	ofdm_rx_ant_sel_val = 0;
+	u8	cck_ant_select_val = 0;
+	u32	cck_ant_sel_val = 0;
+
+	R_ANTENNA_SELECT_CCK *p_cck_txrx;
+
+
+	p_cck_txrx = (R_ANTENNA_SELECT_CCK*)&cck_ant_select_val;
+
+	switch (pAdapter->mppriv.antenna_tx)
+	{
+		case ANTENNA_A:
+			// From SD3 Willis suggestion !!! Set RF A=TX and B as standby
+			set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+			set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 1);
+
+			ofdm_tx_en_val			= 0x3;
+			ofdm_tx_ant_sel_val		= 0x11111111;// Power save
+
+			p_cck_txrx->r_ccktx_enable	= 0x8;
+			break;
+
+		case ANTENNA_B:
+			set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 1);
+			set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+
+			ofdm_tx_en_val			= 0x3;
+			ofdm_tx_ant_sel_val		= 0x22222222;// Power save
+
+			p_cck_txrx->r_ccktx_enable	= 0x4;
+			break;
+
+		case ANTENNA_AB:	// For 8192S
+			set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+			set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+
+			ofdm_tx_en_val			= 0x3;
+			ofdm_tx_ant_sel_val		= 0x3321333;	// Disable Power save
+
+			p_cck_txrx->r_ccktx_enable	= 0xC;
+			break;
+
+		default:
+			break;
+	}
+	set_bb_reg(pAdapter, rFPGA1_TxInfo, 0xffffffff, ofdm_tx_ant_sel_val);	//OFDM Tx
+	set_bb_reg(pAdapter, rFPGA0_TxInfo, 0x0000000f, ofdm_tx_en_val);	//OFDM Tx
+
+	switch (pAdapter->mppriv.antenna_rx)
+	{
+		case ANTENNA_A:
+			ofdm_rx_ant_sel_val		= 0x1;	// A
+			p_cck_txrx->r_cckrx_enable 	= 0x0;	// default: A
+			p_cck_txrx->r_cckrx_enable_2	= 0x0;	// option: A
+			break;
+
+		case ANTENNA_B:
+			ofdm_rx_ant_sel_val		= 0x2;	// B
+			p_cck_txrx->r_cckrx_enable 	= 0x1;	// default: B
+			p_cck_txrx->r_cckrx_enable_2	= 0x1;	// option: B
+			break;
+
+		case ANTENNA_AB:
+			ofdm_rx_ant_sel_val		= 0x3;	// AB
+			p_cck_txrx->r_cckrx_enable 	= 0x0;	// default:A
+			p_cck_txrx->r_cckrx_enable_2	= 0x1;	// option:B
+			break;
+
+		default:
+			break;
+	}
+	set_bb_reg(pAdapter, rOFDM0_TRxPathEnable, 0x0000000f, ofdm_rx_ant_sel_val);	//OFDM Rx
+	set_bb_reg(pAdapter, rOFDM1_TRxPathEnable, 0x0000000f, ofdm_rx_ant_sel_val);	//OFDM Rx
+
+	cck_ant_sel_val = cck_ant_select_val;
+	set_bb_reg(pAdapter, rCCK0_AFESetting, bMaskByte3, cck_ant_sel_val);		//CCK TxRx
+#endif
+
+	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("-SwitchAntenna: finished\n"));
+}
+
+void SetCrystalCap(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetCrystalCap_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetCrystalCap);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetCrystalCap: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetCrystalCap_parm*)_malloc(sizeof(struct SetCrystalCap_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetCrystalCap: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_crystalcap = pAdapter->mppriv.curr_crystalcap;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+#else
+	set_bb_reg(pAdapter, rFPGA0_AnalogParameter1, bXtalCap, pAdapter->mppriv.curr_crystalcap);
+	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("-SetCrystalCap: %d\n", pAdapter->mppriv.curr_crystalcap));
+#endif
+}
+
+void TriggerRFThermalMeter(PADAPTER pAdapter)
+{
+	set_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);	// 0x24: RF Reg[6:5]
+//	RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("TriggerRFThermalMeter() finished.\n" ));
+}
+
+u32 ReadRFThermalMeter(PADAPTER pAdapter)
+{
+	u32 ThermalValue = 0;
+
+	ThermalValue = get_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, 0x1F);	// 0x24: RF Reg[4:0]
+//	RT_TRACE(_module_rtl871x_mp_c_, _drv_alert_, ("ThermalValue = 0x%x\n", ThermalValue));
+	return ThermalValue;
+}
+
+void GetThermalMeter(PADAPTER pAdapter, u32 *value)
+{
+#if 0
+	fw_cmd(pAdapter, IOCMD_GET_THERMAL_METER);
+	msleep_os(1000);
+	fw_cmd_data(pAdapter, value, 1);
+	*value &= 0xFF;
+#else
+	TriggerRFThermalMeter(pAdapter);
+	msleep_os(1000);
+	*value = ReadRFThermalMeter(pAdapter);
+#endif
+}
+
+void SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetSingleCarrierTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetSingleCarrierTx);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleCarrierTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetSingleCarrierTx_parm*)_malloc(sizeof(struct SetSingleCarrierTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleCarrierTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+
+	if (bStart)// Start Single Carrier.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleCarrierTx test start.........\n"));
+		// 1. if OFDM block on?
+		if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
+
+		// 2. set CCK test mode off, set to CCK normal mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+
+		// 3. turn on scramble setting
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+
+		// 4. Turn On Continue Tx and turn off the other test modes.
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	}
+	else// Stop Single Carrier.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleCarrierTx test stop.........\n"));
+		//Turn off all test modes.
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+
+		//Delay 10 ms //delay_ms(10);
+		msleep_os(10);
+
+		//BB Reset
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+#endif
+}
+
+void SetSingleToneTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetSingleToneTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetSingleToneTx);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleToneTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetSingleToneTx_parm*)_malloc(sizeof(struct SetSingleToneTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleToneTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+	switch (pAdapter->mppriv.antenna_tx)
+	{
+		case ANTENNA_B:
+			pparm->curr_rfpath = RF_PATH_B;
+			break;
+		case ANTENNA_A:
+		default:
+			pparm->curr_rfpath = RF_PATH_A;
+			break;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+	u8 rfPath = pAdapter->mppriv.curr_rfpath;
+
+	switch (pAdapter->mppriv.antenna_tx)
+	{
+		case ANTENNA_B:
+			rfPath = RF_PATH_B;
+			break;
+		case ANTENNA_A:
+		default:
+			rfPath = RF_PATH_A;
+			break;
+	}
+
+	if (bStart)// Start Single Tone.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleToneTx test start.........\n"));
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x0);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x0);
+		//set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMTxDACPhase, 0x1);
+
+		set_rf_reg(pAdapter, rfPath, 0x21, bRFRegOffsetMask, 0xd4000);
+		usleep_os(100);
+		set_rf_reg(pAdapter, rfPath, 0x00, bRFRegOffsetMask, 0x2001f); // PAD all on.
+		usleep_os(100);
+	}
+	else// Stop Single Tone.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleToneTx test stop.........\n"));
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x1);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x1);
+		//set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMTxDACPhase, 0x1);
+		set_rf_reg(pAdapter, rfPath, 0x21, bRFRegOffsetMask, 0x54000);
+		usleep_os(100);
+		set_rf_reg(pAdapter, rfPath, 0x00, bRFRegOffsetMask, 0x30000); // PAD all on.
+		usleep_os(100);
+	}
+#endif
+}
+
+void SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetCarrierSuppressionTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetCarrierSuppressionTx);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleToneTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetCarrierSuppressionTx_parm*)_malloc(sizeof(struct SetCarrierSuppressionTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetCarrierSuppressionTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+	pparm->curr_rateidx = pAdapter->mppriv.curr_rateidx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+
+	if (bStart) // Start Carrier Suppression.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCarrierSuppressionTx test start.........\n"));
+		//if(pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M) {
+			// 1. if CCK block on?
+			if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+				set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
+
+			//Turn Off All Test Mode
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);    //transmit mode
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x0);  //turn off scramble setting
+
+			//Set CCK Tx Test Rate
+			//PHY_SetBBReg(pAdapter, rCCK0_System, bCCKTxRate, pMgntInfo->ForcedDataRate);
+			set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, 0x0);    //Set FTxRate to 1Mbps
+		}
+	}
+	else// Stop Carrier Suppression.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCarrierSuppressionTx test stop.........\n"));
+		//if(pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M ) {
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);    //normal mode
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x1);  //turn on scramble setting
+
+			//BB Reset
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+		}
+	}
+	//DbgPrint("\n MPT_ProSetCarrierSupp() is finished. \n");
+#endif
+}
+
+void SetCCKContinuousTx(PADAPTER pAdapter, u8 bStart)
+{
+	u32 cckrate;
+
+	if (bStart)
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCCKContinuousTx test start.........\n"));
+
+		// 1. if CCK block on?
+		if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
+
+		//Turn Off All Test Mode
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		//Set CCK Tx Test Rate
+		#if 0
+		switch(pAdapter->mppriv.curr_rateidx)
+		{
+			case 2:
+				cckrate = 0;
+				break;
+			case 4:
+				cckrate = 1;
+				break;
+			case 11:
+				cckrate = 2;
+				break;
+			case 22:
+				cckrate = 3;
+				break;
+			default:
+				cckrate = 0;
+				break;
+		}
+		#else
+		cckrate  = pAdapter->mppriv.curr_rateidx;
+		#endif
+		set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, cckrate);
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);	//transmit mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x1);	//turn on scramble setting
+	}
+	else{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCCKContinuousTx test stop.........\n"));
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);	//normal mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x1);	//turn on scramble setting
+
+		//BB Reset
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+}/* mpt_StartCckContTx */
+
+void SetOFDMContinuousTx(PADAPTER pAdapter, u8 bStart)
+{
+	if (bStart) {
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetOFDMContinuousTx test start.........\n"));
+		// 1. if OFDM block on?
+		if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
+
+		// 2. set CCK test mode off, set to CCK normal mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+
+		// 3. turn on scramble setting
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+
+		// 4. Turn On Continue Tx and turn off the other test modes.
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	} else {
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetOFDMContinuousTx test stop.........\n"));
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		//Delay 10 ms
+		msleep_os(10);
+		//BB Reset
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+}/* mpt_StartOfdmContTx */
+
+void SetContinuousTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetContinuousTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetContinuousTx);
+
+	pcmd = (struct cmd_obj*)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetContinuousTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetContinuousTx_parm*)_malloc(sizeof(struct SetContinuousTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetContinuousTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+	pparm->CCK_flag = 1;	// CCK
+	pparm->curr_rateidx = pAdapter->mppriv.curr_rateidx;
+	if ((pparm->curr_rateidx >= MPT_RATE_6M) &&
+	    (pparm->curr_rateidx <= MPT_RATE_MCS15))
+		pparm->CCK_flag = 2;	// OFDM
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+	// ADC turn off [bit24-21] adc port0 ~ port1
+	if (bStart) {
+		bb_reg_write(pAdapter, rRx_Wait_CCCA, bb_reg_read(pAdapter, rRx_Wait_CCCA) & 0xFE1FFFFF);
+		usleep_os(100);
+	}
+	RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetContinuousTx #2 rate:%d........\n", pAdapter->mppriv.curr_rateidx));
+	if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M)
+	{
+		SetCCKContinuousTx(pAdapter, bStart);
+	}
+	else if ((pAdapter->mppriv.curr_rateidx >= MPT_RATE_6M) &&
+		 (pAdapter->mppriv.curr_rateidx <= MPT_RATE_MCS15))
+	{
+		SetOFDMContinuousTx(pAdapter, bStart);
+	}
+	// ADC turn on [bit24-21] adc port0 ~ port1
+	if (!bStart) {
+		bb_reg_write(pAdapter, rRx_Wait_CCCA, bb_reg_read(pAdapter, rRx_Wait_CCCA) | 0x01E00000);
+	}
+#endif
+}
+
+void ResetPhyRxPktCount(PADAPTER pAdapter)
+{
+	u32 i, phyrx_set = 0;
+
+	for (i = OFDM_PPDU_BIT; i <= HT_MPDU_FAIL_BIT; i++) {
+		phyrx_set = 0;
+		phyrx_set |= (i << 28);		//select
+		phyrx_set |= 0x08000000;	// set counter to zero
+		write32(pAdapter, RXERR_RPT, phyrx_set);
+	}
+}
+
+static u32 GetPhyRxPktCounts(PADAPTER pAdapter, u32 selbit)
+{
+	//selection
+	u32 phyrx_set = 0, count = 0;
+	u32 SelectBit;
+
+	SelectBit = selbit << 28;
+	phyrx_set |= (SelectBit & 0xF0000000);
+
+	write32(pAdapter, RXERR_RPT, phyrx_set);
+
+	//Read packet count
+	count = read32(pAdapter, RXERR_RPT) & RPTMaxCount;
+
+	return count;
+}
+
+u32 GetPhyRxPktReceived(PADAPTER pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_OK_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_OK_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_OK_BIT);
+
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
+
+u32 GetPhyRxPktCRC32Error(PADAPTER pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_FAIL_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_FAIL_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_FAIL_BIT);
+
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_IQCalibrateBcut()
+ *
+ * Overview:	After all MAC/PHY/RF is configued. We must execute IQ calibration
+ *			to improve RF EVM!!?
+ *
+ * Input:		IN	PADAPTER	pAdapter
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	11/18/2008	MHC		Create. Document from SD3 RFSI Jenyu.
+ *						92S B-cut QFN 68 pin IQ calibration procedure.doc
+ *
+ *---------------------------------------------------------------------------*/
+typedef enum _RF90_RADIO_PATH {
+	RF90_PATH_A = 0,	//Radio Path A
+	RF90_PATH_B = 1,	//Radio Path B
+	RF90_PATH_C = 2,	//Radio Path C
+	RF90_PATH_D = 3,	//Radio Path D
+	RF90_PATH_MAX		//Max RF number 90 support
+}RF90_RADIO_PATH_E, *PRF90_RADIO_PATH_E;
+
+void IQCalibrateBcut(PADAPTER pAdapter)
+{
+	u32	i, reg;
+	u32	old_value;
+	s32	X, Y, TX0[4];
+	u32	TXA[4];
+	u16	calibrate_set[13] = {0};
+	u32	load_value[13];
+
+	RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("@@@@@@ IQCalibrateBcut Start... \n"));
+	// 0. Check QFN68 or 64 92S (Read from EEPROM/EFUSE)
+
+	//
+	// 1. Save e70~ee0 register setting, and load calibration setting
+	//
+	calibrate_set [0] = 0xee0;
+	calibrate_set [1] = 0xedc;
+	calibrate_set [2] = 0xe70;
+	calibrate_set [3] = 0xe74;
+	calibrate_set [4] = 0xe78;
+	calibrate_set [5] = 0xe7c;
+	calibrate_set [6] = 0xe80;
+	calibrate_set [7] = 0xe84;
+	calibrate_set [8] = 0xe88;
+	calibrate_set [9] = 0xe8c;
+	calibrate_set [10] = 0xed0;
+	calibrate_set [11] = 0xed4;
+	calibrate_set [12] = 0xed8;
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Save e70~ee0 register setting\n"));
+	for (i = 0; i < 13; i++)
+	{
+		load_value[i] = get_bb_reg(pAdapter, calibrate_set[i], bMaskDWord);
+		set_bb_reg(pAdapter, calibrate_set[i], bMaskDWord, 0x3fed92fb);
+	}
+
+	//
+	// 2. QFN 68
+	//
+	// For 1T2R IQK only now !!!
+	for (i = 0; i < 10; i++)
+	{
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("IQK -%d\n", i));
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("@@@@@@ IQK -%d\n", i));
+
+		//BB switch to PI mode. If default is PI mode, ignoring 2 commands below.
+		//if (pMgntInfo->bRFSiOrPi == 0)	// SI
+		{
+			set_bb_reg(pAdapter, 0x820, bMaskDWord, 0x01000100);
+			set_bb_reg(pAdapter, 0x828, bMaskDWord, 0x01000100);
+		}
+
+		// IQK
+		// 2. IQ calibration & LO leakage calibration
+		set_bb_reg(pAdapter, 0xc04, bMaskDWord, 0x00a05430);
+
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xc08, bMaskDWord, 0x000800e4);
+
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xe28, bMaskDWord, 0x80800000);
+		udelay_os(5);
+		//path-A IQ K and LO K gain setting
+		set_bb_reg(pAdapter, 0xe40, bMaskDWord, 0x02140102);
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xe44, bMaskDWord, 0x681604c2);
+		udelay_os(5);
+		//set LO calibration
+		set_bb_reg(pAdapter, 0xe4c, bMaskDWord, 0x000028d1);
+		udelay_os(5);
+		//path-B IQ K and LO K gain setting
+		set_bb_reg(pAdapter, 0xe60, bMaskDWord, 0x02140102);
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xe64, bMaskDWord, 0x28160d05);
+		udelay_os(5);
+		//K idac_I & IQ
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xfb000000);
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xf8000000);
+		udelay_os(5);
+
+		// delay 2ms
+		udelay_os(2000);
+
+		//idac_Q setting
+		set_bb_reg(pAdapter, 0xe6c, bMaskDWord, 0x020028d1);
+		udelay_os(5);
+		//K idac_Q & IQ
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xfb000000);
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xf8000000);
+
+		// delay 2ms
+		udelay_os(2000);
+
+		set_bb_reg(pAdapter, 0xc04, bMaskDWord, 0x00a05433);
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xc08, bMaskDWord, 0x000000e4);
+		udelay_os(5);
+		set_bb_reg(pAdapter, 0xe28, bMaskDWord, 0x0);
+
+		//f (pMgntInfo->bRFSiOrPi == 0)	// SI
+		{
+			set_bb_reg(pAdapter, 0x820, bMaskDWord, 0x01000000);
+			set_bb_reg(pAdapter, 0x828, bMaskDWord, 0x01000000);
+		}
+
+		reg = get_bb_reg(pAdapter, 0xeac, bMaskDWord);
+
+		// 3.	check fail bit, and fill BB IQ matrix
+		// Readback IQK value and rewrite
+		if (!(reg&(BIT(27)|BIT(28)|BIT(30)|BIT(31))))
+		{
+			old_value = (get_bb_reg(pAdapter, 0xc80, bMaskDWord) & 0x3FF);
+
+			// Calibrate init gain for A path for TX0
+			X = (get_bb_reg(pAdapter, 0xe94, bMaskDWord) & 0x03FF0000)>>16;
+
+			TXA[RF90_PATH_A] = (X * old_value)/0x100;
+
+			reg = get_bb_reg(pAdapter, 0xc80, bMaskDWord);
+			reg = (reg & 0xFFFFFC00) | (u32)TXA[RF90_PATH_A];
+			set_bb_reg(pAdapter, 0xc80, bMaskDWord, reg);
+			udelay_os(5);
+
+			// Calibrate init gain for C path for TX0
+			Y = ( get_bb_reg(pAdapter, 0xe9C, bMaskDWord) & 0x03FF0000)>>16;
+			TX0[RF90_PATH_C] = ((Y * old_value)/0x100);
+			reg = get_bb_reg(pAdapter, 0xc80, bMaskDWord);
+			reg = (reg & 0xffc0ffff) |((u32) (TX0[RF90_PATH_C]&0x3F)<<16);
+			set_bb_reg(pAdapter, 0xc80, bMaskDWord, reg);
+			reg = get_bb_reg(pAdapter, 0xc94, bMaskDWord);
+			reg = (reg & 0x0fffffff) |(((Y&0x3c0)>>6)<<28);
+			set_bb_reg(pAdapter, 0xc94, bMaskDWord, reg);
+			udelay_os(5);
+
+			// Calibrate RX A and B for RX0
+			reg = get_bb_reg(pAdapter, 0xc14, bMaskDWord);
+			X = (get_bb_reg(pAdapter, 0xea4, bMaskDWord) & 0x03FF0000)>>16;
+			reg = (reg & 0xFFFFFC00) |X;
+			set_bb_reg(pAdapter, 0xc14, bMaskDWord, reg);
+			Y = (get_bb_reg(pAdapter, 0xeac, bMaskDWord) & 0x003F0000)>>16;
+			reg = (reg & 0xFFFF03FF) |(Y<<10);
+			set_bb_reg(pAdapter, 0xc14, bMaskDWord, reg);
+			udelay_os(5);
+			old_value = (get_bb_reg(pAdapter, 0xc88, bMaskDWord) & 0x3FF);
+
+			// Calibrate init gain for A path for TX1 !!!!!!
+			X = (get_bb_reg(pAdapter, 0xeb4, bMaskDWord) & 0x03FF0000)>>16;
+			reg = get_bb_reg(pAdapter, 0xc88, bMaskDWord);
+			TXA[RF90_PATH_A] = (X * old_value) / 0x100;
+			reg = (reg & 0xFFFFFC00) | TXA[RF90_PATH_A];
+			set_bb_reg(pAdapter, 0xc88, bMaskDWord, reg);
+			udelay_os(5);
+
+			// Calibrate init gain for C path for TX1
+			Y = (get_bb_reg(pAdapter, 0xebc, bMaskDWord)& 0x03FF0000)>>16;
+			TX0[RF90_PATH_C] = ((Y * old_value)/0x100);
+			reg = get_bb_reg(pAdapter, 0xc88, bMaskDWord);
+			reg = (reg & 0xffc0ffff) |( (TX0[RF90_PATH_C]&0x3F)<<16);
+			set_bb_reg(pAdapter, 0xc88, bMaskDWord, reg);
+			reg = get_bb_reg(pAdapter, 0xc9c, bMaskDWord);
+			reg = (reg & 0x0fffffff) |(((Y&0x3c0)>>6)<<28);
+			set_bb_reg(pAdapter, 0xc9c, bMaskDWord, reg);
+			udelay_os(5);
+
+			// Calibrate RX A and B for RX1
+			reg = get_bb_reg(pAdapter, 0xc1c, bMaskDWord);
+			X = (get_bb_reg(pAdapter, 0xec4, bMaskDWord) & 0x03FF0000)>>16;
+			reg = (reg & 0xFFFFFC00) |X;
+			set_bb_reg(pAdapter, 0xc1c, bMaskDWord, reg);
+
+			Y = (get_bb_reg(pAdapter, 0xecc, bMaskDWord) & 0x003F0000)>>16;
+			reg = (reg & 0xFFFF03FF) |Y<<10;
+			set_bb_reg(pAdapter, 0xc1c, bMaskDWord, reg);
+			udelay_os(5);
+
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_IQCalibrate OK\n"));
+			RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("@@@@@@ PHY_IQCalibrate OK\n"));
+			break;
+		}
+	}
+
+	//
+	// 4. Reload e70~ee0 register setting.
+	//
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reload e70~ee0 register setting.\n"));
+	for (i = 0; i < 13; i++)
+		set_bb_reg(pAdapter, calibrate_set[i], bMaskDWord, load_value[i]);
+
+	//
+	// 3. QFN64. Not enabled now !!! We must use different gain table for 1T2R.
+	//
+
+}	// PHY_IQCalibrateBcut
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/mp/rtl871x_mp_ioctl.c b/drivers/net/wireless/8712u/mp/rtl871x_mp_ioctl.c
new file mode 100755
index 0000000..1ae60f2
--- /dev/null
+++ b/drivers/net/wireless/8712u/mp/rtl871x_mp_ioctl.c
@@ -0,0 +1,3080 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_MP_IOCTL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mlme_osdep.h>
+
+#include <rtl871x_mp.h>
+#include <rtl871x_mp_ioctl.h>
+#include <rtl871x_mp_phy_regdef.h>
+
+#ifdef PLATFORM_LINUX
+NDIS_STATUS oid_null_function(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+#endif
+
+//****************  oid_rtl_seg_81_85   section start ****************
+NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid == SET_OID)
+	{
+		if (poid_par_priv->information_buf_len >= sizeof(u8))
+			Adapter->registrypriv.wireless_mode = *(u8*)poid_par_priv->information_buf;
+		else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	}
+	else if (poid_par_priv->type_of_oid == QUERY_OID)
+	{
+		if (poid_par_priv->information_buf_len >= sizeof(u8)) {
+			*(u8*)poid_par_priv->information_buf = Adapter->registrypriv.wireless_mode;
+			*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+			 RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-query Wireless Mode=%d\n", Adapter->registrypriv.wireless_mode));
+		} else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	} else {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//****************  oid_rtl_seg_81_87_80   section start ****************
+NDIS_STATUS oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL oldirql;
+
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_write_bb_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+
+	offset = (u16)(pbbreg->offset) & 0xFFF; //0ffset :0x800~0xfff
+	if (offset < BB_REG_BASE_ADDR) offset |= BB_REG_BASE_ADDR;
+
+	value = pbbreg->value;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_write_bb_reg_hdl: offset=0x%04x value=0x%08x\n",
+		  offset, value));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	bb_reg_write(Adapter, offset, value);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL oldirql;
+
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_read_bb_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+
+	offset = (u16)(pbbreg->offset) & 0xFFF; //0ffset :0x800~0xfff
+	if (offset < BB_REG_BASE_ADDR) offset |= BB_REG_BASE_ADDR;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	value = bb_reg_read(Adapter, offset);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	pbbreg->value = value;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_read_bb_reg_hdl: offset=0x%04x value:0x%08x\n",
+		  offset, value));
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL oldirql;
+
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_write_rf_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	offset = (u8)pbbreg->offset;
+	value = pbbreg->value;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_write_rf_reg_hdl: path=%d offset=0x%02x value=0x%08x\n",
+		  path, offset, value));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+ 	rf_reg_write(Adapter, path, offset, value);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	_irqL oldirql;
+
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_read_rf_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B) // 1T2R  path_a /path_b
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	offset = (u8)pbbreg->offset;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	value = rf_reg_read(Adapter, path, offset);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	pbbreg->value = value;
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_read_rf_reg_hdl: path=%d offset=0x%02x value=0x%08x\n",
+		  path, offset, value));
+
+_func_exit_;
+
+	return status;
+}
+//****************  oid_rtl_seg_81_87_00   section end****************
+//------------------------------------------------------------------------------
+//This function initializes the DUT to the MP test mode
+int mp_start_test(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	NDIS_WLAN_BSSID_EX bssid;
+	struct sta_info *psta;
+	unsigned long length;
+
+		_irqL irqL;
+	int res = _SUCCESS;
+
+
+	//3 1. initialize a new NDIS_WLAN_BSSID_EX
+//	_memset(&bssid, 0, sizeof(NDIS_WLAN_BSSID_EX));
+
+	_memcpy(bssid.MacAddress, pmppriv->network_macaddr, ETH_ALEN);
+	bssid.Ssid.SsidLength = 16;
+	_memcpy(bssid.Ssid.Ssid, (unsigned char*)"mp_pseudo_adhoc", bssid.Ssid.SsidLength);
+	bssid.InfrastructureMode = Ndis802_11IBSS;
+	bssid.NetworkTypeInUse = Ndis802_11DS;
+	bssid.IELength = 0;
+
+	length = get_NDIS_WLAN_BSSID_EX_sz(&bssid);
+	if (length % 4)
+		bssid.Length = ((length >> 2) + 1) << 2; //round up to multiple of 4 bytes.
+	else
+		bssid.Length = length;
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		goto end_of_mp_start_test;
+
+	//init mp_start_test status
+	pmppriv->prev_fw_state = get_fwstate(pmlmepriv);
+	pmlmepriv->fw_state = WIFI_MP_STATE;
+
+	if (pmppriv->mode == _LOOPBOOK_MODE_) {
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); //append txdesc
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+start mp in Lookback mode\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+start mp in normal mode\n"));
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+	//3 2. create a new psta for mp driver
+	//clear psta in the cur_network, if any
+	psta = get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
+	if (psta) free_stainfo(padapter, psta);
+
+	psta = alloc_stainfo(&padapter->stapriv, bssid.MacAddress);
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("mp_start_test: Can't alloc sta_info!\n"));
+		res = _FAIL;
+		goto end_of_mp_start_test;
+	}
+
+	//3 3. join psudo AdHoc
+	tgt_network->join_res = 1;
+	tgt_network->aid = psta->aid = 1;
+	_memcpy(&tgt_network->network, &bssid, length);
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	os_indicate_connect(padapter);
+	set_fwstate(pmlmepriv, _FW_LINKED); // Set to LINKED STATE for MP TRX Testing
+
+end_of_mp_start_test:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	return res;
+}
+//------------------------------------------------------------------------------
+//This function change the DUT from the MP test mode into normal mode
+int mp_stop_test(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct sta_info *psta;
+
+	_irqL irqL;
+
+
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE)
+		goto end_of_mp_stop_test;
+
+	//3 1. disconnect psudo AdHoc
+	indicate_disconnect(padapter);
+//	os_indicate_disconnect(padapter);
+
+	//3 2. clear psta used in mp test mode.
+//	free_assoc_resources(padapter);
+	psta = get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
+	if (psta) free_stainfo(padapter, psta);
+
+	//3 3. return to normal state (default:station mode)
+	pmlmepriv->fw_state = pmppriv->prev_fw_state; // WIFI_STATION_STATE;
+
+	//flush the cur_network
+	_memset(tgt_network, 0, sizeof(struct wlan_network));
+
+end_of_mp_stop_test:
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	return _SUCCESS;
+}
+//------------------------------------------------------------------------------
+int mp_start_joinbss(_adapter *padapter, NDIS_802_11_SSID *pssid)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = (struct wlan_network *)&pmppriv->mp_network;
+
+	unsigned char res = _SUCCESS;
+
+#if 1
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE)
+		return _FAIL;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+		return _FAIL;
+
+	_clr_fwstate_(pmlmepriv, _FW_LINKED);
+#else
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE))
+		pmlmepriv->fw_state ^= _FW_LINKED;
+	else
+		return _FAIL;
+#endif
+	res = setassocsta_cmd(padapter, pmppriv->network_macaddr);
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+#if 0
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &mp_priv->mp_network;
+
+	unsigned char *dst_ssid, *src_ssid;
+	unsigned char res = _SUCCESS;
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
+		pmlmepriv->fw_state ^= _FW_LINKED;
+	else
+		return _FAIL;
+
+	_memcpy(&padapter->MgntInfo.ssid, pssid, sizeof(NDIS_802_11_SSID));
+	_memcpy(&pmlmepriv->assoc_ssid, pssid, sizeof(NDIS_802_11_SSID));
+
+	pmlmepriv->cur_network.join_res = -2;
+	pmlmepriv->fw_state |= _FW_UNDER_LINKING;
+
+	dst_ssid = pnetwork->network.Ssid.Ssid;
+	src_ssid = pmlmepriv->assoc_ssid.Ssid;
+	if (_memcmp(dst_ssid, src_ssid, pmlmepriv->assoc_ssid.SsidLength) == _FALSE)
+		return _FAIL;
+
+	res = joinbss_cmd((unsigned char*)padapter, pnetwork);
+
+	NdisMSetTimer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+#endif
+
+	return res;
+}
+
+//****************  oid_rtl_seg_81_80_00   section start ****************
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_data_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+//	unsigned char	datarates[NumRates];
+	u32		ratevalue;//4
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+oid_rt_pro_set_data_rate_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	ratevalue = *((u32*)poid_par_priv->information_buf);//4
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_set_data_rate_hdl: data rate idx=%d\n", ratevalue));
+	if (ratevalue >= MPT_RATE_LAST)
+		return NDIS_STATUS_INVALID_DATA;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+#if 0
+	for (i = 0; i< NumRates; i++)
+	{
+		if (ratevalue == mpdatarate[i]) {
+			datarates[i] = mpdatarate[i];
+		} else {
+			datarates[i] = 0xff;
+		}
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("datarate_inx=%d\n", datarates[i]));
+	}
+
+	if (setdatarate_cmd(Adapter, datarates) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+#else
+	Adapter->mppriv.curr_rateidx = ratevalue;
+	SetDataRate(Adapter);
+#endif
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		mode;
+	u8		val8;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_start_test_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return  NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	//IQCalibrateBcut(Adapter);
+
+	mode = *((u32*)poid_par_priv->information_buf);
+	Adapter->mppriv.mode = mode;// 1 for loopback
+
+	if (mp_start_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	write8(Adapter, MSR, 1); // Link in ad hoc network, 0x1025004C
+	write8(Adapter, RCR, 0); // RCR : disable all pkt, 0x10250048
+	write8(Adapter, RCR+2, 0x57); // RCR disable Check BSSID, 0x1025004a
+
+	//disable RX filter map , mgt frames will put in RX FIFO 0
+	write16(Adapter, RXFLTMAP0, 0x0); // 0x10250116
+
+	val8 = read8(Adapter, EE_9346CR); // 0x1025000A
+	if (!(val8 & _9356SEL))//boot from EFUSE
+	{
+		efuse_reg_init(Adapter);
+		efuse_change_max_size(Adapter);
+		efuse_reg_uninit(Adapter);
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-oid_rt_pro_start_test_hdl: mp_mode=%d\n", Adapter->mppriv.mode));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Set OID_RT_PRO_STOP_TEST\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (mp_stop_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-Set OID_RT_PRO_STOP_TEST\n"));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		Channel;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_channel_direct_call_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	Channel = *((u32*)poid_par_priv->information_buf);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("oid_rt_pro_set_channel_direct_call_hdl: Channel=%d\n", Channel));
+	if (Channel > 14)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_ch = Channel;
+
+#if 0
+	if (setphy_cmd(Adapter, (unsigned char)Adapter->mppriv.curr_modem, (unsigned char)Channel) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+#else
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetChannel(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		antenna;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_antenna_bb_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	antenna = *((u32*)poid_par_priv->information_buf);
+
+	Adapter->mppriv.antenna_tx = (u16)((antenna & 0xFFFF0000) >> 16);
+	Adapter->mppriv.antenna_rx = (u16)(antenna & 0x0000FFFF);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("tx_ant=0x%04x rx_ant=0x%04x\n",
+		  Adapter->mppriv.antenna_tx, Adapter->mppriv.antenna_rx));
+
+	_irqlevel_changed_(&oldirql,LOWER);
+	SwitchAntenna(Adapter);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		tx_pwr_idx;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_pro_set_tx_power_control_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	tx_pwr_idx = *((u32*)poid_par_priv->information_buf);
+	if (tx_pwr_idx > MAX_TX_PWR_INDEX_N_MODE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_txpoweridx = (u8)tx_pwr_idx;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_set_tx_power_control_hdl: idx=0x%2x\n",
+		  Adapter->mppriv.curr_txpoweridx));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetTxPower(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+//****************  oid_rtl_seg_81_80_20   section start ****************
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid !=QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		*(ULONG*)poid_par_priv->information_buf =  Adapter->mppriv.tx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("===> oid_rt_pro_query_rx_packet_received_hdl.\n"));
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		*(ULONG*)poid_par_priv->information_buf =  Adapter->mppriv.rx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("recv_ok:%d \n",Adapter->mppriv.rx_pktcount));
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("===> oid_rt_pro_query_rx_packet_crc32_error_hdl.\n"));
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		*(ULONG*)poid_par_priv->information_buf =  Adapter->mppriv.rx_crcerrpktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("recv_err:%d \n",Adapter->mppriv.rx_crcerrpktcount));
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+
+NDIS_STATUS oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("===> oid_rt_pro_reset_tx_packet_sent_hdl.\n"));
+	Adapter->mppriv.tx_pktcount = 0;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		Adapter->mppriv.rx_pktcount = 0;
+		Adapter->mppriv.rx_crcerrpktcount = 0;
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL		oldirql;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	ResetPhyRxPktCount(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_get_phy_rx_packet_received_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(ULONG))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	*(ULONG*)poid_par_priv->information_buf = GetPhyRxPktReceived(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-oid_rt_get_phy_rx_packet_received_hdl: recv_ok=%d\n", *(ULONG*)poid_par_priv->information_buf));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_get_phy_rx_packet_crc32_error_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+
+	if (poid_par_priv->information_buf_len != sizeof(ULONG))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	*(ULONG*)poid_par_priv->information_buf = GetPhyRxPktCRC32Error(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_get_phy_rx_packet_crc32_error_hdl: recv_err=%d\n", *(ULONG*)poid_par_priv->information_buf));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_modulation_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+OID_RT_PRO_SET_MODULATION\n"));
+	Adapter->mppriv.curr_modem = *((u8*)poid_par_priv->information_buf);
+
+_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_81_80_20   section end ****************
+NDIS_STATUS oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_continuous_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetContinuousTx(Adapter,(u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("+oid_rt_pro_set_single_carrier_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetSingleCarrierTx(Adapter, (u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_carrier_suppression_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetCarrierSuppressionTx(Adapter, (u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32 		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("+oid_rt_pro_set_single_tone_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetSingleToneTx(Adapter,(u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_81_80_00   section end ****************
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	PNDIS_802_11_SSID pssid;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = (u32)sizeof(NDIS_802_11_SSID);
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pssid = (PNDIS_802_11_SSID)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (mp_start_joinbss(Adapter, pssid) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = sizeof(NDIS_802_11_SSID);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pRW_Reg 	RegRWStruct;
+	u16		offset;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("+oid_rt_pro_read_register_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RegRWStruct = (pRW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF))
+	{
+		//baseband register
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;  	//0ffset :0x800~0xfff
+
+		RegRWStruct->value = bb_reg_read(Adapter ,offset);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			 ("oid_rt_pro_read_register_hdl: bb offset=0x%04x value=0x%x\n",
+			  offset, RegRWStruct->value));
+	}
+	else
+	{
+		switch (RegRWStruct->width)
+		{
+			case 1:
+				RegRWStruct->value = read8(Adapter, RegRWStruct->offset);
+				break;
+			case 2:
+				RegRWStruct->value = read16(Adapter, RegRWStruct->offset);
+				break;
+			case 4:
+				RegRWStruct->value = read32(Adapter, RegRWStruct->offset);
+				break;
+			default:
+				status = NDIS_STATUS_NOT_ACCEPTED;
+				break;
+		}
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			 ("oid_rt_pro_read_register_hdl: offset:0x%04x value:0x%x\n",
+			  RegRWStruct->offset, RegRWStruct->value));
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	//DEBUG_ERR(("\n <=== Query OID_RT_PRO_READ_REGISTER.
+	//	Add:0x%08x Width:%d Value:0x%08x\n",RegRWStruct->offset,RegRWStruct->width,RegRWStruct->value));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pRW_Reg 	RegRWStruct;
+	u16		offset;
+	u32		value;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("\n ===> Set OID_RT_PRO_WRITE_REGISTER.\n"));
+
+	RegRWStruct = (pRW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF))
+	{
+		//baseband register
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;  	//0ffset :0x800~0xfff
+		value = RegRWStruct->value;
+#if 1
+{
+		u32 oldValue = 0;
+		switch (RegRWStruct->width)
+		{
+			case 1:
+				oldValue = bb_reg_read(Adapter, offset);
+				oldValue &= 0xFFFFFF00;
+				value &= 0x000000FF;
+				value |= oldValue;
+				break;
+			case 2:
+				oldValue = bb_reg_read(Adapter, offset);
+				oldValue &= 0xFFFF0000;
+				value &= 0x0000FFFF;
+				value |= oldValue;
+				break;
+		}
+}
+#else
+// reduce IO access
+		if ( (RegRWStruct->width == 1) ||
+		     (RegRWStruct->width == 2) )
+		{
+			u32 oldValue = 0;
+			u8 shift = offset & 0x3;
+			u32 mask = 0x000000FF;
+
+			if (RegRWStruct->width == 2) {
+				mask = 0x0000FFFF;
+				if (shift == 3)
+					shift = 0;
+			}
+
+			if (shift != 0) {
+				mask <<= (shift * 8);
+				offset &= 0xFFC;
+			}
+
+			oldValue = bb_reg_read(Adapter, offset);
+			oldValue &= ~mask;
+			value = (value << (shift * 8)) & mask;
+			value |= oldValue;
+		}
+#endif
+		bb_reg_write(Adapter, offset, value);
+	}
+	else
+	{
+		switch (RegRWStruct->width)
+		{
+			case 1:
+				write8(Adapter, RegRWStruct->offset, (unsigned char)RegRWStruct->value);
+				break;
+			case 2:
+				write16(Adapter, RegRWStruct->offset, (unsigned short)RegRWStruct->value);
+				break;
+			case 4:
+				write32(Adapter, RegRWStruct->offset, (unsigned int)RegRWStruct->value);
+				break;
+			default:
+				status = NDIS_STATUS_NOT_ACCEPTED;
+				break;
+		}
+
+		//Henry: for maintain the correct HIMR status
+		if ((status == NDIS_STATUS_SUCCESS) &&
+		    (RegRWStruct->offset == HIMR) &&
+		    (RegRWStruct->width == 4))
+			Adapter->ImrContent=RegRWStruct->value;
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("\n <=== Set OID_RT_PRO_WRITE_REGISTER.offset:0x%08x value0x%x\n",RegRWStruct->offset,RegRWStruct->value));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_burst_read_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pBurst_RW_Reg	pBstRwReg;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_burst_read_register_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pBstRwReg = (pBurst_RW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	read_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len, pBstRwReg->Data);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_pro_burst_read_register_hdl\n"));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_burst_write_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pBurst_RW_Reg	pBstRwReg;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_burst_write_register_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pBstRwReg = (pBurst_RW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	write_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len, pBstRwReg->Data);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_pro_burst_write_register_hdl\n"));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+/*
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+
+	TX_CMD_Desc	*TxCmd_Info;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+Set OID_RT_PRO_WRITE_TXCMD\n"));
+
+	TxCmd_Info=(TX_CMD_Desc*)poid_par_priv->information_buf;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:Addr=%.8X\n", TxCmd_Info->offset));
+  	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:1.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[0]));
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:2.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[1]));
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, (("WRITE_TXCMD:3.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[2]));
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:4.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[3]));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	write32(Adapter, TxCmd_Info->offset + 0, (unsigned int)TxCmd_Info->TxCMD.value[0]);
+	write32(Adapter, TxCmd_Info->offset + 4, (unsigned int)TxCmd_Info->TxCMD.value[1]);
+
+	_irqlevel_changed_(&oldirql, RAISE);
+*/
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-Set OID_RT_PRO_WRITE_TXCMD: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pEEPROM_RWParam pEEPROM;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+Query OID_RT_PRO_READ16_EEPROM\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pEEPROM = (pEEPROM_RWParam)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	pEEPROM->value = eeprom_read16(Adapter, (u16)(pEEPROM->offset >> 1));
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_,  _drv_notice_,
+		 ("-Query OID_RT_PRO_READ16_EEPROM: offset=0x%x value=0x%x\n",
+		  pEEPROM->offset, pEEPROM->value));
+
+_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write16_eeprom_hdl (struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pEEPROM_RWParam pEEPROM;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Set OID_RT_PRO_WRITE16_EEPROM\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pEEPROM = (pEEPROM_RWParam)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	eeprom_write16(Adapter, (u16)(pEEPROM->offset >> 1), pEEPROM->value);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	struct mp_wiparam *pwi_param;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct mp_wiparam))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	if (Adapter->mppriv.workparam.bcompleted == _FALSE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pwi_param = (struct mp_wiparam *)poid_par_priv->information_buf;
+
+	_memcpy(pwi_param, &Adapter->mppriv.workparam, sizeof(struct mp_wiparam));
+	Adapter->mppriv.act_in_progress = _FALSE;
+//	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("rf:%x\n", pwiparam->IoValue));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro8711_pkt_loss_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(uint)*2) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("-oid_rt_pro8711_pkt_loss_hdl: buf_len=%d\n", (int)poid_par_priv->information_buf_len));
+		return NDIS_STATUS_INVALID_LENGTH;
+	}
+
+	if (*(uint*)poid_par_priv->information_buf == 1)//init==1
+		Adapter->mppriv.rx_pktloss = 0;
+
+	*((uint*)poid_par_priv->information_buf+1) = Adapter->mppriv.rx_pktloss;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+	struct io_queue *pio_queue = (struct io_queue *)Adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &pio_queue->intf;
+
+	_irqL	oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+#ifdef CONFIG_SDIO_HCI
+	void (*_attrib_read)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+#endif
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Query OID_RT_RD_ATTRIB_MEM\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+#ifdef CONFIG_SDIO_HCI
+	_irqlevel_changed_(&oldirql, LOWER);
+{
+	u32 *plmem = (u32*)poid_par_priv->information_buf+2;
+	_attrib_read = pintfhdl->io_ops._attrib_read;
+	_attrib_read(pintfhdl, *((u32*)poid_par_priv->information_buf),
+				*((u32*)poid_par_priv->information_buf+1), (u8*)plmem);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+}
+	_irqlevel_changed_(&oldirql, RAISE);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_wr_attrib_mem_hdl (struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct io_queue *pio_queue = (struct io_queue *)Adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &pio_queue->intf;
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+#ifdef CONFIG_SDIO_HCI
+	void (*_attrib_write)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+#endif
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+#ifdef CONFIG_SDIO_HCI
+	_irqlevel_changed_(&oldirql, LOWER);
+{
+	u32 *plmem = (u32*)poid_par_priv->information_buf + 2;
+	_attrib_write = pintfhdl->io_ops._attrib_write;
+	_attrib_write(pintfhdl, *(u32*)poid_par_priv->information_buf,
+				*((u32*)poid_par_priv->information_buf+1), (u8*)plmem);
+}
+	_irqlevel_changed_(&oldirql, RAISE);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+OID_RT_PRO_SET_RF_INTFS\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (setrfintfs_cmd(Adapter, *(unsigned char*)poid_par_priv->information_buf) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_memcpy(poid_par_priv->information_buf, (unsigned char*)&Adapter->mppriv.rxstat, sizeof(struct recv_stat));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	PCFG_DBG_MSG_STRUCT pdbg_msg;
+
+_func_enter_;
+
+//	RT_TRACE(0xffffffffff,_drv_alert_,("===> oid_rt_pro_cfg_debug_message_hdl.\n"));
+
+#if 0//#ifdef CONFIG_DEBUG_RTL871X
+
+	pdbg_msg = (PCFG_DBG_MSG_STRUCT)(poid_par_priv->information_buf);
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		RT_TRACE(0xffffffffff, _drv_alert_,
+			 ("===>Set level :0x%08x, H32:0x%08x L32:0x%08x\n",
+			  pdbg_msg->DebugLevel, pdbg_msg->DebugComponent_H32, pdbg_msg->DebugComponent_L32));
+
+		GlobalDebugLevel = pdbg_msg->DebugLevel;
+		GlobalDebugComponents = (pdbg_msg->DebugComponent_H32 << 32) | pdbg_msg->DebugComponent_L32;
+		RT_TRACE(0xffffffffff, _drv_alert_,
+			 ("===> Set level :0x%08x, component:0x%016x\n",
+			  GlobalDebugLevel, (u32)GlobalDebugComponents));
+	} else {
+		pdbg_msg->DebugLevel = GlobalDebugLevel;
+		pdbg_msg->DebugComponent_H32 = (u32)(GlobalDebugComponents >> 32);
+		pdbg_msg->DebugComponent_L32 = (u32)GlobalDebugComponents;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+		RT_TRACE(0xffffffffff, _drv_alert_,
+			 ("===>Query level:0x%08x H32:0x%08x L32:0x%08x\n",
+			  (u32)pdbg_msg->DebugLevel, (u32)pdbg_msg->DebugComponent_H32, (u32)pdbg_msg->DebugComponent_L32));
+	}
+
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+OID_RT_PRO_SET_DATA_RATE_EX\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (setdatarate_cmd(Adapter, poid_par_priv->information_buf) !=_SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_thermal_meter_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_get_thermal_meter_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (Adapter->mppriv.act_in_progress == _TRUE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	//init workparam
+	Adapter->mppriv.act_in_progress = _TRUE;
+	Adapter->mppriv.workparam.bcompleted = _FALSE;
+	Adapter->mppriv.workparam.act_type = MPT_GET_THERMAL_METER;
+	Adapter->mppriv.workparam.io_offset = 0;
+	Adapter->mppriv.workparam.io_value = 0xFFFFFFFF;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	GetThermalMeter(Adapter, &Adapter->mppriv.workparam.io_value);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+	Adapter->mppriv.workparam.bcompleted = _TRUE;
+	Adapter->mppriv.act_in_progress = _FALSE;
+
+	*(u32*)poid_par_priv->information_buf = Adapter->mppriv.workparam.io_value;
+	*poid_par_priv->bytes_rw = sizeof(u32);
+
+_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_tssi_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_read_tssi_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (Adapter->mppriv.act_in_progress == _TRUE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	//init workparam
+	Adapter->mppriv.act_in_progress = _TRUE;
+	Adapter->mppriv.workparam.bcompleted = _FALSE;
+	Adapter->mppriv.workparam.act_type = MPT_READ_TSSI;
+	Adapter->mppriv.workparam.io_offset = 0;
+	Adapter->mppriv.workparam.io_value = 0xFFFFFFFF;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (!gettssi_cmd(Adapter,0, (u8*)&Adapter->mppriv.workparam.io_value))
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+oid_rt_pro_set_power_tracking_hdl: type=0x%02x\n",
+		  *((u8*)poid_par_priv->information_buf )));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (!setptm_cmd(Adapter,*((u8*)poid_par_priv->information_buf )))
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32 ratevalue;
+	u8 datarates[NumRates];
+	int i;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+OID_RT_PRO_SET_BASIC_RATE\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	ratevalue = *((u32*)poid_par_priv->information_buf);
+
+	for (i = 0; i < NumRates; i++) {
+		if (ratevalue == mpdatarate[i])
+			datarates[i] = mpdatarate[i];
+		else
+			datarates[i] = 0xff;
+		RT_TRACE(_module_rtl871x_ioctl_c_, _drv_info_, ("basicrate_inx=%d\n", datarates[i]));
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (setbasicrate_cmd(Adapter, datarates) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-OID_RT_PRO_SET_BASIC_RATE: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+#ifdef CONFIG_PWRCTRL
+
+	if (poid_par_priv->information_buf_len < 8)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	*poid_par_priv->bytes_rw = 8;
+	_memcpy(poid_par_priv->information_buf, &(Adapter->pwrctrlpriv.pwr_mode), 8);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_qry_pwrstate_hdl: pwr_mode=%d smart_ps=%d\n",
+		  Adapter->pwrctrlpriv.pwr_mode, Adapter->pwrctrlpriv.smart_ps));
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	uint pwr_mode, smart_ps;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Set OID_RT_PRO_SET_PWRSTATE\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+#ifdef CONFIG_PWRCTRL
+
+	*poid_par_priv->bytes_rw = 0;
+	*poid_par_priv->bytes_needed = 8;
+
+	if (poid_par_priv->information_buf_len < 8)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pwr_mode = *(uint *)(poid_par_priv->information_buf);
+	smart_ps = *(uint *)((int)poid_par_priv->information_buf + 4);
+	if (pwr_mode != Adapter->pwrctrlpriv.pwr_mode || smart_ps != Adapter->pwrctrlpriv.smart_ps)
+		set_ps_mode(Adapter, pwr_mode, smart_ps);
+
+	*poid_par_priv->bytes_rw = 8;
+
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	struct setratable_parm *prate_table;
+	u8		res;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed  = sizeof(struct setratable_parm);
+	if (poid_par_priv->information_buf_len < sizeof(struct setratable_parm))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	prate_table = (struct setratable_parm*)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	res = setrttbl_cmd(Adapter, prate_table);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	if (res == _FAIL)
+		status = NDIS_STATUS_FAILURE;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	#if 0
+			struct mp_wi_cntx *pmp_wi_cntx=&(Adapter->mppriv.wi_cntx);
+			u8 res=_SUCCESS;
+			DEBUG_INFO(("===> Set OID_RT_PRO_H2C_GET_RATE_TABLE.\n"));
+
+			if(pmp_wi_cntx->bmp_wi_progress ==_TRUE){
+				DEBUG_ERR(("\n mp workitem is progressing, not allow to set another workitem right now!!!\n"));
+				Status = NDIS_STATUS_NOT_ACCEPTED;
+				break;
+			}
+			else{
+				pmp_wi_cntx->bmp_wi_progress=_TRUE;
+				pmp_wi_cntx->param.bcompleted=_FALSE;
+				pmp_wi_cntx->param.act_type=MPT_GET_RATE_TABLE;
+				pmp_wi_cntx->param.io_offset=0x0;
+				pmp_wi_cntx->param.bytes_cnt=sizeof(struct getratable_rsp);
+				pmp_wi_cntx->param.io_value=0xffffffff;
+
+				res=getrttbl_cmd(Adapter,(struct getratable_rsp *)pmp_wi_cntx->param.data);
+				*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+				if(res != _SUCCESS)
+				{
+					Status = NDIS_STATUS_NOT_ACCEPTED;
+				}
+			}
+			DEBUG_INFO(("\n <=== Set OID_RT_PRO_H2C_GET_RATE_TABLE.\n"));
+	#endif
+
+_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_87_12_00   section start ****************
+NDIS_STATUS oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	ENCRY_CTRL_STATE encry_mode;
+
+
+	*poid_par_priv->bytes_needed = sizeof(u8);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	if (poid_par_priv->type_of_oid == SET_OID)
+	{
+		encry_mode = *((u8*)poid_par_priv->information_buf);
+		switch (encry_mode)
+		{
+			case HW_CONTROL:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_FALSE;
+				Adapter->registrypriv.software_encrypt=_FALSE;
+				#else
+				psecuritypriv->sw_decrypt = _FALSE;
+				psecuritypriv->sw_encrypt = _FALSE;
+				#endif
+				break;
+			case SW_CONTROL:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_TRUE;
+				Adapter->registrypriv.software_encrypt=_TRUE;
+				#else
+				psecuritypriv->sw_decrypt = _TRUE;
+				psecuritypriv->sw_encrypt = _TRUE;
+				#endif
+				break;
+			case HW_ENCRY_SW_DECRY:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_TRUE;
+				Adapter->registrypriv.software_encrypt=_FALSE;
+				#else
+				psecuritypriv->sw_decrypt = _TRUE;
+				psecuritypriv->sw_encrypt = _FALSE;
+				#endif
+				break;
+			case SW_ENCRY_HW_DECRY:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_FALSE;
+				Adapter->registrypriv.software_encrypt=_TRUE;
+				#else
+				psecuritypriv->sw_decrypt = _FALSE;
+				psecuritypriv->sw_encrypt = _TRUE;
+				#endif
+				break;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_c_, _drv_notice_,
+			 ("-oid_rt_pro_encryption_ctrl_hdl: SET encry_mode=0x%x sw_encrypt=0x%x sw_decrypt=0x%x\n",
+			  encry_mode, psecuritypriv->sw_encrypt, psecuritypriv->sw_decrypt));
+	}
+	else {
+		#if 0
+		if (Adapter->registrypriv.software_encrypt == _FALSE) {
+			if (Adapter->registrypriv.software_decrypt == _FALSE)
+				encry_mode = HW_CONTROL;
+			else
+				encry_mode = HW_ENCRY_SW_DECRY;
+		}
+		else {
+			if (Adapter->registrypriv.software_decrypt == _FALSE)
+				encry_mode = SW_ENCRY_HW_DECRY;
+			else
+				encry_mode = SW_CONTROL;
+		}
+		#else
+
+		if ((psecuritypriv->sw_encrypt == _FALSE) && (psecuritypriv->sw_decrypt == _FALSE))
+			encry_mode = HW_CONTROL;
+		else if ((psecuritypriv->sw_encrypt == _FALSE) && (psecuritypriv->sw_decrypt == _TRUE))
+			encry_mode = HW_ENCRY_SW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == _TRUE) && (psecuritypriv->sw_decrypt == _FALSE))
+			encry_mode = SW_ENCRY_HW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == _TRUE) && (psecuritypriv->sw_decrypt == _TRUE))
+			encry_mode = SW_CONTROL;
+
+		#endif
+
+		*(u8*)poid_par_priv->information_buf =  encry_mode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			 ("-oid_rt_pro_encryption_ctrl_hdl: QUERY encry_mode=0x%x\n",
+			  encry_mode));
+	}
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL			oldirql;
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info 	*psta = NULL;
+	UCHAR 			*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	macaddr = (UCHAR *) poid_par_priv->information_buf ;
+
+	RT_TRACE(_module_rtl871x_ioctl_c_,_drv_notice_,
+		 ("OID_RT_PRO_ADD_STA_INFO: addr=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  macaddr[0],macaddr[1],macaddr[2],macaddr[3],macaddr[4],macaddr[5]));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	psta = get_stainfo(&Adapter->stapriv, macaddr);
+
+	if (psta == NULL) { // the sta have been in sta_info_queue => do nothing
+		psta = alloc_stainfo(&Adapter->stapriv, macaddr);
+
+		if (psta == NULL) {
+			RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("Can't alloc sta_info when OID_RT_PRO_ADD_STA_INFO\n"));
+			status = NDIS_STATUS_FAILURE;
+		}
+	} else { //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
+		RT_TRACE(_module_rtl871x_ioctl_c_, _drv_err_,
+			("Error: OID_RT_PRO_ADD_STA_INFO: sta has been in sta_hash_queue \n"));
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL			irqL;
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info 	*psta = NULL;
+	UCHAR			*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	macaddr = (UCHAR *) poid_par_priv->information_buf ;
+	RT_TRACE(_module_rtl871x_ioctl_c_,_drv_notice_,
+		 ("+OID_RT_PRO_ADD_STA_INFO: addr=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]));
+
+	psta = get_stainfo(&Adapter->stapriv, macaddr);
+	if (psta != NULL) {
+		_enter_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
+		free_stainfo(Adapter, psta);
+		_exit_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
+	}
+
+	return status;
+}
+//------------------------------------------------------------------------------
+#include <sdio_osintf.h>
+u32 mp_query_drv_var(_adapter *padapter, u8 offset, u32 var)
+{
+#ifdef CONFIG_SDIO_HCI
+
+	if (offset == 1) {
+		u16 tmp_blk_num;
+		tmp_blk_num = read16(padapter, SDIO_RX0_RDYBLK_NUM);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("Query Information, mp_query_drv_var  SDIO_RX0_RDYBLK_NUM=0x%x   padapter->dvobjpriv.rxblknum=0x%x\n", tmp_blk_num, padapter->dvobjpriv.rxblknum));
+		if (padapter->dvobjpriv.rxblknum != tmp_blk_num) {
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_, ("Query Information, mp_query_drv_var  call recv rx\n"));
+		//	sd_recv_rxfifo(padapter);
+		}
+	}
+
+#if 0
+	if(offset <=100){  //For setting data rate and query data rate
+		if(offset==100){ //For query data rate
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d): query rate=0x%.2x \n",offset,padapter->registrypriv.tx_rate));
+			var=padapter->registrypriv.tx_rate;
+
+		}
+		else if(offset<0x1d){  //For setting data rate
+			padapter->registrypriv.tx_rate=offset;
+			var=padapter->registrypriv.tx_rate;
+			padapter->registrypriv.use_rate=_TRUE;
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d): set rate=0x%.2x \n",offset,padapter->registrypriv.tx_rate));
+		}
+		else{ //not use the data rate
+			padapter->registrypriv.use_rate=_FALSE;
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d) out of rate range\n",offset));
+		}
+	}
+	else if (offset<=110){  //for setting debug level
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var: offset(%d) for set debug level\n",offset));
+		if(offset==110){ //For query data rate
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var: offset(%d): query dbg level=0x%.2x \n",offset,padapter->registrypriv.dbg_level));
+			padapter->registrypriv.dbg_level=GlobalDebugLevel;
+			var=padapter->registrypriv.dbg_level;
+		}
+		else if(offset<110 && offset>100){
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var: offset(%d): set dbg level=0x%.2x \n",offset,offset-100));
+			padapter->registrypriv.dbg_level=GlobalDebugLevel=offset-100;
+			var=padapter->registrypriv.dbg_level;
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var(_drv_emerg_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, (" mp_query_drv_var(_drv_alert_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_crit_, (" mp_query_drv_var(_drv_crit_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, (" mp_query_drv_var(_drv_err_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_warning_, (" mp_query_drv_var(_drv_warning_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, (" mp_query_drv_var(_drv_notice_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, (" mp_query_drv_var(_drv_info_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_debug_, (" mp_query_drv_var(_drv_debug_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+
+		}
+	}
+	else if(offset >110 &&offset <116){
+		if(115==offset){
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var(_drv_emerg_): offset(%d): query TRX access type: [tx_block_mode=%x,rx_block_mode=%x]\n",\
+															offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+		}
+		else {
+			switch(offset){
+				case 111:
+					padapter->dvobjpriv.tx_block_mode=1;
+					padapter->dvobjpriv.rx_block_mode=1;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX block/RX block) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				case 112:
+					padapter->dvobjpriv.tx_block_mode=1;
+					padapter->dvobjpriv.rx_block_mode=0;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX block/RX byte) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				case 113:
+					padapter->dvobjpriv.tx_block_mode=0;
+					padapter->dvobjpriv.rx_block_mode=1;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX byte/RX block) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				case 114:
+					padapter->dvobjpriv.tx_block_mode=0;
+					padapter->dvobjpriv.rx_block_mode=0;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX byte/RX byte) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				default :
+					break;
+
+			}
+
+		}
+
+	}
+	else if(offset>=127){
+		u64	prnt_dbg_comp;
+		u8   chg_idx;
+		u64	tmp_dbg_comp;
+		chg_idx=offset-0x80;
+		tmp_dbg_comp=BIT(chg_idx);
+		prnt_dbg_comp=padapter->registrypriv.dbg_component= GlobalDebugComponents;
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" 1: mp_query_drv_var: offset(%d;0x%x):for dbg conpoment prnt_dbg_comp=0x%.16x GlobalDebugComponents=0x%.16x padapter->registrypriv.dbg_component=0x%.16x\n",offset,offset,prnt_dbg_comp,GlobalDebugComponents,padapter->registrypriv.dbg_component));
+		if(offset==127){
+	//		prnt_dbg_comp=padapter->registrypriv.dbg_component= GlobalDebugComponents;
+			var=(u32)(padapter->registrypriv.dbg_component);
+			RT_TRACE(0xffffffff, _drv_emerg_, ("2: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h) \n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+			prnt_dbg_comp=GlobalDebugComponents;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("2-1: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h)\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+			prnt_dbg_comp=GlobalDebugComponents=padapter->registrypriv.dbg_component;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("2-2: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h)\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+
+		}
+		else{
+			RT_TRACE(0xffffffff, _drv_emerg_, ("3: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h) GlobalDebugComponents=0x%x(l) 0x%x(h) chg_idx=%d\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp,chg_idx));
+			prnt_dbg_comp=GlobalDebugComponents;
+			RT_TRACE(0xffffffff, _drv_emerg_,("3-1: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h) chg_idx=%d\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp,chg_idx));// ("3-1: mp_query_drv_var: offset(%d;0x%x):before set dbg conpoment=0x%x chg_idx=%d or0x%x BIT(chg_idx[%d]=0x%x)\n",offset,offset,prnt_dbg_comp,chg_idx,chg_idx,(chg_idx),tmp_dbg_comp)
+			prnt_dbg_comp=GlobalDebugComponents=padapter->registrypriv.dbg_component;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("3-2: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h)\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+
+			if(GlobalDebugComponents&tmp_dbg_comp){
+				//this bit is already set, now clear it
+				GlobalDebugComponents=GlobalDebugComponents&(~tmp_dbg_comp);
+			}
+			else{
+				//this bit is not set, now set it.
+				GlobalDebugComponents =GlobalDebugComponents|tmp_dbg_comp;
+			}
+			RT_TRACE(0xffffffff, _drv_emerg_, ("4: mp_query_drv_var: offset(%d;0x%x):before set dbg conpoment tmp_dbg_comp=0x%x GlobalDebugComponents=0x%x(l) 0x%x(h)",offset,offset,tmp_dbg_comp,prnt_dbg_comp));
+			prnt_dbg_comp=GlobalDebugComponents;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("4-1: mp_query_drv_var: offset(%d;0x%x):before set dbg conpoment tmp_dbg_comp=0x%x GlobalDebugComponents=0x%x(l) 0x%x(h)",offset,offset,tmp_dbg_comp,prnt_dbg_comp));
+
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_emerg_, ("0: mp_query_drv_var(_module_rtl871x_xmit_c_:0): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,prnt_dbg_comp));
+			RT_TRACE(_module_xmit_osdep_c_, _drv_emerg_, ("1: mp_query_drv_var(_module_xmit_osdep_c_:1): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_emerg_, ("2: mp_query_drv_var(_module_rtl871x_recv_c_:2): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_recv_osdep_c_, _drv_emerg_, ("3: mp_query_drv_var(_module_recv_osdep_c_:3): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_emerg_, ("4: mp_query_drv_var(_module_rtl871x_mlme_c_:4): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_mlme_osdep_c_, _drv_emerg_, (" 5:mp_query_drv_var(_module_mlme_osdep_c_:5): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_emerg_, ("6: mp_query_drv_var(_module_rtl871x_sta_mgt_c_:6): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_emerg_, ("7: mp_query_drv_var(_module_rtl871x_cmd_c_:7): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_cmd_osdep_c_, _drv_emerg_, ("8: mp_query_drv_var(_module_cmd_osdep_c_:8): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_io_c_, _drv_emerg_, ("9: mp_query_drv_var(_module_rtl871x_io_c_:9): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_io_osdep_c_, _drv_emerg_, ("10: mp_query_drv_var(_module_io_osdep_c_:10): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_os_intfs_c_, _drv_emerg_, ("11: mp_query_drv_var(_module_os_intfs_c_:11): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_security_c_, _drv_emerg_, ("12: mp_query_drv_var(_module_rtl871x_security_c_:12): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_eeprom_c_, _drv_emerg_, ("13: mp_query_drv_var(_module_rtl871x_eeprom_c_:13): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hal_init_c_, _drv_emerg_, ("14: mp_query_drv_var(_module_hal_init_c_:14): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_hal_init_c_, _drv_emerg_, ("15: mp_query_drv_var(_module_hci_hal_init_c_:15): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_ioctl_c_, _drv_emerg_, ("16: mp_query_drv_var(_module_rtl871x_ioctl_c_:16): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_emerg_, ("17: mp_query_drv_var(_module_rtl871x_ioctl_set_c_:17): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_ioctl_query_c_, _drv_emerg_, ("18: mp_query_drv_var(_module_rtl871x_ioctl_query_c_:18): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_emerg_, ("19: mp_query_drv_var(_module_rtl871x_pwrctrl_c_:19): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_intfs_c_, _drv_emerg_, ("20: mp_query_drv_var(_module_hci_intfs_c_:20): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_ops_c_, _drv_emerg_, ("21: mp_query_drv_var(_module_hci_ops_c_:21): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_osdep_service_c_, _drv_emerg_, ("22: mp_query_drv_var(_module_osdep_service_c_:22): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("23: mp_query_drv_var(_module_rtl871x_mp_ioctl_c_:23): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_ops_os_c_, _drv_emerg_, ("24: mp_query_drv_var(_module_hci_ops_os_c_:24): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			var=(u32)(GlobalDebugComponents);
+			//GlobalDebugComponents=padapter->registrypriv.dbg_component;
+			RT_TRACE(0xffffffff, _drv_emerg_, (" ==mp_query_drv_var(_module_rtl871x_mp_ioctl_c_): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+
+		}
+	}
+	else{
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d) >110\n",offset));
+	}
+#endif
+#endif
+
+	return var;
+}
+
+NDIS_STATUS oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL oldirql;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+
+	DR_VARIABLE_STRUCT *pdrv_var;
+
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = sizeof(DR_VARIABLE_STRUCT);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Query Information, OID_RT_PRO_QUERY_DR_VARIABLE\n"));
+
+	pdrv_var = (struct _DR_VARIABLE_STRUCT_ *)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	pdrv_var->variable = mp_query_drv_var(Adapter, pdrv_var->offset, pdrv_var->variable);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_query_dr_variable_hdl: offset=0x%x valule=0x%x\n",
+		  pdrv_var->offset, pdrv_var->variable));
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("oid_rt_pro_rx_packet_type_hdl...................\n"));
+#if 0
+
+	if (poid_par_priv->information_buf_len < sizeof (UCHAR)) {
+		status = NDIS_STATUS_INVALID_LENGTH;
+		*poid_par_priv->bytes_needed = sizeof(UCHAR);
+		return status;
+	}
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		Adapter->mppriv.rx_with_status = *(UCHAR *) poid_par_priv->information_buf;
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_, ("Query Information, OID_RT_PRO_RX_PACKET_TYPE:%d \n",\
+												Adapter->mppriv.rx_with_status));
+
+		//*(u32 *)&Adapter->eeprompriv.mac_addr[0]=read32(Adapter, 0x10250050);
+		//*(u16 *)&Adapter->eeprompriv.mac_addr[4]=read16(Adapter, 0x10250054);
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("MAC addr=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x  \n",
+			Adapter->eeprompriv.mac_addr[0],Adapter->eeprompriv.mac_addr[1],Adapter->eeprompriv.mac_addr[2],\
+			Adapter->eeprompriv.mac_addr[3],Adapter->eeprompriv.mac_addr[4],Adapter->eeprompriv.mac_addr[5]));
+
+	}
+	else {
+		*(UCHAR *) poid_par_priv->information_buf = Adapter->mppriv.rx_with_status;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_, ("Query Information, OID_RT_PRO_RX_PACKET_TYPE:%d \n", \
+												Adapter->mppriv.rx_with_status));
+
+		//*(u32 *)&Adapter->eeprompriv.mac_addr[0]=read32(Adapter, 0x10250050);
+		//*(u16 *)&Adapter->eeprompriv.mac_addr[4]=read16(Adapter, 0x10250054);
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("MAC addr=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x  \n",
+			Adapter->eeprompriv.mac_addr[0],Adapter->eeprompriv.mac_addr[1],Adapter->eeprompriv.mac_addr[2],\
+			Adapter->eeprompriv.mac_addr[3],Adapter->eeprompriv.mac_addr[4],Adapter->eeprompriv.mac_addr[5]));
+	}
+#endif
+
+	return NDIS_STATUS_SUCCESS;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL oldirql;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+
+	PEFUSE_ACCESS_STRUCT pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+#if 0
+	u16 i;
+#endif
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(EFUSE_ACCESS_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pefuse = (PEFUSE_ACCESS_STRUCT)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+
+	_memset(data, 0xFF, cnts);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		("+oid_rt_pro_read_efuse_hd: buf_len=%ld addr=0x%04x cnts=%d\n",
+		 poid_par_priv->information_buf_len, addr, cnts));
+
+	if ((addr>511) || (cnts<1) || (cnts>512) || (addr+cnts)>EFUSE_MAX_SIZE) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("!oid_rt_pro_read_efuse_hdl: parameter error\n"));
+		return NDIS_STATUS_NOT_ACCEPTED;
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	if (efuse_access(Adapter, _TRUE, addr, cnts, data) == _FALSE)
+		status = NDIS_STATUS_FAILURE;
+	_irqlevel_changed_(&oldirql, RAISE);
+
+#if 0
+	for (i = 0; i < cnts; i++) {
+		*((UCHAR *)poid_par_priv->information_buf+3+i) = tmpdata[i];
+//		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====> Read Efuse returen [ addr =0x%x, value=0x%x ] =====\n", start_addr+i,tmpdata[i]));
+	}
+#endif
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL oldirql;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+
+	PEFUSE_ACCESS_STRUCT pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pefuse = (PEFUSE_ACCESS_STRUCT)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+oid_rt_pro_write_efuse_hdl: buf_len=%ld addr=0x%04x cnts=%d\n",
+		  poid_par_priv->information_buf_len, addr, cnts));
+
+	if ((addr>511) || (cnts<1) || (cnts>512) || (addr+cnts)>efuse_get_max_size(Adapter)) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("!oid_rt_pro_write_efuse_hdl: parameter error"));
+		return NDIS_STATUS_NOT_ACCEPTED;
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	if (efuse_access(Adapter, _FALSE, addr, cnts, data) == _FALSE)
+		status = NDIS_STATUS_FAILURE;
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	PPGPKT_STRUCT	ppgpkt;
+	u8		tmpidx;
+
+_func_enter_;
+
+//	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_pro_rw_efuse_pgpkt_hdl\n"));
+
+	*poid_par_priv->bytes_rw = 0;
+
+	if (poid_par_priv->information_buf_len < sizeof(PGPKT_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	ppgpkt = (PPGPKT_STRUCT)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+	{
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			("oid_rt_pro_rw_efuse_pgpkt_hdl: Read offset=0x%x\n",\
+			ppgpkt->offset));
+
+		if (efuse_pg_packet_read(Adapter, ppgpkt->offset, ppgpkt->data) == _TRUE)
+			*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		else
+			status = NDIS_STATUS_FAILURE;
+	} else {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			("oid_rt_pro_rw_efuse_pgpkt_hdl: Write offset=0x%x word_en=0x%x\n",\
+			ppgpkt->offset, ppgpkt->word_en));
+
+		if (efuse_reg_init(Adapter) == _TRUE) {
+			if (efuse_pg_packet_write(Adapter, ppgpkt->offset, ppgpkt->word_en, ppgpkt->data) == _TRUE)
+				*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+			else
+				status = NDIS_STATUS_FAILURE;
+			efuse_reg_uninit(Adapter);
+		} else
+			status = NDIS_STATUS_FAILURE;
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("-oid_rt_pro_rw_efuse_pgpkt_hdl: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len <sizeof(int))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	efuse_reg_init(Adapter);
+	*(int*)poid_par_priv->information_buf = efuse_get_current_size(Adapter);
+	efuse_reg_uninit(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	*(int*)poid_par_priv->information_buf = efuse_get_max_size(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("-oid_rt_get_efuse_max_size_hdl: size=%d status=%d\n",
+		  *(int*)poid_par_priv->information_buf, status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_pro_efuse_hdl\n"));
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+		status = oid_rt_pro_read_efuse_hdl(poid_par_priv);
+	else
+		status = oid_rt_pro_write_efuse_hdl(poid_par_priv);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_pro_efuse_hdl: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u8		*data;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_efuse_map_hdl\n"));
+
+	*poid_par_priv->bytes_rw = 0;
+
+	if (poid_par_priv->information_buf_len < EFUSE_MAP_MAX_SIZE)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	data = (u8*)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+	{
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+			("oid_rt_pro_efuse_map_hdl: READ\n"));
+
+		if (efuse_map_read(Adapter, 0, EFUSE_MAP_MAX_SIZE, data) == _TRUE)
+			*poid_par_priv->bytes_rw = EFUSE_MAP_MAX_SIZE;
+		else {
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_,
+				("oid_rt_pro_efuse_map_hdl: READ fail\n"));
+			status = NDIS_STATUS_FAILURE;
+		}
+	} else {
+		// SET_OID
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+			("oid_rt_pro_efuse_map_hdl: WRITE\n"));
+
+		if (efuse_reg_init(Adapter) == _TRUE) {
+			if (efuse_map_write(Adapter, 0, EFUSE_MAP_MAX_SIZE, data) == _TRUE)
+				*poid_par_priv->bytes_rw = EFUSE_MAP_MAX_SIZE;
+			else {
+				RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_,
+					("oid_rt_pro_efuse_map_hdl: WRITE fail\n"));
+				status = NDIS_STATUS_FAILURE;
+			}
+			efuse_reg_uninit(Adapter);
+		} else {
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_,
+				("oid_rt_pro_efuse_map_hdl: WRITE enable clock fail!\n"));
+			status = NDIS_STATUS_FAILURE;
+		}
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("-oid_rt_pro_efuse_map_hdl: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bandwidth;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_set_bandwidth_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	bandwidth = *((u32*)poid_par_priv->information_buf);//4
+	if (bandwidth != HT_CHANNEL_WIDTH_20)
+		bandwidth = HT_CHANNEL_WIDTH_40;
+
+	Adapter->mppriv.curr_bandwidth = (u8)bandwidth;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SwitchBandwidth(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_set_bandwidth_hdl: bandwidth=%d\n", Adapter->mppriv.curr_bandwidth));
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		crystal_cap = 0;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len <sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	crystal_cap = *((u32*)poid_par_priv->information_buf);//4
+	if (crystal_cap > 0xf)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_crystalcap = crystal_cap;
+
+	_irqlevel_changed_(&oldirql,LOWER);
+	SetCrystalCap(Adapter);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS  oid_rt_set_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL		oldirql;
+	u8		rx_pkt_type;
+	u32		rcr_val32;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_set_rx_packet_type_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len < sizeof(u8)) {
+		status = NDIS_STATUS_INVALID_LENGTH;
+		return status;
+	}
+	rx_pkt_type = *((u8*)poid_par_priv->information_buf);//4
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("rx_pkt_type: %x\n",rx_pkt_type ));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+#if 0
+	rcr_val8 = read8(Adapter, 0x10250048);//RCR
+	rcr_val8 &= ~(RCR_AB|RCR_AM|RCR_APM|RCR_AAP);
+
+	if(rx_pkt_type == RX_PKT_BROADCAST){
+		rcr_val8 |= (RCR_AB | RCR_ACRC32 );
+	}
+	else if(rx_pkt_type == RX_PKT_DEST_ADDR){
+		rcr_val8 |= (RCR_AAP| RCR_AM |RCR_ACRC32);
+	}
+	else if(rx_pkt_type == RX_PKT_PHY_MATCH){
+		rcr_val8 |= (RCR_APM|RCR_ACRC32);
+	}
+	else{
+		rcr_val8 &= ~(RCR_AAP|RCR_APM|RCR_AM|RCR_AB|RCR_ACRC32);
+	}
+	write8(Adapter, 0x10250048,rcr_val8);
+#else
+	rcr_val32 = read32(Adapter, RCR);//RCR = 0x10250048
+	rcr_val32 &= ~(RCR_CBSSID|RCR_AB|RCR_AM|RCR_APM|RCR_AAP);
+#if 0
+	if(rx_pkt_type == RX_PKT_BROADCAST){
+		rcr_val32 |= (RCR_AB|RCR_AM|RCR_APM|RCR_AAP|RCR_ACRC32);
+	}
+	else if(rx_pkt_type == RX_PKT_DEST_ADDR){
+		//rcr_val32 |= (RCR_CBSSID|RCR_AAP|RCR_AM|RCR_ACRC32);
+		rcr_val32 |= (RCR_CBSSID|RCR_APM|RCR_ACRC32);
+	}
+	else if(rx_pkt_type == RX_PKT_PHY_MATCH){
+		rcr_val32 |= (RCR_APM|RCR_ACRC32);
+		//rcr_val32 |= (RCR_AAP|RCR_ACRC32);
+	}
+	else{
+		rcr_val32 &= ~(RCR_AAP|RCR_APM|RCR_AM|RCR_AB|RCR_ACRC32);
+	}
+#else
+	switch (rx_pkt_type)
+	{
+		case RX_PKT_BROADCAST :
+			rcr_val32 |= (RCR_AB|RCR_AM|RCR_APM|RCR_AAP|RCR_ACRC32);
+			break;
+		case RX_PKT_DEST_ADDR :
+			rcr_val32 |= (RCR_AB|RCR_AM|RCR_APM|RCR_AAP|RCR_ACRC32);
+			break;
+		case RX_PKT_PHY_MATCH:
+			rcr_val32 |= (RCR_APM|RCR_ACRC32);
+			break;
+		default:
+			rcr_val32 &= ~(RCR_AAP|RCR_APM|RCR_AM|RCR_AB|RCR_ACRC32);
+			break;
+	}
+
+	if (rx_pkt_type == RX_PKT_DEST_ADDR) {
+		Adapter->mppriv.check_mp_pkt = 1;
+	} else {
+		Adapter->mppriv.check_mp_pkt = 0;
+	}
+#endif
+	write32(Adapter, RCR, rcr_val32);
+
+#endif
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32 		txagc;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	txagc = *(u32*)poid_par_priv->information_buf;
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("oid_rt_pro_set_tx_agc_offset_hdl: 0x%08x\n", txagc));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetTxAGCOffset(Adapter, txagc);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+
+	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	struct mp_priv		*pmppriv = &Adapter->mppriv;
+	u32 			type;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len <sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	type = *(u32*)poid_par_priv->information_buf;
+
+	if (_LOOPBOOK_MODE_ == type) {
+		pmppriv->mode = type;
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); //append txdesc
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("test mode change to loopback mode:0x%08x.\n", pmlmepriv->fw_state));
+	} else if (_2MAC_MODE_ == type){
+		pmppriv->mode = type;
+		_clr_fwstate_(pmlmepriv, WIFI_MP_LPBK_STATE);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("test mode change to 2mac mode:0x%08x.\n", pmlmepriv->fw_state));
+	} else
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+//Linux
+struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv)
+{
+	_queue *pfree_xmit_queue = &pmp_priv->free_mp_xmitqueue;
+
+	_irqL irqL;
+
+	struct mp_xmit_frame *pxframe=  NULL;
+	_list *plist, *phead;
+
+_func_enter_;
+
+	_enter_critical(&pfree_xmit_queue->lock, &irqL);
+
+	if (_queue_empty(pfree_xmit_queue) == _TRUE) {
+		//DEBUG_ERR(("free_mp_xmitframe_cnt:%d\n", pmp_priv->free_mp_xmitframe_cnt));
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(pfree_xmit_queue);
+		plist = get_next(phead);
+
+		pxframe = LIST_CONTAINOR(plist, struct mp_xmit_frame, list);
+
+		list_delete(&(pxframe->list));
+	}
+
+	if (pxframe !=  NULL)
+		pmp_priv->free_mp_xmitframe_cnt--;
+
+	_exit_critical(&pfree_xmit_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxframe;
+}
+
+int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe)
+{
+	_irqL irqL;
+	_adapter *padapter = pxmitpriv->adapter;
+	 struct mp_priv *pmp_priv = &padapter->mppriv;
+	_queue *pfree_xmit_queue = &pmp_priv->free_mp_xmitqueue;
+
+	if (pmp_xmitframe == NULL)
+		goto exit;
+
+	if (pmp_xmitframe->frame_tag != MP_FRAMETAG)
+		goto exit;
+
+	list_delete(&pmp_xmitframe->list);
+
+	_enter_critical(&pfree_xmit_queue->lock, &irqL);
+
+	list_insert_tail(&(pmp_xmitframe->list), get_list_head(pfree_xmit_queue));
+
+	pmp_priv->free_mp_xmitframe_cnt++;
+
+	_exit_critical(&pfree_xmit_queue->lock, &irqL);
+
+exit:
+
+	return _SUCCESS;
+}
+
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv)
+{
+#if 0
+	unsigned char *pframe, *pmp_pkt;
+	struct ethhdr *pethhdr;
+	struct pkt_attrib *pattrib;
+	struct ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	int llc_sz, payload_len;
+	struct mp_xmit_frame *pxframe=  NULL;
+	struct mp_xmit_packet *pmp_xmitpkt = (struct mp_xmit_packet*)param;
+	u8 addr3[] = {0x02, 0xE0, 0x4C, 0x87, 0x66, 0x55};
+
+//	printk("+mp_ioctl_xmit_packet_hdl\n");
+
+	pxframe = alloc_mp_xmitframe(&padapter->mppriv);
+	if (pxframe == NULL)
+	{
+		DEBUG_ERR(("Can't alloc pmpframe %d:%s\n", __LINE__, __FILE__));
+		return -1;
+	}
+
+	//mp_xmit_pkt
+	payload_len = pmp_xmitpkt->len - 14;
+	pmp_pkt = (unsigned char*)pmp_xmitpkt->mem;
+	pethhdr = (struct ethhdr *)pmp_pkt;
+
+	//printk("payload_len=%d, pkt_mem=0x%x\n", pmp_xmitpkt->len, (void*)pmp_xmitpkt->mem);
+
+	//printk("pxframe=0x%x\n", (void*)pxframe);
+	//printk("pxframe->mem=0x%x\n", (void*)pxframe->mem);
+
+	//update attribute
+	pattrib = &pxframe->attrib;
+	memset((u8 *)(pattrib), 0, sizeof (struct pkt_attrib));
+	pattrib->pktlen = pmp_xmitpkt->len;
+	pattrib->ether_type = ntohs(pethhdr->h_proto);
+	pattrib->hdrlen = 24;
+	pattrib->nr_frags = 1;
+	pattrib->priority = 0;
+#ifndef CONFIG_MP_LINUX
+	if(IS_MCAST(pethhdr->h_dest))
+		pattrib->mac_id = 4;
+	else
+		pattrib->mac_id = 5;
+#else
+	pattrib->mac_id = 5;
+#endif
+
+	//
+	memset(pxframe->mem, 0 , WLANHDR_OFFSET);
+	pframe = (u8 *)(pxframe->mem) + WLANHDR_OFFSET;
+
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetFrameSubType(pframe, WIFI_DATA);
+
+	_memcpy(pwlanhdr->addr1, pethhdr->h_dest, ETH_ALEN);
+	_memcpy(pwlanhdr->addr2, pethhdr->h_source, ETH_ALEN);
+
+	_memcpy(pwlanhdr->addr3, addr3, ETH_ALEN);
+
+	pwlanhdr->seq_ctl = 0;
+	pframe += pattrib->hdrlen;
+
+	llc_sz= rtl8711_put_snap(pframe, pattrib->ether_type);
+	pframe += llc_sz;
+
+	_memcpy(pframe, (void*)(pmp_pkt+14),  payload_len);
+
+	pattrib->last_txcmdsz = pattrib->hdrlen + llc_sz + payload_len;
+
+	DEBUG_INFO(("issuing mp_xmit_frame, tx_len=%d, ether_type=0x%x\n", pattrib->last_txcmdsz, pattrib->ether_type));
+	xmit_mp_frame(padapter, pxframe);
+
+#endif
+
+	return _SUCCESS;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_power_down_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	_irqL		oldirql;
+	u8		bpwrup;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("\n ===> Setoid_rt_set_power_down_hdl.\n"));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	bpwrup = *(u8 *)poid_par_priv->information_buf;
+	//CALL  the power_down function
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_SDIO_HCI
+	dev_power_down(Adapter,bpwrup);
+#endif
+#endif
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	//DEBUG_ERR(("\n <=== Query OID_RT_PRO_READ_REGISTER.
+	//	Add:0x%08x Width:%d Value:0x%08x\n",RegRWStruct->offset,RegRWStruct->width,RegRWStruct->value));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+//	_irqL		oldirql;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len < sizeof(u32)) {
+		status = NDIS_STATUS_INVALID_LENGTH;
+		return status;
+	}
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("\n ===> oid_rt_get_power_mode_hdl.\n"));
+
+//	_irqlevel_changed_(&oldirql, LOWER);
+	*(int*)poid_par_priv->information_buf = Adapter->registrypriv.low_power ? POWER_LOW : POWER_NORMAL;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+//	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
diff --git a/drivers/net/wireless/8712u/os_dep/linux/cmd_linux.c b/drivers/net/wireless/8712u/os_dep/linux/cmd_linux.c
new file mode 100755
index 0000000..e82aa7d
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/cmd_linux.c
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _CMD_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+
+
diff --git a/drivers/net/wireless/8712u/os_dep/linux/io_linux.c b/drivers/net/wireless/8712u/os_dep/linux/io_linux.c
new file mode 100755
index 0000000..4f9038d
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/io_linux.c
@@ -0,0 +1,129 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _IO_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+
+#include <linux/firmware.h>
+
+#ifdef CONFIG_SDIO_HCI
+	#include<linux/mmc/sdio_func.h>
+#endif
+	
+#ifdef CONFIG_EMBEDDED_FWIMG
+#include <farray.h>
+#endif
+
+
+u32 rtl871x_open_fw(_adapter * padapter, void **pphfwfile_hdl, u8 **ppmappedfw)
+{
+	u32 len;
+	
+#ifdef  CONFIG_EMBEDDED_FWIMG	
+
+	*ppmappedfw = f_array;
+	len = sizeof(f_array);		   
+  
+#else
+
+	int rc;		
+	const struct firmware **praw = (const struct firmware **)(pphfwfile_hdl);	
+	
+#ifdef CONFIG_SDIO_HCI		
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)(&padapter->dvobjpriv);
+	struct sdio_func *func= pdvobjpriv->func;
+	rc = request_firmware(praw, "rtl8712fw.bin",&func->dev);
+#endif
+
+#ifdef CONFIG_USB_HCI
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)(&padapter->dvobjpriv);
+	struct usb_device *pusbdev=pdvobjpriv->pusbdev;
+	rc = request_firmware(praw, "rtl8712fw.bin", &pusbdev->dev);
+	RT_TRACE(_module_io_osdep_c_,_drv_info_,("request_firmware: Reason 0x%.8x\n", rc));
+#endif
+
+	if (rc < 0) {
+		RT_TRACE(_module_io_osdep_c_,_drv_err_,("request_firmware failed: Reason 0x%.8x\n", rc));
+		len = 0;
+	}else{
+		*ppmappedfw = (u8 *)((*praw)->data);
+       	len = (*praw)->size;	
+	}
+
+#endif
+
+ 	return len;
+
+}
+
+
+void rtl871x_close_fw(_adapter *padapter, void *phfwfile_hdl)
+{
+
+#ifndef  CONFIG_EMBEDDED_FWIMG		   
+
+	struct firmware *praw = (struct firmware *)phfwfile_hdl;
+	if(praw)	   
+		release_firmware(praw);
+#endif
+
+}
+
+
+
+
diff --git a/drivers/net/wireless/8712u/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/8712u/os_dep/linux/ioctl_cfg80211.c
new file mode 100755
index 0000000..b447a75
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/ioctl_cfg80211.c
@@ -0,0 +1,2402 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define  _IOCTL_CFG80211_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>		
+#include <rtl871x_ioctl.h>
+#include <rtl871x_ioctl_set.h>
+#include <rtl871x_ioctl_query.h>
+#include <xmit_osdep.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+
+#include "ioctl_cfg80211.h"
+
+#define RTW_SCAN_IE_LEN_MAX      2304
+#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 65535 //ms
+#define RTW_MAX_NUM_PMKIDS 4
+
+#define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
+
+static const u32 rtw_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+};
+
+#define RATETAB_ENT(_rate, _rateid, _flags) \
+	{								\
+		.bitrate	= (_rate),				\
+		.hw_value	= (_rateid),				\
+		.flags		= (_flags),				\
+	}
+
+#define CHAN2G(_channel, _freq, _flags) {			\
+	.band			= IEEE80211_BAND_2GHZ,		\
+	.center_freq		= (_freq),			\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#define CHAN5G(_channel, _flags) {				\
+	.band			= IEEE80211_BAND_5GHZ,		\
+	.center_freq		= 5000 + (5 * (_channel)),	\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+static struct ieee80211_rate rtw_rates[] = {
+	RATETAB_ENT(10,  0x1,   0),
+	RATETAB_ENT(20,  0x2,   0),
+	RATETAB_ENT(55,  0x4,   0),
+	RATETAB_ENT(110, 0x8,   0),
+	RATETAB_ENT(60,  0x10,  0),
+	RATETAB_ENT(90,  0x20,  0),
+	RATETAB_ENT(120, 0x40,  0),
+	RATETAB_ENT(180, 0x80,  0),
+	RATETAB_ENT(240, 0x100, 0),
+	RATETAB_ENT(360, 0x200, 0),
+	RATETAB_ENT(480, 0x400, 0),
+	RATETAB_ENT(540, 0x800, 0),
+};
+
+#define rtw_a_rates		(rtw_rates + 4)
+#define rtw_a_rates_size	8
+#define rtw_g_rates		(rtw_rates + 0)
+#define rtw_g_rates_size	12
+
+static struct ieee80211_channel rtw_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+//{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165},37},	// 0x12, RT_CHANNEL_DOMAIN_WORLD_WIDE37
+
+static struct ieee80211_channel rtw_5ghz_a_channels[] = {
+	CHAN5G(34, 0),		CHAN5G(36, 0),
+	CHAN5G(38, 0),		CHAN5G(40, 0),
+	CHAN5G(42, 0),		CHAN5G(44, 0),
+	CHAN5G(46, 0),		CHAN5G(48, 0),
+	CHAN5G(52, 0),		CHAN5G(56, 0),
+	CHAN5G(60, 0),		CHAN5G(64, 0),
+	CHAN5G(100, 0),		CHAN5G(104, 0),
+	CHAN5G(108, 0),		CHAN5G(112, 0),
+	CHAN5G(116, 0),		CHAN5G(120, 0),
+	CHAN5G(124, 0),		CHAN5G(128, 0),
+	CHAN5G(132, 0),		CHAN5G(136, 0),
+	CHAN5G(140, 0),		CHAN5G(149, 0),
+	CHAN5G(153, 0),		CHAN5G(157, 0),
+	CHAN5G(161, 0),		CHAN5G(165, 0),
+	CHAN5G(184, 0),		CHAN5G(188, 0),
+	CHAN5G(192, 0),		CHAN5G(196, 0),
+	CHAN5G(200, 0),		CHAN5G(204, 0),
+	CHAN5G(208, 0),		CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+
+static struct ieee80211_supported_band rtw_band_2ghz = {
+	.band = IEEE80211_BAND_2GHZ,
+	.channels = rtw_2ghz_channels,
+	.n_channels = ARRAY_SIZE(rtw_2ghz_channels),
+	.bitrates = rtw_g_rates,
+	.n_bitrates = rtw_g_rates_size,
+};
+
+static struct ieee80211_supported_band rtw_band_5ghz = {
+	.band = IEEE80211_BAND_5GHZ,
+	.channels = rtw_5ghz_a_channels,
+	.n_channels = ARRAY_SIZE(rtw_5ghz_a_channels),
+	.bitrates = rtw_a_rates,
+	.n_bitrates = rtw_a_rates_size,
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+static const struct ieee80211_txrx_stypes
+rtw_cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_ADHOC] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_AP_VLAN] = {
+		/* copy AP */
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_P2P_GO] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+};
+#endif
+
+static int rtw_ieee80211_channel_to_frequency(int chan, int band)
+{
+	/* see 802.11 17.3.8.3.2 and Annex J
+	* there are overlapping channel numbers in 5GHz and 2GHz bands */
+           
+	if (band == IEEE80211_BAND_5GHZ) {
+       	if (chan >= 182 && chan <= 196)
+			return 4000 + chan * 5;
+             else
+                    return 5000 + chan * 5;
+       } else { /* IEEE80211_BAND_2GHZ */
+		if (chan == 14)
+			return 2484;
+             else if (chan < 14)
+			return 2407 + chan * 5;
+             else
+			return 0; /* not supported */
+	}
+}
+
+static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnetwork)
+{
+	int ret=0;	
+	struct ieee80211_channel *notify_channel;
+	struct cfg80211_bss *bss;
+	//struct ieee80211_supported_band *band;       
+	u16 channel;
+	u32 freq;
+	u64 notify_timestamp;
+	u16 notify_capability;
+	u16 notify_interval;
+	u8 *notify_ie;
+	size_t notify_ielen;
+	s32 notify_signal;
+	u8 buf[768], *pbuf;
+	size_t len;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	long rssi;
+		
+	struct wireless_dev *wdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = wdev->wiphy;
+
+
+	//printk("%s\n", __func__);
+	
+
+   	channel = pnetwork->network.Configuration.DSConfig;
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+	{
+		//band = wiphy->bands[IEEE80211_BAND_2GHZ];
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	}	
+	else
+	{
+		//band = wiphy->bands[IEEE80211_BAND_5GHZ];
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+	}	
+	
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+
+	//rtw_get_timestampe_from_ie()
+	notify_timestamp = jiffies_to_msecs(jiffies)*1000; /* uSec */
+
+	notify_interval = le16_to_cpu(*(u16*)get_beacon_interval_from_ie(pnetwork->network.IEs));
+	notify_capability = le16_to_cpu(*(u16*)get_capability_from_ie(pnetwork->network.IEs));		
+
+	
+	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
+	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
+	   
+	//notify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;
+
+	//We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
+	//notify_signal = 100*( pnetwork->network.Rssi );
+	rssi = signal_scale_mapping(pnetwork->network.Rssi);
+	notify_signal = 100 * ((u8) ( (rssi+1) >> 1 ) - 95 );
+		
+/*
+	printk("bssid: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",
+                        pnetwork->network.MacAddress[0], pnetwork->network.MacAddress[1], pnetwork->network.MacAddress[2],
+                        pnetwork->network.MacAddress[3], pnetwork->network.MacAddress[4], pnetwork->network.MacAddress[5]);
+	printk("Channel: %d(%d)\n", channel, freq);
+	printk("Capability: %X\n", notify_capability);
+	printk("Beacon interval: %d\n", notify_interval);
+	printk("Signal: %d\n", notify_signal);
+	printk("notify_timestamp: %#018llx\n", notify_timestamp);
+*/
+
+	pbuf = buf;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;	
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+
+    if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
+
+		_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);		
+		
+		SetFrameSubType(pbuf, WIFI_BEACON);
+		
+	} else {
+
+		_memcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);		
+		
+		SetFrameSubType(pbuf, WIFI_PROBERSP);
+	}
+
+	_memcpy(pwlanhdr->addr2, pnetwork->network.MacAddress, ETH_ALEN);
+	_memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
+
+
+	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);	
+	len = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	_memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
+	len += pnetwork->network.IELength;
+	
+
+#if 1	
+	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
+		len, notify_signal, GFP_ATOMIC);
+#else			 
+			
+	bss = cfg80211_inform_bss(wiphy, notify_channel, (const u8 *)pnetwork->network.MacAddress,
+                notify_timestamp, notify_capability, notify_interval, notify_ie,
+                notify_ielen, notify_signal, GFP_ATOMIC/*GFP_KERNEL*/);
+#endif
+
+	if (unlikely(!bss)) {
+		printk("rtw_cfg80211_inform_bss error\n");
+		return -EINVAL;
+	}
+
+	return ret;
+
+}
+
+void rtw_cfg80211_indicate_connect(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+
+	printk("%s(padapter=%p)\n", __func__, padapter);
+
+	if (pwdev->iftype != NL80211_IFTYPE_STATION
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
+		#endif
+	) {
+		return;
+	}
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		return;
+	
+	#ifdef CONFIG_LAYER2_ROAMING
+	if(pmlmepriv->to_roaming > 0) {
+		//rtw_cfg80211_inform_bss(padapter, cur_network);
+		DBG_871X("%s call cfg80211_roamed\n", __FUNCTION__);
+		cfg80211_roamed(padapter->pnetdev,
+			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+			NULL,
+			#endif
+			cur_network->network.MacAddress,
+			cur_network->network.IEs+_FIXED_IE_LENGTH_, cur_network->network.IELength-_FIXED_IE_LENGTH_,
+			NULL, 0, GFP_ATOMIC
+		);
+	}
+	else 
+	#endif
+	{
+		cfg80211_connect_result(padapter->pnetdev, cur_network->network.MacAddress, NULL, 0, NULL, 0, 
+							WLAN_STATUS_SUCCESS, GFP_ATOMIC/*GFP_KERNEL*/);
+	}
+}
+
+void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+
+	printk("%s(padapter=%p)\n", __func__, padapter);
+
+	if (pwdev->iftype != NL80211_IFTYPE_STATION 
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
+		#endif
+	) {
+		return;
+	}
+
+	if(pwdev->sme_state==CFG80211_SME_CONNECTING)
+		cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0, 
+							WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC/*GFP_KERNEL*/);
+	else if(pwdev->sme_state==CFG80211_SME_CONNECTED)
+		cfg80211_disconnected(padapter->pnetdev, 0,
+			   				NULL, 0, GFP_ATOMIC);
+	else
+		printk("pwdev->sme_state=%d\n", pwdev->sme_state);
+
+}
+ 	
+static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	NDIS_802_11_WEP	 *pwep = NULL;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;		
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+_func_enter_;
+
+	printk("%s\n", __func__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;		
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;			
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;		
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("wpa_set_encryption, crypt.alg = WEP\n"));
+		printk("wpa_set_encryption, crypt.alg = WEP\n");
+
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(1)wep_key_idx=%d\n", wep_key_idx));
+		printk("(1)wep_key_idx=%d\n", wep_key_idx);
+
+		if (wep_key_idx > WEP_KEYS)
+			return -EINVAL;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(2)wep_key_idx=%d\n", wep_key_idx));
+
+		if (wep_key_len > 0) 
+		{
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+		 	pwep =(NDIS_802_11_WEP	 *) _malloc(wep_total_len);
+			if(pwep == NULL){
+				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
+				goto exit;
+			}
+
+		 	_memset(pwep, 0, wep_total_len);
+
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if(wep_key_len==13)
+			{
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}
+		}
+		else {		
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if(param->u.crypt.set_tx)
+		{
+			printk("wep, set_tx=1\n");
+
+			if(set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			{
+				ret = -EOPNOTSUPP ;
+			}
+		}
+		else
+		{
+			printk("wep, set_tx=0\n");
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
+			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to fw/cam
+			
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP ;
+				goto exit;
+			}				
+			
+		      _memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;	
+			//set_key(padapter, psecuritypriv, wep_key_idx, 0);
+			set_key(padapter, psecuritypriv, wep_key_idx);
+		}
+
+		goto exit;		
+	}
+
+	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	{
+		struct sta_info * psta,*pbcmc_sta;
+		struct sta_priv * pstapriv = &padapter->stapriv;
+
+		//printk("%s, : dot11AuthAlgrthm == dot11AuthAlgrthm_8021X \n", __func__);
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		{
+			psta = get_stainfo(pstapriv, get_bssid(pmlmepriv));				
+			if (psta == NULL) {
+				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
+				printk("%s, : Obtain Sta_info fail \n", __func__);
+			}
+			else
+			{
+				//Jeff: don't disable ieee8021x_blocked while clearing key
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
+					psta->ieee8021x_blocked = _FALSE;
+
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}		
+
+				if(param->u.crypt.set_tx ==1)//pairwise key
+				{ 
+
+					printk("%s, : param->u.crypt.set_tx ==1 \n", __func__);
+					
+					_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					{						
+						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey=_FALSE;
+						_set_timer(&padapter->securitypriv.tkip_timer, 50);						
+					}
+
+					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
+					//DEBUG_ERR(("\n ~~~~stastakey:unicastkey\n"));
+					printk("\n ~~~~stastakey:unicastkey\n");
+					
+					setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
+				}
+				else//group key
+				{ 					
+					if( ( 0 < param->u.crypt.idx ) &&  ( param->u.crypt.idx < 3 ) )
+					{  //group key idx is 1 or 2
+				
+						_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+						_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx-1].skey,&(param->u.crypt.key[16]),8);
+						_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx-1].skey,&(param->u.crypt.key[24]),8);
+
+						padapter->securitypriv.binstallGrpkey = _TRUE;
+						//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						//DEBUG_ERR(("\n ~~~~stastakey:groupkey\n"));
+						printk("\n ~~~~stastakey:groupkey\n");
+
+						set_key(padapter,&padapter->securitypriv,param->u.crypt.idx);
+						
+#ifdef CONFIG_PWRCTRL
+						if(padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE){
+							if(padapter->registrypriv.power_mgnt != padapter->pwrctrlpriv.pwr_mode){
+								_set_timer(&(padapter->mlmepriv.dhcp_timer), 60000);
+							}
+						}
+#endif
+					}
+					
+				}						
+			}
+
+			pbcmc_sta=get_bcmc_stainfo(padapter);
+			if(pbcmc_sta==NULL)
+			{
+				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
+			}
+			else
+			{
+				//Jeff: don't disable ieee8021x_blocked while clearing key
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
+					pbcmc_sta->ieee8021x_blocked = _FALSE;
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{							
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}					
+			}				
+		}
+		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		{		
+		}			
+	}
+
+exit:
+
+	printk("%s, ret=%d\n", __func__, ret);
+	
+	if (pwep) {
+		_mfree((u8 *)pwep,wep_total_len);		
+	}	
+	
+	_func_exit_;
+	
+	return ret;	
+
+}
+
+static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, bool pairwise, const u8 *mac_addr,
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, const u8 *mac_addr,
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				struct key_params *params)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;	
+	int ret=0;
+	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+	
+	printk("%s(netdev=%p), Adding key for %pM\n", __func__, ndev, mac_addr);
+
+	printk("cipher=0x%x\n", params->cipher);
+
+	printk("key_len=0x%x\n", params->key_len);
+
+	printk("seq_len=0x%x\n", params->seq_len);
+
+	printk("key_index=%d\n", key_index);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	printk("pairwise=%d\n", pairwise);
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+
+
+	param_len = sizeof(struct ieee_param) + params->key_len;
+	param = (struct ieee_param *)_malloc(param_len);
+	if (param == NULL)
+		return -1;
+	
+	_memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	_memset(param->sta_addr, 0xff, ETH_ALEN);
+
+	switch (params->cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		//todo: remove key 
+		//remove = 1;	
+		alg_name = "none";
+		break;
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		alg_name = "WEP";
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		alg_name = "TKIP";
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:	
+		return -ENOTSUPP;
+	}
+	
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+	
+
+	if (!mac_addr || is_broadcast_ether_addr(mac_addr))
+	{
+		param->u.crypt.set_tx = 0;
+	} else {
+		param->u.crypt.set_tx = 1;
+	}
+	
+	
+	//param->u.crypt.idx = key_index - 1;
+	param->u.crypt.idx = key_index;
+	
+	if (params->seq_len && params->seq) 
+	{	
+		_memcpy(param->u.crypt.seq, params->seq, params->seq_len);
+	}
+
+	if(params->key_len && params->key)
+	{
+		param->u.crypt.key_len = params->key_len;		
+		_memcpy(param->u.crypt.key, params->key, params->key_len);
+	}	
+
+	//if(rtw_wdev->iftype == NL80211_IFTYPE_STATION)
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{
+		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);	
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)//else if(rtw_wdev->iftype == NL80211_IFTYPE_AP)
+	{
+#ifdef CONFIG_AP_MODE
+		if(mac_addr)
+			_memcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);
+	
+		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
+#endif
+	}
+	else
+	{
+		printk("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
+		
+	}
+
+	if(param)
+	{
+		_mfree((u8*)param, param_len);
+	}
+
+	return ret;
+
+}
+
+static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, bool pairwise, const u8 *mac_addr,
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, const u8 *mac_addr,
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				void *cookie,
+				void (*callback)(void *cookie,
+						 struct key_params*))
+{
+#if 0
+	struct iwm_priv *iwm = ndev_to_iwm(ndev);
+	struct iwm_key *key = &iwm->keys[key_index];
+	struct key_params params;
+
+	IWM_DBG_WEXT(iwm, DBG, "Getting key %d\n", key_index);
+
+	memset(&params, 0, sizeof(params));
+
+	params.cipher = key->cipher;
+	params.key_len = key->key_len;
+	params.seq_len = key->seq_len;
+	params.seq = key->seq;
+	params.key = key->key;
+
+	callback(cookie, &params);
+
+	return key->key_len ? 0 : -ENOENT;
+#endif	
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, bool pairwise, const u8 *mac_addr)
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, const u8 *mac_addr)
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+{
+#if 0
+	struct iwm_priv *iwm = ndev_to_iwm(ndev);
+	struct iwm_key *key = &iwm->keys[key_index];
+
+	if (!iwm->keys[key_index].key_len) {
+		IWM_DBG_WEXT(iwm, DBG, "Key %d not used\n", key_index);
+		return 0;
+	}
+
+	if (key_index == iwm->default_key)
+		iwm->default_key = -1;
+
+	return iwm_set_key(iwm, 1, key);
+#endif	
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
+					struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+					u8 key_index, bool unicast, bool multicast)
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+					u8 key_index)
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+{
+#if 0
+	struct iwm_priv *iwm = ndev_to_iwm(ndev);
+
+	IWM_DBG_WEXT(iwm, DBG, "Default key index is: %d\n", key_index);
+
+	if (!iwm->keys[key_index].key_len) {
+		IWM_ERR(iwm, "Key %d not used\n", key_index);
+		return -EINVAL;
+	}
+
+	iwm->default_key = key_index;
+
+	return iwm_set_tx_key(iwm, key_index);
+#endif	
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_get_station(struct wiphy *wiphy,
+				    struct net_device *ndev,
+				    u8 *mac, struct station_info *sinfo)
+{
+
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+	if(!mac) {
+		printk("%s, mac==%p\n", __func__, mac);
+		return -ENOENT;
+	}
+
+	printk("%s, mac="MAC_FMT"\n", __func__, MAC_ARG(mac));
+
+	//for infra./P2PClient mode
+	if(	check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+	)
+	{
+		struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+		
+		if (_memcmp(mac, cur_network->network.MacAddress, ETH_ALEN) == _FALSE)
+		{
+			printk("%s, mismatch bssid="MAC_FMT"\n", __func__, MAC_ARG(cur_network->network.MacAddress));
+			return -ENOENT;
+		}	
+
+		sinfo->filled |= STATION_INFO_SIGNAL;
+		//sinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
+		//sinfo->signal = (u8) ((cur_network->network.Rssi+1)>>1)-95;
+		sinfo->signal = cur_network->network.Rssi;
+
+		sinfo->filled |= STATION_INFO_TX_BITRATE;
+		sinfo->txrate.legacy = 10 * rtw_get_network_max_rate(padapter, &pmlmepriv->cur_network.network);
+	}
+	
+	//for Ad-Hoc/AP mode
+	if (	(	check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)
+			||check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)
+			||check_fwstate(pmlmepriv, WIFI_AP_STATE) )
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+	)
+	{
+		struct sta_info *psta = NULL;	
+		struct sta_priv *pstapriv = &padapter->stapriv;
+	
+		psta = get_stainfo(pstapriv, mac);
+		if(psta == NULL)
+		{
+			printk("%s, sta_info is null\n", __func__);
+			return -ENOENT;
+		}			
+		
+		//TODO: should acquire station info...
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     enum nl80211_iftype type, u32 *flags,
+				     struct vif_params *params)
+{
+#if 0
+	enum nl80211_iftype old_type;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);		
+	int ret = 0;
+	u8 change = _FALSE;
+
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret= -EPERM;
+		goto exit;
+	}
+
+	old_type = rtw_wdev->iftype;
+	printk("%s, old_iftype=%d, new_iftype=%d\n", __func__, old_type, type);
+
+
+
+	if(old_type != type)
+		change = _TRUE;
+		
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+		networkType = Ndis802_11IBSS;
+		break;
+	case NL80211_IFTYPE_STATION:
+		networkType = Ndis802_11Infrastructure;
+		if(change && rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+		{
+
+			_cancel_timer_ex( &pwdinfo->find_phase_timer );
+			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+
+			//it means remove GO and change mode from AP(GO) to station(P2P DEVICE)
+			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
+			rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
+
+			printk("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
+	
+		}
+		break;
+	case NL80211_IFTYPE_AP:
+		networkType = Ndis802_11APMode;
+		if(change && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		{
+			//it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO)
+			rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
+		}	
+		break;		
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	rtw_wdev->iftype = type;
+	
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE)
+	{
+		rtw_wdev->iftype = old_type;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	rtw_setopmode_cmd(padapter, networkType);	
+	
+exit:
+
+	return ret;
+#endif
+	printk("%s \n", __FUNCTION__);
+	return 0;
+}
+
+void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted)
+{
+	_irqL	irqL;
+
+	printk("%s \n", __FUNCTION__);
+
+	_enter_critical(&pwdev_priv->scan_req_lock, &irqL);
+	if(pwdev_priv->scan_request != NULL)
+	{
+		//struct cfg80211_scan_request *scan_request = pwdev_priv->scan_request;
+	
+		//avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
+		//if(scan_request == wiphy_to_dev(scan_request->wiphy)->scan_req)
+
+		cfg80211_scan_done(pwdev_priv->scan_request, aborted);
+		pwdev_priv->scan_request = NULL;
+		
+	} else {
+		printk("%s without scan req\n", __FUNCTION__);
+	}
+	_exit_critical(&pwdev_priv->scan_req_lock, &irqL);
+
+}
+
+void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
+{
+	_irqL	irqL;
+	_list					*plist, *phead;	
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	_queue				*queue	= &(pmlmepriv->scanned_queue);	
+	struct	wlan_network	*pnetwork = NULL;
+	u32 cnt=0;
+	u32 wait_for_surveydone;
+	sint wait_status;
+
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	_enter_critical(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+#ifdef CONFIG_VALIDATE_SSID
+		if(validate_ssid(&(pnetwork->network.Ssid))==_TRUE)
+#endif
+		{
+			//ev = translate_scan(padapter, a, pnetwork, ev, stop);
+			rtw_cfg80211_inform_bss(padapter, pnetwork);		
+		}
+
+		plist = get_next(plist);
+	
+	}
+	
+	_exit_critical(&(pmlmepriv->scanned_queue.lock), &irqL);
+	
+	//call this after other things have been done
+	rtw_indicate_scan_done(padapter, _FALSE);
+
+}
+
+static int cfg80211_rtw_scan(struct wiphy *wiphy, struct net_device *ndev,
+			     struct cfg80211_scan_request *request)
+{
+#define RTW_CFG80211_SCAN_AMOUNT 1
+	int i;
+	u8 _status = _FALSE;
+	int ret = 0;	
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	NDIS_802_11_SSID ssid[RTW_CFG80211_SCAN_AMOUNT];
+	_irqL	irqL;
+
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct cfg80211_ssid *ssids = request->ssids;
+	bool need_indicate_scan_done = _FALSE;
+
+#ifdef CONFIG_MP_INCLUDED
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	{
+		ret = -EPERM;
+		goto exit;
+	}
+#endif
+
+	_enter_critical(&pwdev_priv->scan_req_lock, &irqL);
+	pwdev_priv->scan_request = request;
+	_exit_critical(&pwdev_priv->scan_req_lock, &irqL);
+
+	if (padapter->bDriverStopped == _TRUE) {
+		printk("!r8711_wx_set_scan: bDriverStopped=%d\n", padapter->bDriverStopped);
+		ret = -1;
+		goto exit;
+	}
+
+	if (padapter->bup == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (padapter->hw_init_completed == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{
+		printk("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+	} 
+
+	_memset(ssid, 0, sizeof(NDIS_802_11_SSID)*RTW_CFG80211_SCAN_AMOUNT);
+	//parsing request ssids, n_ssids
+	for (i = 0; i < request->n_ssids && i < RTW_CFG80211_SCAN_AMOUNT; i++) {
+		#ifdef CONFIG_DEBUG_CFG80211
+		printk("ssid=%s, len=%d\n", ssids[i].ssid, ssids[i].ssid_len);
+		#endif
+		_memcpy(ssid[i].Ssid, ssids[i].ssid, ssids[i].ssid_len);
+		ssid[i].SsidLength = ssids[i].ssid_len;	
+	}
+
+	_enter_critical(&pmlmepriv->lock, &irqL);	
+	_status = sitesurvey_cmd(padapter, ssid);
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	if(_status == _FALSE)
+	{
+		ret = -1;
+	}
+
+check_need_indicate_scan_done:
+	if(need_indicate_scan_done)
+		rtw_cfg80211_surveydone_event_callback(padapter);
+
+exit:
+
+	return ret;
+}
+
+static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD &&
+	    (iwm->conf.rts_threshold != wiphy->rts_threshold)) {
+		int ret;
+
+		iwm->conf.rts_threshold = wiphy->rts_threshold;
+
+		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
+					     CFG_RTS_THRESHOLD,
+					     iwm->conf.rts_threshold);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD &&
+	    (iwm->conf.frag_threshold != wiphy->frag_threshold)) {
+		int ret;
+
+		iwm->conf.frag_threshold = wiphy->frag_threshold;
+
+		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_FA_CFG_FIX,
+					     CFG_FRAG_THRESHOLD,
+					     iwm->conf.frag_threshold);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *dev,
+				  struct cfg80211_ibss_params *params)
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	struct ieee80211_channel *chan = params->channel;
+
+	if (!test_bit(IWM_STATUS_READY, &iwm->status))
+		return -EIO;
+
+	/* UMAC doesn't support creating or joining an IBSS network
+	 * with specified bssid. */
+	if (params->bssid)
+		return -EOPNOTSUPP;
+
+	iwm->channel = ieee80211_frequency_to_channel(chan->center_freq);
+	iwm->umac_profile->ibss.band = chan->band;
+	iwm->umac_profile->ibss.channel = iwm->channel;
+	iwm->umac_profile->ssid.ssid_len = params->ssid_len;
+	memcpy(iwm->umac_profile->ssid.ssid, params->ssid, params->ssid_len);
+
+	return iwm_send_mlme_profile(iwm);
+#endif	
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+
+	if (iwm->umac_profile_active)
+		return iwm_invalidate_mlme_profile(iwm);
+#endif
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv, u32 wpa_version)
+{
+	printk("%s, wpa_version=%d\n", __func__, wpa_version);
+
+	
+	if (!wpa_version) {		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;		
+		return 0;
+	}
+
+
+	if (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
+	{		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;		
+	}
+
+/*
+	if (wpa_version & NL80211_WPA_VERSION_2)
+	{		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
+	}
+*/
+
+	return 0;
+
+}
+
+static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,
+			     enum nl80211_auth_type sme_auth_type)
+{
+	printk("%s, nl80211_auth_type=%d\n", __func__, sme_auth_type);
+
+
+	switch (sme_auth_type) {
+	case NL80211_AUTHTYPE_AUTOMATIC:
+
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+
+		break;
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+	
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+
+		if(psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+		
+		break;
+	case NL80211_AUTHTYPE_SHARED_KEY:
+
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+
+		psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+
+		break;
+	default:		
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		//return -ENOTSUPP;
+	}
+
+	return 0;
+
+}
+
+static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 cipher, bool ucast)
+{
+	u32 ndisencryptstatus = Ndis802_11EncryptionDisabled;
+
+	u32 *profile_cipher = ucast ? &psecuritypriv->dot11PrivacyAlgrthm :
+		&psecuritypriv->dot118021XGrpPrivacy;
+
+	printk("%s, ucast=%d, cipher=0x%x\n", __func__, ucast, cipher);
+
+
+	if (!cipher) {
+		*profile_cipher = _NO_PRIVACY_;
+		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
+		return 0;
+	}
+	
+	switch (cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		*profile_cipher = _NO_PRIVACY_;
+		ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		break;
+	case WLAN_CIPHER_SUITE_WEP40:
+		*profile_cipher = _WEP40_;
+		ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		*profile_cipher = _WEP104_;
+		ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		*profile_cipher = _TKIP_;
+		ndisencryptstatus = Ndis802_11Encryption2Enabled;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		*profile_cipher = _AES_;
+		ndisencryptstatus = Ndis802_11Encryption3Enabled;
+		break;
+	default:
+		printk("Unsupported cipher: 0x%x\n", cipher);
+		return -ENOTSUPP;
+	}
+
+	if(ucast)
+	{
+		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
+		
+		//if(psecuritypriv->dot11PrivacyAlgrthm >= _AES_)
+		//	psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
+	}	
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv, u32 key_mgt)
+{
+	printk("%s, key_mgt=0x%x\n", __func__, key_mgt);
+
+	if (key_mgt == WLAN_AKM_SUITE_8021X)
+		//*auth_type = UMAC_AUTH_TYPE_8021X;
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+	else if (key_mgt == WLAN_AKM_SUITE_PSK) {
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+	} else {
+		printk("Invalid key mgt: 0x%x\n", key_mgt);		
+		//return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, u8 *pie, size_t ielen)
+{
+	u8 *buf=NULL, *pos=NULL;	
+	u32 left; 	
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+	int wpa_ielen=0;
+	int wpa2_ielen=0;
+	u8 *pwpa, *pwpa2;
+
+
+//	if((ielen > MAX_WPA_IE_LEN+MAX_WPS_IE_LEN+MAX_P2P_IE_LEN) || (pie == NULL)){
+	if(pie == NULL){
+		padapter->securitypriv.wps_phase = _FALSE;	
+		if(pie == NULL)	
+			return ret;
+		else
+			return -EINVAL;
+	}
+
+	if(ielen)
+	{		
+		buf = _malloc(ielen);
+		if (buf == NULL){
+			ret =  -ENOMEM;
+			goto exit;
+		}
+	
+		_memcpy(buf, pie , ielen);
+
+		//dump
+		{
+			int i;
+			printk("set wpa_ie(length:%d):\n", ielen);
+			for(i=0;i<ielen;i=i+8)
+				printk("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+		}
+	
+		pos = buf;
+		if(ielen < RSN_HEADER_LEN){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
+			ret  = -1;
+			goto exit;
+		}
+
+#if 0
+		pos += RSN_HEADER_LEN;
+		left  = ielen - RSN_HEADER_LEN;
+		
+		if (left >= RSN_SELECTOR_LEN){
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}		
+		else if (left > 0){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
+			ret =-1;
+			goto exit;
+		}
+#endif
+
+		pwpa = get_wpa_ie(buf, &wpa_ielen, ielen);
+		pwpa2 = get_wpa2_ie(buf, &wpa2_ielen, ielen);
+
+		if(pwpa && wpa_ielen>0)
+		{
+			if(parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+			{
+				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+				padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
+				_memcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen+2);
+				
+				printk("got wpa_ie\n");
+			}
+		}
+
+		if(pwpa2 && wpa2_ielen>0)
+		{
+			if(parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+			{
+				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+				padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;	
+				_memcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen+2);
+
+				printk("got wpa2_ie\n");
+			}
+		}
+
+		switch(group_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:	
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+
+		switch(pairwise_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:	
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+		
+
+		padapter->securitypriv.wps_phase = _FALSE;			
+		{//set wps_ie	
+			u16 cnt = 0;	
+			u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+			int wps_ielen=0;			
+			u8 *pwps;
+			
+			pwps = get_wps_ie(buf, ielen, NULL, &wps_ielen);
+			 
+			//while( cnt < ielen )
+			while( cnt < wps_ielen )
+			{
+				//eid = buf[cnt];
+				eid = pwps[cnt];
+		
+				if((eid==_VENDOR_SPECIFIC_IE_)&&(_memcmp(&pwps[cnt+2], wps_oui, 4)==_TRUE))
+				{
+					printk("SET WPS_IE\n");
+
+					padapter->securitypriv.wps_ie_len = ( (pwps[cnt+1]+2) < (MAX_WPA_IE_LEN<<2)) ? (pwps[cnt+1]+2):(MAX_WPA_IE_LEN<<2);
+					
+					_memcpy(padapter->securitypriv.wps_ie, &pwps[cnt], padapter->securitypriv.wps_ie_len);
+					
+					if(pwpa==NULL && pwpa2==NULL)
+					{
+						padapter->securitypriv.wps_phase = _TRUE;
+					
+						printk("SET WPS_IE, wps_phase==_TRUE\n");
+					}					
+
+					cnt += pwps[cnt+1]+2;
+					
+					break;
+				} else {
+					cnt += pwps[cnt+1]+2; //goto next	
+				}				
+			}			
+		}//set wps_ie
+
+	}
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
+		  pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+ 	
+exit:
+
+	if (buf) _mfree(buf, ielen);
+
+	return ret;
+}
+
+static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_connect_params *sme)
+{
+	int ret=0;
+	_irqL irqL;	
+	_list *phead;	
+	struct wlan_network *pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;	
+	NDIS_802_11_SSID ndis_ssid;	
+	u8 *dst_ssid, *src_ssid;
+	u8 *dst_bssid, *src_bssid;
+	//u8 matched_by_bssid=_FALSE;
+	//u8 matched_by_ssid=_FALSE;
+	u8 matched=_FALSE;
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	_queue *queue = &pmlmepriv->scanned_queue;	
+	
+	printk("\n=>%s(netdev=%p)\n",__FUNCTION__, dev);
+	
+
+	printk("privacy=%d, key=%p, key_len=%d, key_idx=%d\n", sme->privacy, sme->key, sme->key_len, sme->key_idx);
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (!sme->ssid || !sme->ssid_len)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (sme->ssid_len > IW_ESSID_MAX_SIZE){
+
+		ret= -E2BIG;
+		goto exit;
+	}
+	
+
+	_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));			
+	ndis_ssid.SsidLength = sme->ssid_len;
+	_memcpy(ndis_ssid.Ssid, sme->ssid, sme->ssid_len);
+
+	printk("ssid=%s, len=%d\n", ndis_ssid.Ssid, sme->ssid_len);
+	
+
+	if (sme->bssid)
+		printk("bssid="MAC_FMT"\n", MAC_ARG(sme->bssid));
+
+
+	if(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) 
+	{	
+		ret = -EBUSY;
+		printk("%s, fw_state=0x%x, goto exit\n", __FUNCTION__, pmlmepriv->fw_state);
+		goto exit;		
+	}	
+	
+
+	_enter_critical(&queue->lock, &irqL);
+	
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+
+	while (1)
+	{			
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+		{
+			break;
+		}
+	
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		dst_ssid = pnetwork->network.Ssid.Ssid;
+		dst_bssid = pnetwork->network.MacAddress;
+
+		if(sme->bssid)  {
+			if(_memcmp(pnetwork->network.MacAddress, sme->bssid, ETH_ALEN) == _FALSE)
+				continue;
+		}
+		
+		if(sme->ssid && sme->ssid_len) {
+			if(	pnetwork->network.Ssid.SsidLength != sme->ssid_len
+				|| _memcmp(pnetwork->network.Ssid.Ssid, sme->ssid, sme->ssid_len) == _FALSE
+			)
+				continue;
+		}
+			
+
+		if (sme->bssid)
+		{
+			src_bssid = sme->bssid;
+
+			if ((_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE)
+			{
+				printk("matched by bssid\n");
+
+				ndis_ssid.SsidLength = pnetwork->network.Ssid.SsidLength;				
+				_memcpy(ndis_ssid.Ssid, pnetwork->network.Ssid.Ssid, pnetwork->network.Ssid.SsidLength);
+				
+				matched=_TRUE;
+				break;
+			}
+
+		
+		}
+		else if (sme->ssid && sme->ssid_len)
+		{		
+			src_ssid = ndis_ssid.Ssid;
+
+			if ((_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == _TRUE) &&
+				(pnetwork->network.Ssid.SsidLength==ndis_ssid.SsidLength))
+			{
+				printk("matched by ssid\n");
+				matched=_TRUE;
+				break;
+			}
+		}			
+			
+	}
+	
+	_exit_critical(&queue->lock, &irqL);
+
+	if((matched == _FALSE) || (pnetwork== NULL))
+	{
+		ret = -EBUSY;
+		printk("connect, matched == _FALSE, goto exit\n");
+		goto exit;
+	}
+
+
+	if (set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+	{
+		ret = -EPERM;			
+		goto exit;
+	}
+		
+
+	psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+
+
+	ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
+	if (ret < 0)
+		goto exit;
+
+	ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
+	if (ret < 0)
+		goto exit;
+
+
+	if (sme->crypto.n_ciphers_pairwise) {		
+		ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], _TRUE);
+		if (ret < 0)
+			goto exit;
+	}
+
+	//For WEP Shared auth
+	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared
+		|| psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto )
+	{
+		u32 wep_key_idx, wep_key_len,wep_total_len;
+		NDIS_802_11_WEP	 *pwep = NULL;
+		printk("%s(): Shared WEP\n",__FUNCTION__);
+
+		wep_key_idx = sme->key_idx;
+		wep_key_len = sme->key_len;
+
+		if (sme->key_idx > WEP_KEYS) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (wep_key_len > 0) 
+		{
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+		 	pwep =(NDIS_802_11_WEP	 *) _malloc(wep_total_len);
+			if(pwep == NULL){
+				printk(" wpa_set_encryption: pwep allocate fail !!!\n");
+				ret = -ENOMEM;
+				goto exit;
+			}
+
+		 	_memset(pwep, 0, wep_total_len);
+
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if(wep_key_len==13)
+			{
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}
+		}
+		else {		
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		_memcpy(pwep->KeyMaterial,  (void *)sme->key, pwep->KeyLength);
+
+		if(set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+		{
+			ret = -EOPNOTSUPP ;
+		}
+
+		if (pwep) {
+			_mfree((u8 *)pwep,wep_total_len);		
+		}
+
+		if(ret < 0)
+			goto exit;
+	}
+
+	ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, _FALSE);
+	if (ret < 0)
+		return ret;
+
+	if (sme->crypto.n_akm_suites) {
+		ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
+		if (ret < 0)
+			goto exit;
+	}
+
+	printk("%s, ie_len=%d\n", __func__, sme->ie_len);
+			
+	ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
+	if (ret < 0)
+		goto exit;
+
+	authmode = psecuritypriv->ndisauthtype;
+	set_802_11_authentication_mode(padapter, authmode);
+
+	//rtw_set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+
+	if (set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+
+	printk("set ssid:dot11AuthAlgrthm=%d, dot11PrivacyAlgrthm=%d, dot118021XGrpPrivacy=%d\n", psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
+	
+exit:
+
+	printk("<=%s, ret %d\n",__FUNCTION__, ret);
+	
+	return ret;
+}
+
+static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *dev,
+				   u16 reason_code)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	printk("\n%s(netdev=%p)\n", __func__, dev);
+
+	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) 
+	{
+		disassoc_cmd(padapter);
+		
+		printk("%s...call rtw_indicate_disconnect\n ", __FUNCTION__);
+		
+		indicate_disconnect(padapter);
+		
+		free_assoc_resources(padapter);
+	}
+	
+	return 0;
+}
+
+static int cfg80211_rtw_set_txpower(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+				    enum nl80211_tx_power_setting type, int mbm)
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+					enum tx_power_setting type, int dbm)
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	int ret;
+
+	switch (type) {
+	case NL80211_TX_POWER_AUTOMATIC:
+		return 0;
+	case NL80211_TX_POWER_FIXED:
+		if (mbm < 0 || (mbm % 100))
+			return -EOPNOTSUPP;
+
+		if (!test_bit(IWM_STATUS_READY, &iwm->status))
+			return 0;
+
+		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
+					      CFG_TX_PWR_LIMIT_USR,
+					      MBM_TO_DBM(mbm) * 2);
+		if (ret < 0)
+			return ret;
+
+		return iwm_tx_power_trigger(iwm);
+	default:
+		IWM_ERR(iwm, "Unsupported power type: %d\n", type);
+		return -EOPNOTSUPP;
+	}
+#endif
+	printk("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_get_txpower(struct wiphy *wiphy, int *dbm)
+{
+	//_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	printk("%s\n", __func__);
+
+	*dbm = (12);
+	
+	return 0;
+}
+
+static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       bool enabled, int timeout)
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	u32 power_index;
+
+	if (enabled)
+		power_index = IWM_POWER_INDEX_DEFAULT;
+	else
+		power_index = IWM_POWER_INDEX_MIN;
+
+	if (power_index == iwm->conf.power_index)
+		return 0;
+
+	iwm->conf.power_index = power_index;
+
+	return iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
+				       CFG_POWER_INDEX, iwm->conf.power_index);
+#endif
+
+	printk("%s\n", __func__);
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
+				  struct net_device *netdev,
+				  struct cfg80211_pmksa *pmksa)
+{
+	//struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	printk("%s\n", __func__);
+
+	//return iwm_send_pmkid_update(iwm, pmksa, IWM_CMD_PMKID_ADD);
+	return 0;
+}
+
+static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
+				  struct net_device *netdev,
+				  struct cfg80211_pmksa *pmksa)
+{
+	//struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	printk("%s\n", __func__);
+
+	//return iwm_send_pmkid_update(iwm, pmksa, IWM_CMD_PMKID_DEL);
+	return 0;
+}
+
+static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,
+				    struct net_device *netdev)
+{
+	//struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct cfg80211_pmksa pmksa;
+
+	printk("%s\n", __func__);
+
+	memset(&pmksa, 0, sizeof(struct cfg80211_pmksa));
+
+	//return iwm_send_pmkid_update(iwm, &pmksa, IWM_CMD_PMKID_FLUSH);
+	return 0;
+}
+
+static int	cfg80211_rtw_mgmt_tx(struct wiphy *wiphy, struct net_device *dev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+			struct ieee80211_channel *chan, bool offchan,
+			enum nl80211_channel_type channel_type,
+			bool channel_type_valid, unsigned int wait,
+#else	//(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+			struct ieee80211_channel *chan,
+			enum nl80211_channel_type channel_type,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))			  
+			bool channel_type_valid,
+#endif
+#endif	//(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+			const u8 *buf, size_t len, u64 *cookie)
+{
+#if 0
+	struct xmit_frame		*pmgntframe;
+	struct pkt_attrib	*pattrib;
+	unsigned char	*pframe;	
+	const struct ieee80211_mgmt *mgmt;	
+	//u8 category, action, OUI_Subtype, dialogToken=0;
+	//unsigned char	*frame_body;
+	int ret = 0;	
+	int type = (-1);
+	u16 fc;
+	bool ack = _TRUE;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	_adapter *padapter = wiphy_to_adapter(wiphy);	
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+
+
+	/* cookie generation */
+	*cookie = (unsigned long) buf;
+
+
+	printk("%s(netdev=%p), len=%d, ch=%d, ch_type=%d\n", __func__, dev, len,
+			ieee80211_frequency_to_channel(chan->center_freq), channel_type);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))	
+	printk("channel_type_valid=%d\n", channel_type_valid);			 
+#endif
+
+	mgmt = (const struct ieee80211_mgmt *) buf;
+	fc = mgmt->frame_control;
+	if (fc != IEEE80211_STYPE_ACTION) 
+	{
+		if (fc == IEEE80211_STYPE_PROBE_RESP) 
+		{
+			printk("%s, fc == IEEE80211_STYPE_PROBE_RESP\n", __func__);
+		}
+		else
+		{
+			printk("%s, frame_control == 0x%x\n", __func__, fc);
+		}
+		
+		//cfg80211_mgmt_tx_status(dev, *cookie, buf, len, ack, GFP_KERNEL);
+		
+		goto exit;
+		
+	} 
+	else 
+	{
+		u32 cnt=0;
+		u32 wait_for_surveydone;
+		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+#ifdef CONFIG_DEBUG_CFG80211
+		printk("%s, do: scan_abort\n", __func__);
+#endif
+
+	    /* Abort the dwell time of any previous off-channel action frame that may
+	     * be still in effect.  Sending off-channel action frames relies on the
+	     * driver's scan engine.  If a previous off-channel action frame tx is
+	     * still in progress (including the dwell time), then this new action
+	     * frame will not be sent out.
+	     */		
+
+		rtw_cfg80211_scan_abort(padapter);
+	}	
+#if 0
+	if (wl->p2p->vif_created) {
+		wifi_p2p_pub_act_frame_t *act_frm =
+			(wifi_p2p_pub_act_frame_t *) (action_frame->data);
+		WL_DBG(("action_frame->len: %d chan %d category %d subtype %d\n",
+			action_frame->len, af_params->channel,
+			act_frm->category, act_frm->subtype));
+		/*
+		 * To make sure to send successfully action frame, we have to turn off mpc
+		 */
+		if ((act_frm->subtype == P2P_PAF_GON_REQ)||
+		  (act_frm->subtype == P2P_PAF_GON_RSP)) {
+			wldev_iovar_setint(dev, "mpc", 0);
+		} else if (act_frm->subtype == P2P_PAF_GON_CONF) {
+			wldev_iovar_setint(dev, "mpc", 1);
+		} else if (act_frm->subtype == P2P_PAF_DEVDIS_REQ) {
+			af_params->dwell_time = WL_LONG_DWELL_TIME;
+		}
+	}
+#endif
+
+/*
+	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));	
+	category = frame_body[0];
+	//just for check
+	if(category == RTW_WLAN_CATEGORY_PUBLIC)
+	{
+		action = frame_body[ 1 ];
+		OUI_Subtype = frame_body[ 6 ];
+		dialogToken = frame_body[7];
+
+		if ( action == ACT_PUBLIC_P2P )
+		{
+			printk("ACTION_CATEGORY_PUBLIC: ACT_PUBLIC_P2P, OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
+					cpu_to_be32( *( ( u32* ) ( frame_body + 2 ) ) ), OUI_Subtype, dialogToken);
+		}
+		else
+		{
+			printk("ACTION_CATEGORY_PUBLIC: action=%d, OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
+					action, cpu_to_be32( *( ( u32* ) ( frame_body + 2 ) ) ), OUI_Subtype, dialogToken);
+		}
+		
+	}	
+	else if(category == RTW_WLAN_CATEGORY_P2P)
+	{
+		OUI_Subtype = frame_body[5];
+		dialogToken = frame_body[6];
+
+		printk("ACTION_CATEGORY_P2P: OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
+					cpu_to_be32( *( ( u32* ) ( frame_body + 1 ) ) ), OUI_Subtype, dialogToken);
+
+	}	
+	else 
+	{
+		printk("%s, action frame category=%d\n", __func__, category);
+		ack = _FALSE;		
+		goto exit;
+	}
+*/
+
+	if( ieee80211_frequency_to_channel(chan->center_freq) != pmlmeext->cur_channel )
+	{
+		pmlmeext->cur_channel = ieee80211_frequency_to_channel(chan->center_freq);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+	}
+	
+
+	if( (type = rtw_p2p_check_frames(padapter, buf, len, _TRUE)) < 0)
+	{
+		ack = _FALSE;		
+		goto exit;
+	}	
+
+
+	//if(type == P2P_GO_NEGO_REQ)
+	//{
+	//	rtw_cfg80211_issue_p2p_provision_request(padapter, buf, len);
+	//}
+	
+	
+	//starting alloc mgmt frame to dump it
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		ack = _FALSE;
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+	pattrib->retry_ctrl = _FALSE;
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	_rtw_memcpy(pframe, (void*)buf, len);
+	pattrib->pktlen = len;	
+	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+	//update seq number
+	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
+	pattrib->seqnum = pmlmeext->mgnt_seq;
+	pmlmeext->mgnt_seq++;
+
+	
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	
+#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s, ack=%d, ok!\n", __func__, ack );
+#endif
+
+	//indicate ack before issue frame to avoid racing with rsp frame
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	cfg80211_mgmt_tx_status(dev, *cookie, buf, len, ack, GFP_KERNEL);
+#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
+	cfg80211_action_tx_status(dev, *cookie, buf, len, ack, GFP_KERNEL);
+#endif	
+	
+	dump_mgntframe(padapter, pmgntframe);
+	
+	return ret;
+	
+exit:
+	
+	printk("%s, ack=%d  \n", __func__, ack );
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	cfg80211_mgmt_tx_status(dev, *cookie, buf, len, ack, GFP_KERNEL);
+#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
+	cfg80211_action_tx_status(dev, *cookie, buf, len, ack, GFP_KERNEL);
+#endif	
+	
+	return ret;	
+#endif
+	printk("%s \n", __FUNCTION__);
+	return 0;
+}
+
+static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy, struct net_device *dev,
+	u16 frame_type, bool reg)
+{
+#if 0
+	printk("%s: frame_type: %x, reg: %d\n", __func__, frame_type, reg);
+
+	if (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))
+		return;
+
+	return;
+#endif
+	printk("%s \n", __FUNCTION__);
+	return;
+}
+
+#include <rtw_android.h>
+int rtw_cfg80211_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+
+	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret=0;
+
+#ifdef CONFIG_DEBUG_CFG80211
+	printk("%s, cmd=0x%x\n", __func__, cmd);
+#endif
+
+	switch (cmd)
+	{
+		case (SIOCDEVPRIVATE+1):
+				ret = rtw_android_priv_cmd(dev, rq, cmd);
+				break;
+		//case RTL_IOCTL_WPA_SUPPLICANT:	
+				//ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+		//		break;
+#ifdef CONFIG_AP_MODE
+				case RTL_IOCTL_HOSTAPD:
+				//ret = rtw_hostapd_ioctl(dev, &wrq->u.data);			
+				break;
+#endif
+	  	  default:
+				ret = -EOPNOTSUPP;
+				break;
+	}
+	
+	return ret;
+
+	return 0;
+}
+
+
+static struct cfg80211_ops rtw_cfg80211_ops = {
+	.change_virtual_intf = cfg80211_rtw_change_iface,
+	.add_key = cfg80211_rtw_add_key,
+	.get_key = cfg80211_rtw_get_key,
+	.del_key = cfg80211_rtw_del_key,
+	.set_default_key = cfg80211_rtw_set_default_key,
+	.get_station = cfg80211_rtw_get_station,
+	.scan = cfg80211_rtw_scan,
+	.set_wiphy_params = cfg80211_rtw_set_wiphy_params,
+	.connect = cfg80211_rtw_connect,
+	.disconnect = cfg80211_rtw_disconnect,
+	.join_ibss = cfg80211_rtw_join_ibss,
+	.leave_ibss = cfg80211_rtw_leave_ibss,
+	.set_tx_power = cfg80211_rtw_set_txpower,
+	.get_tx_power = cfg80211_rtw_get_txpower,
+	.set_power_mgmt = cfg80211_rtw_set_power_mgmt,
+	.set_pmksa = cfg80211_rtw_set_pmksa,
+	.del_pmksa = cfg80211_rtw_del_pmksa,
+	.flush_pmksa = cfg80211_rtw_flush_pmksa,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	.mgmt_tx = cfg80211_rtw_mgmt_tx,
+	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
+#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
+	.action = cfg80211_rtw_mgmt_tx,
+#endif
+};
+
+static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum ieee80211_band band, u8 rf_type)
+{
+#define MAX_BIT_RATE_40MHZ_MCS15 	300	/* Mbps */
+#define MAX_BIT_RATE_40MHZ_MCS7 	150	/* Mbps */
+
+	ht_cap->ht_supported = _TRUE;
+
+	ht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+	    				IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |
+	    				IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;
+
+	/*
+	 *Maximum length of AMPDU that the STA can receive.
+	 *Length = 2 ^ (13 + max_ampdu_length_exp) - 1 (octets)
+	 */
+	ht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+
+	/*Minimum MPDU start spacing , */
+	ht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;
+
+	ht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+
+	/*
+	 *hw->wiphy->bands[IEEE80211_BAND_2GHZ]
+	 *base on ant_num
+	 *rx_mask: RX mask
+	 *if rx_ant =1 rx_mask[0]=0xff;==>MCS0-MCS7
+	 *if rx_ant =2 rx_mask[1]=0xff;==>MCS8-MCS15
+	 *if rx_ant >=3 rx_mask[2]=0xff;
+	 *if BW_40 rx_mask[4]=0x01;
+	 *highest supported RX rate
+	 */
+	if(rf_type == RTL8712_RF_1T1R)
+	{
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+		ht_cap->mcs.rx_mask[1] = 0x00;
+		ht_cap->mcs.rx_mask[4] = 0x01;
+
+		ht_cap->mcs.rx_highest = MAX_BIT_RATE_40MHZ_MCS7;
+	}
+	else if((rf_type == RTL8712_RF_1T2R) || (rf_type==RTL8712_RF_2T2R))
+	{
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+		ht_cap->mcs.rx_mask[1] = 0xFF;
+		ht_cap->mcs.rx_mask[4] = 0x01;
+
+		ht_cap->mcs.rx_highest = MAX_BIT_RATE_40MHZ_MCS15;
+	}
+	else
+	{
+		printk("%s, error rf_type=%d\n", __func__, rf_type);
+	}	
+
+}
+
+void rtw_cfg80211_init_wiphy(_adapter *padapter)
+{
+	struct ieee80211_supported_band *bands;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = pwdev->wiphy;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+	
+	printk("%s:rf_config=%d\n", __func__, pregpriv->rf_config);
+
+	bands = wiphy->bands[IEEE80211_BAND_2GHZ];
+	rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_2GHZ, pregpriv->rf_config);
+
+}
+
+static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
+{
+
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+
+	wiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;
+	wiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;	
+	wiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+	wiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;
+#endif
+	
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |BIT(NL80211_IFTYPE_ADHOC);
+
+	wiphy->cipher_suites = rtw_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);
+
+	wiphy->bands[IEEE80211_BAND_2GHZ] = &rtw_band_2ghz;
+	wiphy->bands[IEEE80211_BAND_5GHZ] = &rtw_band_5ghz;
+	
+}
+
+int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
+{
+	int ret = 0;
+	struct wireless_dev *wdev;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct net_device *pnetdev = padapter->pnetdev;
+	
+	printk("%s\n", __func__);
+
+	wdev = (struct wireless_dev *)_zmalloc(sizeof(struct wireless_dev));
+	if (!wdev) {
+		printk("Couldn't allocate wireless device\n");
+		return (-ENOMEM);
+	}
+
+	wdev->wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(struct rtw_wdev_priv));
+	if (!wdev->wiphy) {
+		printk("Couldn't allocate wiphy device\n");
+		ret = -ENOMEM;
+		goto out_err_new;
+	}
+
+	set_wiphy_dev(wdev->wiphy, dev);
+	
+	//	
+	padapter->rtw_wdev = wdev;
+	pnetdev->ieee80211_ptr = wdev;
+
+	//init pwdev_priv
+	pwdev_priv = wdev_to_priv(wdev);
+	pwdev_priv->pmon_ndev = NULL;
+	pwdev_priv->ifname_mon[0] = '\0';	
+	pwdev_priv->rtw_wdev = wdev;
+	pwdev_priv->padapter = padapter;
+	pwdev_priv->scan_request = NULL;
+	_spinlock_init(&pwdev_priv->scan_req_lock);
+		
+	wdev->netdev = pnetdev;
+	wdev->iftype = NL80211_IFTYPE_STATION;
+
+	rtw_cfg80211_preinit_wiphy(padapter, wdev->wiphy);
+
+	ret = wiphy_register(wdev->wiphy);
+	if (ret < 0) {
+		printk("Couldn't register wiphy device\n");
+		goto out_err_register;
+	}
+
+	SET_NETDEV_DEV(pnetdev, wiphy_dev(wdev->wiphy));
+
+	return ret;
+
+ out_err_register:
+	wiphy_free(wdev->wiphy);
+
+ out_err_new:
+	_mfree((u8*)wdev, sizeof(struct wireless_dev));
+
+	return ret;
+	
+}
+
+void rtw_wdev_free(struct wireless_dev *wdev)
+{
+	struct rtw_wdev_priv *pwdev_priv;
+
+	printk("%s\n", __func__);
+
+	if (!wdev)
+		return;
+
+	pwdev_priv = wdev_to_priv(wdev);
+	
+	printk("%s, scan abort when device remove\n", __func__);	
+	rtw_cfg80211_indicate_scan_done(pwdev_priv, _TRUE);
+	
+	if(pwdev_priv->pmon_ndev)
+	{
+		printk("%s, unregister monitor interface\n", __func__);
+	
+		unregister_netdev(pwdev_priv->pmon_ndev);
+		
+		free_netdev(pwdev_priv->pmon_ndev);
+	}		
+	
+
+	wiphy_unregister(wdev->wiphy);
+	wiphy_free(wdev->wiphy);
+
+	_mfree((u8*)wdev, sizeof(struct wireless_dev));
+}
+
+#endif //CONFIG_IOCTL_CFG80211
+
diff --git a/drivers/net/wireless/8712u/os_dep/linux/mlme_linux.c b/drivers/net/wireless/8712u/os_dep/linux/mlme_linux.c
new file mode 100755
index 0000000..c4a7293
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/mlme_linux.c
@@ -0,0 +1,380 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+#define _MLME_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mlme_osdep.h>
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <net/iw_handler.h>
+
+
+/*void hw_pbc_workitem_callback(struct work_struct *work)
+{
+	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, hw_pbc_workitem);
+	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ hw_pbc_workitem_callback\n"));
+
+	printk("CheckPbcGPIO - PBC is pressed\n");
+
+#ifdef RTK_DMP_PLATFORM
+	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_NET_PBC);
+#else
+
+#ifdef PLATFORM_LINUX
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+	kill_pid(find_vpid(padapter->pid), SIGUSR1, 1);
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,26))
+	kill_proc(padapter->pid, SIGUSR1, 1);
+#endif
+
+#endif
+
+#endif
+
+	// set timer to clear wps_hw_pbc_pressed flag after 2sec.
+	_set_timer(&pmlmepriv->hw_pbc_timer, 2000);
+
+_func_exit_;
+}*/
+
+#ifdef RTK_DMP_PLATFORM
+void Linkup_workitem_callback(struct work_struct *work)
+{
+	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, Linkup_workitem);
+	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ Linkup_workitem_callback\n"));
+
+	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_LINKUP);
+
+_func_exit_;
+}
+
+void Linkdown_workitem_callback(struct work_struct *work)
+{
+	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, Linkdown_workitem);
+	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ Linkdown_workitem_callback\n"));
+
+	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_LINKDOWN);
+
+_func_exit_;
+}
+#endif
+
+void sitesurvey_ctrl_handler(void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+
+	_sitesurvey_ctrl_handler(adapter);
+
+	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 3000);
+        }
+
+void join_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	_join_timeout_handler(adapter);
+}
+
+
+void _scan_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	scan_timeout_handler(adapter);
+
+        //_set_workitem(&adapter->wkFilterRxFF0);
+}
+
+void dhcp_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	_dhcp_timeout_handler(adapter);
+}
+
+void regular_site_survey_handler(void *FunctionContext)
+{
+	PADAPTER padapter = (PADAPTER)FunctionContext;
+	_regular_site_survey_handler(padapter);
+}
+
+void wdg_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	
+	_wdg_timeout_handler(adapter);
+	
+	_set_timer(&adapter->mlmepriv.wdg_timer, 2000);
+}
+
+/*void hw_pbc_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	
+	_hw_pbc_timeout_handler(adapter);
+}*/
+
+void init_mlme_timer(_adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, join_timeout_handler, (pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), padapter->pnetdev, sitesurvey_ctrl_handler, (u8 *)(pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, _scan_timeout_handler, (pmlmepriv->nic_hdl));
+#ifdef CONFIG_PWRCTRL
+	_init_timer(&(pmlmepriv->dhcp_timer), padapter->pnetdev, dhcp_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+#endif
+
+	_init_timer(&pmlmepriv->survey_timer, padapter->pnetdev, regular_site_survey_handler, pmlmepriv->nic_hdl);
+
+	_init_timer(&(pmlmepriv->wdg_timer), padapter->pnetdev, wdg_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+
+	//2010-04-16 by Thomas
+	// remove fw detection for hw pbc relative function
+	//_init_timer(&(pmlmepriv->hw_pbc_timer), padapter->pnetdev, hw_pbc_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+	//_init_workitem(&(pmlmepriv->hw_pbc_workitem), hw_pbc_workitem_callback, padapter);
+
+#ifdef RTK_DMP_PLATFORM
+	_init_workitem(&(pmlmepriv->Linkup_workitem), Linkup_workitem_callback, padapter);
+	_init_workitem(&(pmlmepriv->Linkdown_workitem), Linkdown_workitem_callback, padapter);
+#endif
+}
+
+extern void indicate_wx_assoc_event(_adapter *padapter);
+extern void indicate_wx_disassoc_event(_adapter *padapter);
+
+void os_indicate_connect(_adapter *adapter)
+{
+
+_func_enter_;	
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_indicate_connect(adapter);
+#endif //CONFIG_IOCTL_CFG80211
+
+        indicate_wx_assoc_event(adapter);
+	netif_carrier_on(adapter->pnetdev);
+
+#ifdef RTK_DMP_PLATFORM
+	_set_workitem(&adapter->mlmepriv.Linkup_workitem);
+#endif
+
+_func_exit_;	
+
+}
+
+extern void indicate_wx_scan_complete_event(_adapter *padapter);
+void rtw_os_indicate_scan_done( _adapter *padapter, bool aborted)
+{
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), aborted);
+#endif //CONFIG_IOCTL_CFG80211
+	indicate_wx_scan_complete_event(padapter);
+}
+
+static RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+void os_indicate_disconnect( _adapter *adapter )
+{
+	//RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+	u8	backupPMKIDIndex = 0;
+	u8	backupTKIPCountermeasure = 0x00;
+      
+_func_enter_;
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_indicate_disconnect(adapter); 	
+#endif //CONFIG_IOCTL_CFG80211
+
+	indicate_wx_disassoc_event(adapter);	
+	netif_carrier_off(adapter->pnetdev);
+
+#ifdef RTK_DMP_PLATFORM
+	_set_workitem(&adapter->mlmepriv.Linkdown_workitem);
+#endif
+
+	if(adapter->securitypriv.dot11AuthAlgrthm == 2)//802.1x
+	{
+		// Added by Albert 2009/02/18
+		// We have to backup the PMK information for WiFi PMK Caching test item.
+		//
+		// Backup the btkip_countermeasure information.
+		// When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
+        
+		_memset( &backupPMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+
+		_memcpy( &backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
+		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
+
+		_memset((unsigned char *)&adapter->securitypriv, 0, sizeof (struct security_priv));
+		_init_timer(&(adapter->securitypriv.tkip_timer),adapter->pnetdev, use_tkipkey_handler, adapter);
+
+		// Added by Albert 2009/02/18
+		// Restore the PMK information to securitypriv structure for the following connection.
+		_memcpy( &adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
+		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
+	}
+	else //reset values in securitypriv 
+	{
+		//if(adapter->mlmepriv.fw_state & WIFI_STATION_STATE)
+		//{
+		struct security_priv *psec_priv=&adapter->securitypriv;
+
+		psec_priv->dot11AuthAlgrthm = 0; //open system
+		psec_priv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		psec_priv->dot11PrivacyKeyIndex = 0;
+
+		psec_priv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+		psec_priv->dot118021XGrpKeyid = 1;
+
+		psec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
+		psec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;
+
+		psec_priv->wps_phase = _FALSE;
+		//}
+	}
+
+_func_exit_;
+
+}
+
+
+void report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie)
+{
+		uint len;
+		u8 *buff,*p,i;
+		union iwreq_data wrqu;
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+report_sec_ie, authmode=%d\n", authmode));
+
+	buff = NULL;
+	if(authmode==_WPA_IE_ID_)
+	{
+		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("report_sec_ie, authmode=%d\n", authmode));
+		
+		buff = _malloc(IW_CUSTOM_MAX);
+		
+		if(buff == NULL) {
+			RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("report_sec_ie, _malloc fail !\n"));
+			return;
+		}
+		
+		_memset(buff,0,IW_CUSTOM_MAX);
+		
+		p=buff;
+		
+		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
+
+		len = sec_ie[1]+2;
+		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
+			
+		for(i=0;i<len;i++){
+			p+=sprintf(p,"%02x",sec_ie[i]);
+		}
+
+		p+=sprintf(p,")");
+		
+		_memset(&wrqu,0,sizeof(wrqu));
+		
+		wrqu.data.length=p-buff;
+		
+		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+		
+		wireless_send_event(adapter->pnetdev,IWEVCUSTOM,&wrqu,buff);
+
+		if(buff)
+		    _mfree(buff, IW_CUSTOM_MAX);
+		
+	}
+
+_func_exit_;
+
+}
+
+
+#ifdef CONFIG_MLME_EXT
+
+void _survey_timer_hdl (void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	survey_timer_hdl(padapter);
+}
+
+void _reauth_timer_hdl(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	reauth_timer_hdl(padapter);
+}
+
+void _reassoc_timer_hdl(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	reassoc_timer_hdl(padapter);
+}
+
+void init_mlme_ext_timer(_adapter *padapter)
+{	
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
+	_init_timer(&pmlmeext->reauth_timer, padapter->pnetdev, _reauth_timer_hdl, padapter);
+	_init_timer(&pmlmeext->reassoc_timer, padapter->pnetdev, _reassoc_timer_hdl, padapter);
+}
+
+#endif
+
diff --git a/drivers/net/wireless/8712u/os_dep/linux/recv_linux.c b/drivers/net/wireless/8712u/os_dep/linux/recv_linux.c
new file mode 100755
index 0000000..21dab2f
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/recv_linux.c
@@ -0,0 +1,287 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RECV_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <wifi.h>
+#include <recv_osdep.h>
+
+#include <osdep_intf.h>
+#include <ethernet.h>
+#include <linux/if_arp.h>
+
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+//init os related resource in struct recv_priv
+int os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter)
+{	
+	int	res=_SUCCESS;
+
+	return res;
+}
+
+//alloc os related resource in union recv_frame
+int os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe)
+{	
+	int	res=_SUCCESS;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);	
+	
+	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
+
+	return res;
+
+}
+
+//free os related resource in union recv_frame
+void os_recv_resource_free(struct recv_priv *precvpriv)
+{
+
+}
+
+
+//alloc os related resource in struct recv_buf
+#ifdef CONFIG_RTL8712
+int os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+
+#ifdef CONFIG_USB_HCI	
+	precvbuf->irp_pending = _FALSE;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if(precvbuf->purb == NULL){		 				
+		res = _FAIL;			
+	}
+
+	precvbuf->pskb = NULL;
+
+	precvbuf->reuse = _FALSE;
+
+	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
+
+        precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pend = NULL;
+
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+	
+#endif
+#ifdef CONFIG_SDIO_HCI
+	precvbuf->pskb = NULL;
+
+	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
+
+        precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pend = NULL;
+
+
+	precvbuf->len = 0;
+#endif
+	return res;
+	
+}
+
+//free os related resource in struct recv_buf
+int os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int ret = _SUCCESS;
+	
+	if(precvbuf->pskb)
+		dev_kfree_skb_any(precvbuf->pskb);
+
+#ifdef CONFIG_USB_HCI
+	if(precvbuf->purb)
+	{
+		usb_kill_urb(precvbuf->purb);
+		usb_free_urb(precvbuf->purb);
+	}
+#endif
+
+	return ret;	
+}
+
+#endif
+
+void handle_tkip_mic_err(_adapter *padapter,u8 bgroup)
+{
+#ifdef CONFIG_IOCTL_CFG80211
+	enum nl80211_key_type key_type;
+#endif //CONFIG_IOCTL_CFG80211
+    union iwreq_data wrqu;
+    struct iw_michaelmicfailure    ev;
+    struct mlme_priv*              pmlmepriv  = &padapter->mlmepriv;
+
+    
+    _memset( &ev, 0x00, sizeof( ev ) );
+
+#ifdef CONFIG_IOCTL_CFG80211
+	if ( bgroup )
+	{
+		key_type |= NL80211_KEYTYPE_GROUP;
+	}
+	else
+	{
+		key_type |= NL80211_KEYTYPE_PAIRWISE;
+	}
+
+	cfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[ 0 ], key_type, -1,
+		NULL, GFP_ATOMIC);
+#endif
+	
+    if ( bgroup )
+    {
+        ev.flags |= IW_MICFAILURE_GROUP;
+    }
+    else
+    {
+        ev.flags |= IW_MICFAILURE_PAIRWISE;
+    }
+   
+    ev.src_addr.sa_family = ARPHRD_ETHER;
+    _memcpy( ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+
+    _memset( &wrqu, 0x00, sizeof( wrqu ) );
+    wrqu.data.length = sizeof( ev );
+
+    wireless_send_event( padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev );
+}
+
+void recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
+{	
+       struct recv_priv *precvpriv;
+       _queue	*pfree_recv_queue;	     
+	_pkt *skb;	
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+#endif
+
+_func_enter_;
+
+	precvpriv = &(padapter->recvpriv);	
+	pfree_recv_queue = &(precvpriv->free_recv_queue);	
+     
+	skb = precv_frame->u.hdr.pkt;	       
+       if(skb == NULL)
+       {        
+            RT_TRACE(_module_recv_osdep_c_,_drv_err_,("recv_indicatepkt():skb==NULL something wrong!!!!\n"));		   
+	     goto _recv_indicatepkt_drop;
+	}
+
+	   
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("recv_indicatepkt():skb != NULL !!!\n"));		
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n recv_indicatepkt():precv_frame->u.hdr.rx_head=%p  precv_frame->hdr.rx_data=%p ", precv_frame->u.hdr.rx_head, precv_frame->u.hdr.rx_data));
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("precv_frame->hdr.rx_tail=%p precv_frame->u.hdr.rx_end=%p precv_frame->hdr.len=%d \n", precv_frame->u.hdr.rx_tail, precv_frame->u.hdr.rx_end, precv_frame->u.hdr.len));
+		
+	skb->data = precv_frame->u.hdr.rx_data;
+	skb->tail = precv_frame->u.hdr.rx_tail;	
+	skb->len = precv_frame->u.hdr.len;
+	
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n", skb->head, skb->data, skb->tail, skb->end, skb->len));
+	
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+        if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		//printk("CHECKSUM_UNNECESSARY \n");
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+		//printk("CHECKSUM_NONE(%d, %d) \n", pattrib->tcpchk_valid, pattrib->tcp_chkrpt);
+	}
+#else /* !CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX */
+
+	skb->ip_summed = CHECKSUM_NONE;
+
+#endif
+	skb->dev = padapter->pnetdev;
+	skb->protocol = eth_type_trans(skb, padapter->pnetdev);
+	
+	netif_rx(skb);
+
+
+	precv_frame->u.hdr.pkt = NULL; // pointers to NULL before free_recvframe()
+
+
+	free_recvframe(precv_frame, pfree_recv_queue);
+
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n recv_indicatepkt :after netif_rx!!!!\n"));
+
+_func_exit_;		
+
+        return;		
+
+_recv_indicatepkt_drop:
+
+	 //enqueue back to free_recv_queue	
+	 if(precv_frame)
+		 free_recvframe(precv_frame, pfree_recv_queue);
+
+	 
+ 	 precvpriv->rx_drop++;	
+
+_func_exit_;
+
+}
+
+void os_read_port(_adapter *padapter, struct recv_buf *precvbuf)
+{	
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+#ifdef CONFIG_USB_HCI
+
+	precvbuf->ref_cnt--;
+
+	//free skb in recv_buf
+	dev_kfree_skb_any(precvbuf->pskb);
+
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = _FALSE;
+
+	if(precvbuf->irp_pending == _FALSE)
+	{
+		read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+	}	
+		
+
+#endif
+#ifdef CONFIG_SDIO_HCI
+		precvbuf->pskb = NULL;
+#endif
+
+}
+
+void _reordering_ctrl_timeout_handler (void *FunctionContext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+	reordering_ctrl_timeout_handler(preorder_ctrl);
+}
+
+void init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	_adapter *padapter = preorder_ctrl->padapter;
+
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _reordering_ctrl_timeout_handler, preorder_ctrl);
+
+	
+}
+
diff --git a/drivers/net/wireless/8712u/os_dep/linux/rtw_android.c b/drivers/net/wireless/8712u/os_dep/linux/rtw_android.c
new file mode 100755
index 0000000..9c68729
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/rtw_android.c
@@ -0,0 +1,927 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+
+#include <rtw_android.h>
+#include <osdep_service.h>
+#include <rtl871x_ioctl_set.h>
+
+#if 0
+#include <wldev_common.h>
+#include <wlioctl.h>
+#include <bcmutils.h>
+#include <linux_osl.h>
+#include <dhd_dbg.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <bcmsdbus.h>
+#ifdef WL_CFG80211
+#include <wl_cfg80211.h>
+#endif
+#endif
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+#include <linux/platform_device.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+#include <linux/wlan_plat.h>
+#else
+#include <linux/wifi_tiwlan.h>
+#endif
+#endif /* CONFIG_WIFI_CONTROL_FUNC */
+
+
+
+/*
+ * Android private command strings, PLEASE define new private commands here
+ * so they can be updated easily in the future (if needed)
+ */
+
+const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
+	"START",
+	"STOP",
+	"SCAN-ACTIVE",
+	"SCAN-PASSIVE",
+	"RSSI",
+	"LINKSPEED",
+	"RXFILTER-START",
+	"RXFILTER-STOP",
+	"RXFILTER-ADD",
+	"RXFILTER-REMOVE",
+	"BTCOEXSCAN-START",
+	"BTCOEXSCAN-STOP",
+	"BTCOEXMODE",
+	"SETSUSPENDOPT",
+	"P2P_DEV_ADDR",
+	"SETFWPATH",
+	"SETBAND",
+	"GETBAND",
+	"COUNTRY",
+	"P2P_SET_NOA",
+	"P2P_GET_NOA",
+	"P2P_SET_PS",
+	"SET_AP_WPS_P2P_IE",
+#ifdef PNO_SUPPORT
+	"PNOSSIDCLR",
+	"PNOSETUP ",
+	"PNOFORCE",
+	"PNODEBUG",
+#endif
+
+	"MACADDR",
+
+};
+
+#ifdef PNO_SUPPORT
+#define PNO_TLV_PREFIX			'S'
+#define PNO_TLV_VERSION			'1'
+#define PNO_TLV_SUBVERSION 		'2'
+#define PNO_TLV_RESERVED		'0'
+#define PNO_TLV_TYPE_SSID_IE		'S'
+#define PNO_TLV_TYPE_TIME		'T'
+#define PNO_TLV_FREQ_REPEAT		'R'
+#define PNO_TLV_FREQ_EXPO_MAX		'M'
+
+typedef struct cmd_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+} cmd_tlv_t;
+#endif /* PNO_SUPPORT */
+
+typedef struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+} android_wifi_priv_cmd;
+
+
+#if 0
+/**
+ * Extern function declarations (TODO: move them to dhd_linux.h)
+ */
+void dhd_customer_gpio_wlan_ctrl(int onoff);
+uint dhd_dev_reset(struct net_device *dev, uint8 flag);
+void dhd_dev_init_ioctl(struct net_device *dev);
+#ifdef WL_CFG80211
+int wl_cfg80211_get_p2p_dev_addr(struct net_device *net, struct ether_addr *p2pdev_addr);
+int wl_cfg80211_set_btcoex_dhcp(struct net_device *dev, char *command);
+#else
+int wl_cfg80211_get_p2p_dev_addr(struct net_device *net, struct ether_addr *p2pdev_addr)
+{ return 0; }
+int wl_cfg80211_set_p2p_noa(struct net_device *net, char* buf, int len)
+{ return 0; }
+int wl_cfg80211_get_p2p_noa(struct net_device *net, char* buf, int len)
+{ return 0; }
+int wl_cfg80211_set_p2p_ps(struct net_device *net, char* buf, int len)
+{ return 0; }
+#endif
+extern int dhd_os_check_if_up(void *dhdp);
+extern void *bcmsdh_get_drvdata(void);
+
+extern bool ap_fw_loaded;
+#ifdef CUSTOMER_HW2
+extern char iface_name[IFNAMSIZ];
+#endif
+#endif
+
+/**
+ * Local (static) functions and variables
+ */
+
+/* Initialize g_wifi_on to 1 so dhd_bus_start will be called for the first
+ * time (only) in dhd_open, subsequential wifi on will be handled by
+ * wl_android_wifi_on
+ */
+static int g_wifi_on = _TRUE;
+
+/**
+ * Local (static) function definitions
+ */
+ #if 0
+static int wl_android_get_link_speed(struct net_device *net, char *command, int total_len)
+{
+	int link_speed;
+	int bytes_written;
+	int error;
+
+	error = wldev_get_link_speed(net, &link_speed);
+	if (error)
+		return -1;
+
+	/* Convert Kbps to Android Mbps */
+	link_speed = link_speed / 1000;
+	bytes_written = snprintf(command, total_len, "LinkSpeed %d", link_speed);
+	DHD_INFO(("%s: command result is %s\n", __FUNCTION__, command));
+	return bytes_written;
+}
+
+static int wl_android_get_rssi(struct net_device *net, char *command, int total_len)
+{
+	wlc_ssid_t ssid = {0};
+	int rssi;
+	int bytes_written = 0;
+	int error;
+
+	error = wldev_get_rssi(net, &rssi);
+	if (error)
+		return -1;
+
+	error = wldev_get_ssid(net, &ssid);
+	if (error)
+		return -1;
+	if ((ssid.SSID_len == 0) || (ssid.SSID_len > DOT11_MAX_SSID_LEN)) {
+		DHD_ERROR(("%s: wldev_get_ssid failed\n", __FUNCTION__));
+	} else {
+		memcpy(command, ssid.SSID, ssid.SSID_len);
+		bytes_written = ssid.SSID_len;
+	}
+	bytes_written += snprintf(&command[bytes_written], total_len, " rssi %d", rssi);
+	DHD_INFO(("%s: command result is %s (%d)\n", __FUNCTION__, command, bytes_written));
+	return bytes_written;
+}
+
+static int wl_android_set_suspendopt(struct net_device *dev, char *command, int total_len)
+{
+	int suspend_flag;
+	int ret_now;
+	int ret = 0;
+
+	suspend_flag = *(command + strlen(CMD_SETSUSPENDOPT) + 1) - '0';
+
+	if (suspend_flag != 0)
+		suspend_flag = 1;
+	ret_now = net_os_set_suspend_disable(dev, suspend_flag);
+
+	if (ret_now != suspend_flag) {
+		if (!(ret = net_os_set_suspend(dev, ret_now)))
+			DHD_INFO(("%s: Suspend Flag %d -> %d\n",
+				__FUNCTION__, ret_now, suspend_flag));
+		else
+			DHD_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
+	}
+	return ret;
+}
+
+static int wl_android_get_band(struct net_device *dev, char *command, int total_len)
+{
+	uint band;
+	int bytes_written;
+	int error;
+
+	error = wldev_get_band(dev, &band);
+	if (error)
+		return -1;
+	bytes_written = snprintf(command, total_len, "Band %d", band);
+	return bytes_written;
+}
+#endif
+
+#ifdef PNO_SUPPORT
+static int wl_android_set_pno_setup(struct net_device *dev, char *command, int total_len)
+{
+	wlc_ssid_t ssids_local[MAX_PFN_LIST_COUNT];
+	int res = -1;
+	int nssid = 0;
+	cmd_tlv_t *cmd_tlv_temp;
+	char *str_ptr;
+	int tlv_size_left;
+	int pno_time = 0;
+	int pno_repeat = 0;
+	int pno_freq_expo_max = 0;
+
+#ifdef PNO_SET_DEBUG
+	int i;
+	char pno_in_example[] = {
+		'P', 'N', 'O', 'S', 'E', 'T', 'U', 'P', ' ',
+		'S', '1', '2', '0',
+		'S',
+		0x05,
+		'd', 'l', 'i', 'n', 'k',
+		'S',
+		0x04,
+		'G', 'O', 'O', 'G',
+		'T',
+		'0', 'B',
+		'R',
+		'2',
+		'M',
+		'2',
+		0x00
+		};
+#endif /* PNO_SET_DEBUG */
+
+	DHD_INFO(("%s: command=%s, len=%d\n", __FUNCTION__, command, total_len));
+
+	if (total_len < (strlen(CMD_PNOSETUP_SET) + sizeof(cmd_tlv_t))) {
+		DHD_ERROR(("%s argument=%d less min size\n", __FUNCTION__, total_len));
+		goto exit_proc;
+	}
+
+#ifdef PNO_SET_DEBUG
+	memcpy(command, pno_in_example, sizeof(pno_in_example));
+	for (i = 0; i < sizeof(pno_in_example); i++)
+		printf("%02X ", command[i]);
+	printf("\n");
+	total_len = sizeof(pno_in_example);
+#endif
+
+	str_ptr = command + strlen(CMD_PNOSETUP_SET);
+	tlv_size_left = total_len - strlen(CMD_PNOSETUP_SET);
+
+	cmd_tlv_temp = (cmd_tlv_t *)str_ptr;
+	memset(ssids_local, 0, sizeof(ssids_local));
+
+	if ((cmd_tlv_temp->prefix == PNO_TLV_PREFIX) &&
+		(cmd_tlv_temp->version == PNO_TLV_VERSION) &&
+		(cmd_tlv_temp->subver == PNO_TLV_SUBVERSION)) {
+
+		str_ptr += sizeof(cmd_tlv_t);
+		tlv_size_left -= sizeof(cmd_tlv_t);
+
+		if ((nssid = wl_iw_parse_ssid_list_tlv(&str_ptr, ssids_local,
+			MAX_PFN_LIST_COUNT, &tlv_size_left)) <= 0) {
+			DHD_ERROR(("SSID is not presented or corrupted ret=%d\n", nssid));
+			goto exit_proc;
+		} else {
+			if ((str_ptr[0] != PNO_TLV_TYPE_TIME) || (tlv_size_left <= 1)) {
+				DHD_ERROR(("%s scan duration corrupted field size %d\n",
+					__FUNCTION__, tlv_size_left));
+				goto exit_proc;
+			}
+			str_ptr++;
+			pno_time = simple_strtoul(str_ptr, &str_ptr, 16);
+			DHD_INFO(("%s: pno_time=%d\n", __FUNCTION__, pno_time));
+
+			if (str_ptr[0] != 0) {
+				if ((str_ptr[0] != PNO_TLV_FREQ_REPEAT)) {
+					DHD_ERROR(("%s pno repeat : corrupted field\n",
+						__FUNCTION__));
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_repeat = simple_strtoul(str_ptr, &str_ptr, 16);
+				DHD_INFO(("%s :got pno_repeat=%d\n", __FUNCTION__, pno_repeat));
+				if (str_ptr[0] != PNO_TLV_FREQ_EXPO_MAX) {
+					DHD_ERROR(("%s FREQ_EXPO_MAX corrupted field size\n",
+						__FUNCTION__));
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_freq_expo_max = simple_strtoul(str_ptr, &str_ptr, 16);
+				DHD_INFO(("%s: pno_freq_expo_max=%d\n",
+					__FUNCTION__, pno_freq_expo_max));
+			}
+		}
+	} else {
+		DHD_ERROR(("%s get wrong TLV command\n", __FUNCTION__));
+		goto exit_proc;
+	}
+
+	res = dhd_dev_pno_set(dev, ssids_local, nssid, pno_time, pno_repeat, pno_freq_expo_max);
+
+exit_proc:
+	return res;
+}
+#endif /* PNO_SUPPORT */
+
+#if 0
+static int wl_android_get_p2p_dev_addr(struct net_device *ndev, char *command, int total_len)
+{
+	int ret;
+	int bytes_written = 0;
+
+	ret = wl_cfg80211_get_p2p_dev_addr(ndev, (struct ether_addr*)command);
+	if (ret)
+		return 0;
+	bytes_written = sizeof(struct ether_addr);
+	return bytes_written;
+}
+#endif
+
+/**
+ * Global function definitions (declared in wl_android.h)
+ */
+
+#if 0
+int wl_android_wifi_on(struct net_device *dev)
+{
+	int ret = 0;
+
+	printk("%s in\n", __FUNCTION__);
+	if (!dev) {
+		DHD_ERROR(("%s: dev is null\n", __FUNCTION__));
+		return -EINVAL;
+	}
+
+	dhd_net_if_lock(dev);
+	if (!g_wifi_on) {
+		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_ON);
+		sdioh_start(NULL, 0);
+		ret = dhd_dev_reset(dev, FALSE);
+		sdioh_start(NULL, 1);
+		if (!ret)
+			dhd_dev_init_ioctl(dev);
+		g_wifi_on = 1;
+	}
+	dhd_net_if_unlock(dev);
+
+	return ret;
+}
+
+int wl_android_wifi_off(struct net_device *dev)
+{
+	int ret = 0;
+
+	printk("%s in\n", __FUNCTION__);
+	if (!dev) {
+		DHD_TRACE(("%s: dev is null\n", __FUNCTION__));
+		return -EINVAL;
+	}
+
+	dhd_net_if_lock(dev);
+	if (g_wifi_on) {
+		ret = dhd_dev_reset(dev, TRUE);
+		sdioh_stop(NULL);
+		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
+		g_wifi_on = 0;
+	}
+	dhd_net_if_unlock(dev);
+
+	return ret;
+}
+#endif
+
+int rtw_android_cmdstr_to_num(char *cmdstr)
+{
+	int cmd_num;
+	for(cmd_num=0 ; cmd_num<ANDROID_WIFI_CMD_MAX; cmd_num++)
+		if(0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])) )
+			break;
+		
+	return cmd_num;
+}
+
+int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+	int bytes_written = 0;
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {	
+		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d", 
+			pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
+	}
+
+	return bytes_written;
+}
+
+int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+	int bytes_written = 0;
+	u16 link_speed = 0;
+
+	link_speed = rtw_get_network_max_rate(padapter, &pcur_network->network);	
+	bytes_written = snprintf(command, total_len, "LinkSpeed %d", link_speed);
+
+	return bytes_written;
+}
+
+int rtw_android_set_country(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *country_code = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_COUNTRY]) + 1;
+	int ret;
+	
+	ret = rtw_set_country(adapter, country_code);
+
+	return (ret==_SUCCESS)?0:-1;
+}
+
+#if 0
+int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len)
+{
+	int ret;
+	int bytes_written = 0;
+
+	//We use the same address as our HW MAC address
+	_rtw_memcpy(command, net->dev_addr, ETH_ALEN);
+	
+	bytes_written = ETH_ALEN;
+	return bytes_written;
+}
+#endif
+
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+	int ret = 0;
+	char *command = NULL;
+	int cmd_num;
+	int bytes_written = 0;
+	android_wifi_priv_cmd priv_cmd;
+
+//	rtw_lock_suspend();
+
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	command = kmalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (!command)
+	{
+		printk("%s: failed to allocate memory\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	printk("%s: Android private cmd \"%s\" on %s\n"
+		, __FUNCTION__, command, ifr->ifr_name);
+
+	cmd_num = rtw_android_cmdstr_to_num(command);
+	
+	switch(cmd_num) {
+	case ANDROID_WIFI_CMD_START:
+		//bytes_written = wl_android_wifi_on(net);
+		goto response;
+	case ANDROID_WIFI_CMD_SETFWPATH:
+		goto response;
+	}
+
+	if (!g_wifi_on) {
+		printk("%s: Ignore private cmd \"%s\" - iface %s is down\n"
+			,__FUNCTION__, command, ifr->ifr_name);
+		ret = 0;
+		goto exit;
+	}
+
+	switch(cmd_num) {
+
+	case ANDROID_WIFI_CMD_STOP:
+		//bytes_written = wl_android_wifi_off(net);
+		break;
+		
+	case ANDROID_WIFI_CMD_SCAN_ACTIVE:
+		rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_ACTIVE);
+		break;
+	case ANDROID_WIFI_CMD_SCAN_PASSIVE:
+		rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_PASSIVE);
+		break;
+		
+	case ANDROID_WIFI_CMD_RSSI:
+		bytes_written = rtw_android_get_rssi(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_LINKSPEED:
+		bytes_written = rtw_android_get_link_speed(net, command, priv_cmd.total_len);
+		break;
+		
+	case ANDROID_WIFI_CMD_RXFILTER_START:
+		//bytes_written = net_os_set_packet_filter(net, 1);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_STOP:
+		//bytes_written = net_os_set_packet_filter(net, 0);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_ADD:
+		//int filter_num = *(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
+		//bytes_written = net_os_rxfilter_add_remove(net, TRUE, filter_num);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_REMOVE:
+		//int filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
+		//bytes_written = net_os_rxfilter_add_remove(net, FALSE, filter_num);
+		break;
+		
+	case ANDROID_WIFI_CMD_BTCOEXSCAN_START:
+		/* TBD: BTCOEXSCAN-START */
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXSCAN_STOP:
+		/* TBD: BTCOEXSCAN-STOP */
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXMODE:
+		#if 0
+		uint mode = *(command + strlen(CMD_BTCOEXMODE) + 1) - '0';
+		if (mode == 1)
+			net_os_set_packet_filter(net, 0); /* DHCP starts */
+		else
+			net_os_set_packet_filter(net, 1); /* DHCP ends */
+#ifdef WL_CFG80211
+		bytes_written = wl_cfg80211_set_btcoex_dhcp(net, command);
+#endif
+		#endif
+		break;
+		
+	case ANDROID_WIFI_CMD_SETSUSPENDOPT:
+		//bytes_written = wl_android_set_suspendopt(net, command, priv_cmd.total_len);
+		break;
+		
+	case ANDROID_WIFI_CMD_SETBAND:
+		//uint band = *(command + strlen(CMD_SETBAND) + 1) - '0';
+		//bytes_written = wldev_set_band(net, band);
+		break;
+	case ANDROID_WIFI_CMD_GETBAND:
+		//bytes_written = wl_android_get_band(net, command, priv_cmd.total_len);
+		break;
+		
+	case ANDROID_WIFI_CMD_COUNTRY:
+		bytes_written = rtw_android_set_country(net, command, priv_cmd.total_len);
+		break;
+		
+#ifdef PNO_SUPPORT
+	case ANDROID_WIFI_CMD_PNOSSIDCLR_SET:
+		//bytes_written = dhd_dev_pno_reset(net);
+		break;
+	case ANDROID_WIFI_CMD_PNOSETUP_SET:
+		//bytes_written = wl_android_set_pno_setup(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_PNOENABLE_SET:
+		//uint pfn_enabled = *(command + strlen(CMD_PNOENABLE_SET) + 1) - '0';
+		//bytes_written = dhd_dev_pno_enable(net, pfn_enabled);
+		break;
+#endif
+
+	case ANDROID_WIFI_CMD_P2P_DEV_ADDR:
+		//bytes_written = rtw_android_get_p2p_dev_addr(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_P2P_SET_NOA:
+		//int skip = strlen(CMD_P2P_SET_NOA) + 1;
+		//bytes_written = wl_cfg80211_set_p2p_noa(net, command + skip, priv_cmd.total_len - skip);
+		break;
+	case ANDROID_WIFI_CMD_P2P_GET_NOA:
+		//bytes_written = wl_cfg80211_get_p2p_noa(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_P2P_SET_PS:
+		//int skip = strlen(CMD_P2P_SET_PS) + 1;
+		//bytes_written = wl_cfg80211_set_p2p_ps(net, command + skip, priv_cmd.total_len - skip);
+		break;
+#if 0		
+#ifdef CONFIG_IOCTL_CFG80211
+	case ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE:
+	{
+		int skip = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE]) + 3;
+		bytes_written = rtw_cfg80211_set_mgnt_wpsp2pie(net, command + skip, priv_cmd.total_len - skip, *(command + skip - 2) - '0');
+		break;
+	}
+#endif //CONFIG_IOCTL_CFG80211
+#endif
+
+	default:
+		printk("Unknown PRIVATE command %s - ignored\n", command);
+		snprintf(command, 3, "OK");
+		bytes_written = strlen("OK");
+	}
+
+response:
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0))
+			command[0] = '\0';
+		if (bytes_written >= priv_cmd.total_len) {
+			printk("%s: bytes_written = %d\n", __FUNCTION__, bytes_written);
+			bytes_written = priv_cmd.total_len;
+		} else {
+			bytes_written++;
+		}
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
+			printk("%s: failed to copy data to user buffer\n", __FUNCTION__);
+			ret = -EFAULT;
+		}
+	}
+	else {
+		ret = bytes_written;
+	}
+
+exit:
+//	rtw_unlock_suspend();
+	if (command) {
+		kfree(command);
+	}
+
+	return ret;
+}
+
+#if 0
+int wl_android_init(void)
+{
+	int ret = 0;
+
+	dhd_msg_level = DHD_ERROR_VAL;
+#ifdef ENABLE_INSMOD_NO_FW_LOAD
+	dhd_download_fw_on_driverload = FALSE;
+#endif /* ENABLE_INSMOD_NO_FW_LOAD */
+#ifdef CUSTOMER_HW2
+	if (!iface_name[0]) {
+		memset(iface_name, 0, IFNAMSIZ);
+		bcm_strncpy_s(iface_name, IFNAMSIZ, "wlan", IFNAMSIZ);
+	}
+#endif /* CUSTOMER_HW2 */
+	return ret;
+}
+
+int wl_android_exit(void)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+int wl_android_post_init(void)
+{
+	struct net_device *ndev;
+	int ret = 0;
+	char buf[IFNAMSIZ];
+	if (!dhd_download_fw_on_driverload) {
+		/* Call customer gpio to turn off power with WL_REG_ON signal */
+		dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
+		g_wifi_on = 0;
+	} else {
+		memset(buf, 0, IFNAMSIZ);
+#ifdef CUSTOMER_HW2
+		snprintf(buf, IFNAMSIZ, "%s%d", iface_name, 0);
+#else
+		snprintf(buf, IFNAMSIZ, "%s%d", "eth", 0);
+#endif
+		if ((ndev = dev_get_by_name (&init_net, buf)) != NULL) {
+			dhd_dev_init_ioctl(ndev);
+			dev_put(ndev);
+		}
+	}
+	return ret;
+}
+#endif
+
+/**
+ * Functions for Android WiFi card detection
+ */
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+
+static int g_wifidev_registered = 0;
+static struct semaphore wifi_control_sem;
+static struct wifi_platform_data *wifi_control_data = NULL;
+static struct resource *wifi_irqres = NULL;
+
+static int wifi_add_dev(void);
+static void wifi_del_dev(void);
+
+int wl_android_wifictrl_func_add(void)
+{
+	int ret = 0;
+	sema_init(&wifi_control_sem, 0);
+
+	ret = wifi_add_dev();
+	if (ret) {
+		DHD_ERROR(("%s: platform_driver_register failed\n", __FUNCTION__));
+		return ret;
+	}
+	g_wifidev_registered = 1;
+
+	/* Waiting callback after platform_driver_register is done or exit with error */
+	if (down_timeout(&wifi_control_sem,  msecs_to_jiffies(1000)) != 0) {
+		ret = -EINVAL;
+		DHD_ERROR(("%s: platform_driver_register timeout\n", __FUNCTION__));
+	}
+
+	return ret;
+}
+
+void wl_android_wifictrl_func_del(void)
+{
+	if (g_wifidev_registered)
+	{
+		wifi_del_dev();
+		g_wifidev_registered = 0;
+	}
+}
+
+void *wl_android_prealloc(int section, unsigned long size)
+{
+	void *alloc_ptr = NULL;
+	if (wifi_control_data && wifi_control_data->mem_prealloc) {
+		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
+		if (alloc_ptr) {
+			DHD_INFO(("success alloc section %d\n", section));
+			if (size != 0L)
+				bzero(alloc_ptr, size);
+			return alloc_ptr;
+		}
+	}
+
+	DHD_ERROR(("can't alloc section %d\n", section));
+	return NULL;
+}
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr)
+{
+	if (wifi_irqres) {
+		*irq_flags_ptr = wifi_irqres->flags & IRQF_TRIGGER_MASK;
+		return (int)wifi_irqres->start;
+	}
+#ifdef CUSTOM_OOB_GPIO_NUM
+	return CUSTOM_OOB_GPIO_NUM;
+#else
+	return -1;
+#endif
+}
+
+int wifi_set_power(int on, unsigned long msec)
+{
+	DHD_ERROR(("%s = %d\n", __FUNCTION__, on));
+	if (wifi_control_data && wifi_control_data->set_power) {
+		wifi_control_data->set_power(on);
+	}
+	if (msec)
+		msleep(msec);
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+int wifi_get_mac_addr(unsigned char *buf)
+{
+	DHD_ERROR(("%s\n", __FUNCTION__));
+	if (!buf)
+		return -EINVAL;
+	if (wifi_control_data && wifi_control_data->get_mac_addr) {
+		return wifi_control_data->get_mac_addr(buf);
+	}
+	return -EOPNOTSUPP;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+void *wifi_get_country_code(char *ccode)
+{
+	DHD_TRACE(("%s\n", __FUNCTION__));
+	if (!ccode)
+		return NULL;
+	if (wifi_control_data && wifi_control_data->get_country_code) {
+		return wifi_control_data->get_country_code(ccode);
+	}
+	return NULL;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) */
+
+static int wifi_set_carddetect(int on)
+{
+	DHD_ERROR(("%s = %d\n", __FUNCTION__, on));
+	if (wifi_control_data && wifi_control_data->set_carddetect) {
+		wifi_control_data->set_carddetect(on);
+	}
+	return 0;
+}
+
+static int wifi_probe(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	DHD_ERROR(("## %s\n", __FUNCTION__));
+	wifi_irqres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "bcmdhd_wlan_irq");
+	if (wifi_irqres == NULL)
+		wifi_irqres = platform_get_resource_byname(pdev,
+			IORESOURCE_IRQ, "bcm4329_wlan_irq");
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(1, 0);	/* Power On */
+	wifi_set_carddetect(1);	/* CardDetect (0->1) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+static int wifi_remove(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	DHD_ERROR(("## %s\n", __FUNCTION__));
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(0, 0);	/* Power Off */
+	wifi_set_carddetect(0);	/* CardDetect (1->0) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+static int wifi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	DHD_TRACE(("##> %s\n", __FUNCTION__));
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
+	bcmsdh_oob_intr_set(0);
+#endif
+	return 0;
+}
+
+static int wifi_resume(struct platform_device *pdev)
+{
+	DHD_TRACE(("##> %s\n", __FUNCTION__));
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
+	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
+		bcmsdh_oob_intr_set(1);
+#endif
+	return 0;
+}
+
+static struct platform_driver wifi_device = {
+	.probe          = wifi_probe,
+	.remove         = wifi_remove,
+	.suspend        = wifi_suspend,
+	.resume         = wifi_resume,
+	.driver         = {
+	.name   = "bcmdhd_wlan",
+	}
+};
+
+static struct platform_driver wifi_device_legacy = {
+	.probe          = wifi_probe,
+	.remove         = wifi_remove,
+	.suspend        = wifi_suspend,
+	.resume         = wifi_resume,
+	.driver         = {
+	.name   = "bcm4329_wlan",
+	}
+};
+
+static int wifi_add_dev(void)
+{
+	DHD_TRACE(("## Calling platform_driver_register\n"));
+	platform_driver_register(&wifi_device);
+	platform_driver_register(&wifi_device_legacy);
+	return 0;
+}
+
+static void wifi_del_dev(void)
+{
+	DHD_TRACE(("## Unregister platform_driver_register\n"));
+	platform_driver_unregister(&wifi_device);
+	platform_driver_unregister(&wifi_device_legacy);
+}
+#endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
diff --git a/drivers/net/wireless/8712u/os_dep/linux/xmit_linux.c b/drivers/net/wireless/8712u/os_dep/linux/xmit_linux.c
new file mode 100755
index 0000000..c1e68cb
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_dep/linux/xmit_linux.c
@@ -0,0 +1,329 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _XMIT_OSDEP_C_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#include <if_ether.h>
+#include <ip.h>
+#include <rtl871x_byteorder.h>
+#include <wifi.h>
+#include <mlme_osdep.h>
+#include <xmit_osdep.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+ #ifdef CONFIG_SDIO_HCI
+#include <linux/mmc/sdio_func.h> 
+#endif
+uint remainder_len(struct pkt_file *pfile)
+{
+
+	return (pfile->buf_len - ((u32)(pfile->cur_addr) - (u32)(pfile->buf_start)));
+
+}
+
+void _open_pktfile (_pkt *pktptr, struct pkt_file *pfile)
+{
+_func_enter_;
+
+	pfile->pkt = pktptr;
+	pfile->cur_addr = pfile->buf_start = pktptr->data;
+	pfile->pkt_len = pfile->buf_len = pktptr->len;
+
+	pfile->cur_buffer = pfile->buf_start ;
+	
+_func_exit_;
+}
+
+uint _pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen)
+{
+	uint len = 0;
+
+_func_enter_;
+
+	len = remainder_len(pfile);
+	len = (rlen > len)? len : rlen;
+
+	if (rmem)
+		skb_copy_bits(pfile->pkt, pfile->buf_len - pfile->pkt_len, rmem, len);
+
+	pfile->cur_addr += len;
+	pfile->pkt_len -= len;
+
+_func_exit_;
+
+	return len; 
+}
+
+sint endofpktfile (struct pkt_file *pfile)
+{
+_func_enter_;
+	if (pfile->pkt_len == 0){
+_func_exit_;	
+		return _TRUE;
+	}
+	else{
+_func_exit_;	
+		return _FALSE;
+	}
+}
+
+
+void set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib)
+{
+	int i;
+	struct ethhdr etherhdr;
+	struct iphdr ip_hdr; 
+	u16 UserPriority = 0;
+
+	_open_pktfile(ppktfile->pkt, ppktfile);	
+	_pktfile_read(ppktfile, (unsigned char*)&etherhdr, ETH_HLEN);	
+
+	//i = _pktfile_read (ppktfile, (u8*)&ip_hdr, sizeof(ip_hdr));
+
+	// get UserPriority from IP hdr
+	if (pattrib->ether_type == 0x0800)
+	{		
+		i = _pktfile_read(ppktfile, (u8*)&ip_hdr, sizeof(ip_hdr));
+		//UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3 ;
+		UserPriority = ip_hdr.tos >> 5;
+	}
+	else
+	{
+		// "When priority processing of data frames is supported, 
+		//a STA's SME should send EAPOL-Key frames at the highest priority."
+
+		if (pattrib->ether_type == 0x888e)
+			UserPriority = 7;
+	}
+
+	pattrib->priority = UserPriority;
+	pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
+	pattrib->subtype = WIFI_QOS_DATA_TYPE;
+}
+
+#ifdef CONFIG_SDIO_HCI
+int os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf)
+{
+	int	res=_SUCCESS;   
+
+	return res;
+
+}
+void os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf)
+{
+
+}
+#endif
+#ifdef CONFIG_USB_HCI
+
+void urb_reset4_workitem_callback(struct work_struct *work)
+{
+
+	struct xmit_priv *pxmitpriv = container_of(work, struct xmit_priv, xmit_pipe4_reset_wi);
+	_adapter *padapter = container_of(pxmitpriv, _adapter, xmitpriv);
+	struct dvobj_priv * pdvobjpriv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct usb_device *pusbdev=pdvobjpriv->pusbdev;	  
+
+	usb_clear_halt(pusbdev,usb_sndbulkpipe(pusbdev, 0x04));
+
+}
+
+void urb_reset6_workitem_callback(struct work_struct *work)
+{
+	struct xmit_priv *pxmitpriv = container_of(work, struct xmit_priv, xmit_pipe6_reset_wi);
+	_adapter *padapter = container_of(pxmitpriv, _adapter, xmitpriv);
+	struct dvobj_priv * pdvobjpriv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct usb_device *pusbdev=pdvobjpriv->pusbdev;	  
+
+	usb_clear_halt(pusbdev,usb_sndbulkpipe(pusbdev, 0x06));
+
+}
+
+void urb_resetd_workitem_callback(struct work_struct *work)
+{
+	struct xmit_priv *pxmitpriv = container_of(work, struct xmit_priv, xmit_piped_reset_wi);
+	_adapter *padapter = container_of(pxmitpriv, _adapter, xmitpriv);
+	struct dvobj_priv * pdvobjpriv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct usb_device *pusbdev=pdvobjpriv->pusbdev;	  
+
+	usb_clear_halt(pusbdev,usb_sndbulkpipe(pusbdev, 0x0d));
+}
+
+void SetFilter(struct work_struct *work)
+{
+	_adapter *padapter = container_of(work, _adapter, wkFilterRxFF0);
+	struct dvobj_priv * pdvobjpriv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	u8  oldvalue = 0x00, newvalue = 0x00;
+	_irqL	irqL;
+
+	printk("+ SetFilter() \n");
+
+	oldvalue = read8( padapter, 0x117 );
+	newvalue = oldvalue & 0xfe;
+	write8( padapter, 0x117, newvalue );
+
+	_enter_critical( &padapter->lockRxFF0Filter, &irqL );
+	padapter->blnEnableRxFF0Filter = 1;
+	_exit_critical( &padapter->lockRxFF0Filter, &irqL );
+	
+	do
+	{
+		msleep( 100 );
+	}
+	while( padapter->blnEnableRxFF0Filter == 1 );
+
+	write8( padapter, 0x117, oldvalue );
+
+	printk("- SetFilter() \n");
+}
+
+
+
+int os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf)
+{
+	int i;
+	
+       for(i=0; i<8; i++)
+      	{
+      		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+             	if(pxmitbuf->pxmit_urb[i] == NULL) 
+             	{
+             		printk("pxmitbuf->pxmit_urb[i]==NULL");
+	        	return _FAIL;	 
+             	}      		  	
+	
+      	}
+                     
+	return _SUCCESS;
+	
+}
+void os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf)
+{
+        int i;
+        for(i=0; i<8; i++)
+        {
+                if(pxmitbuf->pxmit_urb[i])
+                {
+                        usb_kill_urb(pxmitbuf->pxmit_urb[i]);
+                        usb_free_urb(pxmitbuf->pxmit_urb[i]);
+                }
+        }
+}
+#endif
+
+void os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe)
+{
+	if(pxframe->pkt)
+	{
+		RT_TRACE(_module_xmit_osdep_c_,_drv_err_,("linux : os_xmit_complete, dev_kfree_skb()\n"));	
+
+		dev_kfree_skb_any(pxframe->pkt);		
+	}	
+
+	pxframe->pkt = NULL;
+
+}
+
+int xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
+{
+	struct xmit_frame *pxmitframe = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	int ret = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
+
+	if (if_up(padapter) == _FALSE)
+	{
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("xmit_entry: if_up fail\n"));
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+
+	pxmitframe = alloc_xmitframe(pxmitpriv);
+	if (pxmitframe == NULL)
+	{
+		//printk("pxmitframe == NULL \n");
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pxmitframe == NULL\n"));
+
+		//if (!netif_queue_stopped(pnetdev))
+		//       netif_stop_queue(pnetdev);
+
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+
+	if ((update_attrib(padapter, pkt, &pxmitframe->attrib)) == _FAIL)
+	{
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("drop xmit pkt for update fail\n"));		
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_TX);
+
+	pxmitframe->pkt = pkt;
+	if (pre_xmit(padapter, pxmitframe) == _TRUE)
+	{
+		//dump xmitframe directly or drop xframe
+		RT_TRACE(_module_xmit_osdep_c_,_drv_err_,("xmit_entry(): dev_kfree_skb()\n"));			
+		dev_kfree_skb_any(pkt);
+		pxmitframe->pkt = NULL;
+	}
+	else
+	{
+#ifdef CONFIG_SDIO_HCI
+		_up_sema(&(pxmitpriv->xmit_sema));
+		RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("xmit_entry: enqueue xmit pkt xmit_frame=0x%p up sema\n", pxmitframe));
+#endif
+	}
+
+	pxmitpriv->tx_pkts++;
+
+	RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("xmit_entry:tx_pkts=%d\n", (u32)pxmitpriv->tx_pkts));
+
+_func_exit_;
+
+	return ret;
+
+_xmit_entry_drop:
+
+	RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("_xmit_etnry_drop\n"));
+
+	if (pxmitframe) {
+		free_xmitframe(pxmitpriv, pxmitframe);
+	}
+
+	pxmitpriv->tx_drop++;
+
+	dev_kfree_skb_any(pkt);
+
+_func_exit_;
+
+	return ret;
+}
+
diff --git a/drivers/net/wireless/8712u/os_intf/linux/os_intfs.c b/drivers/net/wireless/8712u/os_intf/linux/os_intfs.c
new file mode 100755
index 0000000..d855ab9
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_intf/linux/os_intfs.c
@@ -0,0 +1,1065 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _OS_INTFS_C_
+
+#include <drv_conf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+ 
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <xmit_osdep.h>
+#include <recv_osdep.h>
+#include <hal_init.h>
+#include <rtl871x_ioctl.h>
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_osintf.h>
+#include <linux/mmc/sdio_func.h> 
+#include <linux/mmc/sdio_ids.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_osintf.h>
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("rtl871x wireless lan driver");
+MODULE_AUTHOR("...");
+
+/* module param defaults */
+int chip_version =RTL8712_2ndCUT;
+int rfintfs = HWPI;
+int lbkmode = RTL8712_AIR_TRX;
+#ifdef CONFIG_SDIO_HCI
+int hci = RTL8712_SDIO;
+#endif
+#ifdef CONFIG_USB_HCI
+int hci = RTL8712_USB;
+#endif
+
+// Added by Albert 2010/02/23
+// The video_mode variable is for vedio mode.
+// It may be specify when inserting module with video_mode=1 parameter.
+int video_mode = 1;   // enable video mode
+
+int network_mode = Ndis802_11IBSS;//Ndis802_11Infrastructure;//infra, ad-hoc, auto	  
+//NDIS_802_11_SSID	ssid;
+int channel = 1;//ad-hoc support requirement 
+int wireless_mode = WIRELESS_11BG;
+int vrtl_carrier_sense = AUTO_VCS;
+int vcs_type = RTS_CTS;//*
+int rts_thresh = 2347;//*
+int frag_thresh = 2346;//*
+int preamble = PREAMBLE_LONG;//long, short, auto
+int scan_mode = 1;//active, passive
+int adhoc_tx_pwr = 1;
+int soft_ap = 0;
+int smart_ps = 1;  
+int power_mgnt = PS_MODE_ACTIVE;
+int radio_enable = 1;
+int long_retry_lmt = 7;
+int short_retry_lmt = 7;
+int busy_thresh = 40;
+//int qos_enable = 0; //*
+int ack_policy = NORMAL_ACK;
+int mp_mode = 0;	
+int software_encrypt = 0;
+int software_decrypt = 0;	  
+ 
+int wmm_enable = 1;// default is set to enable the wmm.
+int uapsd_enable = 0;	  
+int uapsd_max_sp = NO_LIMIT;
+int uapsd_acbk_en = 0;
+int uapsd_acbe_en = 0;
+int uapsd_acvi_en = 0;
+int uapsd_acvo_en = 0;
+	
+#ifdef CONFIG_80211N_HT
+int ht_enable = 1;
+int cbw40_enable = 1;
+int ampdu_enable = 1;//for enable tx_ampdu
+#endif
+int rf_config = RTL8712_RF_1T2R;  // 1T2R	
+int low_power = 0;
+char* initmac = 0;  // temp mac address if users want to use instead of the mac address in Efuse
+int wifi_test = 0;    // if wifi_test = 1, driver had to disable the turbo mode and pass it to firmware private.
+u8* g_pallocated_recv_buf = NULL;
+
+module_param(initmac, charp, 0644);
+module_param(wifi_test, int, 0644);
+module_param(video_mode, int, 0644);
+module_param(chip_version, int, 0644);
+module_param(rfintfs, int, 0644);
+module_param(lbkmode, int, 0644);
+module_param(hci, int, 0644);
+module_param(network_mode, int, 0644);
+module_param(channel, int, 0644);
+module_param(mp_mode, int, 0644);
+module_param(wmm_enable, int, 0644);
+module_param(vrtl_carrier_sense, int, 0644);
+module_param(vcs_type, int, 0644);
+module_param(busy_thresh, int, 0644);
+#ifdef CONFIG_80211N_HT
+module_param(ht_enable, int, 0644);
+module_param(cbw40_enable, int, 0644);
+module_param(ampdu_enable, int, 0644);
+#endif
+module_param(rf_config, int, 0644);
+module_param(power_mgnt, int, 0644);
+module_param(low_power, int, 0644);
+#ifdef CONFIG_R871X_TEST
+int start_pseudo_adhoc(_adapter *padapter);
+int stop_pseudo_adhoc(_adapter *padapter);
+#endif
+
+extern void r871x_dev_unload(_adapter *padapter);
+
+u32 start_drv_threads(_adapter *padapter);
+void stop_drv_threads (_adapter *padapter);
+u8 init_drv_sw(_adapter *padapter);
+u8 free_drv_sw(_adapter *padapter);
+
+struct net_device *init_netdev(void);
+
+static uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev);
+static int netdev_open (struct net_device *pnetdev);
+static int netdev_close (struct net_device *pnetdev);
+
+uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev)
+{
+       
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+_func_enter_;
+
+	registry_par->chip_version = (u8)chip_version;
+	registry_par->rfintfs = (u8)rfintfs;
+	registry_par->lbkmode = (u8)lbkmode;	
+	registry_par->hci = (u8)hci;
+	registry_par->network_mode  = (u8)network_mode;	
+
+     	_memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+	
+	registry_par->channel = (u8)channel;
+	registry_par->wireless_mode = (u8)wireless_mode;
+	registry_par->vrtl_carrier_sense = (u8)vrtl_carrier_sense ;
+	registry_par->vcs_type = (u8)vcs_type;
+	registry_par->frag_thresh=(u16)frag_thresh;
+	registry_par->preamble = (u8)preamble;
+	registry_par->scan_mode = (u8)scan_mode;
+	registry_par->adhoc_tx_pwr = (u8)adhoc_tx_pwr;
+	registry_par->soft_ap=  (u8)soft_ap;
+	registry_par->smart_ps =  (u8)smart_ps;  
+	registry_par->power_mgnt = (u8)power_mgnt;
+	registry_par->radio_enable = (u8)radio_enable;
+	registry_par->long_retry_lmt = (u8)long_retry_lmt;
+	registry_par->short_retry_lmt = (u8)short_retry_lmt;
+  	registry_par->busy_thresh = (u16)busy_thresh;
+  	//registry_par->qos_enable = (u8)qos_enable;
+    	registry_par->ack_policy = (u8)ack_policy;
+	registry_par->mp_mode = (u8)mp_mode;	
+	registry_par->software_encrypt = (u8)software_encrypt;
+	registry_par->software_decrypt = (u8)software_decrypt;	  
+
+	 //UAPSD
+	registry_par->wmm_enable = (u8)wmm_enable;
+	registry_par->uapsd_enable = (u8)uapsd_enable;	  
+	registry_par->uapsd_max_sp = (u8)uapsd_max_sp;
+	registry_par->uapsd_acbk_en = (u8)uapsd_acbk_en;
+	registry_par->uapsd_acbe_en = (u8)uapsd_acbe_en;
+	registry_par->uapsd_acvi_en = (u8)uapsd_acvi_en;
+	registry_par->uapsd_acvo_en = (u8)uapsd_acvo_en;
+
+#ifdef CONFIG_80211N_HT
+	registry_par->ht_enable = (u8)ht_enable;
+	registry_par->cbw40_enable = (u8)cbw40_enable;
+	registry_par->ampdu_enable = (u8)ampdu_enable;
+#endif
+
+	registry_par->rf_config = (u8)rf_config;
+	registry_par->low_power = (u8)low_power;
+	registry_par->wifi_test = (u8) wifi_test;
+
+_func_exit_;
+
+	return status;
+}
+
+static int r871x_net_set_mac_address(struct net_device *pnetdev, void *p)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct sockaddr *addr = p;
+	
+	if(padapter->bup == _FALSE)
+	{
+		//printk("r8711_net_set_mac_address(), MAC=%x:%x:%x:%x:%x:%x\n", addr->sa_data[0], addr->sa_data[1], addr->sa_data[2], addr->sa_data[3],
+		//addr->sa_data[4], addr->sa_data[5]);
+		//_memcpy(padapter->eeprompriv.mac_addr, addr->sa_data, ETH_ALEN);
+		_memcpy(pnetdev->dev_addr, addr->sa_data, ETH_ALEN);
+		//padapter->bset_hwaddr = _TRUE;
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *r871x_net_get_stats(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;//pxmitpriv->tx_pkts++;
+	padapter->stats.rx_packets = precvpriv->rx_pkts;//precvpriv->rx_pkts++; 		
+	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
+	padapter->stats.rx_dropped = precvpriv->rx_drop;
+	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
+	padapter->stats.rx_bytes = precvpriv->rx_bytes;
+	
+	return &padapter->stats;	
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtl8712_netdev_ops = {
+	.ndo_open = netdev_open,
+        .ndo_stop = netdev_close,
+        .ndo_start_xmit = xmit_entry,
+        .ndo_set_mac_address = r871x_net_set_mac_address,
+        .ndo_get_stats = r871x_net_get_stats,
+#ifdef CONFIG_IOCTL_CFG80211
+	.ndo_do_ioctl = rtw_cfg80211_do_ioctl,
+#else //CONFIG_IOCTL_CFG80211
+        .ndo_do_ioctl = r871x_ioctl,
+#endif //CONFIG_IOCTL_CFG80211
+};
+#endif
+
+struct net_device *init_netdev(void)	
+{
+	_adapter *padapter;
+	struct net_device *pnetdev;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+init_net_dev\n"));
+
+	//pnetdev = alloc_netdev(sizeof(_adapter), "wlan%d", ether_setup);
+	pnetdev = rtw_alloc_etherdev(sizeof(_adapter));	
+	if (!pnetdev)
+	   return NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	SET_MODULE_OWNER(pnetdev);
+#endif
+
+	//ether_setup(pnetdev); already called in alloc_etherdev() -> alloc_netdev().
+	
+	padapter = rtw_netdev_priv(pnetdev);
+	padapter->pnetdev = pnetdev;	
+	
+	//pnetdev->init = NULL;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+
+	printk("register rtl8712_netdev_ops to netdev_ops\n");
+	pnetdev->netdev_ops = &rtl8712_netdev_ops;
+
+#else
+	pnetdev->open = netdev_open;
+	pnetdev->stop = netdev_close;	
+	
+	pnetdev->hard_start_xmit = xmit_entry;
+
+	pnetdev->set_mac_address = r871x_net_set_mac_address;
+	pnetdev->get_stats = r871x_net_get_stats;
+
+#ifdef CONFIG_IOCTL_CFG80211
+	pnetdev->do_ioctl = rtw_cfg80211_do_ioctl;
+#else  //CONFIG_IOCTL_CFG80211
+	pnetdev->do_ioctl = r871x_ioctl;
+#endif //CONFIG_IOCTL_CFG80211
+
+#endif
+
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif	
+	//pnetdev->tx_timeout = NULL;
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */	
+	
+	pnetdev->wireless_handlers = (struct iw_handler_def *)&r871x_handlers_def;  
+	
+#ifdef WIRELESS_SPY
+	//priv->wireless_data.spy_data = &priv->spy_data;
+	//pnetdev->wireless_data = &priv->wireless_data;
+#endif
+
+#ifdef CONFIG_PLATFORM_MT53XX
+	if(dev_alloc_name(pnetdev,"rea%d") < 0)
+#else
+	if(dev_alloc_name(pnetdev,"wlan%d") < 0)
+#endif
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("dev_alloc_name, fail! \n"));
+	}
+
+	//step 2.
+   	loadparam(padapter, pnetdev);	   
+
+	netif_carrier_off(pnetdev);
+	//netif_stop_queue(pnetdev);
+
+	padapter->pid = 0;  // Initial the PID value used for HW PBC.
+	
+	return pnetdev;
+
+}
+
+u32 start_drv_threads(_adapter *padapter)
+{
+    u32 _status = _SUCCESS;
+
+    RT_TRACE(_module_os_intfs_c_,_drv_info_,("+start_drv_threads\n"));
+
+#ifdef CONFIG_SDIO_HCI
+    padapter->xmitThread = kernel_thread(xmit_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->xmitThread < 0)
+		_status = _FAIL;
+#endif
+
+#ifdef CONFIG_RECV_THREAD_MODE
+    padapter->recvThread = kernel_thread(recv_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->recvThread < 0)
+		_status = _FAIL;	
+#endif
+
+    padapter->cmdThread = kernel_thread(cmd_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->cmdThread < 0)
+		_status = _FAIL;		
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+    padapter->evtThread = kernel_thread(event_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->evtThread < 0)
+		_status = _FAIL;		
+#endif
+  
+    return _status;
+}
+
+void stop_drv_threads (_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+stop_drv_threads\n"));	
+
+	//Below is to termindate cmd_thread & event_thread...
+	_up_sema(&padapter->cmdpriv.cmd_queue_sema);
+	//_up_sema(&padapter->cmdpriv.cmd_done_sema);
+	if(padapter->cmdThread){
+	_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
+	}
+	padapter->cmdpriv.cmd_seq = 1;
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+        _up_sema(&padapter->evtpriv.evt_notify);
+	if(padapter->evtThread){
+	_down_sema(&padapter->evtpriv.terminate_evtthread_sema);
+	}
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+	// Below is to termindate tx_thread...
+	_up_sema(&padapter->xmitpriv.xmit_sema);	
+	_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt: xmit_thread can be terminated ! \n"));
+#endif
+	 
+#ifdef CONFIG_RECV_THREAD_MODE	
+	// Below is to termindate rx_thread...
+	_up_sema(&padapter->recvpriv.recv_sema);
+	_down_sema(&padapter->recvpriv.terminate_recvthread_sema);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:recv_thread can be terminated! \n"));
+#endif
+}
+
+void start_drv_timers (_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+start_drv_timers\n"));
+
+	_set_timer(&padapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 5000);
+
+	_set_timer(&padapter->mlmepriv.wdg_timer, 2000);
+}
+
+void stop_drv_timers (_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+stop_drv_timers\n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.assoc_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("stop_drv_timers:cancel association timer complete! \n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("stop_drv_timers:cancel sitesurvey_ctrl_timer! \n"));
+
+	_cancel_timer_ex(&padapter->securitypriv.tkip_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("stop_drv_timers:cancel tkip_timer! \n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.scan_to_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("stop_drv_timers:cancel scan_to_timer! \n"));
+	
+#ifdef CONFIG_PWRCTRL
+	_cancel_timer_ex(&padapter->mlmepriv.dhcp_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_err_,("stop_drv_timers:cancel dhcp_timer! \n"));
+#endif
+
+	_cancel_timer_ex(&padapter->mlmepriv.survey_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("stop_drv_timers: cancel survey_timer!\n"));
+	
+	_cancel_timer_ex(&padapter->mlmepriv.wdg_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("stop_drv_timers:cancel wdg_timer! \n"));
+}
+
+u8 init_default_value(_adapter *padapter)
+{
+	u8 ret  = _SUCCESS;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+
+	//xmit_priv
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+	
+		
+
+	//recv_priv
+	
+
+	//mlme_priv
+	pmlmepriv->passive_mode=1; // 1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff)
+	
+	//qos_priv
+	//pmlmepriv->qospriv.qos_option = pregistrypriv->wmm_enable;
+	
+	//ht_priv
+#ifdef CONFIG_80211N_HT		
+	{
+		int i;
+		struct ht_priv	 *phtpriv = &pmlmepriv->htpriv;
+		
+	//padapter->registrypriv.ht_enable = 1;//gtest
+		
+		phtpriv->ampdu_enable = _FALSE;//set to disabled
+
+		for(i=0; i<16; i++)
+		{
+			phtpriv->baddbareq_issued[i] = _FALSE;
+		}
+		
+	}	
+#endif	
+
+	//security_priv
+	//get_encrypt_decrypt_from_registrypriv(padapter);
+	psecuritypriv->sw_encrypt=pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt=pregistrypriv->software_decrypt;
+	psecuritypriv->binstallGrpkey=_FAIL;
+	
+	
+
+	//pwrctrl_priv
+
+
+	//registry_priv
+	init_registrypriv_dev_network(padapter);		
+	update_registrypriv_dev_network(padapter);
+
+
+	//misc.
+	
+		
+	return ret;
+
+}
+
+u8 init_drv_sw(_adapter *padapter)
+{
+	u8	ret8=_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+init_drv_sw\n"));
+
+	if ((init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init cmd_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+	padapter->cmdpriv.padapter=padapter;
+	
+	if ((init_evt_priv(&padapter->evtpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init evt_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+	
+#ifdef CONFIG_RECV_BH
+	tasklet_init(&padapter->evtpriv.event_tasklet, 
+				(void(*)(unsigned long))recv_event_bh,
+	     			(unsigned long)padapter);
+#endif
+	
+	if (init_mlme_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init mlme_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+		
+	_init_xmit_priv(&padapter->xmitpriv, padapter);
+		
+	_init_recv_priv(&padapter->recvpriv, padapter);
+
+	_memset((unsigned char *)&padapter->securitypriv, 0, sizeof (struct security_priv));	
+	_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pnetdev, use_tkipkey_handler, padapter);
+
+	_init_sta_priv(&padapter->stapriv);
+	padapter->stapriv.padapter = padapter;	
+
+	init_bcmc_stainfo(padapter);
+
+	init_pwrctrl_priv(padapter);	
+
+	//_memset((u8 *)&padapter->qospriv, 0, sizeof (struct qos_priv));//move to mlme_priv
+
+	_init_sema(&(padapter->pwrctrlpriv.pnp_pwr_mgnt_sema), 0);
+		
+#ifdef CONFIG_MP_INCLUDED
+        mp871xinit(padapter); 
+#endif
+
+/*
+#ifdef CONFIG_MLME_EXT
+	if (init_mlme_ext_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("can't init mlme_ext_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+#endif
+*/
+	ret8 = init_default_value(padapter);		
+
+	InitSwLeds(padapter);
+
+exit:
+	
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-init_drv_sw\n"));
+
+	_func_exit_;	
+	
+	return ret8;
+	
+}
+
+u8 free_drv_sw(_adapter *padapter)
+{
+	u8 bool;
+
+
+	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("==>free_drv_sw"));
+	
+	free_cmd_priv(&padapter->cmdpriv);	
+	free_evt_priv(&padapter->evtpriv);
+
+	DeInitSwLeds(padapter);
+	
+	free_mlme_priv(&padapter->mlmepriv);
+	
+	free_io_queue(padapter);
+	
+	_free_xmit_priv(&padapter->xmitpriv);
+	
+	_free_sta_priv(&padapter->stapriv); //will free bcmc_stainfo here
+	
+	_free_recv_priv(&padapter->recvpriv);
+
+	_spinlock_free( &padapter->lockRxFF0Filter);
+
+	//_mfree((void *)padapter, sizeof (padapter));
+
+#ifdef CONFIG_MP_INCLUDED
+        mp871xdeinit(padapter);
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+	free_drvext(&padapter->drvextpriv);
+#endif	
+
+#ifdef CONFIG_MLME_EXT
+	free_mlme_ext_priv(&padapter->mlmeextpriv);
+#endif	
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("<==free_drv_sw\n"));
+
+	if(pnetdev)
+	{
+		rtw_free_netdev(pnetdev);
+	}
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-free_drv_sw\n"));
+
+	return _SUCCESS;
+}
+
+
+void enable_video_mode( _adapter* padapter, int cbw40_value)
+{
+        //   bit 8:
+        //   1 -> enable video mode to 96B AP
+        //   0 -> disable video mode to 96B AP
+        //   bit 9:
+        //   1 -> enable 40MHz mode
+        //   0 -> disable 40MHz mode
+        //   bit 10:
+        //   1 -> enable STBC
+        //   0 -> disable STBC
+        u32  intcmd = 0xf4000500;   // enable bit8, bit10
+
+        if ( cbw40_value )
+        {
+        //  if the driver supports the 40M bandwidth, we can enable the bit 9.
+            intcmd |= 0x200;
+        }
+        fw_cmd( padapter, intcmd);
+}
+
+static int netdev_open(struct net_device *pnetdev)
+{
+	uint status;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - dev_open\n"));
+	//printk("+871x_drv - drv_open, bup=%d\n", padapter->bup);
+
+       if(padapter->bup == _FALSE)
+    	{    
+		padapter->bDriverStopped = _FALSE;
+	 	padapter->bSurpriseRemoved = _FALSE;	 
+        	padapter->bup = _TRUE;
+	
+		status = rtl871x_hal_init(padapter);		
+		if (status ==_FAIL)
+		{			
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("rtl871x_hal_init(): Can't init h/w!\n"));
+			goto netdev_open_error;
+		}
+		
+		if ( initmac == NULL )	//	Use the mac address stored in the Efuse
+		{
+			_memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
+		}
+		else
+		{	//	Use the user specifiy mac address. So, we have to inform f/w to use it.
+			msleep_os( 200 );
+			setMacAddr_cmd( padapter, (u8*) pnetdev->dev_addr );
+			//	The "myid" function will get the wifi mac address from eeprompriv structure instead of netdev structure.			
+			//	So, we have to overwrite the mac_addr stored in the eeprompriv structure.
+			//	In this case, the real mac address won't be used anymore.
+			//	So that, the eeprompriv.mac_addr should store the mac which users specify.
+			_memcpy( padapter->eeprompriv.mac_addr, pnetdev->dev_addr, ETH_ALEN );
+		}
+
+		printk("MAC Address= %x-%x-%x-%x-%x-%x\n", 
+				 pnetdev->dev_addr[0],	pnetdev->dev_addr[1],  pnetdev->dev_addr[2],	pnetdev->dev_addr[3], pnetdev->dev_addr[4], pnetdev->dev_addr[5]);		
+
+		
+#ifdef CONFIG_MLME_EXT
+		if (init_mlme_ext_priv(padapter) == _FAIL)
+		{
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("can't init mlme_ext_priv\n"));
+			goto netdev_open_error;
+		}
+#endif
+
+		
+#ifdef CONFIG_DRVEXT_MODULE
+		init_drvext(padapter);
+#endif	   
+		
+		status=start_drv_threads(padapter);
+		if(status ==_FAIL)
+		{			
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));			
+			goto netdev_open_error;			
+		}
+		
+
+#ifdef CONFIG_USB_HCI	
+		if(padapter->dvobjpriv.inirp_init == NULL)
+		{
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("Initialize dvobjpriv.inirp_init error!!!\n"));
+			goto netdev_open_error;	
+		}
+		else
+		{	
+			padapter->dvobjpriv.inirp_init(padapter);
+		}			
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+		rtw_cfg80211_init_wiphy(padapter);
+#endif
+	
+#ifdef CONFIG_PWRCTRL
+		RT_TRACE(_module_os_intfs_c_,_drv_info_,("Initialize Power Mode. \n"));
+		set_ps_mode(padapter, padapter->registrypriv.power_mgnt, padapter->registrypriv.smart_ps);
+#endif	
+	
+
+#ifdef CONFIG_R871X_TEST
+		//start_pseudo_adhoc(padapter);
+#endif
+
+       	//padapter->bDriverStopped = _FALSE;
+	 	//padapter->bSurpriseRemoved = _FALSE;	 
+        	//padapter->bup = _TRUE;
+	}		
+		
+	//netif_carrier_on(pnetdev);//call this func when joinbss_event_callback return success       
+ 	if(!netif_queue_stopped(pnetdev))
+      		netif_start_queue(pnetdev);
+	else
+		netif_wake_queue(pnetdev);
+		
+	 if ( video_mode )
+	 {
+              enable_video_mode( padapter, cbw40_enable );
+	 }
+	 
+	//start driver mlme relation timer
+	start_drv_timers(padapter);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);	
+
+        RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - dev_open\n"));
+	//printk("-871x_drv - drv_open, bup=%d\n", padapter->bup);
+		
+	 return 0;
+	
+netdev_open_error:
+
+	padapter->bup = _FALSE;
+	
+	netif_carrier_off(pnetdev);	
+	netif_stop_queue(pnetdev);
+	
+	RT_TRACE(_module_os_intfs_c_,_drv_err_,("-871x_drv - dev_open, fail!\n"));
+	//printk("-871x_drv - drv_open fail, bup=%d\n", padapter->bup);
+	
+	return (-1);
+}
+
+static int netdev_close(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+		
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - drv_close\n"));	
+
+	// Close LED
+        padapter->ledpriv.LedControlHandler(padapter, LED_CTL_POWER_OFF);
+        msleep( 200 );
+
+/*	if(!padapter->hw_init_completed)
+	{
+		printk("(1)871x_drv - drv_close, bup=%d, hw_init_completed=%d\n", padapter->bup, padapter->hw_init_completed);
+
+	padapter->bDriverStopped = _TRUE;   
+
+	r871x_dev_unload(padapter);	
+	}
+	else*/
+	{
+		printk("(2)871x_drv - drv_close, bup=%d, hw_init_completed=%d\n", padapter->bup, padapter->hw_init_completed);
+
+		//s1.
+		if(pnetdev)   
+     		{
+			if (!netif_queue_stopped(pnetdev))
+				netif_stop_queue(pnetdev);
+     		}
+		
+		#ifndef CONFIG_ANDROID
+			
+		//s2.	
+		//s2-1.  issue disassoc_cmd to fw
+		disassoc_cmd(padapter);
+		//s2-2.  indicate disconnect to os
+		indicate_disconnect(padapter);
+		//s2-3. 
+		free_assoc_resources(padapter);	
+		//s2-4.
+		free_network_queue(padapter);
+
+		#endif
+			
+
+	}
+
+#ifdef CONFIG_IOCTL_CFG80211
+	printk("call rtw_indicate_scan_done when drv_close\n");
+	rtw_indicate_scan_done(padapter, _TRUE);
+#endif //CONFIG_IOCTL_CFG80211	
+
+	//r871x_dev_unload(padapter);
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - drv_close\n"));
+	printk("-871x_drv - drv_close, bup=%d\n", padapter->bup);
+	   
+	return 0;
+}
+
+
+#ifdef CONFIG_R871X_TEST
+
+#include <mlme_osdep.h>
+
+int start_pseudo_adhoc(_adapter *padapter)
+{
+     	_irqL irqL;
+	int	res;
+	struct sta_info *psta, *psta_old;
+	unsigned char ibssid[6];
+	unsigned char adhoc_sta_addr[6];
+	unsigned long length;
+		
+	struct wlan_network *pnetwork=NULL;	
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);	
+
+
+	ibssid[0] = 0x02;  //in ad-hoc mode bit1 must set to 1
+	ibssid[1] = 0x87;
+	ibssid[2] = 0x11;
+	ibssid[3] = 0x12;
+	ibssid[4] = 0x66;
+	ibssid[5] = 0x55;
+
+	//87-4c-e0-0-1-55
+	adhoc_sta_addr[0] = 0x00; 
+	adhoc_sta_addr[1] = 0xE0;
+	adhoc_sta_addr[2] = 0x4C;
+	adhoc_sta_addr[3] = 0x87;
+	adhoc_sta_addr[4] = 0x12;
+
+#ifdef CONFIG_R8712_TEST_ASTA
+	adhoc_sta_addr[5] = 0x22;//A-22, B-11
+#endif
+#ifdef CONFIG_R8712_TEST_BSTA
+	adhoc_sta_addr[5] = 0x11;//A-22, B-11
+#endif
+
+	pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	
+	//clear psta in the cur_network, if any
+	psta_old = get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
+	if (psta_old)
+	   	free_stainfo(padapter,  psta_old);
+
+	//create new  a wlan_network for mp driver and replace the cur_network;
+	pnetwork= (struct wlan_network *)_malloc(sizeof(struct wlan_network));       
+	if(pnetwork == NULL){
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("Can't alloc wlan_network for pseudo_adhoc\n"));
+		return _FAIL;
+	}
+	_memset((unsigned char *)pnetwork, 0, sizeof (struct wlan_network));
+	pnetwork->join_res = 1;//
+	_memcpy(&(pnetwork->network.MacAddress), ibssid, ETH_ALEN);
+		   
+	pnetwork->network.InfrastructureMode = Ndis802_11IBSS;
+	pnetwork->network.NetworkTypeInUse = Ndis802_11OFDM24;
+
+	pnetwork->network.IELength = 0;
+	   
+	pnetwork->network.Ssid.SsidLength = 21;
+	_memcpy(pnetwork->network.Ssid.Ssid , (unsigned char*)"rtl_pseudo_adhoc_8712", pnetwork->network.Ssid.SsidLength);
+
+	length = get_NDIS_WLAN_BSSID_EX_sz(&pnetwork->network);
+	pnetwork->network.Length = ((length>>2) + ((length%4 != 0) ? 1 : 0))*4;//round up to multiple of 4 bytes.
+
+       //create a new psta for mp driver in the new created wlan_network
+	//psta = alloc_stainfo(&padapter->stapriv, pnetwork->network.MacAddress);
+	psta = alloc_stainfo(&padapter->stapriv, adhoc_sta_addr);
+	if (psta == NULL) {
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("Can't alloc sta_info for pseudo_adhoc\n"));
+		return _FAIL;
+	}
+
+/*
+{
+	//87-4c-e0-0-1-55
+	adhoc_sta_addr[0] = 0x00; 
+	adhoc_sta_addr[1] = 0xE0;
+	adhoc_sta_addr[2] = 0x4C;
+	adhoc_sta_addr[3] = 0x87;
+	adhoc_sta_addr[4] = 0x12;
+	adhoc_sta_addr[5] = 0x11;
+	
+	psta = alloc_stainfo(&padapter->stapriv, adhoc_sta_addr);
+	if (psta == NULL) {
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("Can't alloc sta_info for pseudo_adhoc\n"));
+		return _FAIL;
+	}
+
+	
+}
+*/
+	_enter_critical(&pmlmepriv->lock, &irqL);
+
+	tgt_network->join_res = pnetwork->join_res;
+	
+	if (pnetwork->join_res > 0) {
+
+		if ((pmlmepriv->fw_state) & _FW_UNDER_LINKING) {
+
+			psta_old = get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
+
+			if (psta_old)
+				free_stainfo(padapter, psta_old);
+			
+			 _memcpy(&tgt_network->network, &pnetwork->network,
+				(get_NDIS_WLAN_BSSID_EX_sz(&pnetwork->network)));
+
+			tgt_network->aid = psta->aid  = pnetwork->join_res;
+
+			(pmlmepriv->fw_state) ^= _FW_UNDER_LINKING;
+		}
+		else {
+
+			//RT_TRACE(_module_os_intfs_c_,_drv_err_,"err: fw_state:%x",pmlmepriv->fw_state);
+			free_stainfo(padapter, psta);
+			
+			res = _FAIL;
+			goto end_of_mp_start_test;
+		}
+
+		  
+              //Set to LINKED STATE for pseudo_adhoc
+		pmlmepriv->fw_state |= _FW_LINKED;	
+
+		os_indicate_connect(padapter);
+			  
+/*
+              //NDIS_802_11_NETWORK_INFRASTRUCTURE networktype;
+              if(padapter->eeprompriv.bautoload_fail_flag==_FALSE)
+              		res = setopmode_cmd(padapter, 5);//?
+*/
+		res=_SUCCESS;
+
+	}
+	else {
+
+		free_stainfo(padapter, psta);
+              res = _FAIL;
+
+	}	
+				
+
+	//
+	pmlmepriv->qospriv.qos_option=1;
+				
+end_of_mp_start_test:				
+
+	_exit_critical(&pmlmepriv->lock, &irqL);
+
+	_mfree((unsigned char*)pnetwork, sizeof(struct wlan_network));
+
+	return res;
+
+}
+
+int stop_pseudo_adhoc(_adapter *padapter)
+{
+  	struct sta_info *psta;	
+	unsigned char adhoc_sta_addr[6];
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);	
+
+	//87-4c-e0-0-1-55
+	adhoc_sta_addr[0] = 0x00; 
+	adhoc_sta_addr[1] = 0xE0;
+	adhoc_sta_addr[2] = 0x4C;
+	adhoc_sta_addr[3] = 0x87;
+	adhoc_sta_addr[4] = 0x12;
+	adhoc_sta_addr[5] = 0x22;
+
+	 //return to normal state (default:null mode)
+       pmlmepriv->fw_state = WIFI_NULL_STATE;
+
+	os_indicate_disconnect(padapter);
+	
+	//clear psta used in mp test mode.
+       psta = get_stainfo(&padapter->stapriv, adhoc_sta_addr);
+       if(psta)	   	
+	   	free_stainfo(padapter, psta);
+
+/*
+{
+	//87-4c-e0-0-1-55
+	adhoc_sta_addr[0] = 0x00; 
+	adhoc_sta_addr[1] = 0xE0;
+	adhoc_sta_addr[2] = 0x4C;
+	adhoc_sta_addr[3] = 0x87;
+	adhoc_sta_addr[4] = 0x12;
+	adhoc_sta_addr[5] = 0x11;
+
+	psta = get_stainfo(&padapter->stapriv, adhoc_sta_addr);
+       if(psta)	   	
+	   	free_stainfo(padapter, psta);
+
+	   
+}
+*/
+	//flush the cur_network   
+	_memset((unsigned char *)tgt_network, 0, sizeof (struct wlan_network));	
+
+	
+	
+	return _SUCCESS;
+
+}
+
+#endif
diff --git a/drivers/net/wireless/8712u/os_intf/linux/usb_intf.c b/drivers/net/wireless/8712u/os_intf/linux/usb_intf.c
new file mode 100755
index 0000000..a915126
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_intf/linux/usb_intf.c
@@ -0,0 +1,1066 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _HCI_INTF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <hal_init.h>
+#include <rtl8712_efuse.h>
+#include <version.h>
+
+#ifndef CONFIG_USB_HCI
+
+#error "CONFIG_USB_HCI shall be on!\n"
+
+#endif
+
+#include <usb_vendor_req.h>
+#include <usb_ops.h>
+#include <usb_osintf.h>
+#include <usb_hal.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#ifdef CONFIG_80211N_HT
+extern int ht_enable;
+extern int cbw40_enable;
+extern int ampdu_enable;//for enable tx_ampdu
+#endif
+
+static struct usb_interface *pintf;
+
+extern u32 start_drv_threads(_adapter *padapter);
+extern void stop_drv_threads (_adapter *padapter);
+extern void stop_drv_timers (_adapter *padapter);
+extern u8 init_drv_sw(_adapter *padapter);
+extern u8 free_drv_sw(_adapter *padapter);
+extern struct net_device *init_netdev(void);
+extern char* initmac;
+extern u8* g_pallocated_recv_buf;
+
+void r871x_dev_unload(_adapter *padapter);
+
+static int r871xu_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid);
+static void r871xu_dev_remove(struct usb_interface *pusb_intf);
+
+static struct usb_device_id rtl871x_usb_id_tbl[] ={
+/* RTL8188SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8171)},
+	{USB_DEVICE(0x0bda, 0x8173)}, // =
+	{USB_DEVICE(0x0bda, 0x8712)}, // =
+	{USB_DEVICE(0x0bda, 0x8713)}, // =
+	{USB_DEVICE(0x0bda, 0xC512)}, // =
+	/* Abocom */
+	{USB_DEVICE(0x07B8, 0x8188)},
+	/* ASUS */
+	{USB_DEVICE(0x0B05, 0x1786)},
+	{USB_DEVICE(0x0B05, 0x1791)}, // 11n mode disable -
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x945A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0047)},
+	/* D-Link */
+	{USB_DEVICE(0x2001, 0x3306)},
+	{USB_DEVICE(0x07D1, 0x3306)}, // 11n mode disable *
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7611)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9603)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0016)},
+	/* Hercules */
+	{USB_DEVICE(0x06F8, 0xE034)},
+	{USB_DEVICE(0x06F8, 0xE032)},
+	/* Logitec */
+	{USB_DEVICE(0x0789, 0x0167)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xAB28)},
+	{USB_DEVICE(0x2019, 0xED16)},
+	/* itecom */
+	{USB_DEVICE(0x0DF6, 0x0057)},
+	{USB_DEVICE(0x0DF6, 0x0045)},
+	{USB_DEVICE(0x0DF6, 0x0059)}, // 11n mode disable *
+	{USB_DEVICE(0x0DF6, 0x004B)},
+	{USB_DEVICE(0x0DF6, 0x0063)},
+	/* Sweex */
+	{USB_DEVICE(0x177F, 0x0154)},
+	/* Thinkware */
+	{USB_DEVICE(0x0BDA, 0x5077)},
+	/* Toshiba */
+	{USB_DEVICE(0x1690, 0x0752)},
+	/* - */
+	{USB_DEVICE(0x20F4, 0x646B)},
+	{USB_DEVICE(0x083A, 0xC512)}, // =
+
+/* RTL8191SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	/* Amigo */
+	{USB_DEVICE(0x0EB0, 0x9061)},
+	/* ASUS/EKB */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	{USB_DEVICE(0x13D3, 0x3323)},
+	{USB_DEVICE(0x13D3, 0x3311)}, // 11n mode disable -
+	{USB_DEVICE(0x13D3, 0x3342)},
+	/* ASUS/EKBLenovo */
+	{USB_DEVICE(0x13D3, 0x3333)},
+	{USB_DEVICE(0x13D3, 0x3334)},
+	{USB_DEVICE(0x13D3, 0x3335)}, // 11n mode disable *
+	{USB_DEVICE(0x13D3, 0x3336)}, // 11n mode disable *
+	/* ASUS/Media BOX */
+	{USB_DEVICE(0x13D3, 0x3309)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x815F)},
+	/* D-Link */
+	{USB_DEVICE(0x07D1, 0x3302)},
+	{USB_DEVICE(0x07D1, 0x3300)},
+	{USB_DEVICE(0x07D1, 0x3303)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7612)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9605)},
+	/* Guillemot */
+	{USB_DEVICE(0x06F8, 0xE031)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0015)},
+	/* Mediao */
+	{USB_DEVICE(0x13D3, 0x3306)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xED18)},
+	{USB_DEVICE(0x2019, 0x4901)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0058)},
+	{USB_DEVICE(0x0DF6, 0x0049)},
+	{USB_DEVICE(0x0DF6, 0x004C)},
+	{USB_DEVICE(0x0DF6, 0x0064)},
+	/* Skyworth */
+	{USB_DEVICE(0x14b2, 0x3300)},
+	{USB_DEVICE(0x14b2, 0x3301)},
+	{USB_DEVICE(0x14B2, 0x3302)},
+	/* - */
+	{USB_DEVICE(0x04F2, 0xAFF2)},
+	{USB_DEVICE(0x04F2, 0xAFF5)},
+	{USB_DEVICE(0x04F2, 0xAFF6)},
+	{USB_DEVICE(0x13D3, 0x3339)},
+	{USB_DEVICE(0x13D3, 0x3340)}, // 11n mode disable *
+	{USB_DEVICE(0x13D3, 0x3341)}, // 11n mode disable *
+	{USB_DEVICE(0x13D3, 0x3310)},
+	{USB_DEVICE(0x13D3, 0x3325)},
+
+/* RTL8192SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x845A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0051)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7622)},
+	/* NEC */
+	{USB_DEVICE(0x0409, 0x02B6)},
+	
+	{}
+};
+
+
+static struct specific_device_id specific_device_id_tbl[] = {
+	{.idVendor=0x0b05, .idProduct=0x1791, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x0B05, 0x1791 -
+	{.idVendor=0x13D3, .idProduct=0x3311, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x13D3, 0x3311 -
+		
+	{.idVendor=0x0DF6, .idProduct=0x0059, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x0DF6, 0x0059 *
+	{.idVendor=0x07D1, .idProduct=0x3306, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x07D1, 0x3306 *
+	{.idVendor=0x13D3, .idProduct=0x3335, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x13D3, 0x3335 *
+	{.idVendor=0x13D3, .idProduct=0x3336, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x13D3, 0x3336 *
+	{.idVendor=0x13D3, .idProduct=0x3340, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x13D3, 0x3340 *
+	{.idVendor=0x13D3, .idProduct=0x3341, .flags=SPEC_DEV_ID_DISABLE_HT}, // 0x13D3, 0x3341 *
+	{}
+};
+
+typedef struct _driver_priv{
+      
+	struct usb_driver r871xu_drv;
+	int drv_registered;	
+
+}drv_priv, *pdrv_priv;
+
+
+static drv_priv drvpriv = {	
+		
+	.r871xu_drv.name="r871x_usb_drv",
+	.r871xu_drv.id_table=rtl871x_usb_id_tbl,
+	.r871xu_drv.probe=r871xu_drv_init,
+	.r871xu_drv.disconnect=r871xu_dev_remove,
+	.r871xu_drv.suspend=NULL,
+	.r871xu_drv.resume=NULL,
+};	
+
+MODULE_DEVICE_TABLE(usb, rtl871x_usb_id_tbl);
+
+uint usb_dvobj_init(_adapter * padapter)
+{
+	int i;
+	u8 val8;
+	u32 	blocksz;
+	uint	status=_SUCCESS;
+	
+	struct	usb_device_descriptor 		*pdev_desc;
+
+	struct	usb_host_config			*phost_conf;
+	struct	usb_config_descriptor 		*pconf_desc;
+
+	struct	usb_host_interface		*phost_iface;
+	struct	usb_interface_descriptor	*piface_desc;
+	
+	struct	usb_host_endpoint		*phost_endp;
+	struct	usb_endpoint_descriptor		*pendp_desc;
+	
+	
+	struct dvobj_priv *pdvobjpriv=&padapter->dvobjpriv;
+	struct usb_device *pusbd=pdvobjpriv->pusbdev;
+
+	PURB urb = NULL;
+
+_func_enter_;
+	
+	pdvobjpriv->padapter=padapter;
+	padapter->EepromAddressSize = 6;
+
+	pdev_desc = &pusbd->descriptor;
+
+#if 0
+	printk("\n8712_usb_device_descriptor:\n");
+	printk("bLength=%x\n", pdev_desc->bLength);
+	printk("bDescriptorType=%x\n", pdev_desc->bDescriptorType);
+	printk("bcdUSB=%x\n", pdev_desc->bcdUSB);
+	printk("bDeviceClass=%x\n", pdev_desc->bDeviceClass);
+	printk("bDeviceSubClass=%x\n", pdev_desc->bDeviceSubClass);
+	printk("bDeviceProtocol=%x\n", pdev_desc->bDeviceProtocol);
+	printk("bMaxPacketSize0=%x\n", pdev_desc->bMaxPacketSize0);
+	printk("idVendor=%x\n", pdev_desc->idVendor);
+	printk("idProduct=%x\n", pdev_desc->idProduct);
+	printk("bcdDevice=%x\n", pdev_desc->bcdDevice);	
+	printk("iManufacturer=%x\n", pdev_desc->iManufacturer);
+	printk("iProduct=%x\n", pdev_desc->iProduct);
+	printk("iSerialNumber=%x\n", pdev_desc->iSerialNumber);
+	printk("bNumConfigurations=%x\n", pdev_desc->bNumConfigurations);
+#endif	
+	
+	phost_conf = pusbd->actconfig;
+	pconf_desc = &phost_conf->desc;
+	
+#if 0	
+	printk("\n8712_usb_configuration_descriptor:\n");
+	printk("bLength=%x\n", pconf_desc->bLength);
+	printk("bDescriptorType=%x\n", pconf_desc->bDescriptorType);
+	printk("wTotalLength=%x\n", pconf_desc->wTotalLength);
+	printk("bNumInterfaces=%x\n", pconf_desc->bNumInterfaces);
+	printk("bConfigurationValue=%x\n", pconf_desc->bConfigurationValue);
+	printk("iConfiguration=%x\n", pconf_desc->iConfiguration);
+	printk("bmAttributes=%x\n", pconf_desc->bmAttributes);
+	printk("bMaxPower=%x\n", pconf_desc->bMaxPower);
+#endif
+
+	//printk("\n/****** num of altsetting = (%d) ******/\n", pintf->num_altsetting);
+		
+	phost_iface = &pintf->altsetting[0];
+	piface_desc = &phost_iface->desc;
+
+#if 0
+	printk("\n8712_usb_interface_descriptor:\n");
+	printk("bLength=%x\n", piface_desc->bLength);
+	printk("bDescriptorType=%x\n", piface_desc->bDescriptorType);
+	printk("bInterfaceNumber=%x\n", piface_desc->bInterfaceNumber);
+	printk("bAlternateSetting=%x\n", piface_desc->bAlternateSetting);
+	printk("bNumEndpoints=%x\n", piface_desc->bNumEndpoints);
+	printk("bInterfaceClass=%x\n", piface_desc->bInterfaceClass);
+	printk("bInterfaceSubClass=%x\n", piface_desc->bInterfaceSubClass);
+	printk("bInterfaceProtocol=%x\n", piface_desc->bInterfaceProtocol);
+	printk("iInterface=%x\n", piface_desc->iInterface);	
+#endif
+	
+	pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
+	
+
+	//printk("\ndump 8712_usb_endpoint_descriptor:\n");
+
+	for(i=0; i<pdvobjpriv->nr_endpoint; i++)
+	{
+		phost_endp = phost_iface->endpoint+i;
+		if(phost_endp)
+		{
+			pendp_desc = &phost_endp->desc;
+		
+			printk("\n8712_usb_endpoint_descriptor(%d):\n", i);
+			printk("bLength=%x\n",pendp_desc->bLength);
+			printk("bDescriptorType=%x\n",pendp_desc->bDescriptorType);
+			printk("bEndpointAddress=%x\n",pendp_desc->bEndpointAddress);
+			//printk("bmAttributes=%x\n",pendp_desc->bmAttributes);
+			//printk("wMaxPacketSize=%x\n",pendp_desc->wMaxPacketSize);
+			printk("wMaxPacketSize=%x\n",le16_to_cpu(pendp_desc->wMaxPacketSize));
+			printk("bInterval=%x\n",pendp_desc->bInterval);
+			//printk("bRefresh=%x\n",pendp_desc->bRefresh);
+			//printk("bSynchAddress=%x\n",pendp_desc->bSynchAddress);	
+		}	
+
+	}
+
+	printk("\n");
+	
+	if (pusbd->speed==USB_SPEED_HIGH)
+	{
+                pdvobjpriv->ishighspeed = _TRUE;
+                printk("8712u : USB_SPEED_HIGH\n");
+	}
+	else
+	{
+		 pdvobjpriv->ishighspeed = _FALSE;
+                 printk("8712u: NON USB_SPEED_HIGH\n");
+	}
+	  	
+			
+	printk("nr_endpoint=%d\n", pdvobjpriv->nr_endpoint);
+	  	
+	if ( (alloc_io_queue(padapter)) == _FAIL)
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" \n Can't init io_reqs\n"));
+		status = _FAIL;			
+	}	
+	
+	_init_sema(&(padapter->dvobjpriv.usb_suspend_sema), 0);
+
+
+_func_exit_;
+	
+	return status;
+
+
+}
+
+void usb_dvobj_deinit(_adapter * padapter){
+	
+	struct dvobj_priv *pdvobjpriv=&padapter->dvobjpriv;
+
+	_func_enter_;
+
+
+	_func_exit_;
+}
+
+void rtl871x_intf_stop(_adapter *padapter)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtl871x_intf_stop\n"));
+	
+	//disabel_hw_interrupt
+	if(padapter->bSurpriseRemoved == _FALSE)
+	{
+		//device still exists, so driver can do i/o operation
+		//TODO:
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("SurpriseRemoved==_FALSE\n"));
+	}
+	
+	//cancel in irp
+	if(padapter->dvobjpriv.inirp_deinit !=NULL)
+	{	
+		padapter->dvobjpriv.inirp_deinit(padapter);	
+	}	
+
+	//cancel out irp
+	usb_write_port_cancel(padapter);
+
+
+	//todo:cancel other irps
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-rtl871x_intf_stop\n"));
+
+}
+
+#if 0
+void r871x_dev_unload(_adapter *padapter)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+r871x_dev_unload\n"));
+
+	if(padapter->bSurpriseRemoved == _TRUE)
+	{		
+		padapter->bDriverStopped = _TRUE;
+	
+		RT_TRACE(_module_os_intfs_c_, _drv_info_, ("padapter->bSurpriseRemoved==_TRUE\n"));
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("unload -> surprise removed\n"));
+		
+		free_drv_sw(padapter);
+		
+		return;
+
+	}
+					
+       padapter->bDriverStopped = _TRUE;
+	padapter->bSurpriseRemoved = _TRUE;   
+
+	rtl871x_intf_stop(padapter);
+
+	stop_drv_threads(padapter);
+
+	rtl871x_hal_deinit(padapter);
+
+	
+	if(padapter->dvobj_deinit)
+	{
+		padapter->dvobj_deinit(padapter);
+		
+	}else
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize hcipriv.hci_priv_init error!!!\n"));
+	}			
+	
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-r871x_dev_unload\n"));
+}
+#else
+void r871x_dev_unload(_adapter *padapter)
+{
+	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+r871x_dev_unload\n"));
+
+	if(padapter->bup == _TRUE)
+	{
+		printk("+r871x_dev_unload\n");
+		//s1.
+/*		if(pnetdev)   
+     		{
+        		netif_carrier_off(pnetdev);
+     	  		netif_stop_queue(pnetdev);
+     		}
+		
+		//s2.
+		//s2-1.  issue disassoc_cmd to fw
+		disassoc_cmd(padapter);	
+		//s2-2.  indicate disconnect to os
+		indicate_disconnect(padapter);				
+		//s2-3. 
+	       free_assoc_resources(padapter);	
+		//s2-4.
+		free_network_queue(padapter);*/
+
+		padapter->bDriverStopped = _TRUE;
+	
+		//s3.
+		rtl871x_intf_stop(padapter);
+
+		//s4.
+		stop_drv_threads(padapter);
+
+
+		//s5.
+		if(padapter->bSurpriseRemoved == _FALSE)
+		{
+			printk("r871x_dev_unload()->rtl871x_hal_deinit()\n");
+			rtl871x_hal_deinit(padapter);
+
+			//padapter->bSurpriseRemoved = _TRUE;
+		}	
+
+		//s6.	
+		if(padapter->dvobj_deinit)
+		{
+			padapter->dvobj_deinit(padapter);
+		
+		}
+		else
+		{
+			RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize hcipriv.hci_priv_init error!!!\n"));
+		}			
+		
+		padapter->bup = _FALSE;
+
+	}
+	else
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == _FALSE\n" ));
+	}
+				
+	printk("-r871x_dev_unload\n");		
+	
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-r871x_dev_unload\n"));
+	
+}
+#endif
+
+static void disable_ht_for_spec_devid(const struct usb_device_id *pdid)
+{
+#ifdef CONFIG_80211N_HT
+	u16 vid, pid;
+	u32 flags;
+	int i;	
+	int num = sizeof(specific_device_id_tbl)/sizeof(struct specific_device_id);
+
+	for(i=0; i<num; i++)
+	{
+		vid = specific_device_id_tbl[i].idVendor;
+		pid = specific_device_id_tbl[i].idProduct;
+		flags = specific_device_id_tbl[i].flags;
+
+		if((pdid->idVendor==vid) && (pdid->idProduct==pid) && (flags&SPEC_DEV_ID_DISABLE_HT))
+		{
+			 ht_enable = 0;            
+			 cbw40_enable = 0;            
+			 ampdu_enable = 0;			
+		}
+	}
+#endif
+}
+
+u8 key_char2num(u8 ch)
+{
+    if((ch>='0')&&(ch<='9'))
+        return ch - '0';
+    else if ((ch>='a')&&(ch<='f'))
+        return ch - 'a' + 10;
+    else if ((ch>='A')&&(ch<='F'))
+        return ch - 'A' + 10;
+    else
+	 return 0xff;
+}
+
+u8 key_2char2num(u8 hch, u8 lch)
+{
+    return ((key_char2num(hch) << 4) | key_char2num(lch));
+}
+
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us to support.
+ *        We accept the new device by returning 0.
+*/
+static int r871xu_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid)
+{  	
+  	uint status;	 
+	_adapter *padapter = NULL;
+  	struct dvobj_priv *pdvobjpriv;
+	struct net_device *pnetdev;
+	struct usb_device	*udev;
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+871x - drv_init\n"));
+
+	printk( "==DriverVersion: %s==\n", DRVER );
+
+	//2009.8.13, by Thomas
+	// In this probe function, O.S. will provide the usb interface pointer to driver.
+	// We have to increase the reference count of the usb device structure by using the usb_get_dev function.
+	udev = interface_to_usbdev(pusb_intf);
+	usb_get_dev(udev);
+
+	pintf = pusb_intf;
+
+#ifdef CONFIG_80211N_HT
+	//step 0.	
+	disable_ht_for_spec_devid(pdid);
+#endif
+
+	//step 1.
+	pnetdev = init_netdev();
+	if (!pnetdev)
+		goto error;	
+	
+	padapter = rtw_netdev_priv(pnetdev);
+	pdvobjpriv = &padapter->dvobjpriv;	
+	pdvobjpriv->padapter = padapter;
+
+	padapter->dvobjpriv.pusbdev = udev;
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_wdev_alloc(padapter, &pusb_intf->dev);
+#endif //CONFIG_IOCTL_CFG80211
+
+	usb_set_intfdata(pusb_intf, pnetdev);	
+	SET_NETDEV_DEV(pnetdev, &pusb_intf->dev);
+
+	//step 2.
+	padapter->dvobj_init=&usb_dvobj_init;
+	padapter->dvobj_deinit=&usb_dvobj_deinit;
+	padapter->halpriv.hal_bus_init=&usb_hal_bus_init;
+	padapter->halpriv.hal_bus_deinit=&usb_hal_bus_deinit;	
+	padapter->dvobjpriv.inirp_init=&usb_inirp_init;
+	padapter->dvobjpriv.inirp_deinit=&usb_inirp_deinit;
+
+	//step 3.
+	//initialize the dvobj_priv 		
+	if(padapter->dvobj_init ==NULL){
+			RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Initialize dvobjpriv.dvobj_init error!!!\n"));
+			goto error;
+	}else{
+	
+		status=padapter->dvobj_init(padapter);
+		if (status != _SUCCESS) {
+			RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n initialize device object priv Failed!\n"));			
+			goto error;
+		} 
+	}
+
+	//step 4.
+	status = init_drv_sw(padapter);	
+	if(status ==_FAIL){
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));	
+		goto error;					
+	}	
+
+#if 1
+	//step 5. read efuse/eeprom data and get mac_addr
+	{
+		int i, offset;
+		u8 mac[6];
+		u8	tmpU1b, AutoloadFail, eeprom_CustomerID;
+		u8 *pdata = padapter->eeprompriv.efuse_eeprom_data;
+
+		tmpU1b = read8(padapter, EE_9346CR);//CR9346	
+
+		// To check system boot selection.
+		if (tmpU1b & _9356SEL)
+		{
+			printk("Boot from EEPROM\n");
+		}
+		else 
+		{
+			printk("Boot from EFUSE\n");
+		}	
+
+		// To check autoload success or not.
+		if (tmpU1b & _EEPROM_EN)
+		{
+			printk("Autoload OK!!\n");
+			AutoloadFail = _TRUE;
+
+			//tmpU1b = read8(padapter, EFUSE_TEST+3);
+			//write8(padapter, EFUSE_TEST+3, tmpU1b|0x80);
+			//mdelay_os(1);
+			//write8(padapter, EFUSE_TEST+3, (tmpU1b&(~ BIT(7))));
+
+			// Retrieve Chip version.
+			// 20090915 Joseph: Recognize IC version by Reg0x4 BIT15.
+			tmpU1b = (u8)((read32(padapter, PMC_FSM)>>15)&0x1F);
+
+			if(tmpU1b==0x3)
+				padapter->registrypriv.chip_version = RTL8712_3rdCUT;
+			else
+				padapter->registrypriv.chip_version = (tmpU1b>>1)+1;
+
+			switch(padapter->registrypriv.chip_version)
+			{
+				case RTL8712_1stCUT:
+					RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Chip Version ID: RTL8712_1stCUT.\n"));
+					break;
+				case RTL8712_2ndCUT:
+					RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Chip Version ID: RTL8712_2ndCUT.\n"));
+					break;
+				case RTL8712_3rdCUT:
+					RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Chip Version ID: RTL8712_3rdCUT.\n"));
+					break;
+				default:
+					RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Unknown Chip Version!!\n"));
+					padapter->registrypriv.chip_version = RTL8712_2ndCUT;
+					break;
+			}
+			
+#if 1
+
+			for(i=0, offset=0 ; i<128; i+=8, offset++)
+			{
+				efuse_pg_packet_read(padapter, offset, &pdata[i]);			
+			}
+
+			if ( initmac )
+			{	//	Users specify the mac address
+				int jj,kk;
+
+				for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+				{
+	            			mac[jj] = key_2char2num(initmac[kk], initmac[kk+ 1]);
+				}
+			}
+			else
+			{	//	Use the mac address stored in the Efuse
+			 	_memcpy(mac, &pdata[0x12], ETH_ALEN);//offset = 0x12 for usb in efuse 
+			}
+
+
+			eeprom_CustomerID = pdata[0x52];
+			switch(eeprom_CustomerID)
+			{
+				case EEPROM_CID_ALPHA:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_ALPHA;
+					break;
+					
+				case EEPROM_CID_CAMEO:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_CAMEO;
+					break;			
+					
+				case EEPROM_CID_SITECOM:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_Sitecom;
+					break;	
+					
+				case EEPROM_CID_COREGA:
+					padapter->eeprompriv.CustomerID = RT_CID_COREGA;						
+					break;			
+			
+				case EEPROM_CID_Senao:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_Senao;
+					break;
+		
+				case EEPROM_CID_EDIMAX_BELKIN:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_Edimax_Belkin;
+					break;
+		
+				case EEPROM_CID_SERCOMM_BELKIN:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_Sercomm_Belkin;
+					break;
+					
+				case EEPROM_CID_WNC_COREGA:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_WNC_COREGA;
+					break;
+		
+				case EEPROM_CID_WHQL:
+					break;
+					
+				case EEPROM_CID_NetCore:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_Netcore;
+					break;
+		
+				case EEPROM_CID_CAMEO1:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_CAMEO1;
+					break;
+					
+				case EEPROM_CID_CLEVO:
+					padapter->eeprompriv.CustomerID = RT_CID_819x_CLEVO;
+					break;
+		
+				default:
+					padapter->eeprompriv.CustomerID = RT_CID_DEFAULT;
+					break;
+					
+			}
+			printk("CustomerID = 0x%4x\n", padapter->eeprompriv.CustomerID);
+
+			//
+			// Led mode
+			// 
+			switch(padapter->eeprompriv.CustomerID)
+			{
+				case RT_CID_DEFAULT:
+				case RT_CID_819x_ALPHA:
+				case RT_CID_819x_CAMEO:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE1;
+					padapter->ledpriv.bRegUseLed = _TRUE;
+					break;	
+
+				case RT_CID_819x_Sitecom:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE2;
+					padapter->ledpriv.bRegUseLed = _TRUE;
+					break;	
+
+				case RT_CID_COREGA:
+				case RT_CID_819x_Senao:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE3;
+					padapter->ledpriv.bRegUseLed = _TRUE;
+					break;			
+
+				case RT_CID_819x_Edimax_Belkin:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE4;
+					padapter->ledpriv.bRegUseLed = _TRUE;
+					break;					
+
+				case RT_CID_819x_Sercomm_Belkin:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE5;
+					padapter->ledpriv.bRegUseLed = _TRUE;
+					break;
+
+				case RT_CID_819x_WNC_COREGA:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE6;
+					padapter->ledpriv.bRegUseLed = _TRUE;
+					break;
+
+				default:
+					padapter->ledpriv.LedStrategy = SW_LED_MODE0;
+					padapter->ledpriv.bRegUseLed = _FALSE;
+					break;			
+			}
+#endif
+		}
+		else {
+			printk("AutoLoad Fail reported from CR9346!!\n");
+			AutoloadFail = _FALSE;
+		}
+
+		if(	((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff)  && (mac[3]==0xff) &&
+			(mac[4]==0xff) &&(mac[5]==0xff) ) || 
+			((mac[0]==0x0) &&(mac[1]==0x0) && (mac[2]==0x0)  && (mac[3]==0x0) &&
+			(mac[4]==0x0) &&(mac[5]==0x0)) || (AutoloadFail == _FALSE))
+		{
+		mac[0]=0x00;
+		mac[1]=0xe0;
+		mac[2]=0x4c;
+		mac[3]=0x87;
+		mac[4]=0x00;
+		mac[5]=0x00;
+		}
+	
+		_memcpy(pnetdev->dev_addr, mac/*padapter->eeprompriv.mac_addr*/, ETH_ALEN);
+
+		 printk("MAC Address from efuse= %x-%x-%x-%x-%x-%x\n", 
+			mac[0],mac[1],mac[2],mac[3], mac[4], mac[5]);		
+	}	
+#endif
+
+	//step 6.
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
+		goto error;
+	}
+	
+	_spinlock_init( &padapter->lockRxFF0Filter );
+	
+  	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-drv_init - Adapter->bDriverStopped=%d, Adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
+  	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_drv - drv_init, success!\n"));
+	//printk("-871x_drv - drv_init, success!\n");
+
+#ifdef CONFIG_HOSTAPD_MODE
+	hostapd_mode_init(padapter);
+#endif	
+
+#ifdef CONFIG_PLATFORM_RTD2880B
+	printk("wlan link up\n");
+	rtd2885_wlan_netlink_sendMsg("linkup", "8712");	
+#endif	
+
+  	return 0;
+
+error:	      
+
+	usb_put_dev(udev);//decrease the reference count of the usb device structure if driver fail on initialzation
+
+	usb_set_intfdata(pusb_intf, NULL);
+
+   	if(padapter->dvobj_deinit==NULL){
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Initialize dvobjpriv.dvobj_deinit error!!!\n"));
+	}else{
+		padapter->dvobj_deinit(padapter);
+	} 	  
+
+	if(pnetdev)
+	{
+		//unregister_netdev(pnetdev);
+		free_netdev(pnetdev);
+	}
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_sdio - drv_init, fail!\n"));
+	//printk("-871x_sdio - drv_init, fail!\n");
+
+	return -ENODEV;
+
+}
+
+/*
+ * dev_remove() - our device is being removed
+*/
+#if 0
+static void r871xu_dev_remove(struct usb_interface *pusb_intf)
+{	
+	_irqL irqL;
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);	
+     _adapter *padapter = (_adapter*)rtw_netdev_priv(pnetdev);
+	 struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_exit_;
+
+	if(padapter)	
+	{
+       		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));
+		
+		pnetdev= (struct net_device*)padapter->pnetdev;	
+      		
+		padapter->bSurpriseRemoved = _TRUE;	 
+     
+    		if(pnetdev)   
+     		{
+        		netif_carrier_off(pnetdev);
+     	  		netif_stop_queue(pnetdev);
+     		}
+
+		rtl871x_intf_stop(padapter);			
+		stop_drv_threads(padapter);
+
+		// indicate-disconnect if necssary (free all assoc-resources)
+		// dis-assoc from assoc_sta (optional)			
+		_enter_critical(&pmlmepriv->lock, &irqL);
+		if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) 
+		{
+			indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not		
+		}
+		_exit_critical(&pmlmepriv->lock, &irqL);
+			
+		//todo:wait until fw has process dis-assoc cmd		
+
+
+		r871x_dev_unload(padapter);		
+			
+	}
+	
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-dev_remove()\n"));
+
+_func_exit_;	
+
+	return;
+	
+}
+#else
+//rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both
+static void r871xu_dev_remove(struct usb_interface *pusb_intf)
+{		
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);	
+	struct usb_device	*udev = interface_to_usbdev(pusb_intf);
+       _adapter *padapter = (_adapter*)rtw_netdev_priv(pnetdev);
+   
+_func_exit_;
+
+	usb_set_intfdata(pusb_intf, NULL);
+
+	if(padapter)	
+	{
+
+#ifdef CONFIG_IOCTL_CFG80211
+		struct wireless_dev *wdev = padapter->rtw_wdev;
+#endif //CONFIG_IOCTL_CFG80211
+
+		printk("+r871xu_dev_remove\n");
+       	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));		
+      		
+#ifdef CONFIG_HOSTAPD_MODE
+		hostapd_mode_unload(padapter);
+#endif	
+			
+		if(drvpriv.drv_registered == _TRUE)
+		{
+			//printk("r871xu_dev_remove():padapter->bSurpriseRemoved == _TRUE\n");
+		        padapter->bSurpriseRemoved = _TRUE;	 
+		}
+		/*else
+		{
+			//printk("r871xu_dev_remove():module removed\n");
+			padapter->hw_init_completed = _FALSE;
+		}*/
+
+		if(pnetdev != NULL) {
+			unregister_netdev(pnetdev); //will call netdev_close()
+		}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	/* kernel 2.4 series */
+#else
+		flush_scheduled_work();
+#endif
+		udelay_os(1);
+
+		//Stop driver mlme relation timer
+		stop_drv_timers(padapter);
+
+		r871x_dev_unload(padapter);
+
+		free_drv_sw(padapter);
+
+#ifdef CONFIG_IOCTL_CFG80211
+		rtw_wdev_free(wdev);
+#endif //CONFIG_IOCTL_CFG80211		
+	}
+
+	usb_put_dev(udev);//decrease the reference count of the usb device structure when disconnect
+		
+	//If we didn't unplug usb dongle and remove/insert modlue, driver fails on sitesurvey for the first time when device is up . 
+	//Reset usb port for sitesurvey fail issue. 2009.8.13, by Thomas
+	if(udev->state != USB_STATE_NOTATTACHED)
+		usb_reset_device(udev);
+	
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-dev_remove()\n"));
+	//printk("-r871xu_dev_remove, hw_init_completed=%d\n", padapter->hw_init_completed);
+
+#ifdef CONFIG_PLATFORM_RTD2880B
+	printk("wlan link down\n");
+	rtd2885_wlan_netlink_sendMsg("linkdown", "8712");	
+#endif	
+	
+
+_func_exit_;	
+
+	return;
+	
+}
+#endif
+
+static int __init r8712u_drv_entry(void)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+r8712u_drv_entry\n"));
+	g_pallocated_recv_buf = _malloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4);
+	drvpriv.drv_registered = _TRUE;
+	return usb_register(&drvpriv.r871xu_drv);	
+}
+
+static void __exit r8712u_drv_halt(void)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+r8712u_drv_halt\n"));
+	printk("+r8712u_drv_halt\n");
+	drvpriv.drv_registered = _FALSE;
+	
+	usb_deregister(&drvpriv.r871xu_drv);
+
+	if( g_pallocated_recv_buf )
+		_mfree(g_pallocated_recv_buf, NR_RECVBUFF *sizeof(struct recv_buf) + 4);
+	
+	printk("-r8712u_drv_halt\n");
+}
+
+
+module_init(r8712u_drv_entry);
+module_exit(r8712u_drv_halt);
+
+
+/*
+init (driver module)-> r8712u_drv_entry
+probe (sd device)-> r871xu_drv_init(dev_init)
+open (net_device) ->netdev_open
+close (net_device) ->netdev_close
+remove (sd device) ->r871xu_dev_remove
+exit (driver module)-> r8712u_drv_halt
+*/
+
+
+/*
+r8711s_drv_entry()
+r8711u_drv_entry()
+r8712s_drv_entry()
+r8712u_drv_entry()
+*/
+
diff --git a/drivers/net/wireless/8712u/os_intf/osdep_service.c b/drivers/net/wireless/8712u/os_intf/osdep_service.c
new file mode 100755
index 0000000..80750d5
--- /dev/null
+++ b/drivers/net/wireless/8712u/os_intf/osdep_service.c
@@ -0,0 +1,670 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+
+
+#define _OSDEP_SERVICE_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <linux/vmalloc.h>
+
+#ifdef RTK_DMP_PLATFORM
+#include <linux/auth.h>
+#endif
+
+#define RT_TAG	'1178'
+
+u8* _malloc(u32 sz)
+{
+
+	u8 	*pbuf;
+
+#ifdef PLATFORM_LINUX
+#ifdef RTK_DMP_PLATFORM
+	if(sz > 0x4000)
+		pbuf = dvr_malloc(sz);
+	else
+#endif
+		pbuf = 	kmalloc(sz, /*GFP_KERNEL*/GFP_ATOMIC);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
+
+#endif
+	if ( pbuf == NULL )
+		printk( "[%s] allocate memory failed! sz = %d\n", __FUNCTION__, sz);
+	
+	return pbuf;	
+	
+}
+
+void	_mfree(u8 *pbuf, u32 sz)
+{
+
+#ifdef	PLATFORM_LINUX
+#ifdef RTK_DMP_PLATFORM
+	if(sz > 0x4000)
+		dvr_free(pbuf);
+	else
+#endif
+		kfree(pbuf);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisFreeMemory(pbuf,sz, 0);
+
+#endif
+	
+	
+}
+
+struct net_device *rtw_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *pnetdev;
+	struct rtw_netdev_priv_indicator *pnpi;
+	
+	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+	if (!pnetdev)
+		goto RETURN;
+	
+	pnpi = netdev_priv(pnetdev);
+	
+	pnpi->priv = _zvmalloc(sizeof_priv);
+	if (!pnpi->priv) {
+		free_netdev(pnetdev);
+		pnetdev = NULL;
+		goto RETURN;
+	}
+	
+	pnpi->sizeof_priv=sizeof_priv;
+RETURN:
+	return pnetdev;
+}
+
+void rtw_free_netdev(struct net_device * netdev)
+{
+	struct rtw_netdev_priv_indicator *pnpi;
+	
+	if(!netdev)
+		goto RETURN;
+	
+	pnpi = netdev_priv(netdev);
+
+	if(!pnpi->priv)
+		goto RETURN;
+
+	_vmfree(pnpi->priv, pnpi->sizeof_priv);
+	free_netdev(netdev);
+
+RETURN:
+	return;
+}
+
+u8* _zmalloc(u32 sz)
+{
+	u8 	*pbuf = _malloc(sz);
+
+	if (pbuf != NULL) {
+
+#ifdef PLATFORM_LINUX
+		memset(pbuf, 0, sz);
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+		NdisFillMemory(pbuf, sz, 0);
+#endif
+
+	}
+	return pbuf;	
+}
+
+inline u8* _vmalloc(u32 sz)
+{
+	u8 	*pbuf;
+#ifdef PLATFORM_LINUX	
+	pbuf = vmalloc(sz);
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);	
+#endif
+
+	return pbuf;	
+}
+
+inline u8* _zvmalloc(u32 sz)
+{
+	u8 	*pbuf;
+#ifdef PLATFORM_LINUX
+	pbuf = _vmalloc(sz);
+	if (pbuf != NULL)
+		memset(pbuf, 0, sz);
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
+	if (pbuf != NULL)
+		NdisFillMemory(pbuf, sz, 0);
+#endif
+
+	return pbuf;	
+}
+
+inline void _vmfree(u8 *pbuf, u32 sz)
+{
+#ifdef	PLATFORM_LINUX
+	vfree(pbuf);
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+	NdisFreeMemory(pbuf,sz, 0);
+#endif
+}
+
+void _memcpy(void* dst, void* src, u32 sz)
+{
+
+#ifdef PLATFORM_LINUX
+
+	memcpy(dst, src, sz);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMoveMemory(dst, src, sz);
+
+#endif
+
+}
+
+int	_memcmp(void *dst, void *src, u32 sz)
+{
+
+#ifdef PLATFORM_LINUX
+//under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0
+
+	if (!(memcmp(dst, src, sz)))
+		return _TRUE;
+	else
+		return _FALSE;
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+//under Windows, the return value of NdisEqualMemory for two same mem. chunk is 1
+	
+	if (NdisEqualMemory (dst, src, sz))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif	
+	
+	
+	
+}
+
+void _memset(void *pbuf, int c, u32 sz)
+{
+
+#ifdef PLATFORM_LINUX
+
+        memset(pbuf, c, sz);
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#if 0
+	NdisZeroMemory(pbuf, sz);
+	if (c != 0) memset(pbuf, c, sz);
+#else
+	NdisFillMemory(pbuf, sz, c);
+#endif
+#endif
+
+}
+
+void _init_listhead(_list *list)
+{
+
+#ifdef PLATFORM_LINUX
+
+        INIT_LIST_HEAD(list);
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+        NdisInitializeListHead(list);
+
+#endif
+
+}
+
+
+/*
+For the following list_xxx operations, 
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+u32	is_list_empty(_list *phead)
+{
+
+#ifdef PLATFORM_LINUX
+
+	if (list_empty(phead))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+	
+
+#ifdef PLATFORM_WINDOWS
+
+	if (IsListEmpty(phead))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+
+	
+}
+
+
+void list_insert_tail(_list *plist, _list *phead)
+{
+
+#ifdef PLATFORM_LINUX	
+	
+	list_add_tail(plist, phead);
+	
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+  InsertTailList(phead, plist);
+
+#endif		
+	
+}
+
+
+/*
+
+Caller must check if the list is empty before calling list_delete
+
+*/
+
+
+void _init_sema(_sema	*sema, int init_val)
+{
+
+#ifdef PLATFORM_LINUX
+
+	sema_init(sema, init_val);
+
+#endif
+
+#ifdef PLATFORM_OS_XP
+
+	KeInitializeSemaphore(sema, init_val,  SEMA_UPBND); // count=0;
+
+#endif
+	
+#ifdef PLATFORM_OS_CE
+	if(*sema == NULL)
+		*sema = CreateSemaphore(NULL, init_val, SEMA_UPBND, NULL);
+#endif
+
+}
+
+void _free_sema(_sema	*sema)
+{
+
+#ifdef PLATFORM_OS_CE
+	CloseHandle(*sema);
+#endif
+
+}
+
+void _up_sema(_sema	*sema)
+{
+
+#ifdef PLATFORM_LINUX
+
+	up(sema);
+
+#endif	
+
+#ifdef PLATFORM_OS_XP
+
+	KeReleaseSemaphore(sema, IO_NETWORK_INCREMENT, 1,  FALSE );
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+	ReleaseSemaphore(*sema,  1,  NULL );
+#endif
+}
+
+u32 _down_sema(_sema *sema)
+{
+
+#ifdef PLATFORM_LINUX
+	
+	if (down_interruptible(sema))
+		return _FAIL;
+    else
+    	return _SUCCESS;
+
+#endif    	
+
+#ifdef PLATFORM_OS_XP
+
+	if(STATUS_SUCCESS == KeWaitForSingleObject(sema, Executive, KernelMode, TRUE, NULL))
+		return  _SUCCESS;
+	else
+		return _FAIL;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	if(WAIT_OBJECT_0 == WaitForSingleObject(*sema, INFINITE ))
+		return _SUCCESS; 
+	else
+		return _FAIL;
+#endif
+}
+
+
+
+void	_rtl_rwlock_init(_rwlock *prwlock)
+{
+#ifdef PLATFORM_LINUX
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37))
+	init_MUTEX(prwlock);
+#else
+	sema_init(prwlock, 1);
+#endif
+#endif
+#ifdef PLATFORM_OS_XP
+
+	KeInitializeMutex(prwlock, 0);
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+	*prwlock =  CreateMutex( NULL, _FALSE, NULL);
+#endif
+}
+
+
+void	_spinlock_init(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock_init(plock);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisAllocateSpinLock(plock);
+
+#endif
+	
+}
+
+void	_spinlock_free(_lock *plock)
+{
+
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisFreeSpinLock(plock);
+
+#endif
+	
+}
+
+
+void	_spinlock(_lock	*plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisAcquireSpinLock(plock);
+
+#endif
+	
+}
+
+void	_spinunlock(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_unlock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisReleaseSpinLock(plock);
+
+#endif
+}
+
+
+void	_spinlock_ex(_lock	*plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisDprAcquireSpinLock(plock);
+
+#endif
+	
+}
+
+void	_spinunlock_ex(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_unlock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisDprReleaseSpinLock(plock);
+
+#endif
+}
+
+
+
+void	_init_queue(_queue	*pqueue)
+{
+
+	_init_listhead(&(pqueue->queue));
+
+	_spinlock_init(&(pqueue->lock));
+
+}
+
+u32	  _queue_empty(_queue	*pqueue)
+{
+	return (is_list_empty(&(pqueue->queue)));
+}
+
+
+u32 end_of_queue_search(_list *head, _list *plist)
+{
+
+	if (head == plist)
+		return _TRUE;
+	else
+		return _FALSE;
+		
+}
+
+
+u32	get_current_time(void)
+{
+	
+#ifdef PLATFORM_LINUX
+
+	return jiffies;
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	LARGE_INTEGER	SystemTime;
+	NdisGetCurrentSystemTime(&SystemTime);
+	return (u32)(SystemTime.LowPart);// count of 100-nanosecond intervals 
+
+#endif
+	
+	
+}
+
+void sleep_schedulable(int ms)	
+{
+
+#ifdef PLATFORM_LINUX
+
+    u32 delta;
+    
+    delta = (ms * HZ)/1000;//(ms)
+    if (delta == 0) {
+        delta = 1;// 1 ms
+    }
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (schedule_timeout(delta) != 0) {
+        return ;
+    }
+    return;
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+}
+
+
+void msleep_os(int ms)
+{
+
+#ifdef PLATFORM_LINUX
+
+  	msleep((unsigned int)ms);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void usleep_os(int us)
+{
+
+#ifdef PLATFORM_LINUX
+  	
+       msleep((unsigned int)us);
+
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(us); //(us)
+
+#endif
+
+
+}
+
+void mdelay_os(int ms)
+{
+
+#ifdef PLATFORM_LINUX
+
+   	mdelay((unsigned long)ms); 
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisStallExecution(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void udelay_os(int us)
+{
+
+#ifdef PLATFORM_LINUX
+
+      udelay((unsigned long)us); 
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisStallExecution(us); //(us)
+
+#endif
+
+}
+
diff --git a/drivers/net/wireless/8712u/pwrctrl/rtl871x_pwrctrl.c b/drivers/net/wireless/8712u/pwrctrl/rtl871x_pwrctrl.c
new file mode 100755
index 0000000..d54d2b4
--- /dev/null
+++ b/drivers/net/wireless/8712u/pwrctrl/rtl871x_pwrctrl.c
@@ -0,0 +1,750 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_PWRCTRL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef PLATFORM_LINUX
+        #include<linux/mmc/sdio_func.h>
+#endif
+#include <sdio_ops.h>
+#endif
+
+
+
+#ifdef CONFIG_PWRCTRL
+
+void set_rpwm(_adapter * padapter, u8 val8)
+{
+	u8	rpwm;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	if(pwrpriv->rpwm == val8){
+		if(pwrpriv->rpwm_retry== 0 ){
+			RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Already set rpwm [%d] ! \n", val8));
+			return;
+		}
+	}
+
+	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE)){
+		//DbgPrint("xmit_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved);
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("set_rpwm=> bDriverStopped or bSurpriseRemoved \n"));
+		return;
+	}
+	rpwm = val8 |pwrpriv->tog;
+
+	switch(val8){
+		case PS_STATE_S1:
+			pwrpriv->cpwm = val8;
+			break;
+		case PS_STATE_S2://only for USB normal powersave mode use,temp mark some code.
+		case PS_STATE_S3:
+		case PS_STATE_S4:
+#ifdef CONFIG_SDIO_HCI
+//			pwrpriv->cpwm = val8;
+			rpwm |= BIT(6);
+			_set_timer(&pwrpriv->rpwm_check_timer, 1000);
+#endif
+#ifdef CONFIG_USB_HCI
+			pwrpriv->cpwm = val8;
+			//rpwm |= BIT(6);
+			//_set_timer(&pwrpriv->rpwm_check_timer, 1000);
+#endif
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("set_rpwm: set_timer\n"));
+			break;
+		default:
+			RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("set_rpwm: value = %x is wrong !!!\n", val8));
+			break;
+	}
+	pwrpriv->rpwm_retry=0;
+	pwrpriv->rpwm = val8;
+	
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("set_rpwm: value = %x\n", rpwm));
+
+#ifdef CONFIG_SDIO_HCI
+	write8(padapter, SDIO_HRPWM, rpwm);
+#else
+	write8(padapter, 0x1025FE58, rpwm);
+#endif
+	
+	pwrpriv->tog += 0x80;
+
+_func_exit_;
+}
+
+
+void set_ps_mode(_adapter * padapter, uint ps_mode, uint smart_ps)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("========= Power Mode is :%d, Smart_PS = %d\n", ps_mode,smart_ps));
+
+	if(ps_mode > PM_Card_Disable) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("ps_mode:%d error\n", ps_mode));
+		goto exit;
+	}
+
+	// if driver is in active state, we dont need set smart_ps.
+	if(ps_mode == PS_MODE_ACTIVE)
+		smart_ps = 0;
+
+	if( (pwrpriv->pwr_mode != ps_mode) || (pwrpriv->smart_ps != smart_ps))
+	{		
+		if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+		{
+			pwrpriv->bSleep = _TRUE;
+		}
+		else
+		{
+			pwrpriv->bSleep = _FALSE;
+		}
+		pwrpriv->pwr_mode = ps_mode;
+		pwrpriv->smart_ps = smart_ps;
+
+		_set_workitem(&(pwrpriv->SetPSModeWorkItem));
+	}
+
+exit:	
+_func_exit_;
+}
+
+
+/*
+Caller:ISR handler...
+
+This will be called when CPWM interrupt is up.
+
+using to update cpwn of drv; and drv willl make a decision to up or down pwr level
+*/
+void cpwm_int_hdl(_adapter *padapter, struct reportpwrstate_parm *preportpwrstate)
+{
+	struct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);
+	struct cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+
+_func_enter_;
+
+	if(pwrpriv->cpwm_tog == ((preportpwrstate->state)&0x80)){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("cpwm_int_hdl : cpwm_tog = %x this time cpwm=0x%x  toggle bit didn't change !!!\n",pwrpriv->cpwm_tog ,preportpwrstate->state));	
+		goto exit;
+	}
+	
+	_cancel_timer_ex(&padapter->pwrctrlpriv.rpwm_check_timer);
+
+	_enter_pwrlock(&pwrpriv->lock);
+
+	pwrpriv->cpwm = (preportpwrstate->state)&0xf;
+
+	if(pwrpriv->cpwm >= PS_STATE_S2){
+		if(pwrpriv->alives & CMD_ALIVE)
+			_up_sema(&(pcmdpriv->cmd_queue_sema));
+
+		if(pwrpriv->alives & XMIT_ALIVE)
+			_up_sema(&(pxmitpriv->xmit_sema));
+	}
+	pwrpriv->cpwm_tog=  (preportpwrstate->state)&0x80;
+	_exit_pwrlock(&pwrpriv->lock);
+exit:
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("cpwm_int_hdl : cpwm = %x !!!\n",pwrpriv->cpwm));
+
+_func_exit_;
+
+}
+
+
+static __inline void	register_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+_func_enter_;
+		pwrctrl->alives |= tag;
+_func_exit_;
+}
+
+static __inline void	unregister_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+_func_enter_;
+
+	if (pwrctrl->alives & tag)
+		pwrctrl->alives ^= tag;
+
+_func_exit_;	
+}
+void _rpwm_check_handler (_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+	if(padapter->bDriverStopped == _TRUE || padapter->bSurpriseRemoved== _TRUE){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("_rpwm_check_handler  bDriverStopped or bSurpriseRemoved\n"));
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("_rpwm_check_handler  cancel timer\n"));
+		return;
+		}
+	if(pwrpriv->cpwm !=pwrpriv->rpwm){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Set RPWM(0x%x) again[cpwm=0x%x]!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+		_set_workitem(&(pwrpriv->rpwm_workitem));
+	}
+_func_exit_;	
+
+}
+void cpwm_hdl(PADAPTER padapter);
+#ifdef PLATFORM_WINDOWS
+
+void rpwm_check_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	)
+       {
+	_adapter *adapter = (_adapter *)FunctionContext;
+	u8 bcancelled;
+	if(adapter->bDriverStopped == _TRUE || adapter->bSurpriseRemoved== _TRUE){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_check_handler  bDriverStopped or bSurpriseRemoved\n"));
+		_cancel_timer(&adapter->pwrctrlpriv.rpwm_check_timer, &bcancelled);
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_check_handler  cancel timer\n"));
+	}else{
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_check_handler\n"));
+		_rpwm_check_handler(adapter);
+	}
+}
+
+void rpwm_workitem_callback(
+	IN NDIS_WORK_ITEM*	pWorkItem,
+	IN PVOID			Context
+	)
+{
+	_adapter			*padapter = (_adapter *)Context;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	u8 cpwm=pwrpriv->cpwm;
+
+_func_enter_;	
+//	msleep_os(10);
+	_enter_pwrlock(&pwrpriv->lock);
+	if(pwrpriv->cpwm !=pwrpriv->rpwm){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback: set RPWM(0x%x) again[cpwm=0x%x]!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+		cpwm=read8(padapter, SDIO_HCPWM);
+/*		if(cpwm>1 && (cpwm!=pwrpriv->cpwm)){
+			reportpwrstate.state=cpwm;	
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback:RPWM(0x%x) [cpwm=0x%x]  call cpwm_hdl!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+			
+			cpwm_hdl(padapter);
+		}
+		else if(pwrpriv->cpwm !=pwrpriv->rpwm)
+*/
+		{
+			
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback:RPWM(0x%x) [cpwm=0x%x]  SET RPWM again!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+			pwrpriv->rpwm_retry=1;
+			set_rpwm(padapter, pwrpriv->rpwm);
+		}
+	}
+	else{
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback: RPWM(0x%x)  [cpwm=0x%x]!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+	}
+	_exit_pwrlock(&pwrpriv->lock);
+_func_exit_;	
+}
+//-----------------------------------------------------------------------------
+//	Description:
+//		Work item for Set PowerSaving Mode.
+//
+//	Assumption:
+//		Since it is callback function of SetPSModeWorkItem,
+//		it should be in PASSIVE level.
+//
+//-----------------------------------------------------------------------------
+void
+SetPSModeWorkItemCallback(
+	IN NDIS_WORK_ITEM*	pWorkItem,
+	IN PVOID			Context
+	)
+{
+	_adapter			*padapter = (_adapter *)Context;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_info_,("SetPSModeWorkItemCallback: Power Mode is :%d\n", pwrpriv->pwr_mode));
+
+	_enter_pwrlock(&pwrpriv->lock);
+
+	if(pwrpriv->bSleep)
+	{
+		if(!setpwrmode_cmd(padapter,  pwrpriv->pwr_mode, pwrpriv->smart_ps)) {
+			RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Can't invoke FW to change its power settings.\n"));
+		}
+
+		//set_rpwm(padapter, PS_STATE_S2);
+		//set_rpwm(padapter, PS_STATE_S0);
+	}
+	else
+	{
+		if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			set_rpwm(padapter, PS_STATE_S4);
+
+		if(!setpwrmode_cmd(padapter,  pwrpriv->pwr_mode, pwrpriv->smart_ps)) {
+			RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Can't invoke FW to change its power settings.\n"));
+		}
+	}
+
+	_exit_pwrlock(&pwrpriv->lock);
+
+_func_exit_;	
+
+}
+#endif
+
+#ifdef PLATFORM_LINUX
+void
+SetPSModeWorkItemCallback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work, struct pwrctrl_priv, SetPSModeWorkItem);
+	_adapter *padapter = container_of(pwrpriv, _adapter, pwrctrlpriv);
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_info_,("SetPSModeWorkItemCallback: Power Mode is :%d\n", pwrpriv->pwr_mode));
+
+	_enter_pwrlock(&pwrpriv->lock);
+
+	if(pwrpriv->bSleep)
+	{
+		if(!setpwrmode_cmd(padapter,  pwrpriv->pwr_mode, pwrpriv->smart_ps)) {
+			RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Can't invoke FW to change its power settings.\n"));
+		}
+
+		//set_rpwm(padapter, PS_STATE_S2);
+		//set_rpwm(padapter, PS_STATE_S0);
+	}
+	else
+	{
+		if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			set_rpwm(padapter, PS_STATE_S4);
+
+		if(!setpwrmode_cmd(padapter,  pwrpriv->pwr_mode, pwrpriv->smart_ps)) {
+			RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Can't invoke FW to change its power settings.\n"));
+		}
+	}
+
+	_exit_pwrlock(&pwrpriv->lock);
+
+_func_exit_;	
+
+}
+void
+rpwm_workitem_callback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work, struct pwrctrl_priv, rpwm_workitem);
+	_adapter *padapter = container_of(pwrpriv, _adapter, pwrctrlpriv);
+
+	u8 cpwm=pwrpriv->cpwm;
+	struct reportpwrstate_parm reportpwrstate;
+_func_enter_;	
+//	msleep_os(10);
+	_enter_pwrlock(&pwrpriv->lock);
+	if(pwrpriv->cpwm !=pwrpriv->rpwm){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback: set RPWM(0x%x) again[cpwm=0x%x]!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+		cpwm=read8(padapter, SDIO_HCPWM);
+/*		if(cpwm>1 && (cpwm!=pwrpriv->cpwm)){
+			reportpwrstate.state=cpwm;	
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback:RPWM(0x%x) [cpwm=0x%x]  call cpwm_hdl!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+			
+			cpwm_hdl(padapter);
+		}
+		else if(pwrpriv->cpwm !=pwrpriv->rpwm)
+*/
+		{
+			
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback:RPWM(0x%x) [cpwm=0x%x]  SET RPWM again!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+			pwrpriv->rpwm_retry=1;
+			set_rpwm(padapter, pwrpriv->rpwm);
+		}
+	}
+	else{
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rpwm_workitem_callback: RPWM(0x%x)  [cpwm=0x%x]!!!!\n",pwrpriv->rpwm,pwrpriv->cpwm));
+	}
+	_exit_pwrlock(&pwrpriv->lock);
+_func_exit_;	
+}
+void rpwm_check_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	_rpwm_check_handler(adapter);
+}
+
+#endif
+
+#endif
+
+
+void	init_pwrctrl_priv(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+
+#ifdef PLATFORM_WINDOWS
+	_spinlock_init(&(pwrctrlpriv->pnp_pwr_mgnt_lock));
+	pwrctrlpriv->pnp_wwirp_pending=_FALSE;
+
+	pwrctrlpriv->pnp_current_pwr_state=NdisDeviceStateD0;
+
+	#ifdef CONFIG_USB_HCI
+	NdisInitializeEvent( &(pwrctrlpriv->pnp_wwirp_complete_evt));
+	pwrctrlpriv->pnp_wwirp=NULL;
+	#endif
+
+#endif
+
+	_init_pwrlock(&pwrctrlpriv->lock);
+
+	pwrctrlpriv->cpwm = PS_STATE_S4;
+
+	pwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;
+
+	pwrctrlpriv->smart_ps = 0;
+
+	pwrctrlpriv->tog = 0x80;
+
+#ifdef CONFIG_PWRCTRL
+
+// clear RPWM to ensure driver and fw back to initial state.
+#ifdef CONFIG_SDIO_HCI
+	write8(padapter, SDIO_HRPWM, 0);
+#else
+	write8(padapter, 0x1025FE58, 0);
+#endif
+
+	_init_workitem(&(pwrctrlpriv->SetPSModeWorkItem), SetPSModeWorkItemCallback, padapter);
+	_init_workitem(&(pwrctrlpriv->rpwm_workitem), rpwm_workitem_callback, padapter);
+#ifdef PLATFORM_WINDOWS
+	_init_timer(&(pwrctrlpriv->rpwm_check_timer), padapter->hndis_adapter, rpwm_check_handler, (u8 *)padapter);
+#endif
+#ifdef PLATFORM_LINUX
+	_init_timer(&(pwrctrlpriv->rpwm_check_timer), padapter->pnetdev, rpwm_check_handler, (u8 *)padapter);
+
+#endif
+#endif
+
+_func_exit_;
+
+}
+
+
+void	free_pwrctrl_priv(_adapter *adapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &adapter->pwrctrlpriv;
+
+_func_enter_;
+
+#ifdef CONFIG_PWRCTRL
+	_cancel_timer_ex(&(pwrctrlpriv->rpwm_check_timer));
+#endif
+	_memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+
+	_free_pwrlock(&pwrctrlpriv->lock);
+
+	_spinlock_free(&pwrctrlpriv->pnp_pwr_mgnt_lock);
+
+_func_exit_;
+}
+
+
+/*
+Caller: xmit_thread
+
+Check if the fw_pwrstate is okay for xmit.
+If not (cpwm is less than P1 state), then the sub-routine
+will raise the cpwm to be greater than or equal to P1. 
+
+Calling Context: Passive
+
+Return Value:
+
+_SUCCESS: xmit_thread can write fifo/txcmd afterwards.
+_FAIL: xmit_thread can not do anything.
+*/
+sint register_tx_alive(_adapter *padapter)
+{
+	uint res = _SUCCESS;
+	
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, XMIT_ALIVE);
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("register_tx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	if(pwrctrl->cpwm < PS_STATE_S2){
+		set_rpwm(padapter, PS_STATE_S3);
+		res = _FAIL;
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+	
+_func_exit_;
+
+#endif	/* CONFIG_PWRCTRL */
+
+	return res;	
+
+}
+
+/*
+Caller: cmd_thread
+
+Check if the fw_pwrstate is okay for issuing cmd.
+If not (cpwm should be is less than P2 state), then the sub-routine
+will raise the cpwm to be greater than or equal to P2. 
+
+Calling Context: Passive
+
+Return Value:
+
+_SUCCESS: cmd_thread can issue cmds to firmware afterwards.
+_FAIL: cmd_thread can not do anything.
+*/
+sint register_cmd_alive(_adapter *padapter)
+{
+	uint res = _SUCCESS;
+	
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, CMD_ALIVE);
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("register_cmd_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	if(pwrctrl->cpwm < PS_STATE_S2){
+		set_rpwm(padapter, PS_STATE_S3);
+		res = _FAIL;
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+_func_exit_;
+#endif
+
+	return res;
+}
+
+
+/*
+Caller: rx_isr
+
+Calling Context: Dispatch/ISR
+
+Return Value:
+
+*/
+sint register_rx_alive(_adapter *padapter)
+{
+
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, RECV_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("register_rx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+	
+#endif /*CONFIG_PWRCTRL*/
+
+	return _SUCCESS;
+}
+
+
+/*
+Caller: evt_isr or evt_thread
+
+Calling Context: Dispatch/ISR or Passive
+
+Return Value:
+*/
+sint register_evt_alive(_adapter *padapter)
+{
+
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, EVT_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_info_,("register_evt_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+
+	return _SUCCESS;
+}
+
+
+/*
+Caller: ISR
+
+If ISR's txdone,
+No more pkts for TX,
+Then driver shall call this fun. to power down firmware again.
+*/
+
+void unregister_tx_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, XMIT_ALIVE);
+
+	if((pwrctrl->cpwm > PS_STATE_S2) && (pwrctrl->pwr_mode > PS_MODE_ACTIVE)){
+		if(pwrctrl->alives == 0){
+			set_rpwm(padapter, PS_STATE_S0);
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("unregister_tx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+	
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+}
+
+/*
+Caller: ISR
+
+If ISR's txdone,
+No more pkts for TX,
+Then driver shall call this fun. to power down firmware again.
+*/
+
+void unregister_cmd_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, CMD_ALIVE);
+
+	if((pwrctrl->cpwm > PS_STATE_S2) && (pwrctrl->pwr_mode > PS_MODE_ACTIVE)){
+		if((pwrctrl->alives == 0)&&(check_fwstate(&padapter->mlmepriv, _FW_UNDER_LINKING)!=_TRUE)){
+			set_rpwm(padapter, PS_STATE_S0);
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("unregister_cmd_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+}
+
+
+/*
+
+Caller: ISR
+
+*/
+void unregister_rx_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, RECV_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("unregister_rx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+	
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif
+}
+
+
+void unregister_evt_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, EVT_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("unregister_evt_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+	
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+}
+
+
+
diff --git a/drivers/net/wireless/8712u/recv/rtl8712_recv.c b/drivers/net/wireless/8712u/recv/rtl8712_recv.c
new file mode 100755
index 0000000..b17a630
--- /dev/null
+++ b/drivers/net/wireless/8712u/recv/rtl8712_recv.c
@@ -0,0 +1,2638 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL8712_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <mlme_osdep.h>
+#include <ip.h>
+#include <if_ether.h>
+#include <ethernet.h>
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#include <wifi.h>
+#include <circ_buf.h>
+
+extern u8* g_pallocated_recv_buf;
+
+int	init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	//struct recv_reorder_ctrl *preorder_ctrl;
+	int	res=_SUCCESS;
+
+	
+	_init_sema(&precvpriv->recv_sema, 0);//will be removed
+	_init_sema(&precvpriv->terminate_recvthread_sema, 0);//will be removed
+	
+      //init recv_buf
+      _init_queue(&precvpriv->free_recv_buf_queue);	  
+
+
+      precvpriv->pallocated_recv_buf = g_pallocated_recv_buf;
+      if(precvpriv->pallocated_recv_buf==NULL){
+		res= _FAIL;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("alloc recv_buf fail!\n"));
+		goto exit;
+      }
+      _memset(precvpriv->pallocated_recv_buf, 0, NR_RECVBUFF *sizeof(struct recv_buf) + 4);
+
+      precvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -
+							((uint) (precvpriv->pallocated_recv_buf) &(4-1));
+
+
+      precvbuf = (struct recv_buf*)precvpriv->precv_buf;
+
+      for(i=0; i < NR_RECVBUFF ; i++)
+     {
+	    _init_listhead(&precvbuf->list);
+
+	     _spinlock_init(&precvbuf->recvbuf_lock);	     
+	     
+	     res = os_recvbuf_resource_alloc(padapter, precvbuf);		 
+	     if(res==_FAIL)
+		 	break;
+		 
+	     precvbuf->ref_cnt = 0;
+	     precvbuf->adapter =padapter;
+  
+
+	     list_insert_tail(&precvbuf->list, &(precvpriv->free_recv_buf_queue.queue));	 
+  
+	     precvbuf++;
+		 
+	}
+#ifdef CONFIG_SDIO_HCI
+	
+	precvpriv->recvbuf_drop= (struct recv_buf*)_malloc(sizeof(struct recv_buf));
+#ifdef PLATFORM_LINUX
+	((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf = _malloc(MAX_RECVBUF_SZ+4);
+        if(((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf == NULL){
+                res = _FAIL;
+        }
+
+        ((struct recv_buf *)precvpriv->recvbuf_drop)->pbuf=((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf + 4 -  ((uint) (((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf) &(4-1));
+
+        ((struct recv_buf *)precvpriv->recvbuf_drop)->pdata = ((struct recv_buf *)precvpriv->recvbuf_drop)->phead = ((struct recv_buf *)precvpriv->recvbuf_drop)->ptail =((struct recv_buf *)precvpriv->recvbuf_drop)->pbuf;
+
+        ((struct recv_buf *)precvpriv->recvbuf_drop)->pend = ((struct recv_buf *)precvpriv->recvbuf_drop)->pdata + MAX_RECVBUF_SZ;
+
+        ((struct recv_buf *)precvpriv->recvbuf_drop)->len = 0;
+
+#else
+		os_recvbuf_resource_alloc(padapter, precvpriv->recvbuf_drop);	
+#endif
+#endif	
+
+	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
+	
+#if 0 //move to sta_info when alloc sta_info
+	//for A-MPDU Rx reordering buffer control
+	for(i=0; i < 16 ; i++)
+	{
+		preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+
+		preorder_ctrl->padapter = padapter;
+		
+		preorder_ctrl->indicate_seq = 0xffff;
+		preorder_ctrl->wend_b= 0xffff;       
+		//preorder_ctrl->wsize_b = (NR_RECVBUFF-2);
+		preorder_ctrl->wsize_b = 16;//64;
+
+		_init_queue(&preorder_ctrl->pending_recvframe_queue);
+
+		init_recv_timer(preorder_ctrl);
+	}
+#endif
+
+#ifdef PLATFORM_LINUX
+//#if defined (CONFIG_USB_HCI) && defined(PLATFORM_LINUX)
+
+#ifdef CONFIG_RECV_TASKLET
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))recv_tasklet,
+	     (unsigned long)padapter);
+#else
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))recv_bh,
+	     (unsigned long)padapter);
+#endif
+
+	skb_queue_head_init(&precvpriv->rx_skb_queue);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+	{
+		int i;
+		u32 tmpaddr=0;
+		int alignment=0;
+		struct sk_buff *pskb=NULL;		
+			
+		skb_queue_head_init(&precvpriv->free_recv_skb_queue);
+
+		for(i=0; i<NR_PREALLOC_RECV_SKB; i++)
+		{
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+			pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);			
+	#else			
+			pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);	
+	#endif
+
+			if(pskb)
+			{
+				pskb->dev = padapter->pnetdev;
+
+				tmpaddr = (u32)pskb->data;
+	        		alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+				skb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));		
+				
+				skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+			}
+
+			pskb=NULL;
+			
+		}
+		
+	}
+#endif
+
+#endif
+	
+exit:
+	
+	return res;	
+	
+}
+
+void free_recv_priv (struct recv_priv *precvpriv)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	_adapter *padapter = precvpriv->adapter;
+
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+
+	for(i=0; i < NR_RECVBUFF ; i++)
+	{ 
+		os_recvbuf_resource_free(padapter, precvbuf);
+		precvbuf++;	
+	}	
+		
+	if(precvpriv->pallocated_recv_buf)
+		precvpriv->pallocated_recv_buf = NULL;
+
+
+#ifdef PLATFORM_LINUX
+
+	if (skb_queue_len(&precvpriv->rx_skb_queue)) {
+		printk(KERN_WARNING "rx_skb_queue not empty\n");
+	}
+
+	skb_queue_purge(&precvpriv->rx_skb_queue);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+
+	if (skb_queue_len(&precvpriv->free_recv_skb_queue)) {
+		printk(KERN_WARNING "free_recv_skb_queue not empty, %d\n", skb_queue_len(&precvpriv->free_recv_skb_queue));
+	}
+
+	skb_queue_purge(&precvpriv->free_recv_skb_queue);
+
+#endif
+	
+#endif	
+
+}
+
+int init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+#ifdef CONFIG_USB_HCI
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+
+	precvbuf->ref_cnt = 0;
+	
+#endif //#ifdef CONFIG_USB_HCI
+	if(precvbuf->pbuf)
+	{
+		precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pbuf;
+		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
+	}	
+
+	return res;
+	
+}
+
+void init_recvframe(union recv_frame *precvframe, struct recv_priv *precvpriv)
+{		
+	struct recv_buf *precvbuf = precvframe->u.hdr.precvbuf;
+	
+	/* Perry: This can be removed */
+	_init_listhead(&precvframe->u.hdr.list);
+
+	precvframe->u.hdr.len=0;
+	
+#ifdef PLATFORM_LINUX
+
+	if(precvbuf)
+	{		
+		if(precvbuf->pskb)
+		{
+			precvframe->u.hdr.pkt = skb_clone(precvbuf->pskb, GFP_ATOMIC);			
+		}	
+	}
+	
+#endif	     
+
+}
+
+int free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue)
+{
+	_irqL irqL;
+	_adapter *padapter=precvframe->u.hdr.adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	
+_func_enter_;
+
+	
+#ifdef PLATFORM_WINDOWS
+	os_read_port(padapter, precvframe->u.hdr.precvbuf);
+#endif
+
+#ifdef PLATFORM_LINUX
+
+	if(precvframe->u.hdr.pkt)
+	{
+		dev_kfree_skb_any(precvframe->u.hdr.pkt);//free skb by driver
+		precvframe->u.hdr.pkt = NULL;
+	}	
+
+#ifdef CONFIG_SDIO_HCI
+{
+_irqL irql;
+struct recv_buf *precvbuf=precvframe->u.hdr.precvbuf;
+	if(precvbuf !=NULL){
+        _enter_critical_ex(&precvbuf->recvbuf_lock, &irql);
+
+        precvbuf->ref_cnt--;
+	 if(precvbuf->ref_cnt == 0 ){
+                _enter_critical(&precvpriv->free_recv_buf_queue.lock, &irqL);
+                list_delete(&(precvbuf->list));
+                list_insert_tail(&(precvbuf->list), get_list_head(&precvpriv->free_recv_buf_queue));
+                precvpriv->free_recv_buf_queue_cnt++;
+                _exit_critical(&precvpriv->free_recv_buf_queue.lock, &irqL);
+                RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("os_read_port: precvbuf=0x%p enqueue:precvpriv->free_recv_buf_queue_cnt=%d\n",precvbuf,precvpriv->free_recv_buf_queue_cnt));
+        }
+                RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("os_read_port: precvbuf=0x%p enqueue:precvpriv->free_recv_buf_queue_cnt=%d\n",precvbuf,precvpriv->free_recv_buf_queue_cnt));
+ _exit_critical_ex(&precvbuf->recvbuf_lock, &irql);
+	}
+}
+#endif
+#endif
+
+	_enter_critical(&pfree_recv_queue->lock, &irqL);
+	//_spinlock_ex(&pfree_recv_queue->lock);
+	
+	list_delete(&(precvframe->u.hdr.list));	
+	
+	list_insert_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));
+
+	if(padapter !=NULL){			
+		if(pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt++;
+	}
+	
+      //_spinunlock_ex(&pfree_recv_queue->lock);
+      _exit_critical(&pfree_recv_queue->lock, &irqL);
+	
+_func_exit_;	
+
+	return _SUCCESS;
+	
+}
+
+void update_recvframe_attrib_from_recvstat(struct rx_pkt_attrib *pattrib, struct recv_stat *prxstat)
+{
+	u32 *pphy_info;
+	struct phy_stat *pphy_stat;
+	u16 drvinfo_sz=0;
+	drvinfo_sz = (le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16;
+	drvinfo_sz = drvinfo_sz<<3;
+
+	//TODO:	
+	//Offset 0
+	pattrib->bdecrypted = ((le32_to_cpu(prxstat->rxdw0) & BIT(27)) >> 27)? 0:1;
+
+#ifdef CONFIG_MP_INCLUDED 	
+	pattrib->crc_err = ((le32_to_cpu(prxstat->rxdw0) & BIT(14)) >> 14 );
+#endif
+
+	//Offset 4
+
+
+	//Offset 8
+	
+
+	//Offset 12
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	if ( le32_to_cpu(prxstat->rxdw3) & BIT(13)) {
+		pattrib->tcpchk_valid = 1; // valid
+		if ( le32_to_cpu(prxstat->rxdw3) & BIT(11) ) {
+			pattrib->tcp_chkrpt = 1; // correct
+			//printk("tcp csum ok\n");
+		} else
+			pattrib->tcp_chkrpt = 0; // incorrect
+
+		if ( le32_to_cpu(prxstat->rxdw3) & BIT(12) )
+			pattrib->ip_chkrpt = 1; // correct
+		else
+			pattrib->ip_chkrpt = 0; // incorrect
+
+	} else {
+		pattrib->tcpchk_valid = 0; // invalid
+	}	
+
+#endif
+	pattrib->mcs_rate=(u8)(( le32_to_cpu(prxstat->rxdw3))&0x3f);
+	pattrib->htc=(u8) ( ( le32_to_cpu(prxstat->rxdw3) >>14)&0x1);
+	//Offset 16
+
+
+	//Offset 20
+	
+	
+	//phy_info
+	if(drvinfo_sz)
+	{
+		pphy_stat =(struct phy_stat *)(prxstat+1);
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n prxstat=%p  pphy_stat=%p \n",prxstat,pphy_stat));
+		pphy_info=(u32 *)prxstat+1;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n prxstat=%p  pphy_info=%p \n",prxstat,pphy_info));
+		//printk("pphy_info, of0=0x%08x\n", *pphy_info);
+		//printk("pphy_info, of1=0x%08x\n", *(pphy_info+1));
+		//printk("pphy_info, of2=0x%08x\n", *(pphy_info+2));
+		//printk("pphy_info, of3=0x%08x\n", *(pphy_info+3));		
+		//printk("pphy_info, of4=0x%08x\n", *(pphy_info+4));
+		//printk("pphy_info, of5=0x%08x\n", *(pphy_info+5));
+		//printk("pphy_info, of6=0x%08x\n", *(pphy_info+6));
+		//printk("pphy_info, of7=0x%08x\n", *(pphy_info+7));		
+
+	}
+	
+	
+}
+
+//perform defrag
+union recv_frame * recvframe_defrag(_adapter *adapter,_queue *defrag_q)
+{
+	_list	 *plist, *phead;	
+	u8	*data,wlanhdr_offset;
+	u8   curfragnum;
+	struct recv_frame_hdr *pfhdr,*pnfhdr;
+	union recv_frame* prframe, *pnextrframe;
+	_queue	*pfree_recv_queue;
+
+_func_enter_;		
+
+	curfragnum=0;
+	pfree_recv_queue=&adapter->recvpriv.free_recv_queue;
+
+	phead = get_list_head(defrag_q);			
+	plist = get_next(phead);	
+	prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+	pfhdr=&prframe->u.hdr;
+	list_delete(&(prframe->u.list));
+
+	if(curfragnum!=pfhdr->attrib.frag_num)
+	{
+		//the first fragment number must be 0
+		//free the whole queue
+		free_recvframe(prframe, pfree_recv_queue);
+		free_recvframe_queue(defrag_q, pfree_recv_queue); 
+		
+		return NULL;
+	}
+	
+	curfragnum++;
+	
+	plist= get_list_head(defrag_q);
+
+	plist = get_next(plist);
+
+	data=get_recvframe_data(prframe);
+
+	while(end_of_queue_search(phead, plist) == _FALSE)
+	{			
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame , u);
+		pnfhdr=&pnextrframe->u.hdr;
+
+		
+		//check the fragment sequence  (2nd ~n fragment frame)
+		
+		if(curfragnum!=pnfhdr->attrib.frag_num)
+		{
+			//the fragment number must be increasing  (after decache) 
+			//release the defrag_q & prframe
+			free_recvframe(prframe, pfree_recv_queue);  
+			free_recvframe_queue(defrag_q, pfree_recv_queue);  
+			return NULL;
+		}
+		
+		curfragnum++;
+
+		//copy the 2nd~n fragment frame's payload to the first fragment		
+		//get the 2nd~last fragment frame's payload
+		
+		wlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;
+
+		recvframe_pull(pnextrframe, wlanhdr_offset);
+			
+		//append  to first fragment frame's tail (if privacy frame, pull the ICV)
+		recvframe_pull_tail(prframe, pfhdr->attrib.icv_len);
+
+		//memcpy
+		_memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
+		
+		recvframe_put(prframe, pnfhdr->len);
+		
+		pfhdr->attrib.icv_len=pnfhdr->attrib.icv_len;
+		plist = get_next(plist);
+				
+	};
+
+	//free the defrag_q queue and return the prframe
+	free_recvframe_queue(defrag_q, pfree_recv_queue);  
+	
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Performance defrag!!!!!\n"));
+	
+_func_exit_;	
+
+	return prframe;
+
+}  
+
+//check if need to defrag, if needed queue the frame to defrag_q
+union recv_frame * recvframe_chk_defrag(_adapter *padapter,union recv_frame* precv_frame)
+{
+	u8	ismfrag;
+	u8	fragnum;
+	u8   *psta_addr;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info * psta;
+	struct	sta_priv *pstapriv ;
+	_list	 *phead;
+	union recv_frame* prtnframe=NULL;
+	_queue *pfree_recv_queue, *pdefrag_q;
+
+_func_enter_;		
+
+	pstapriv = &padapter->stapriv;
+
+	pfhdr=&precv_frame->u.hdr;
+	
+	pfree_recv_queue=&padapter->recvpriv.free_recv_queue;
+
+	//need to define struct of wlan header frame ctrl
+	ismfrag= pfhdr->attrib.mfrag;
+	fragnum=pfhdr->attrib.frag_num;
+	
+	psta_addr=pfhdr->attrib.ta;
+	psta=get_stainfo(pstapriv, psta_addr);
+	if(psta==NULL)
+		pdefrag_q=NULL;
+	else	
+		pdefrag_q=&psta->sta_recvpriv.defrag_q;
+
+	if((ismfrag==0)&&(fragnum==0))
+	{
+		prtnframe = precv_frame;//isn't a fragment frame
+	}	
+	
+	if(ismfrag==1)
+	{
+		//0~(n-1) fragment frame
+		//enqueue to defraf_g
+	  	if(pdefrag_q != NULL)
+		{		
+			if(fragnum==0)
+			{
+				//the first fragment				
+				if(_queue_empty(pdefrag_q) == _FALSE)
+				{
+					//free current defrag_q
+					free_recvframe_queue(pdefrag_q, pfree_recv_queue);	
+				}	
+			}
+
+			
+			//Then enqueue the 0~(n-1) fragment into the defrag_q
+			
+			//_spinlock(&pdefrag_q->lock);
+			phead = get_list_head(pdefrag_q);
+			list_insert_tail(&pfhdr->list, phead);			
+			//_spinunlock(&pdefrag_q->lock);
+			
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Enqueuq: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
+			
+			prtnframe=NULL;
+			
+		}
+		else
+		{
+			//can't find this ta's defrag_queue, so free this recv_frame 
+			free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe=NULL;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag, fragnum));
+		}
+		
+	} 
+	
+	if((ismfrag==0)&&(fragnum!=0))
+	{
+		//the last fragment frame
+		//enqueue the last fragment
+		if(pdefrag_q != NULL)
+		{
+			//_spinlock(&pdefrag_q->lock);
+			phead = get_list_head(pdefrag_q);
+			list_insert_tail(&pfhdr->list,phead);
+			//_spinunlock(&pdefrag_q->lock);			
+		
+			//call recvframe_defrag to defrag
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("defrag: ismfrag = %d, fragnum= %d\n", ismfrag, fragnum));
+			precv_frame = recvframe_defrag(padapter, pdefrag_q);
+			prtnframe=precv_frame;
+		
+		}
+		else
+		{
+			//can't find this ta's defrag_queue, so free this recv_frame 
+			free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe=NULL;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
+		}
+		
+	}
+
+	
+	if((prtnframe!=NULL)&&(prtnframe->u.hdr.attrib.privacy))
+	{
+		//after defrag we must check tkip mic code 
+		if(recvframe_chkmic(padapter,  prtnframe)==_FAIL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\nrecvframe_chkmic(padapter,  prtnframe)==_FAIL \n"));
+			free_recvframe(prtnframe,pfree_recv_queue);
+			prtnframe=NULL;
+		}
+	}
+	
+_func_exit_;		
+
+	return prtnframe;
+	
+}
+
+int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
+{
+#ifdef CONFIG_USB_HCI
+	_irqL	irql;	
+	uint pkt_offset;
+	u32 transfer_len;
+	u16 drvinfo_sz;
+#endif
+	u8 *pbuf;
+	u8 bsumbit = _FALSE;
+	uint pkt_len ;
+	struct recv_stat *prxstat;	
+	u16 pkt_cnt;
+	_queue *pfree_recv_queue;
+#ifdef CONFIG_SKB_COPY  //compile flag for linux only
+	_pkt  *pkt_copy=NULL;
+#endif
+	union recv_frame *precvframe=NULL; 
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct intf_hdl * pintfhdl=&padapter->pio_queue->intf;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+recvbuf2recvframe()\n"));
+	
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	
+	pbuf = (u8*)precvbuf->pbuf;	
+	
+	prxstat = (struct recv_stat *)pbuf;	
+	
+	//pkt_cnt = le16_to_cpu((prxstat->rxdw2>>16)&0x3ffff);
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16)&0x3ffff;
+	
+	//pkt_len = le32_to_cpu(prxstat->rxdw0&0x00003fff); //pkt_len = prxstat->frame_length;	
+	pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+	
+#ifdef CONFIG_USB_HCI
+
+	transfer_len = precvbuf->transfer_len;
+
+#if 0 //temp remove when disable usb rx aggregation
+	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
+	{		
+		return _FAIL;
+	}
+#endif
+
+	precvbuf->ref_cnt++;
+	do{		
+
+		prxstat = (struct recv_stat *)pbuf;		      
+	       //pkt_len = le32_to_cpu(prxstat->rxdw0&0x00003fff); //pkt_len = prxstat->frame_length;	
+	       pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("rxdesc : offsset0:0x%08x, offsset4:0x%08x, offsset8:0x%08x, offssetc:0x%08x\n", 
+			prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
+	
+		//drvinfo_sz = le16_to_cpu((prxstat->rxdw0&0x000f0000)>>16);//uint 2^3 = 8 bytes
+		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16;
+		drvinfo_sz = drvinfo_sz<<3;
+
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("DRV_INFO_SIZE=%d\n", drvinfo_sz));
+
+		if(pkt_len<=0)
+		{
+			//KeBugCheckEx(0x87120044, 0xe0, 0x4c, 0x87, 0x44);	
+	
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), pkt_len<=0\n"));
+		
+			goto  _exit_recvbuf2recvframe;
+		}		
+
+		   
+
+		precvframe = alloc_recvframe(pfree_recv_queue);
+		if(precvframe==NULL)
+		{
+			//KeBugCheckEx(0x87120055, 0xe0, 0x4c, 0x87, 0x55);	
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe(), precvframe==NULL\n"));
+			
+			goto  _exit_recvbuf2recvframe;
+		}
+
+		precvframe->u.hdr.precvbuf = precvbuf;
+	
+		//pkt_offset = (u16)_RND512(pkt_len + drvinfo_sz + RXDESC_SIZE);
+		//pkt_offset = (u16)_RND256(pkt_len + drvinfo_sz + RXDESC_SIZE);
+		pkt_offset = (u16)_RND128(pkt_len + drvinfo_sz + RXDESC_SIZE);//TODO: need to check init. setting.
+		
+#ifdef CONFIG_SKB_COPY  //compile flag for linux only		
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+		pkt_copy = dev_alloc_skb(pkt_offset>1600?pkt_offset:1600);
+		pkt_copy->dev = padapter->pnetdev;
+	#else			
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, pkt_offset>1600?pkt_offset:1600);
+	#endif		
+		if(pkt_copy==NULL)
+		{
+			//printk("recvbuf2recvframe:can not allocate memory for skb copy\n");
+			init_recvframe(precvframe, precvpriv); 
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
+			precvframe->u.hdr.rx_end = precvbuf->pend;
+			goto _cont;	
+		}
+
+		_init_listhead(&precvframe->u.hdr.list);
+		precvframe->u.hdr.len=0;
+		precvframe->u.hdr.pkt = pkt_copy;		
+
+		_memcpy(pkt_copy->data, pbuf, pkt_offset);			
+
+		precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
+
+		precvframe->u.hdr.rx_end = pkt_copy->data + (pkt_offset>1600?pkt_offset:1600);
+#else
+		init_recvframe(precvframe, precvpriv); 
+		precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
+		precvframe->u.hdr.rx_end = precvbuf->pend;
+
+#endif
+
+#ifdef CONFIG_SKB_COPY  //compile flag for linux only
+_cont:
+#endif
+
+              recvframe_put(precvframe, pkt_len + drvinfo_sz + RXDESC_SIZE);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);	
+
+#ifdef PLATFORM_WINDOWS
+		_enter_critical_ex(&precvbuf->recvbuf_lock, &irql);
+		precvbuf->ref_cnt++;
+		_exit_critical_ex(&precvbuf->recvbuf_lock, &irql);
+#endif
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), transfer_len=%d, pkt_offset=%d, pkt_len=%d, ref_cnt=%d, precvbuf=0x%x\n",
+				transfer_len, pkt_offset, pkt_len, precvbuf->ref_cnt, precvbuf));
+
+
+		//because the endian issue, driver avoid reference to the rxstat after calling update_recvframe_attrib_from_recvstat();
+		update_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib, prxstat);		
+						
+		if( recv_entry(precvframe) != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), recv_entry(precvframe) != _SUCCESS\n"));			
+		}
+
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;
+		pkt_cnt--;
+		precvframe = NULL;
+
+	}while((transfer_len>0) && (pkt_cnt>0));
+		
+	
+_exit_recvbuf2recvframe:
+
+	os_read_port(padapter, precvbuf);
+	
+#endif //#ifdef CONFIG_USB_HCI	
+
+
+	return _SUCCESS;
+	
+}
+
+#ifdef PLATFORM_LINUX
+int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
+{
+	int	a_len, padding_len;
+	u16	eth_type, nSubframe_Length;	
+	u8	nr_subframes, i;
+	unsigned char *data_ptr, *pdata;
+	struct rx_pkt_attrib *pattrib;
+	_pkt *sub_skb,*subframes[MAX_SUBFRAME_COUNT];
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int	ret = _SUCCESS;
+
+	nr_subframes = 0;
+
+	pattrib = &prframe->u.hdr.attrib;
+
+	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
+	
+	if(prframe->u.hdr.attrib.iv_len >0)
+	{
+		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
+	}
+
+	a_len = prframe->u.hdr.len;
+
+	pdata = prframe->u.hdr.rx_data;
+
+	while(a_len > ETH_HLEN) {
+		
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = *((u16*)(pdata + 12));
+		//==m==>change the length order
+		nSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);
+
+		if( a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length) ) {
+			printk("nRemain_Length is %d and nSubframe_Length is : %d\n",a_len,nSubframe_Length);
+			goto exit;
+		}
+
+		/* move the data point to data content */
+		pdata += ETH_HLEN;
+		a_len -= ETH_HLEN;
+
+		/* Allocate new skb for releasing to upper layer */
+#ifdef CONFIG_SKB_COPY
+		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+		_memcpy(data_ptr, pdata, nSubframe_Length);
+#else
+		sub_skb = skb_clone(prframe->u.hdr.pkt, GFP_ATOMIC);
+		sub_skb->data = pdata;
+		sub_skb->len = nSubframe_Length;
+		sub_skb->tail = sub_skb->data + nSubframe_Length;
+#endif
+
+		//sub_skb->dev = padapter->pnetdev;
+		subframes[nr_subframes++] = sub_skb;
+		if(nr_subframes >= MAX_SUBFRAME_COUNT) {
+			printk("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+			break;
+		}
+
+		pdata += nSubframe_Length;
+		a_len -= nSubframe_Length;
+		if(a_len != 0) {
+			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & (4-1));
+			if(padding_len == 4) {
+				padding_len = 0;
+			}
+
+			if(a_len < padding_len) {
+				goto exit;
+			}
+			pdata += padding_len;
+			a_len -= padding_len;
+		}
+	}
+
+	for(i=0; i<nr_subframes; i++){
+		sub_skb = subframes[i];
+		/* convert hdr + possible LLC headers into Ethernet header */
+		eth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];
+		if (sub_skb->len >= 8 &&
+			((_memcmp(sub_skb->data, rtw_rfc1042_header, SNAP_SIZE) &&
+			  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+			 _memcmp(sub_skb->data, rtw_bridge_tunnel_header, SNAP_SIZE) )) {
+			/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+			skb_pull(sub_skb, SNAP_SIZE);
+			_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+			_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+		} else {
+			u16 len;
+			/* Leave Ethernet header part of hdr and full payload */
+			len = htons(sub_skb->len);
+			_memcpy(skb_push(sub_skb, 2), &len, 2);
+			_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+			_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+		}
+
+		/* Indicat the packets to upper layer */
+		if (sub_skb) {
+			//memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
+
+			sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
+			sub_skb->dev = padapter->pnetdev;
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+			if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+			} else {
+				sub_skb->ip_summed = CHECKSUM_NONE;
+			}
+#else /* !CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX */
+			sub_skb->ip_summed = CHECKSUM_NONE;
+#endif
+
+			netif_rx(sub_skb);
+		}
+	}
+
+exit:
+
+	prframe->u.hdr.len=0;
+	free_recvframe(prframe, pfree_recv_queue);//free this recv_frame
+	
+	return ret;
+
+}
+
+#else
+
+int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
+{
+	_irqL irql;
+	unsigned char *ptr, *pdata, *pbuf, *psnap_type;	
+	union recv_frame *pnrframe, *pnrframe_new;
+	int a_len, mv_len, padding_len;
+	u16 eth_type, type_len;	
+	u8 bsnaphdr;	
+	struct ieee80211_snap_hdr	*psnap;		
+	struct _vlan *pvlan;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int ret = _SUCCESS;	
+#ifdef PLATFORM_WINDOWS
+	struct recv_buf *precvbuf = prframe->u.hdr.precvbuf;
+#endif
+	a_len = prframe->u.hdr.len - prframe->u.hdr.attrib.hdrlen;	
+
+	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
+	
+	if(prframe->u.hdr.attrib.iv_len >0)
+	{
+		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
+	}
+
+	pdata = prframe->u.hdr.rx_data;
+
+	prframe->u.hdr.len=0;	
+
+	pnrframe = prframe;
+
+	
+	do{
+
+		mv_len=0;
+		pnrframe->u.hdr.rx_data = pnrframe->u.hdr.rx_tail = pdata;		
+		ptr = pdata;
+	
+		
+		_memcpy(pnrframe->u.hdr.attrib.dst, ptr, ETH_ALEN);
+		ptr+=ETH_ALEN;
+		_memcpy(pnrframe->u.hdr.attrib.src, ptr, ETH_ALEN);
+		ptr+=ETH_ALEN;
+		
+		_memcpy(&type_len, ptr, 2);
+		type_len= ntohs((unsigned short )type_len); 
+		ptr +=2;
+		mv_len += ETH_HLEN;
+	
+		recvframe_put(pnrframe, type_len+ETH_HLEN);//update tail;
+
+		if(pnrframe->u.hdr.rx_data >= pnrframe->u.hdr.rx_tail || type_len<8)
+		{		
+			//panic("pnrframe->u.hdr.rx_data >= pnrframe->u.hdr.rx_tail || type_len<8\n");				
+			
+			free_recvframe(pnrframe, pfree_recv_queue);
+			
+			goto exit;
+		}	
+
+		psnap=(struct ieee80211_snap_hdr *)(ptr);
+		psnap_type=ptr+SNAP_SIZE;
+	       if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03)
+		{
+		 	if ( _memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN))
+			{
+   				bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;
+  			}
+  			else if (_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
+     					_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
+     			{  					
+    				bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
+  			}	
+  			else if (_memcmp( psnap->oui, oui_8021h, WLAN_IEEE_OUI_LEN))
+  			{
+   				bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL;
+  			}	
+  			else
+			{
+  				 RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("drop pkt due to invalid frame format!\n"));
+   				
+				//KeBugCheckEx(0x87123333, 0xe0, 0x4c, 0x87, 0xdd);	
+
+				//panic("0x87123333, 0xe0, 0x4c, 0x87, 0xdd\n");	
+
+				free_recvframe(pnrframe, pfree_recv_queue);
+				
+				goto exit;
+ 		 	}
+ 		}
+	 	else
+	 	{
+  			bsnaphdr=_FALSE;//wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS;
+	 	}	
+
+		ptr += (bsnaphdr?SNAP_SIZE:0);
+		_memcpy(&eth_type, ptr, 2);
+		eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+
+		mv_len+= 2+(bsnaphdr?SNAP_SIZE:0);
+		ptr += 2;//now move to iphdr;
+
+		pvlan = NULL;
+		if(eth_type == 0x8100) //vlan
+		{
+			pvlan = (struct _vlan *)ptr;
+			ptr+=4;
+			mv_len+=4;
+		}
+
+		if(eth_type==0x0800)//ip 
+		{
+			struct iphdr*  piphdr = (struct iphdr*)ptr;
+	
+			if (piphdr->protocol == 0x06)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("@@@===recv tcp len:%d @@@===\n", pnrframe->u.hdr.len));
+			}
+		}	
+#ifdef PLATFORM_OS_XP		
+		else
+		{
+			NDIS_PACKET_8021Q_INFO VlanPriInfo;
+			UINT32 UserPriority = pnrframe->u.hdr.attrib.priority;
+			UINT32 VlanID = (pvlan!=NULL ? get_vlan_id(pvlan) : 0 );
+
+			VlanPriInfo.Value =          // Get current value.
+      				NDIS_PER_PACKET_INFO_FROM_PACKET(pnrframe->u.hdr.pkt, Ieee8021QInfo); 
+
+			VlanPriInfo.TagHeader.UserPriority = UserPriority;
+			VlanPriInfo.TagHeader.VlanId =  VlanID ;
+
+			VlanPriInfo.TagHeader.CanonicalFormatId = 0; // Should be zero.
+			VlanPriInfo.TagHeader.Reserved = 0; // Should be zero.
+			NDIS_PER_PACKET_INFO_FROM_PACKET(pnrframe->u.hdr.pkt, Ieee8021QInfo) = VlanPriInfo.Value;	
+	
+		}
+#endif		
+		
+		pbuf = recvframe_pull(pnrframe, (mv_len-sizeof(struct ethhdr)));
+		
+		_memcpy(pbuf, pnrframe->u.hdr.attrib.dst, ETH_ALEN);
+		_memcpy(pbuf+ETH_ALEN, pnrframe->u.hdr.attrib.src, ETH_ALEN);
+		
+		eth_type = htons((unsigned short)eth_type) ;
+		_memcpy(pbuf+12, &eth_type, 2);
+
+		padding_len = (4) - ((type_len + ETH_HLEN)&(4-1));
+
+                a_len -= (type_len + ETH_HLEN + padding_len) ;
+
+		pnrframe_new = NULL;
+
+//#ifdef CONFIG_SKB_COPY	
+#if 0
+		if(a_len > ETH_HLEN) 
+		{
+			pnrframe_new = alloc_recvframe(pfree_recv_queue);
+			if(pnrframe_new)
+			{						
+/*				_pkt *pskb_copy;
+				unsigned int copy_len  = pnrframe->u.hdr.len;
+			
+				_init_listhead(&pnrframe_new->u.hdr.list);
+
+				pnrframe_new->u.hdr.len=0;
+
+		#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+				pskb_copy = dev_alloc_skb(copy_len+64);
+		#else			
+				pskb_copy = netdev_alloc_skb(padapter->pnetdev, copy_len + 64);
+		#endif		
+				if(pskb_copy==NULL)
+				{			
+					printk("amsdu_to_msdu:can not all(ocate memory for skb copy\n");
+				}		
+			
+				pnrframe_new->u.hdr.pkt = pskb_copy;
+
+				_memcpy(pskb_copy->data, pnrframe->u.hdr.rx_data, copy_len);
+				
+				pnrframe_new->u.hdr.rx_data = pnrframe->u.hdr.rx_data;
+				pnrframe_new->u.hdr.rx_tail = pnrframe->u.hdr.rx_data + copy_len;*/
+
+				_pkt *pskb_copy;
+			
+				_init_listhead(&pnrframe_new->u.hdr.list);
+
+				pnrframe_new->u.hdr.len=0;
+
+		#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+				pskb_copy = dev_alloc_skb(a_len);
+		#else			
+				pskb_copy = netdev_alloc_skb(padapter->pnetdev, a_len);
+		#endif		
+				if(pskb_copy==NULL)
+				{			
+					printk("amsdu_to_msdu:can not all(ocate memory for skb copy\n");
+				}		
+			
+				pnrframe_new->u.hdr.pkt = pskb_copy;
+
+				pdata += (type_len + ETH_HLEN + padding_len);
+
+				_memcpy(pskb_copy->data, pdata, a_len);
+
+				pdata = pskb_copy->data;
+				pnrframe_new->u.hdr.rx_head = pskb_copy->head;
+				pnrframe_new->u.hdr.rx_data = pnrframe_new->u.hdr.rx_tail = pdata;
+				pnrframe_new->u.hdr.rx_end = pskb_copy->end;
+
+			}
+			else
+			{
+				printk("amsdu_to_msdu:can not allocate memory for pnrframe_new\n");
+			}
+		}
+
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+		{
+			recv_indicatepkt(padapter, pnrframe);//indicate this recv_frame			
+		}
+		else
+		{
+			free_recvframe(pnrframe, pfree_recv_queue);//free this recv_frame
+		}
+
+		pnrframe = NULL;
+		if(pnrframe_new)
+		{
+			pnrframe = pnrframe_new;
+		}			
+			
+#else
+
+		if(a_len > ETH_HLEN) 
+		{			
+			pnrframe_new = alloc_recvframe(pfree_recv_queue);
+
+			if(pnrframe_new)
+			{									
+				//pnrframe_new->u.hdr.precvbuf = precvbuf;//precvbuf is assigned before call init_recvframe()
+				//init_recvframe(pnrframe_new, precvpriv); 	
+				{					
+						_pkt *pskb = pnrframe->u.hdr.pkt;	  
+						_init_listhead(&pnrframe_new->u.hdr.list);
+
+						pnrframe_new->u.hdr.len=0;
+	
+#ifdef PLATFORM_LINUX
+						if(pskb)
+						{
+							pnrframe_new->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);								
+						}	
+#endif
+				}
+
+				pdata += (type_len + ETH_HLEN + padding_len);
+				pnrframe_new->u.hdr.rx_head = pnrframe_new->u.hdr.rx_data = pnrframe_new->u.hdr.rx_tail = pdata;
+				pnrframe_new->u.hdr.rx_end = pdata + a_len + padding_len;//
+
+#ifdef PLATFORM_WINDOWS								
+				pnrframe_new->u.hdr.precvbuf=precvbuf;
+				_enter_critical(&precvbuf->recvbuf_lock, &irql);
+				precvbuf->ref_cnt++;
+				_exit_critical(&precvbuf->recvbuf_lock, &irql);
+#endif
+				
+			}
+			else
+			{
+				//panic("pnrframe_new=%x\n", pnrframe_new);
+			}
+		}	
+
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE) )
+		{
+			recv_indicatepkt(padapter, pnrframe);//indicate this recv_frame	
+		}
+		else
+		{			
+			free_recvframe(pnrframe, pfree_recv_queue);//free this recv_frame
+		}
+
+		pnrframe = NULL;
+		if(pnrframe_new)
+		{
+			pnrframe = pnrframe_new;
+		}
+		
+#endif
+
+	}while(pnrframe);
+
+exit:
+	
+	return ret;
+
+}
+#endif
+
+void rxcmd_event_hdl(_adapter *padapter, void *prxcmdbuf)
+{	
+	uint voffset;
+	u8	*poffset;
+
+#ifdef CONFIG_RECV_BH
+	u8	*pevtcmd;
+	struct evt_obj *pc2h;	
+#endif
+
+//	u8	*prspbuf;
+
+	u16 pkt_len, cmd_len, drvinfo_sz;
+	u8 eid, cmd_seq;	
+	struct recv_stat *prxstat;
+	struct evt_priv *pevtpriv = &(padapter->evtpriv);
+	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
+
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+rxcmd_event_hdl\n"));
+
+	poffset = (u8*)prxcmdbuf;
+	voffset = *(uint*)poffset;
+	pkt_len = le32_to_cpu(voffset)&0x00003fff;
+
+	prxstat = (struct recv_stat *)prxcmdbuf;
+	drvinfo_sz = ((le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16);//uint 2^3 = 8 bytes		
+	drvinfo_sz = drvinfo_sz<<3;
+
+	poffset +=RXDESC_SIZE + drvinfo_sz;
+	do{
+		
+		voffset  = *(uint*)poffset;
+		cmd_len = (u16)(le32_to_cpu(voffset)&0xffff);
+		cmd_seq = (u8)((le32_to_cpu(voffset)>>24)&0x7f);
+		eid = (u8)((le32_to_cpu(voffset)>>16)&0xff);
+	
+		{
+
+#ifdef CONFIG_RECV_BH		
+			//
+			//.2 async_event
+			//		
+			pc2h = (struct evt_obj*)_malloc(sizeof(struct evt_obj));		
+			if(pc2h==NULL){
+				break;
+			}
+						
+			_init_listhead(&pc2h->list);
+
+			if(cmd_len<64)
+			{
+				pevtcmd = (u8*)_malloc(64+8);
+			}	
+			else
+			{				
+				pevtcmd = (u8*)_malloc(cmd_len+8);
+			}
+			
+			if(pevtcmd==NULL)
+			{
+				_mfree((u8 *)pc2h, sizeof(struct evt_obj));
+				break;
+			}
+			
+			//_memcpy(pevtcmd, poffset+4, cmd_len);
+			_memcpy(pevtcmd, poffset, cmd_len+8);		
+
+			pc2h->evtcode = eid;
+			pc2h->evtsz = cmd_len;
+			pc2h->parmbuf  = pevtcmd;
+
+			enqueue_evt(pevtpriv, pc2h);//enqueue evt_obj
+			
+#ifdef PLATFORM_LINUX
+
+			//printk("schedule event_tasklet, pc2h=%p, evtsz=%d\n", pc2h, pc2h->evtsz);
+
+			tasklet_hi_schedule(&pevtpriv->event_tasklet);
+#endif
+
+#else
+			event_handle(padapter, (uint*)poffset);
+#endif
+
+			poffset += (cmd_len + 8);//8 bytes aligment
+
+		}
+
+	}while(le32_to_cpu(voffset)&BIT(31));
+
+}
+
+int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)	
+{
+	u8	wsize = preorder_ctrl->wsize_b;
+	u16	wend = (preorder_ctrl->indicate_seq + wsize -1)%4096;
+
+	// Rx Reorder initialize condition.
+	if(preorder_ctrl->indicate_seq == 0xffff)
+	{		
+		preorder_ctrl->indicate_seq = seq_num;
+
+		//DbgPrint("check_indicate_seq, 1st->indicate_seq=%d\n", precvpriv->indicate_seq);
+	}	
+
+	//DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+
+	// Drop out the packet which SeqNum is smaller than WinStart
+	if( SN_LESS(seq_num, preorder_ctrl->indicate_seq) )
+	{
+		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
+
+		//DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+		
+		return _FALSE;
+	}
+
+	//
+	// Sliding window manipulation. Conditions includes:
+	// 1. Incoming SeqNum is equal to WinStart =>Window shift 1
+	// 2. Incoming SeqNum is larger than the WinEnd => Window shift N
+	//
+	if( SN_EQUAL(seq_num, preorder_ctrl->indicate_seq) )
+	{
+		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) % 4096;
+	}
+	else if(SN_LESS(wend, seq_num))
+	{
+		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
+		//DbgPrint("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+		
+		if(seq_num >= (wsize - 1))
+			preorder_ctrl->indicate_seq = seq_num + 1 -wsize;
+		else
+			preorder_ctrl->indicate_seq = 4095 - (wsize - (seq_num +1)) + 1;
+	}
+
+	//DbgPrint("exit->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+
+	return _TRUE;
+	
+}
+
+int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union recv_frame *prframe)
+{	
+
+	_list	*phead, *plist;
+	union recv_frame *pnextrframe;
+	struct rx_pkt_attrib *pnextattrib;
+	 _queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+
+	//DbgPrint("+enqueue_reorder_recvframe()\n");
+
+	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//_spinlock_ex(&ppending_recvframe_queue->lock);
+
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+
+	
+	while(end_of_queue_search(phead, plist) == _FALSE)
+	{
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pnextattrib = &pnextrframe->u.hdr.attrib;	
+
+		if(SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
+		{
+			plist = get_next(plist);	
+		}	
+		else if( SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+		{
+			//Duplicate entry is found!! Do not insert current entry.
+			//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));			
+
+			//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+			return _FALSE;
+		}
+		else
+		{			
+			break;
+		}
+
+		//DbgPrint("enqueue_reorder_recvframe():while\n");
+		
+	}
+
+	
+	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//_spinlock_ex(&ppending_recvframe_queue->lock);
+
+	list_delete(&(prframe->u.hdr.list));	
+	
+	list_insert_tail(&(prframe->u.hdr.list), plist);
+
+	//_spinunlock_ex(&ppending_recvframe_queue->lock);
+	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	
+	
+	//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+	return _TRUE;
+
+}
+
+int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced)
+{	
+//	_irqL irql;
+	//u8 bcancelled;
+	_list	*phead, *plist;
+	union recv_frame *prframe;
+	struct rx_pkt_attrib *pattrib;
+	//u8 index = 0;
+	int bPktInBuf = _FALSE;	
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+	//DbgPrint("+recv_indicatepkts_in_order\n");
+
+	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//_spinlock_ex(&ppending_recvframe_queue->lock);
+	
+	phead = 	get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+
+	
+#if 0
+	// Check if there is any other indication thread running.
+	if(pTS->RxIndicateState == RXTS_INDICATE_PROCESSING)
+		return;
+#endif
+
+	// Handling some condition for forced indicate case.
+	if(bforced==_TRUE)
+	{
+		if(is_list_empty(phead))
+		{
+	              // _exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+			//_spinunlock_ex(&ppending_recvframe_queue->lock);
+			return _TRUE;
+		}
+		else
+		{
+			prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+			pattrib = &prframe->u.hdr.attrib;	
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+		}
+	}
+
+	// Prepare indication list and indication.
+	// Check if there is any packet need indicate.
+	while(!is_list_empty(phead))
+	{
+		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pattrib = &prframe->u.hdr.attrib;	
+
+		if(!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num))
+		{
+
+#if 0		
+			// This protect buffer from overflow.
+			if(index >= REORDER_WIN_SIZE)
+			{
+				RT_ASSERT(FALSE, ("IndicateRxReorderList(): Buffer overflow!! \n"));
+				bPktInBuf = TRUE;
+				break;
+			}
+#endif
+
+			plist = get_next(plist);	
+			list_delete(&(prframe->u.hdr.list));
+			
+			if(SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num))
+			{
+				preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+			}
+				
+#if 0				
+			index++;
+			if(index==1)
+			{
+				//Cancel previous pending timer.
+				//PlatformCancelTimer(Adapter, &pTS->RxPktPendingTimer);
+				if(bforced!=_TRUE)
+				{
+				  //printk("_cancel_timer(&preorder_ctrl->reordering_ctrl_timer, &bcancelled);\n");
+				  _cancel_timer(&preorder_ctrl->reordering_ctrl_timer, &bcancelled);
+			        }				
+			}				
+#endif
+
+			//Set this as a lock to make sure that only one thread is indicating packet.
+			//pTS->RxIndicateState = RXTS_INDICATE_PROCESSING;
+
+			// Indicate packets
+			//RT_ASSERT((index<=REORDER_WIN_SIZE), ("RxReorderIndicatePacket(): Rx Reorder buffer full!! \n"));
+			
+			
+			//indicate this recv_frame
+			//DbgPrint("recv_indicatepkts_in_order, indicate_seq=%d, seq_num=%d\n", precvpriv->indicate_seq, pattrib->seq_num);
+			if(!pattrib->amsdu)
+			{
+				//printk("recv_indicatepkts_in_order, amsdu!=1, indicate_seq=%d, seq_num=%d\n", preorder_ctrl->indicate_seq, pattrib->seq_num);
+				
+				if((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+				{
+					recv_indicatepkt(padapter, prframe);		//indicate this recv_frame	
+				}
+			}
+			else if(pattrib->amsdu==1)
+			{			
+				if(amsdu_to_msdu(padapter, prframe)!=_SUCCESS)
+				{
+					free_recvframe(prframe, &precvpriv->free_recv_queue);
+				}
+			}
+			else
+			{				
+				//error condition;
+			}
+				
+
+			//Update local variables.
+			bPktInBuf = _FALSE;
+												
+		}
+		else
+		{
+			bPktInBuf = _TRUE;
+			break;
+		}	
+
+		//DbgPrint("recv_indicatepkts_in_order():while\n");
+		
+	}
+
+	//_spinunlock_ex(&ppending_recvframe_queue->lock);
+	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+/*
+	//Release the indication lock and set to new indication step.
+	if(bPktInBuf)
+	{
+		// Set new pending timer.
+		//pTS->RxIndicateState = RXTS_INDICATE_REORDER;
+		//PlatformSetTimer(Adapter, &pTS->RxPktPendingTimer, pHTInfo->RxReorderPendingTime);
+		//printk("_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME)\n");
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+	}
+	else
+	{
+		//pTS->RxIndicateState = RXTS_INDICATE_IDLE;
+	}
+*/
+	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+	//return _TRUE;
+	return bPktInBuf;
+
+}
+
+int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
+{	
+	_irqL irql;
+	int retval = _SUCCESS;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;	
+
+	if(!pattrib->amsdu)
+	{
+		//s1.
+		wlanhdr_to_ethhdr(prframe);
+
+#ifdef CONFIG_DRVEXT_MODULE
+		retval = drvext_rx_handler(padapter, prframe->u.hdr.rx_data, prframe->u.hdr.len);
+		if (retval == _SUCCESS)
+		{		
+			free_recvframe(prframe, &padapter->recvpriv.free_recv_queue);
+			return retval;
+		}
+#endif
+		
+
+		if(pattrib->qos !=1 /*|| pattrib->priority!=0 || IS_MCAST(pattrib->ra)*/)
+		{
+			if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE) )
+			{
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n" ));	
+
+				recv_indicatepkt(padapter, prframe);		
+				return _SUCCESS;
+
+			}
+			else
+			{	
+				return _FAIL;			
+			}
+		}
+		else if(preorder_ctrl->enable == _FALSE)
+		{
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+
+			recv_indicatepkt(padapter, prframe);				
+
+			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+
+			return _SUCCESS;	
+		}			
+#ifndef CONFIG_RECV_REORDERING_CTRL
+		else
+		{
+			//indicate this recv_frame			
+			recv_indicatepkt(padapter, prframe);		
+			return _SUCCESS;	
+		}
+#endif	
+
+	}	
+	else if(pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
+	{
+		//printk("recv_indicatepkt_reorder():pattrib->amsdu==1\n");
+		if(preorder_ctrl->enable == _FALSE)
+		{
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+
+			retval = amsdu_to_msdu(padapter, prframe);
+		
+			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+
+			return retval;	
+		}
+		else
+		{
+#ifndef CONFIG_RECV_REORDERING_CTRL
+
+		preorder_ctrl->indicate_seq = pattrib->seq_num;
+
+		retval = amsdu_to_msdu(padapter, prframe);
+
+		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+
+		return retval;		
+#endif
+		}
+		
+	}
+	else
+	{
+
+	}
+		
+	//printk("start reorder buffer ctrl\n");
+		
+	_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+	//s2. check if winstart_b(indicate_seq) needs to been updated		
+	if(!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
+	{
+		//pHTInfo->RxReorderDropCounter++;
+		//ReturnRFDList(Adapter, pRfd);
+		//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n"));		
+		//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	        //return _FAIL;
+                goto _err_exit;
+	}
+
+
+	//s3. Insert all packet into Reorder Queue to maintain its ordering.
+	if(!enqueue_reorder_recvframe(preorder_ctrl, prframe))
+	{
+	       //DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n");
+	       //_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	       //return _FAIL;
+               goto _err_exit;
+	}
+		
+		
+	//s4.
+	// Indication process.
+	// After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
+	// with the SeqNum smaller than latest WinStart and buffer other packets.
+	//
+	// For Rx Reorder condition:
+	// 1. All packets with SeqNum smaller than WinStart => Indicate
+	// 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
+	//		
+	
+	//recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE);
+	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, _FALSE)==_TRUE)
+	{
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+		_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);	
+	}
+	else
+	{
+		_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+
+		
+	return _SUCCESS;
+
+_err_exit:
+ 
+        _exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+		
+        return _FAIL;
+
+
+}
+
+void reordering_ctrl_timeout_handler(void *pcontext)
+{
+	_irqL irql;
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
+	_adapter *padapter = preorder_ctrl->padapter;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+
+	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved)
+	{
+		return;
+	}
+
+	//printk("+reordering_ctrl_timeout_handler()=>\n");
+
+	_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+	recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE);
+
+	_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+}
+
+
+int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
+{
+	int retval = _SUCCESS;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;	
+	
+#ifdef CONFIG_80211N_HT
+
+	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+
+	if(phtpriv->ht_option==1) //B/G/N Mode
+	{
+		//prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority];
+			
+		if(recv_indicatepkt_reorder(padapter, prframe)!=_SUCCESS)// including perform A-MPDU Rx Ordering Buffer Control
+		{
+			if((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+			{
+				retval = _FAIL;
+				return retval;
+			}	
+		}
+	}
+	else //B/G mode
+#endif	
+	{
+		retval=wlanhdr_to_ethhdr (prframe);
+		if(retval != _SUCCESS)
+		{		
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
+			return retval;
+		}
+		
+#ifdef CONFIG_DRVEXT_MODULE
+		retval = drvext_rx_handler(padapter, prframe->u.hdr.rx_data, prframe->u.hdr.len);
+		if (retval == _SUCCESS)
+		{		
+			free_recvframe(prframe, &padapter->recvpriv.free_recv_queue);
+			return retval;
+		}
+#endif
+
+		
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+		{
+			//indicate this recv_frame
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n" ));	
+			recv_indicatepkt(padapter, prframe);	
+
+			
+		}
+		else
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n" ));	
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+			retval = _FAIL;
+			return retval;
+		}	
+		
+	}
+
+	return retval;
+	
+}
+
+
+
+
+
+
+
+u8 query_rx_pwr_percentage(s8	antpower)
+{
+	if ((antpower <= -100) || (antpower >= 20))
+	{
+		return	0;
+	}
+	else if (antpower >= 0)
+	{
+		return	100;
+	}
+	else
+	{
+		return	(100+antpower);
+	}
+	
+}
+
+
+
+static u8 evm_db2percentage(s8 value)
+{
+	//
+	// -33dB~0dB to 0%~99%
+	//
+	s8 ret_val;
+    
+	ret_val = value;
+	//ret_val /= 2;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("EVMdbToPercentage92S Value=%d / %x \n", ret_val, ret_val));
+		
+	if(ret_val >= 0)
+		ret_val = 0;
+	if(ret_val <= -33)
+		ret_val = -33;
+
+	ret_val = 0 - ret_val;
+	ret_val*=3;
+
+	if(ret_val == 99)
+		ret_val = 100;
+
+	return(ret_val);
+}
+
+
+s32 signal_scale_mapping(s32 cur_sig )
+{
+	s32 ret_sig;
+
+#ifdef RTK_DMP_PLATFORM
+	// Step 1. Scale mapping.
+	if(cur_sig >= 81 && cur_sig <= 100)
+	{
+		ret_sig = 100; 
+	}
+	if(cur_sig >= 61 && cur_sig <= 80)
+	{
+		// mapping to 90~95
+		ret_sig = 90 + ((cur_sig - 60) / 4);
+	}
+	else if(cur_sig >= 41 && cur_sig <= 60)
+	{
+		// mapping to 78~88
+		ret_sig = 78 + ((cur_sig - 40) / 2);
+	}
+	else if(cur_sig >= 31 && cur_sig <= 40)
+	{
+		// mapping to 67~76
+		ret_sig = 66 + (cur_sig - 30);
+	}
+	else if(cur_sig >= 21 && cur_sig <= 30)
+	{
+		// mapping to 55~64
+		ret_sig = 54 + (cur_sig - 20);
+	}
+	else if(cur_sig >= 5 && cur_sig <= 20)
+	{
+		// mapping to 42~52
+		ret_sig = 42 + (((cur_sig - 5) * 2) / 3);
+	}
+	else if(cur_sig == 4)
+	{
+		ret_sig = 15;
+	}
+	else if(cur_sig == 3)
+	{
+		ret_sig = 13;
+	}
+	else if(cur_sig == 2)
+	{
+		ret_sig = 11;
+	}
+	else if(cur_sig == 1)
+	{
+		ret_sig = 9;
+	}
+	else
+	{
+		ret_sig = cur_sig;
+	}
+#else
+/*
+	if(cur_sig >= 51 && cur_sig <= 100)
+	{
+		ret_sig = 100;
+	}
+	else if(cur_sig >= 41 && cur_sig <= 50)
+	{
+		ret_sig = 80 + ((cur_sig - 40)*2);
+	}
+	else if(cur_sig >= 31 && cur_sig <= 40)
+	{
+		ret_sig = 66 + (cur_sig - 30);
+	}
+	else if(cur_sig >= 21 && cur_sig <= 30)
+	{
+		ret_sig = 54 + (cur_sig - 20);
+	}
+	else if(cur_sig >= 10 && cur_sig <= 20)
+	{
+		ret_sig = 42 + (((cur_sig - 10) * 2) / 3);
+	}
+	else if(cur_sig >= 5 && cur_sig <= 9)
+	{
+		ret_sig = 22 + (((cur_sig - 5) * 3) / 2);
+	}
+	else if(cur_sig >= 1 && cur_sig <= 4)
+	{
+		ret_sig = 6 + (((cur_sig - 1) * 3) / 2);
+	}
+	else
+	{
+		ret_sig = cur_sig;
+	}
+*/
+
+	if(cur_sig >= 70 && cur_sig <= 100)
+	{
+		ret_sig = 100;
+	}
+	else if ( cur_sig >= 30 && cur_sig <= 69 )
+	{
+		ret_sig = 100 - ( ( 70 - cur_sig ) * 2 );
+	}
+	else
+	{
+		ret_sig = 10;
+	}
+
+#endif
+	
+	return ret_sig;
+}
+
+
+
+s32  translate2dbm(_adapter *padapter,u8 signal_strength_idx	)
+{
+	s32	signal_power; // in dBm.
+
+
+	// Translate to dBm (x=0.5y-95).
+	signal_power = (s32)((signal_strength_idx + 1) >> 1); 
+	signal_power -= 95; 
+
+	return signal_power;
+}
+
+void query_rx_phy_status(_adapter *padapter,union recv_frame *prframe)
+{	
+
+	u8 i,max_spatial_stream,evm;
+	struct recv_stat *prxstat=(struct recv_stat *)prframe->u.hdr.rx_head;	
+	struct phy_stat *pphy_stat=(struct phy_stat *)(prxstat+1);
+	u8 *pphy_head=(u8 *)(prxstat+1);
+	s8				rx_pwr[4], rx_pwr_all;
+		u8				 pwdb_all;
+		u32				rssi,total_rssi=0;
+	u8 				bcck_rate=0,rf_rx_num = 0,cck_highpwr = 0;
+
+	
+	struct phy_cck_rx_status *pcck_buf;
+
+
+	// Record it for next packet processing
+	bcck_rate=(prframe->u.hdr.attrib.mcs_rate<=3? 1:0);
+	if(bcck_rate)
+	{
+		u8 report;
+	
+		// CCK Driver info Structure is not the same as OFDM packet.
+		pcck_buf = (struct phy_cck_rx_status *)pphy_stat;	
+//		Adapter->RxStats.NumQryPhyStatusCCK++;
+	
+		// 
+		// (1)Hardware does not provide RSSI for CCK
+		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		//
+//		if(pHalData->eRFPowerState == eRfOn)
+//			cck_highpwr = (u1Byte)pHalData->bCckHighPower;
+//		else
+//			cck_highpwr = FALSE;
+		if(!cck_highpwr)
+		{
+			report = pcck_buf->cck_agc_rpt & 0xc0;
+			report = report>>6;
+			switch(report)
+			{
+				// 03312009 modified by cosa
+				// Modify the RF RNA gain value to -40, -20, -2, 14 by Jenyu's suggestion
+				// Note: different RF with the different RNA gain.
+				case 0x3:
+					rx_pwr_all = -40 - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x2:
+					rx_pwr_all = -20 - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x1:
+					rx_pwr_all = -2 - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x0:
+					rx_pwr_all = 14 - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+			}
+		}
+		else
+		{
+			report =((u8)(le32_to_cpu( pphy_stat->phydw1) >>8)) & 0x60;
+			report = report>>5;
+			switch(report)
+			{
+				case 0x3:
+					rx_pwr_all = -40 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+				case 0x2:
+					rx_pwr_all = -20 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1);
+					break;
+				case 0x1:
+					rx_pwr_all = -2 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+				case 0x0:
+					rx_pwr_all = 14 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+			}
+		}
+
+		pwdb_all= query_rx_pwr_percentage(rx_pwr_all);
+		//if(pMgntInfo->CustomerID == RT_CID_819x_Lenovo)		
+		{
+			// CCK gain is smaller than OFDM/MCS gain, 
+			// so we add gain diff by experiences, the val is 6
+			pwdb_all+=6;
+			if(pwdb_all > 100)
+				pwdb_all = 100;
+			// modify the offset to make the same gain index with OFDM.
+			if(pwdb_all > 34 && pwdb_all <= 42)
+				pwdb_all -= 2;
+			else if(pwdb_all > 26 && pwdb_all <= 34)
+				pwdb_all -= 6;
+			else if(pwdb_all > 14 && pwdb_all <= 26)
+				pwdb_all -= 8;
+			else if(pwdb_all > 4 && pwdb_all <= 14)
+				pwdb_all -= 4;
+		}
+		
+
+		//
+		// (3) Get Signal Quality (EVM)
+		//
+		
+		//if(bPacketMatchBSSID)
+		{
+			u8	sq;
+
+			{
+				
+			if(pwdb_all> 40 )
+			{
+				sq = 100;
+			}else
+			{
+				sq = pcck_buf->sq_rpt;
+				
+				if(pcck_buf->sq_rpt > 64)
+					sq = 0;
+				else if (pcck_buf->sq_rpt < 20)
+					sq= 100;
+				else
+					sq = ((64-sq) * 100) / 44;
+
+			}
+			}
+			prframe->u.hdr.attrib.signal_qual=sq;
+			prframe->u.hdr.attrib.rx_mimo_signal_qual[0] =sq;
+			prframe->u.hdr.attrib.rx_mimo_signal_qual[1] = -1;
+		}
+	}
+	else
+	{
+
+		// 
+		// (1)Get RSSI for HT rate
+		//
+		for(i=0; i<((padapter->registrypriv.rf_config) &0x0f ); i++)
+		{
+			rf_rx_num++;
+			//if (IS_HARDWARE_TYPE_8192S(Adapter))
+			{
+				rx_pwr[i] = ((pphy_head[PHY_STAT_GAIN_TRSW_SHT+i]&0x3F)*2) - 110;
+			}		
+			/* Translate DBM to percentage. */
+			rssi=query_rx_pwr_percentage(rx_pwr[i]);
+			total_rssi += rssi;
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], rssi));
+			
+			//Get Rx snr value in DB			
+
+		}
+		
+		
+		//
+		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		//
+		rx_pwr_all = (((pphy_head[PHY_STAT_PWDB_ALL_SHT]) >> 1 )& 0x7f) -106;
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);	
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("PWDB_ALL=%d\n",	pwdb_all));
+		
+		
+	//	if(pMgntInfo->CustomerID != RT_CID_819x_Lenovo)		
+		{
+			//
+			// (3)EVM of HT rate
+			//
+			if(prframe->u.hdr.attrib.htc &&  prframe->u.hdr.attrib.mcs_rate >=20 && prframe->u.hdr.attrib.mcs_rate<=27)
+
+				max_spatial_stream = 2; //both spatial stream make sense
+			else
+				max_spatial_stream = 1; //only spatial stream 1 makes sense
+
+			for(i=0; i<max_spatial_stream; i++)
+			{
+				// Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
+				// fill most significant bit to "zero" when doing shifting operation which may change a negative 
+				// value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.
+				evm =evm_db2percentage( (pphy_head[PHY_STAT_RXEVM_SHT+i] /*/ 2*/));	//dbm
+
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RXRATE=%x RXEVM=%x EVM=%s%d\n", 
+				prframe->u.hdr.attrib.mcs_rate, pphy_head[PHY_STAT_RXEVM_SHT+i], "%",evm));
+				
+			//	if(bPacketMatchBSSID)
+				{
+					if(i==0) // Fill value in RFD, Get the first spatial stream only
+					{
+						prframe->u.hdr.attrib.signal_qual = (u8)(evm & 0xff);
+					}
+					prframe->u.hdr.attrib.rx_mimo_signal_qual[i] = (u8)(evm & 0xff);
+				}
+			}
+		}
+		//
+		// 4. Record rx statistics for debug 
+		//		
+
+	}
+
+	//UI BSS List signal strength(in percentage), make it good looking, from 0~100.
+	//It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
+	if(bcck_rate)
+	{
+		prframe->u.hdr.attrib.signal_strength=(u8)signal_scale_mapping(pwdb_all);
+	}
+	else
+	{	
+		if (rf_rx_num != 0)
+		{
+			prframe->u.hdr.attrib.signal_strength= (u8)(signal_scale_mapping( total_rssi/=rf_rx_num));
+		}
+	}
+}
+
+ void process_link_qual(_adapter *padapter,union recv_frame *prframe)
+{
+	u32	last_evm=0, nSpatialStream, tmpVal;
+ 	struct rx_pkt_attrib *pattrib;
+
+	if(prframe == NULL || padapter==NULL){
+		return;
+	}
+
+	pattrib = &prframe->u.hdr.attrib;	
+	if(pattrib->signal_qual != 0)	
+	{
+
+			//
+			// 1. Record the general EVM to the sliding window.
+			//
+			if(padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
+			{
+				padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
+				last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
+				padapter->recvpriv.signal_qual_data.total_val -= last_evm;
+			}
+			padapter->recvpriv.signal_qual_data.total_val += pattrib->signal_qual;
+
+			padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = pattrib->signal_qual;
+			if(padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
+				padapter->recvpriv.signal_qual_data.index = 0;
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, pattrib->signal_qual));
+
+			// <1> Showed on UI for user, in percentage.
+			tmpVal = padapter->recvpriv.signal_qual_data.total_val/padapter->recvpriv.signal_qual_data.total_num;
+			padapter->recvpriv.signal=(u8)tmpVal;
+			
+	}
+	else
+		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" pattrib->signal_qual =%d\n", pattrib->signal_qual ));
+	
+}	// Process_UiLinkQuality8192S
+
+
+
+void process_rssi(_adapter *padapter,union recv_frame *prframe)
+{
+		u32			last_rssi, tmp_val;
+	struct rx_pkt_attrib *pattrib= &prframe->u.hdr.attrib;
+//	if(pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
+	{
+//		Adapter->RxStats.RssiCalculateCnt++;	//For antenna Test
+		if(padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
+		{
+			padapter->recvpriv.signal_strength_data.total_num = PHY_RSSI_SLID_WIN_MAX;
+			last_rssi = padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index];
+			padapter->recvpriv.signal_strength_data.total_val -= last_rssi;
+		}
+		padapter->recvpriv.signal_strength_data.total_val  +=pattrib->signal_strength;
+	
+		padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index++] = pattrib->signal_strength;
+		if(padapter->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
+			padapter->recvpriv.signal_strength_data.index = 0;
+	
+
+		tmp_val = padapter->recvpriv.signal_strength_data.total_val/padapter->recvpriv.signal_strength_data.total_num;
+		padapter->recvpriv.rssi=(s8)translate2dbm( padapter,(u8)tmp_val);
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d \n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
+	}
+
+	
+	
+}	// Process_UI_RSSI_8192S
+
+void process_phy_info(_adapter *padapter,union recv_frame *prframe){
+	query_rx_phy_status(padapter, prframe);
+	process_rssi(padapter, prframe);
+	process_link_qual(padapter,  prframe);
+
+}
+
+int recv_func(_adapter *padapter, void *pcontext)
+{	
+	struct rx_pkt_attrib *pattrib;
+	union recv_frame *prframe, *orig_prframe;	
+	int retval = _SUCCESS;
+	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+		
+	prframe = (union recv_frame *)pcontext;	
+	orig_prframe = prframe;
+
+	pattrib = &prframe->u.hdr.attrib;	
+
+#ifdef CONFIG_MP_INCLUDED		
+       if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)	)//&&(padapter->mppriv.check_mp_pkt == 0))
+       {     	       	
+		if(pattrib->crc_err == 1)
+			padapter->mppriv.rx_crcerrpktcount++;
+		else
+			padapter->mppriv.rx_pktcount++;	         	
+					   
+		if(check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) ==_FALSE){
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_alert_,("MP - Not in loopback mode , drop pkt \n"));
+			free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+			goto _exit_recv_func;	
+		}
+       }	   
+#endif	
+
+
+	//check the frame crtl field and decache
+	retval=validate_recv_frame(padapter, prframe);
+	if(retval !=_SUCCESS)
+	{ 		
+		free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recv_func: drop pkt \n"));
+		goto _exit_recv_func;
+	}
+	process_phy_info(padapter, prframe);
+	prframe=decryptor(padapter, prframe);
+	if(prframe==NULL){
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("decryptor: drop pkt \n"));
+		retval = _FAIL;
+		goto _exit_recv_func;
+	}
+
+
+	prframe = recvframe_chk_defrag(padapter, prframe);
+	if(prframe==NULL){
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvframe_chk_defrag: drop pkt \n"));
+		goto _exit_recv_func;
+	}
+
+	prframe=portctrl(padapter, prframe);
+	if(prframe==NULL)	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl: drop pkt \n"));
+		retval = _FAIL;
+		goto _exit_recv_func;		
+	}
+
+
+//#if defined(CONFIG_80211N_HT) && defined(CONFIG_RECV_REORDERING_CTRL)
+#ifdef CONFIG_80211N_HT
+
+	retval = process_recv_indicatepkts(padapter, prframe);
+	if(retval != _SUCCESS)
+	{		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recv_func: process_recv_indicatepkts fail! \n"));
+		free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		goto _exit_recv_func;	
+	}	
+
+#else
+
+	if(!pattrib->amsdu)
+	{
+		retval=wlanhdr_to_ethhdr (prframe);
+		if(retval != _SUCCESS)
+		{		
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
+			free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+			goto _exit_recv_func;	
+		}
+		
+#ifdef CONFIG_DRVEXT_MODULE
+		retval = drvext_rx_handler(padapter, prframe->u.hdr.rx_data, prframe->u.hdr.len);
+		if (retval == _SUCCESS)
+		{		
+			free_recvframe(orig_prframe, pfree_recv_queue);
+			goto _exit_recv_func;
+		}
+#endif
+		
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func recv_indicatepkt\n" ));	
+			//indicate this recv_frame
+			recv_indicatepkt(padapter, prframe);
+		}
+		else
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_func: free_recvframe\n" ));		
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_debug_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+			retval = _FAIL;
+			free_recvframe(orig_prframe, pfree_recv_queue); //free this recv_frame
+		}		
+		
+	}	
+	else if(pattrib->amsdu==1)
+	{		
+	
+		retval = amsdu_to_msdu(padapter, prframe);
+		if(retval != _SUCCESS)
+		{			
+			free_recvframe(orig_prframe, pfree_recv_queue);
+			goto _exit_recv_func;	
+		}
+	}
+	else
+	{
+		
+	}
+	
+#endif
+
+
+_exit_recv_func:
+
+	return retval;	
+
+}
+
+#ifdef  PLATFORM_LINUX
+#ifdef CONFIG_RECV_TASKLET
+static int recvbuf2recvframe_u(_adapter *padapter, struct sk_buff *pskb)
+{
+	u8 *pbuf, shift_sz = 0;	
+	u8	frag, mf;
+	uint	pkt_len;
+	s32 transfer_len;
+	struct recv_stat *prxstat;	
+	u16	drvinfo_sz, pkt_offset, tmp_len, alloc_sz;
+	s16	pkt_cnt;
+	_queue *pfree_recv_queue;
+	_pkt  *pkt_copy=NULL;
+	union recv_frame *precvframe=NULL; 
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+recvbuf2recvframe_u()\n"));
+	
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	
+	//pbuf = (u8*)precvbuf->pbuf;
+	pbuf = pskb->data;	
+	prxstat = (struct recv_stat *)pbuf;
+	
+	//pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16)&0x3ffff;
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16)&0xff;
+	pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+	
+#ifdef CONFIG_USB_HCI
+
+	//transfer_len = precvbuf->transfer_len;
+	transfer_len = pskb->len;
+
+	//	Added by Albert 2010/04/21
+	//	Test throughput with Netgear 3700 ( No security ) with Chariot 3T3R pairs.
+	//	The packet count will be a big number so that the containing packet will effect the Rx reordering.
+
+	if ( transfer_len < pkt_len )
+	{	//	 In this case, it means the MAX_RECVBUF_SZ is too small to get the data from 8712u.
+		return _FAIL;
+	}
+	
+	do{		
+
+		prxstat = (struct recv_stat *)pbuf;	   
+		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+
+		mf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;//more fragment bit
+		frag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;//fragmentation number
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("rxdesc : offsset0:0x%08x, offsset4:0x%08x, offsset8:0x%08x, offssetc:0x%08x\n", 
+			prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
+			
+		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16;//uint 2^3 = 8 bytes
+		drvinfo_sz = drvinfo_sz<<3;
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("DRV_INFO_SIZE=%d\n", drvinfo_sz));
+
+		if(pkt_len<=0)
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), pkt_len<=0\n"));		
+			goto  _exit_recvbuf2recvframe_u;
+		}		
+
+		if ( ( le32_to_cpu( prxstat->rxdw0 ) >> 23 ) & 0x01 )	//	Qos data, wireless lan header length is 26
+		{
+			shift_sz = 2;
+		}
+		
+		precvframe = alloc_recvframe(pfree_recv_queue);
+		if(precvframe==NULL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe(), precvframe==NULL\n"));			
+			goto  _exit_recvbuf2recvframe_u;
+		}
+
+		_init_listhead(&precvframe->u.hdr.list);	
+		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf 
+		precvframe->u.hdr.len=0;
+	
+		tmp_len = pkt_len + drvinfo_sz + RXDESC_SIZE;
+		pkt_offset = (u16)_RND128(tmp_len);
+
+		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
+		if((mf ==1)&&(frag == 0)){
+			alloc_sz = 1658;	//	1658 + 6 = 1664, 1664 is 128 alignment.
+		}
+		else {
+			alloc_sz = tmp_len;
+		}
+
+		//	2 is for IP header 4 bytes alignment in QoS packet case.
+		//	4 is for skb->data 4 bytes alignment.
+		alloc_sz += 6;	
+		
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+		pkt_copy = dev_alloc_skb(alloc_sz);
+#else			
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
+#endif		
+		if(pkt_copy)
+		{
+			pkt_copy->dev = padapter->pnetdev;
+			precvframe->u.hdr.pkt = pkt_copy;
+			skb_reserve( pkt_copy, 4 - ((u32) ( pkt_copy->data ) % 4 ) );
+			skb_reserve( pkt_copy, shift_sz );
+			_memcpy(pkt_copy->data, pbuf, tmp_len);
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
+			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
+		}
+		else
+		{	
+			//printk("recvbuf2recvframe:can not allocate memory for skb copy\n");				
+			precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);	
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
+			precvframe->u.hdr.rx_end = pbuf + alloc_sz;
+		}
+		
+
+		recvframe_put(precvframe, tmp_len);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);	
+
+		//because the endian issue, driver avoid reference to the rxstat after calling update_recvframe_attrib_from_recvstat();
+		update_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib, prxstat);		
+						
+		if( recv_entry(precvframe) != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), recv_entry(precvframe) != _SUCCESS\n"));			
+		}
+
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;
+		pkt_cnt--;
+		precvframe = NULL;
+		pkt_copy = NULL;
+
+	}while((transfer_len>0) && (pkt_cnt>0));
+
+_exit_recvbuf2recvframe_u:
+
+	//dev_kfree_skb_any(pskb);
+	
+#endif //#ifdef CONFIG_USB_HCI	
+
+	return _SUCCESS;
+	
+}
+
+void recv_tasklet(void *priv)
+{
+	struct sk_buff *pskb;
+	_adapter *padapter = (_adapter*)priv;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	
+	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
+	{
+
+		recvbuf2recvframe_u(padapter, pskb);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+
+		pskb->tail = pskb->data;
+		pskb->len = 0;
+		
+		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+		
+#else
+		dev_kfree_skb_any(pskb);
+#endif
+				
+	}	
+}
+
+#else
+void recv_bh(void *priv)
+{	
+	int ret = _SUCCESS;
+	union recv_frame *prframe= NULL;
+	_adapter *padapter = (_adapter*)priv;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *precv_pending_queue=&precvpriv->recv_pending_queue;
+
+	while(1)
+	{
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		{
+			printk("recv_bh => bDriverStopped or bSurpriseRemoved \n");
+			break;
+		}
+
+		prframe = dequeue_recvframe(precv_pending_queue);
+		if(prframe==NULL)   //no recv frame need to process
+			break;
+
+		ret = recv_func(padapter, prframe);
+		if(ret != _SUCCESS)		
+		{
+			//printk("recv_bh(): after recv_func(), ret=%d\n", ret);
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_debug_, ("recv_bh(): after recv_func(), ret=%d\n", ret));		
+		}
+	}
+	
+}
+#endif
+#endif
+
diff --git a/drivers/net/wireless/8712u/recv/rtl871x_recv.c b/drivers/net/wireless/8712u/recv/rtl871x_recv.c
new file mode 100755
index 0000000..bf102f9
--- /dev/null
+++ b/drivers/net/wireless/8712u/recv/rtl871x_recv.c
@@ -0,0 +1,1522 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <mlme_osdep.h>
+#include <ip.h>
+#include <if_ether.h>
+#include <ethernet.h>
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#include <wifi.h>
+#include <circ_buf.h>
+
+
+/*
+pfree_recv_queue accesser: returnPkt(dispatch level), rx_done(ISR?),  =>  using crtitical sec ??
+
+caller of alloc_recvframe have to call =====> init_recvframe(precvframe, _pkt *pkt);
+
+*/
+
+
+void	_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
+{	
+	
+	
+_func_enter_;	
+
+	_memset((u8 *)psta_recvpriv, 0, sizeof (struct sta_recv_priv));
+
+	_spinlock_init(&psta_recvpriv->lock);
+
+	//for(i=0; i<MAX_RX_NUMBLKS; i++)
+	//	_init_queue(&psta_recvpriv->blk_strms[i]);
+
+	_init_queue(&psta_recvpriv->defrag_q);
+	
+_func_exit_;
+
+}
+
+sint	_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
+{
+	sint i;
+
+	union recv_frame *precvframe;
+
+	sint	res=_SUCCESS;
+	
+_func_enter_;		
+
+	 _memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv));
+
+	_spinlock_init(&precvpriv->lock);
+
+	_init_queue(&precvpriv->free_recv_queue);
+	_init_queue(&precvpriv->recv_pending_queue);
+	
+	precvpriv->adapter = padapter;
+	
+	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
+
+	os_recv_resource_init(precvpriv, padapter);
+
+	precvpriv->pallocated_frame_buf = _vmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+	if(precvpriv->pallocated_frame_buf==NULL){
+		res= _FAIL;
+		goto exit;
+	}	
+	_memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+
+	precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ -
+							((uint) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1));
+
+	precvframe = (union recv_frame*) precvpriv->precv_frame_buf;
+
+
+	for(i=0; i < NR_RECVFRAME ; i++)
+	{
+		_init_listhead(&(precvframe->u.list));
+
+		list_insert_tail(&(precvframe->u.list), &(precvpriv->free_recv_queue.queue));
+
+		res = os_recv_resource_alloc(padapter, precvframe);
+	
+            	precvframe->u.hdr.adapter =padapter;
+		precvframe++;
+		
+	}
+	
+#ifdef CONFIG_USB_HCI
+
+	precvpriv->rx_pending_cnt=1;
+
+	_init_sema(&precvpriv->allrxreturnevt, 0);		
+	
+#endif
+	
+	
+	res = init_recv_priv(precvpriv, padapter);
+
+	
+exit:
+
+_func_exit_;
+
+	return res;
+	
+}
+
+void mfree_recv_priv_lock(struct recv_priv *precvpriv)
+{	
+       _spinlock_free(&precvpriv->lock);
+	_free_sema(&precvpriv->recv_sema);
+	_free_sema(&precvpriv->terminate_recvthread_sema);
+
+	_spinlock_free(&precvpriv->free_recv_queue.lock);
+	_spinlock_free(&precvpriv->recv_pending_queue.lock);
+}
+
+void _free_recv_priv (struct recv_priv *precvpriv)
+{
+_func_enter_;		
+
+	mfree_recv_priv_lock(precvpriv);
+
+	os_recv_resource_free(precvpriv);
+
+	if(precvpriv->pallocated_frame_buf)
+		_vmfree(precvpriv->pallocated_frame_buf, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+
+	free_recv_priv(precvpriv);
+	
+_func_exit_;
+
+}
+
+union recv_frame *alloc_recvframe (_queue *pfree_recv_queue)
+{
+	_irqL irqL;
+	union recv_frame  *precvframe;
+	_list	*plist, *phead;
+	_adapter *padapter;
+	struct recv_priv *precvpriv;
+_func_enter_;
+
+	_enter_critical(&pfree_recv_queue->lock, &irqL);
+	
+	if(_queue_empty(pfree_recv_queue) == _TRUE)
+	{
+		precvframe = NULL;
+	}
+	else
+	{
+		phead = get_list_head(pfree_recv_queue);
+
+		plist = get_next(phead);
+
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+
+		list_delete(&precvframe->u.hdr.list);
+		padapter=precvframe->u.hdr.adapter;
+		if(padapter !=NULL){
+			precvpriv=&padapter->recvpriv;
+			if(pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt--;
+		}
+	}
+	        
+	_exit_critical(&pfree_recv_queue->lock, &irqL);
+	
+_func_exit_;
+
+	return precvframe;
+	
+}
+
+union recv_frame *dequeue_recvframe (_queue *queue)
+{
+	return alloc_recvframe(queue);	
+}
+
+
+sint	enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
+{	
+       _irqL irqL;
+	_adapter *padapter=precvframe->u.hdr.adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	
+_func_enter_;
+
+
+	//_spinlock(&pfree_recv_queue->lock);
+	 _enter_critical(&queue->lock, &irqL);
+
+	//_init_listhead(&(precvframe->u.hdr.list));
+	list_delete(&(precvframe->u.hdr.list));
+	
+	
+	list_insert_tail(&(precvframe->u.hdr.list), get_list_head(queue));
+
+	if(padapter !=NULL){			
+			if(queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt++;
+	}
+
+	//_spinunlock(&pfree_recv_queue->lock);
+	 _exit_critical(&queue->lock, &irqL);
+		
+
+_func_exit_;	
+
+	return _SUCCESS;
+}
+
+/*
+sint	enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
+{
+	return free_recvframe(precvframe, queue);
+}
+*/
+
+
+
+
+/*
+caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
+pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
+
+using spinlock to protect
+
+*/
+
+void free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue)
+{
+	union	recv_frame 	*precvframe;
+	_list	*plist, *phead;
+
+_func_enter_;
+	_spinlock(&pframequeue->lock);
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+
+	while(end_of_queue_search(phead, plist) == _FALSE)
+	{
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+
+		plist = get_next(plist);
+		
+		//list_delete(&precvframe->u.hdr.list); // will do this in free_recvframe()
+		
+		free_recvframe(precvframe, pfree_recv_queue);
+	}
+
+	_spinunlock(&pframequeue->lock);
+	
+_func_exit_;
+
+}
+
+
+
+sint recvframe_chkmic(_adapter *adapter,  union recv_frame *precvframe){
+
+	sint 			i,res=_SUCCESS;
+	u32	datalen;
+	u8 miccode[8];
+	u8	bmic_err=_FALSE;
+	u8	*pframe, *payload,*pframemic;
+	u8   *mickey,idx,*iv;
+	struct	sta_info		*stainfo;
+
+	struct	rx_pkt_attrib	*prxattrib=&precvframe->u.hdr.attrib;
+	struct 	security_priv	*psecuritypriv=&adapter->securitypriv;
+	//struct 	recv_stat *prxstat=(struct recv_stat *)precvframe->u.hdr.rx_head;
+	
+_func_enter_;	
+	
+	stainfo=get_stainfo(&adapter->stapriv ,&prxattrib->ta[0] );
+
+	if(prxattrib->encrypt ==_TKIP_)
+        {
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:prxattrib->encrypt ==_TKIP_\n"));
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:da=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+			prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5]));
+
+		//calculate mic code
+		if(stainfo!= NULL)
+                {
+			if(IS_MCAST(prxattrib->ra))
+			{
+                        	iv=precvframe->u.hdr.rx_data+prxattrib->hdrlen;
+				idx=iv[3];
+				mickey=&psecuritypriv->dot118021XGrprxmickey[(( (idx>>6)&0x3 ))-1].skey[0];
+
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic: bcmc key \n"));
+				if(psecuritypriv->binstallGrpkey==_FALSE)
+                                {
+					res=_FAIL;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n"));
+					goto exit;
+				}
+			}
+			else{
+				mickey=&stainfo->dot11tkiprxmickey.skey[0];
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic: unicast key \n"));
+			}
+			datalen=precvframe->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8;//icv_len included the mic code
+			pframe=precvframe->u.hdr.rx_data;
+			payload=pframe+prxattrib->hdrlen+prxattrib->iv_len;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n prxattrib->iv_len=%d prxattrib->icv_len=%d\n",prxattrib->iv_len,prxattrib->icv_len));
+			//seccalctkipmic(&stainfo->dot11tkiprxmickey.skey[0],pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+			seccalctkipmic(mickey,pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+			pframemic=payload+datalen;
+			bmic_err=_FALSE;
+			for(i=0;i<8;i++){
+				if(miccode[i] != *(pframemic+i)){
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",i,miccode[i],i,*(pframemic+i)));
+					bmic_err=_TRUE;
+				}
+			}
+			if(bmic_err==_TRUE){
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+					*(pframemic-8),*(pframemic-7),*(pframemic-6),*(pframemic-5),*(pframemic-4),*(pframemic-3),*(pframemic-2),*(pframemic-1)));
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-16)-*(pframemic-9)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+					*(pframemic-16),*(pframemic-15),*(pframemic-14),*(pframemic-13),*(pframemic-12),*(pframemic-11),*(pframemic-10),*(pframemic-9)));
+
+				{
+					uint i;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ======demp packet (len=%d)======\n",precvframe->u.hdr.len));
+					for(i=0;i<precvframe->u.hdr.len;i=i+8){
+						RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x",
+							*(precvframe->u.hdr.rx_data+i),*(precvframe->u.hdr.rx_data+i+1),
+							*(precvframe->u.hdr.rx_data+i+2),*(precvframe->u.hdr.rx_data+i+3),
+							*(precvframe->u.hdr.rx_data+i+4),*(precvframe->u.hdr.rx_data+i+5),
+							*(precvframe->u.hdr.rx_data+i+6),*(precvframe->u.hdr.rx_data+i+7)));
+					}
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ======demp packet end [len=%d]======\n",precvframe->u.hdr.len));
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n hrdlen=%d, \n",prxattrib->hdrlen));
+				}
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("ra=0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x psecuritypriv->binstallGrpkey=%d ",
+					prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],
+					prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5],psecuritypriv->binstallGrpkey));
+				if(prxattrib->bdecrypted ==_TRUE)
+                                {
+					handle_tkip_mic_err(adapter,(u8)IS_MCAST(prxattrib->ra));
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d ",prxattrib->bdecrypted));
+                                }
+				else
+                                {
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d ",prxattrib->bdecrypted));
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d ",prxattrib->bdecrypted));
+				}
+				res=_FAIL;
+			}
+			else{
+				//mic checked ok
+				if((psecuritypriv->bcheck_grpkey ==_FALSE)&&(IS_MCAST(prxattrib->ra)==_TRUE)){
+					psecuritypriv->bcheck_grpkey =_TRUE;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =_TRUE"));
+				}					
+			}
+			recvframe_pull_tail(precvframe, 8);	
+		}
+		else{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic: get_stainfo==NULL!!!\n"));
+		}
+	}
+exit:	
+_func_exit_;
+	return res;
+}
+
+//decrypt and set the ivlen,icvlen of the recv_frame
+union recv_frame * decryptor(_adapter *padapter,union recv_frame *precv_frame)
+{
+
+	struct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;
+	struct security_priv *psecuritypriv=&padapter->securitypriv;
+	union recv_frame *return_packet=precv_frame;
+	
+_func_enter_;		
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x \n",prxattrib->bdecrypted,prxattrib->encrypt));
+
+       if((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==_TRUE)))
+	{
+		psecuritypriv->hw_decrypted=_FALSE;
+		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("prxstat->decrypted==0 psecuritypriv->hw_decrypted=_FALSE"));
+		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("perfrom software decryption! \n"));
+		
+		//printk("perfrom software decryption!\n");
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("###  software decryption!\n"));
+		switch(prxattrib->encrypt){
+		case _WEP40_:
+		case _WEP104_:
+			wep_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _TKIP_:
+			tkip_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _AES_:
+			aes_decrypt(padapter, (u8 * )precv_frame);
+			break;
+		default:
+				break;
+		}
+	}	
+	else if(prxattrib->bdecrypted==1)
+	{
+#if 0	
+		if((prxstat->icv==1)&&(prxattrib->encrypt!=_AES_))
+		{
+			psecuritypriv->hw_decrypted=_FALSE;
+			
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->hw_decrypted=_FALSE"));
+			
+			free_recvframe(precv_frame, &padapter->recvpriv.free_recv_queue);
+			
+			return_packet=NULL;
+			
+		}
+		else
+#endif			
+		{
+			psecuritypriv->hw_decrypted=_TRUE;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("### psecuritypriv->hw_decrypted=_TRUE"));
+
+		}
+	}
+	
+	//recvframe_chkmic(adapter, precv_frame);   //move to recvframme_defrag function
+	
+_func_exit_;		
+	
+	return return_packet;
+	
+}
+//###set the security information in the recv_frame
+union recv_frame * portctrl(_adapter *adapter,union recv_frame * precv_frame)
+{
+	u8   *psta_addr,*ptr;
+	uint  auth_alg;	
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info * psta;
+	struct	sta_priv *pstapriv ;			
+	union recv_frame * prtnframe;
+	u16	ether_type=0;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	
+_func_enter_;			
+
+	pstapriv = &adapter->stapriv;
+	ptr=get_recvframe_data(precv_frame);
+	pfhdr=&precv_frame->u.hdr;
+	psta_addr=pfhdr->attrib.ta;
+	psta=get_stainfo(pstapriv, psta_addr);
+	
+	auth_alg=adapter->securitypriv.dot11AuthAlgrthm;
+	
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:adapter->securitypriv.dot11AuthAlgrthm= 0x%d\n",adapter->securitypriv.dot11AuthAlgrthm));
+	
+	if(auth_alg==2)
+	{
+		
+	  if((psta!=NULL)&&( psta->ieee8021x_blocked)){
+	  	
+		//blocked
+		//only accept EAPOL frame
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==1\n"));
+		
+		prtnframe=precv_frame;
+		
+				//get ether_type
+		ptr=ptr+pfhdr->attrib.hdrlen+pfhdr->attrib.iv_len+LLC_HEADER_SIZE;
+		 _memcpy(&ether_type,ptr, 2);
+		 ether_type= ntohs((unsigned short )ether_type);
+		 
+		if(ether_type == 0x888e){
+			prtnframe=precv_frame;
+		}
+		else{ 
+
+			//free this frame
+			free_recvframe(precv_frame, &adapter->recvpriv.free_recv_queue);
+			prtnframe=NULL;
+		}			
+	  }
+	  else
+	  { 
+	  	//allowed
+	  	//check decryption status, and decrypt the frame if needed	
+	  	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==0\n"));
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:precv_frame->hdr.attrib.privacy=%x\n",precv_frame->u.hdr.attrib.privacy));
+
+		//prxstat=(struct recv_stat *)(precv_frame->u.hdr.rx_head);	
+		if(pattrib->bdecrypted==0)
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:prxstat->decrypted=%x\n", pattrib->bdecrypted));
+
+	  	prtnframe=precv_frame;
+  		//check is the EAPOL frame or not (Rekey)
+		if(ether_type == 0x888e){
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type == 0x888e\n"));
+			//check Rekey 
+
+			prtnframe=precv_frame;
+			
+		}
+		else{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type = 0x%.4x\n",ether_type));
+		}
+	  }
+	  
+	}
+	else
+	{
+		prtnframe=precv_frame;
+	}	
+	
+_func_exit_;	
+
+		return prtnframe;
+		
+}
+
+sint recv_decache(union recv_frame *precv_frame, u8 bretry, struct stainfo_rxcache *prxcache)
+{
+	sint tid = precv_frame->u.hdr.attrib.priority;
+
+	u16 seq_ctrl = ( (precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) | 
+		(precv_frame->u.hdr.attrib.frag_num & 0xf);
+
+_func_enter_;			
+
+	if(tid>15)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_decache, (tid>15)! seq_ctrl=0x%x, tid=0x%x\n", seq_ctrl, tid));	
+			
+		return _FAIL;
+	}
+
+	if(1)//if(bretry)
+	{
+		if(seq_ctrl == prxcache->tid_rxseq[tid])
+		{			
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_decache, seq_ctrl=0x%x, tid=0x%x, tid_rxseq=0x%x\n", seq_ctrl, tid, prxcache->tid_rxseq[tid]));	
+			
+			return _FAIL;
+		}
+	}
+	
+	prxcache->tid_rxseq[tid] = seq_ctrl;
+	
+_func_exit_;		
+
+	return _SUCCESS;
+
+}
+
+
+sint sta2sta_data_frame(
+	_adapter *adapter, 
+	union recv_frame *precv_frame, 
+ 	struct sta_info**psta
+ )
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	sint ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;	
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	u8 * sta_addr = NULL;
+
+	sint bmcast = IS_MCAST(pattrib->dst);
+	
+_func_enter_;		
+
+ 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) 
+	{
+
+           // filter packets that SA is myself or multicast or broadcast
+	    if (_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+		  RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself \n"));
+		  ret= _FAIL;
+		  goto exit;
+	    }		
+        
+	    if( (!_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
+		  ret= _FAIL;
+		  goto exit;
+	    	}  
+		
+	    if( _memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		   _memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		   (!_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ) {
+			ret= _FAIL;
+			goto exit;
+	    	}
+	    	
+	    sta_addr = pattrib->src;			
+		
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{	
+	      // For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
+		if(!_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("bssid != TA under STATION_MODE; drop pkt\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+	       sta_addr = pattrib->bssid;			
+
+	 }
+	 else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	 {
+	      	if (bmcast)
+		{
+			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
+			if (!IS_MCAST(pattrib->bssid)){
+					ret= _FAIL;
+					goto exit;
+			}
+		}
+		else // not mc-frame
+		{
+			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
+			if(!_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
+				ret= _FAIL;
+				goto exit;
+			}
+
+	       	sta_addr = pattrib->src;			
+		
+		}
+		
+	  }
+	 else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	 {
+              _memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+	       _memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+	       _memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+  	       _memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+              sta_addr = mybssid;	 
+	  }
+	 else
+	 {
+	 	ret  = _FAIL;
+	 }
+
+
+	 
+	if(bmcast)
+		*psta = get_bcmc_stainfo(adapter);
+	else
+		*psta = get_stainfo(pstapriv, sta_addr); // get ap_info
+
+	if (*psta == NULL) {
+	       RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under sta2sta_data_frame ; drop pkt\n"));
+#ifdef CONFIG_MP_INCLUDED		   
+               if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+                    adapter->mppriv.rx_pktloss++;   
+#endif			   
+	       ret= _FAIL;
+		   goto exit;
+	}			
+	 
+exit:
+_func_exit_;		
+	return ret;
+
+}
+
+
+sint ap2sta_data_frame(
+	_adapter *adapter, 
+	union recv_frame *precv_frame, 
+ 	struct sta_info**psta )
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	sint ret = _SUCCESS;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;	
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+_func_enter_;	
+
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE) 
+#ifndef CONFIG_DRVEXT_MODULE			
+		&& (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) 
+#endif			
+		)	
+	{
+	
+	       // if NULL-frame, drop packet
+	      if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
+	      {
+		   	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" NULL frame \n"));	
+			ret= _FAIL;
+			goto exit;
+	           
+	       }
+		   
+		//drop QoS-SubType Data, including QoS NULL, excluding QoS-Data
+		if( (GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE )== WIFI_QOS_DATA_TYPE)
+		{
+			if(GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
+			{
+				ret= _FAIL;
+				goto exit;
+			}
+					
+		}
+		  
+              // filter packets that SA is myself or multicast or broadcast
+	       if (_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+		     RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself \n"));
+			ret= _FAIL;
+			goto exit;
+		}	
+
+		// da should be for me  
+              if((!_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
+              {
+                  RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" ap2sta_data_frame:  compare DA fail; DA= %x:%x:%x:%x:%x:%x \n",
+					pattrib->dst[0],
+					pattrib->dst[1],
+					pattrib->dst[2],
+					pattrib->dst[3],
+					pattrib->dst[4],
+					pattrib->dst[5]));
+				   
+				ret= _FAIL;
+				goto exit;
+              }
+			  
+		
+		// check BSSID
+		if( _memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     _memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     (!_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
+		{
+                    RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" ap2sta_data_frame:  compare BSSID fail ; BSSID=%x:%x:%x:%x:%x:%x\n",
+				pattrib->bssid[0],
+				pattrib->bssid[1],
+				pattrib->bssid[2],
+				pattrib->bssid[3],
+				pattrib->bssid[4],
+				pattrib->bssid[5]));
+				
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("mybssid= %x:%x:%x:%x:%x:%x\n", 
+				mybssid[0],
+				mybssid[1],
+				mybssid[2],
+				mybssid[3],
+				mybssid[4],
+				mybssid[5]));
+                   
+			ret= _FAIL;
+			goto exit;
+			}	
+
+		if(bmcast)
+			*psta = get_bcmc_stainfo(adapter);
+		else
+		       *psta = get_stainfo(pstapriv, pattrib->bssid); // get ap_info
+
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("ap2sta: can't get psta under STATION_MODE ; drop pkt\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+	}
+       else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && 
+		     (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
+	{      
+	       _memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+	       _memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+	       _memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+  	       _memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		//
+		_memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
+		  
+		  
+		   *psta = get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+		if (*psta == NULL) {
+		       RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under MP_MODE ; drop pkt\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+	
+	}
+	else
+	{
+		ret =  _FAIL;
+	}
+	
+exit:	
+	
+_func_exit_;	
+
+	return ret;
+
+}
+
+
+
+
+sint sta2ap_data_frame(
+	_adapter *adapter, 
+	union recv_frame *precv_frame, 
+ 	struct sta_info**psta )
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;	
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	unsigned char *mybssid  = get_bssid(pmlmepriv);
+	unsigned char *myhwaddr = myid(&adapter->eeprompriv);
+	sint ret=_SUCCESS;
+	//sint bmcast = IS_MCAST(pattrib->dst);
+
+_func_enter_;
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{ 
+
+#if 0
+		if (bmcast)
+		{
+			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
+			//bssid = mc-addr => psta=NULL
+
+			//???
+			//if (!IS_MCAST(pattrib->bssid)){
+			//	ret= _FAIL;
+			//	goto exit;
+			//}
+			
+			*psta = get_bcmc_stainfo(adapter);
+			
+		}
+		else // not mc-frame
+#endif			
+		{
+		
+			//??? For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
+			//???if( (!_memcmp(mybssid, pattrib->dst, ETH_ALEN)) || 
+			//For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
+			if(!_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
+			{
+					ret= _FAIL;
+					goto exit;
+				}
+
+			*psta = get_stainfo(pstapriv, pattrib->src);
+
+			if (*psta == NULL)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under AP_MODE; drop pkt\n"));
+				ret= _FAIL;
+				goto exit;
+			}
+			
+		}
+
+	}
+	
+exit:
+	
+_func_exit_;	
+
+	return ret;
+
+}
+
+sint validate_recv_ctrl_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("+validate_recv_ctrl_frame\n"));
+	
+	return _FAIL;
+}
+
+sint validate_recv_mgnt_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+
+#ifdef CONFIG_MLME_EXT
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("+validate_recv_mgnt_frame\n"));
+	
+	mgt_dispatcher(adapter, precv_frame->u.hdr.rx_data, precv_frame->u.hdr.len);
+
+#endif
+	
+	return _FAIL;
+
+}
+
+
+sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	int res;	
+	u8 bretry;
+	u8	*psa, *pda, *pbssid;
+	struct	sta_info	*psta = NULL;
+	
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	uint	frtype = GetFrameType(ptr);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+
+	struct	rx_pkt_attrib	*pattrib = & precv_frame->u.hdr.attrib;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;	
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	NDIS_WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	sint	ret=_SUCCESS;
+
+_func_enter_;	
+
+	bretry = GetRetry(ptr);
+	pda = get_da(ptr);
+	psa = get_sa(ptr);
+	pbssid = get_hdr_bssid(ptr);
+
+#if 0
+{
+	u8 psaddr[6] = {0x00, 0xe0, 0x4c, 0x87, 0x12, 0x22};
+	_memcpy(psa, psaddr, ETH_ALEN);
+}
+#endif
+
+
+
+	if(pbssid == NULL){
+		ret= _FAIL;
+		goto exit;
+	}
+
+	_memcpy(pattrib->dst, pda, ETH_ALEN);
+	_memcpy(pattrib->src, psa, ETH_ALEN);
+	
+	_memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+
+	switch(pattrib->to_fr_ds)
+	{
+		case 0:
+			_memcpy(pattrib->ra, pda, ETH_ALEN);
+			_memcpy(pattrib->ta, psa, ETH_ALEN);
+			res= sta2sta_data_frame(adapter, precv_frame, &psta);
+			break;
+
+		case 1:				
+			_memcpy(pattrib->ra, pda, ETH_ALEN);
+			_memcpy(pattrib->ta, pbssid, ETH_ALEN);
+			res= ap2sta_data_frame(adapter, precv_frame, &psta);
+			break;
+
+		case 2:
+			_memcpy(pattrib->ra, pbssid, ETH_ALEN);
+			_memcpy(pattrib->ta, psa, ETH_ALEN);
+			res= sta2ap_data_frame(adapter, precv_frame, &psta);
+			break;
+		
+		case 3:	
+			_memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+			_memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+                     res=_FAIL;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" case 3\n"));
+			break;		
+			
+		default:
+			res=_FAIL;			
+			break;			
+
+	}
+
+	if(res==_FAIL){
+		//RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" after to_fr_ds_chk; res = fail \n"));
+		ret= res;
+		goto exit;
+	}	
+
+#if 0
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+	{
+		psta = get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n pattrib->bssid=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+		pattrib->bssid[0],pattrib->bssid[1],pattrib->bssid[2],pattrib->bssid[3],pattrib->bssid[4],pattrib->bssid[5]));
+		
+	}
+#endif
+	
+	if(psta==NULL){
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" after to_fr_ds_chk; psta==NULL \n"));
+		ret= _FAIL;
+		goto exit;
+	}
+	else
+	{	
+		//psta->rssi = prxcmd->rssi;
+		//psta->signal_quality= prxcmd->sq;
+		precv_frame->u.hdr.psta = psta;
+	}	
+	
+	if(pcur_bss!=NULL){
+		//pcur_bss->Rssi =  	prxcmd->rssi;
+	}
+
+	pattrib->amsdu=0;
+	//parsing QC field
+	if(pattrib->qos == 1)
+	{
+		pattrib->priority = GetPriority((ptr + 24));
+		pattrib->ack_policy =GetAckpolicy((ptr + 24));
+		pattrib->amsdu = GetAMsdu((ptr + 24));		
+		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 32 : 26;
+	}
+	else
+	{
+		pattrib->priority=0;
+		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 30 : 24;
+	}
+
+
+	if(pattrib->order)//HT-CTRL 11n
+	{
+		pattrib->hdrlen += 4;
+	}
+
+	precv_frame->u.hdr.preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];
+
+	// decache, drop duplicate recv packets
+	if(recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("decache : drop pkt\n"));
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(pattrib->privacy){
+		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("validate_recv_data_frame:pattrib->privacy=%x\n", pattrib->privacy));		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n", pattrib->ra[0],IS_MCAST(pattrib->ra)));
+		
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, IS_MCAST(pattrib->ra));
+		
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n pattrib->encrypt=%d\n",pattrib->encrypt));
+		
+		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len, pattrib->encrypt);
+	}
+	else
+	{
+		pattrib->encrypt = 0;
+		pattrib->iv_len = pattrib->icv_len = 0;
+	}
+		
+exit:
+	
+_func_exit_;
+
+	return ret;
+
+}
+
+
+
+sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	//shall check frame subtype, to / from ds, da, bssid
+	
+	//then call check if rx seq/frag. duplicated.
+
+	u8 type;
+	u8 subtype;
+	sint retval = _SUCCESS;
+	
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	u8  ver =(unsigned char) (*ptr)&0x3 ;
+
+_func_enter_;
+
+	
+#if 0
+MSG_8712("\n");
+{
+	int i;
+	for(i=0; i<64;i=i+8)
+		MSG_8712("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:", *(ptr+i),
+		*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
+
+}	
+MSG_8712("\n");	
+#endif	
+
+	//add version chk
+	if(ver!=0){
+		 RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n  validate_recv_data_frame fail! (ver!=0)\n"));
+		retval= _FAIL;
+		goto exit;
+	}
+	
+	type =  GetFrameType(ptr);
+	subtype = GetFrameSubType(ptr); //bit(7)~bit(2)
+
+	pattrib->to_fr_ds = get_tofr_ds(ptr);
+	 
+	pattrib->frag_num = GetFragNum(ptr);
+	pattrib->seq_num = GetSequence(ptr);
+
+	pattrib->pw_save = GetPwrMgt(ptr);
+	pattrib->mfrag = GetMFrag(ptr);
+	pattrib->mdata = GetMData(ptr);	
+	pattrib->privacy =  GetPrivacy(ptr);
+	pattrib->order = GetOrder(ptr);
+
+
+
+	switch(type)
+	{
+		case WIFI_MGT_TYPE: //mgnt
+			  retval=validate_recv_mgnt_frame(adapter, precv_frame);
+			  if (retval==_FAIL)
+                          {
+			  RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n  validate_recv_mgnt_frame fail\n"));
+                          }
+			  break;
+		case WIFI_CTRL_TYPE://ctrl
+			  retval=validate_recv_ctrl_frame(adapter, precv_frame);
+			   if (retval==_FAIL)
+			  {
+			  RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n  validate_recv_ctrl_frame fail\n"));
+                          }
+			  break;
+		case WIFI_DATA_TYPE: //data 
+			pattrib->qos = (subtype & BIT(7))? 1:0;
+			retval=validate_recv_data_frame(adapter, precv_frame);
+			if (retval==_FAIL)
+                        {
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("  validate_recv_data_frame fail\n"));
+                        }
+			break;
+		default:
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("  validate_recv_data_frame fail! type=0x%x\n", type));
+			  retval=_FAIL;
+			  break;
+			
+	}
+	
+exit:
+	
+_func_exit_;	
+
+	return retval;
+
+}
+
+#if 1
+sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
+{
+	//remove the wlanhdr and add the eth_hdr
+	sint	rmv_len;
+	u16	eth_type, len;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr	*psnap;
+	
+	sint ret=_SUCCESS;
+	_adapter			*adapter =precvframe->u.hdr.adapter;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8	*ptr = get_recvframe_data(precvframe) ; // point to frame_ctrl field
+	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
+
+_func_enter_;
+
+	if(pattrib->encrypt){
+		recvframe_pull_tail(precvframe, pattrib->icv_len);	
+	}
+
+	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+	/* convert hdr + possible LLC headers into Ethernet header */
+	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
+	if((_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
+		(_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == _FALSE) && 
+		(_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==_FALSE) )||
+		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		 _memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		bsnaphdr = _TRUE;
+	}
+	else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = _FALSE;
+	}
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+	len = precvframe->u.hdr.len - rmv_len;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", pattrib->hdrlen,  pattrib->iv_len));
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))	   	
+	{
+		ptr += rmv_len ;	
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+
+		eth_type = 0x8712;
+		// append rx status for mp test packets
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
+		_memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr+=24;
+	}
+	else {
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+ (bsnaphdr?2:0)));
+	}
+
+	_memcpy(ptr, pattrib->dst, ETH_ALEN);
+	_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	if(!bsnaphdr) {
+		len = htons(len);
+		_memcpy(ptr+12, &len, 2);
+	}
+
+exit:	
+_func_exit_;	
+	return ret;
+
+}
+#else
+sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
+{
+	//remove the wlanhdr and add the eth_hdr
+
+	sint rmv_len;
+	u16 eth_type;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr	*psnap;
+	
+	sint ret=_SUCCESS;
+	_adapter	*adapter =precvframe->u.hdr.adapter;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8* ptr = get_recvframe_data(precvframe) ; // point to frame_ctrl field
+	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
+        struct _vlan *pvlan = NULL;
+
+_func_enter_;	
+
+	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+	 if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03) {
+		 if ( _memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)) {
+   			bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;
+  		}
+  		else if (_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
+     			_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
+    			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
+  		else if (_memcmp( psnap->oui, oui_8021h, WLAN_IEEE_OUI_LEN))
+   			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL;
+  		else {
+  			 RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("drop pkt due to invalid frame format!\n"));
+   			ret= _FAIL;
+			goto exit;
+ 		 }
+ 	}
+	 else
+  		bsnaphdr=_FALSE;//wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS;
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", pattrib->hdrlen,  pattrib->iv_len));
+	
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))	   	
+       {
+	   ptr += rmv_len ;	
+          *ptr = 0x87;
+	   *(ptr+1) = 0x12;
+	   
+	    //back to original pointer	 
+	    ptr -= rmv_len;          
+        } 
+	
+	ptr += rmv_len ;
+
+	_memcpy(&eth_type, ptr, 2);
+	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+
+	ptr +=2;
+	
+	if(pattrib->encrypt){
+		recvframe_pull_tail(precvframe, pattrib->icv_len);	
+	}
+	
+	if(eth_type == 0x8100) //vlan
+	{
+		pvlan = (struct _vlan *) ptr;
+		
+		//eth_type = get_vlan_encap_proto(pvlan);
+                //eth_type = pvlan->h_vlan_encapsulated_proto;//?
+		rmv_len += 4;
+		ptr+=4;
+	}
+
+	if(eth_type==0x0800)//ip 
+	{
+		struct iphdr*  piphdr = (struct iphdr*) ptr;
+		//__u8 tos = (unsigned char)(pattrib->priority & 0xff);
+
+		//piphdr->tos = tos;
+
+		if (piphdr->protocol == 0x06)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("@@@===recv tcp len:%d @@@===\n", precvframe->u.hdr.len));
+		}
+	}
+	else if(eth_type==0x8712)// append rx status for mp test packets
+	{
+	       //ptr -= 16;
+	       //_memcpy(ptr, get_rxmem(precvframe), 16);		 
+	}
+	else
+	{
+#ifdef PLATFORM_OS_XP
+		NDIS_PACKET_8021Q_INFO VlanPriInfo;
+		UINT32 UserPriority = precvframe->u.hdr.attrib.priority;
+		UINT32 VlanID = (pvlan!=NULL ? get_vlan_id(pvlan) : 0 );
+
+		VlanPriInfo.Value =          // Get current value.
+      			NDIS_PER_PACKET_INFO_FROM_PACKET(precvframe->u.hdr.pkt, Ieee8021QInfo); 
+
+		VlanPriInfo.TagHeader.UserPriority = UserPriority;
+		VlanPriInfo.TagHeader.VlanId =  VlanID ;
+
+		VlanPriInfo.TagHeader.CanonicalFormatId = 0; // Should be zero.
+		VlanPriInfo.TagHeader.Reserved = 0; // Should be zero.
+		NDIS_PER_PACKET_INFO_FROM_PACKET(precvframe->u.hdr.pkt, Ieee8021QInfo) = VlanPriInfo.Value;	
+#endif		
+	}
+
+       if(eth_type==0x8712)// append rx status for mp test packets
+      	{
+              ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);       
+	       _memcpy(ptr, get_rxmem(precvframe), 24);		
+             ptr+=24;			  
+      	}
+       else
+	ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2));
+
+	_memcpy(ptr, pattrib->dst, ETH_ALEN);
+	_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	eth_type = htons((unsigned short)eth_type) ;
+	_memcpy(ptr+12, &eth_type, 2);
+exit:	
+_func_exit_;	
+	return ret;
+
+}
+#endif
+
+s32 recv_entry(union recv_frame *precvframe)
+{
+	_adapter *padapter;
+	struct recv_priv *precvpriv;
+	struct	mlme_priv	*pmlmepriv ;
+	 struct dvobj_priv *pdev;		
+	struct recv_stat *prxstat; 
+	 u8 *phead, *pdata, *ptail,*pend;    
+
+	_queue *pfree_recv_queue, *ppending_recv_queue;
+	u8 blk_mode = _FALSE;
+	s32 ret=_SUCCESS;	
+	struct intf_hdl * pintfhdl;
+
+_func_enter_;
+
+	//RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("+recv_entry\n"));
+
+	padapter=precvframe->u.hdr.adapter;
+	pintfhdl=&padapter->pio_queue->intf;
+
+	pmlmepriv = &padapter->mlmepriv;
+	precvpriv = &(padapter->recvpriv);
+	pdev=&padapter->dvobjpriv;	
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	ppending_recv_queue = &(precvpriv->recv_pending_queue);
+
+	phead=precvframe->u.hdr.rx_head;
+	pdata=precvframe->u.hdr.rx_data;
+	ptail=precvframe->u.hdr.rx_tail;
+	pend=precvframe->u.hdr.rx_end;  
+	prxstat=(struct recv_stat *)phead;	
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);
+
+#ifdef CONFIG_SDIO_HCI
+	if(precvpriv->free_recvframe_cnt >1)
+#endif		
+	{
+#ifdef CONFIG_RECV_THREAD_MODE
+ 		if(_queue_empty(ppending_recv_queue) == _TRUE)
+		{		
+			//enqueue_recvframe_usb(precvframe, ppending_recv_queue);//enqueue to recv_pending_queue
+		 	enqueue_recvframe(precvframe, ppending_recv_queue);
+			_up_sema(&precvpriv->recv_sema);
+		}
+		else 	
+		{	
+			//enqueue_recvframe_usb(precvframe, ppending_recv_queue);//enqueue to recv_pending_queue
+			 enqueue_recvframe(precvframe, ppending_recv_queue);
+		}	
+#else
+
+#ifdef CONFIG_RECV_BH
+		#ifdef PLATFORM_LINUX
+		
+		if(_queue_empty(ppending_recv_queue) == _TRUE)
+		{
+			enqueue_recvframe(precvframe, ppending_recv_queue);
+			tasklet_hi_schedule(&precvpriv->recv_tasklet);
+		}
+		else
+		{
+			enqueue_recvframe(precvframe, ppending_recv_queue);
+		}
+		
+		#endif
+#else
+		if((ret = recv_func(padapter, precvframe)) == _FAIL)
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recv_entry: recv_func return fail!!!\n"));
+			goto _recv_entry_drop;
+		}	
+#endif		
+
+#endif
+	   	precvpriv->rx_pkts++;
+		
+	}
+#ifdef CONFIG_SDIO_HCI	
+	else
+		goto _recv_entry_drop;
+#endif	
+
+
+_func_exit_;	
+
+	   return ret;
+	
+_recv_entry_drop:
+	
+
+	precvpriv->rx_drop++;	
+
+#ifdef CONFIG_MP_INCLUDED	
+	padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
+#endif
+
+       //RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("_recv_entry_drop\n"));
+
+_func_exit_;	
+
+	return ret;
+
+}
+
diff --git a/drivers/net/wireless/8712u/rf/rtl8712_rf.c b/drivers/net/wireless/8712u/rf/rtl8712_rf.c
new file mode 100755
index 0000000..6b747aa
--- /dev/null
+++ b/drivers/net/wireless/8712u/rf/rtl8712_rf.c
@@ -0,0 +1,508 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL8712_RF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+//io_cmd format : (class<<24)|index
+//Rate Adaptive related
+#define IOCMD_CLS_FD_IDX_A0 0xFD0000A0
+#define IOCMD_CLS_FD_IDX_A1 0xFD0000A1
+#define IOCMD_CLS_FD_IDX_A2 0xFD0000A2
+#define IOCMD_CLS_FD_IDX_A3 0xFD0000A3
+#define IOCMD_CLS_FD_IDX_A4 0xFD0000A4
+#define IOCMD_CLS_FD_IDX_A5 0xFD0000A5
+#define IOCMD_CLS_FD_IDX_A6 0xFD0000A6
+#define IOCMD_CLS_FD_IDX_A7 0xFD0000A7
+#define IOCMD_CLS_FD_IDX_A8 0xFD0000A8
+#define IOCMD_CLS_FD_IDX_A9 0xFD0000A9
+#define IOCMD_CLS_FD_IDX_AF 0xFD0000AF
+
+//BB/RF register read/write
+#define IOCMD_CLS_F0_IDX_00 0xF0000000 //BB_READ
+#define IOCMD_CLS_F0_IDX_01 0xF0000001 //BB_WRITE
+#define IOCMD_CLS_F0_IDX_02 0xF0000002 //RF_READ
+#define IOCMD_CLS_F0_IDX_03 0xF0000003 //RF_WRIT
+#define IOCMD_CLS_F0_IDX_04 0xF0000004	//read EEPROM/EFUSE content
+
+
+
+//#define	bMaskDWord	0xffffffff
+
+#define	bMask20Bits        0xfffff	// RF Reg mask bits T65 RF
+
+#define	HST_RDBUSY		BIT(0)
+
+// The following two definition are only used for USB interface.
+#if 0
+#define	RF_BB_CMD_ADDR			0x02c0	// RF/BB read/write command address.
+#define	RF_BB_CMD_DATA			0x02c4	// RF/BB read/write command data.
+#else
+#define	RF_BB_CMD_ADDR			0x10250370
+#define	RF_BB_CMD_DATA			0x10250374
+#endif
+
+#define IOCMD_CTRL_ADDR		RF_BB_CMD_ADDR
+#define IOCMD_DATA_ADDR		RF_BB_CMD_DATA
+
+
+/**
+* Function:	phy_CalculateBitShift
+*
+* OverView:	Get shifted position of the BitMask
+*
+* Input:
+*			u4Byte		BitMask,	
+*
+* Output:	none
+* Return:		u4Byte		Return the shift bit bit position of the mask
+*/
+static u32 phy_CalculateBitShift(u32 BitMask)
+{
+	u32 i;
+
+	for(i=0; i<=31; i++)
+	{
+		if ( ((BitMask>>i) &  0x1 ) == 1)
+			break;
+	}
+
+	return (i);
+}
+
+u32 phy_QueryBBReg(IN PADAPTER	Adapter, IN u32 RegAddr)
+{	
+	u32	ReturnValue = 0xffffffff;
+	u8	PollingCnt = 50;	
+	
+	read32(Adapter, RegAddr);	
+
+	do
+	{
+		// Make sure that access could be done.
+		if((read8(Adapter, PHY_REG_RPT)&HST_RDBUSY) == 0)
+			break;
+		
+	}while( --PollingCnt );
+
+	if(PollingCnt == 0)
+	{
+		//ERR_8712 ("Fail!!!phy_QueryBBReg(): RegAddr(%#x) = %#x\n", RegAddr, ReturnValue);
+	}
+	else
+	{
+		// Data FW read back.
+		ReturnValue = read32(Adapter, PHY_REG_DATA);		
+	}
+
+	return ReturnValue;
+	
+}
+
+void phy_SetBBReg(IN	PADAPTER Adapter, IN	u32 RegAddr, IN	u32 Data)
+{
+	write32(Adapter, RegAddr, Data);	
+}
+
+u32 phy_QueryRFReg(
+	IN	PADAPTER	Adapter,
+	IN	int			eRFPath,
+	IN	u32			Offset
+	)
+{	
+	u32	ReturnValue = 0;	
+	u8	PollingCnt = 50;
+
+
+	Offset &= 0x3f; //RF_Offset= 0x00~0x3F		
+	
+	write32(Adapter, RF_BB_CMD_ADDR, 0xF0000002|(Offset<<8)|//RF_Offset= 0x00~0x3F
+											(eRFPath<<16)); 	//RF_Path = 0(A) or 1(B)
+	
+	do
+	{
+		// Make sure that access could be done.
+		if(read32(Adapter, RF_BB_CMD_ADDR) == 0)
+			break;
+		
+	}while( --PollingCnt );
+
+	// Data FW read back.
+	ReturnValue = read32(Adapter, RF_BB_CMD_DATA);	
+	
+	return ReturnValue;
+
+}
+
+void phy_SetRFReg(
+	IN	PADAPTER	Adapter,
+	IN	int			eRFPath,
+	IN	u32			RegAddr,
+	IN	u32			Data
+	)
+{
+	u8	PollingCnt = 50;
+	
+	
+	RegAddr &= 0x3f; //RF_Offset= 0x00~0x3F
+	
+	write32(Adapter, RF_BB_CMD_DATA, Data);	
+	write32(Adapter, RF_BB_CMD_ADDR, 0xF0000003|(RegAddr<<8)| //RF_Offset= 0x00~0x3F
+												(eRFPath<<16));  //RF_Path = 0(A) or 1(B)
+	
+	do
+	{
+		// Make sure that access could be done.
+		if(read32(Adapter, RF_BB_CMD_ADDR) == 0)
+				break;
+		
+	}while( --PollingCnt );		
+
+	if(PollingCnt == 0)
+	{		
+		//ERR_8712("phy_SetRFReg(): Set RegAddr(%#x) = %#x Fail!!!\n", RegAddr, Data);
+	}
+	
+
+}
+
+void SetBBReg(PADAPTER padapter, u32 addr, u32 bitmask, u32 data)
+{
+	u32	OriginalValue, BitShift, NewValue;
+
+	if(bitmask!= bMaskDWord)//if not "double word" write
+	{		
+		OriginalValue = phy_QueryBBReg(padapter, addr);
+		BitShift = phy_CalculateBitShift(bitmask);
+            	NewValue = ((OriginalValue & (~bitmask)) | (data << BitShift));
+		phy_SetBBReg(padapter, addr, NewValue);	
+	}
+	else
+	{
+		phy_SetBBReg(padapter, addr, data);	
+	}	
+
+}
+
+u32 QueryBBReg(PADAPTER padapter, u32 addr, u32 bitmask)
+{
+  	u32	ReturnValue = 0, OriginalValue, BitShift;
+
+	//
+	// <Roger_Notes> Due to 8051 operation cycle (limitation cycle: 6us) and 1-Byte access issue, we should use 
+	// 4181 to access Base Band instead of 8051 on USB interface to make sure that access could be done in 
+	// infinite cycle.
+	// 2008.09.06.
+	//
+
+	OriginalValue = phy_QueryBBReg(padapter, addr);
+	
+	if(bitmask!= bMaskDWord)//if not "double word" write
+	{		
+		//OriginalValue = phy_QueryBBReg(padapter, addr);
+
+		BitShift = phy_CalculateBitShift(bitmask);
+		ReturnValue = (OriginalValue & bitmask) >> BitShift;
+	}
+	else
+	{
+		//ReturnValue = phy_QueryBBReg(padapter, addr);
+		ReturnValue = OriginalValue;
+	}
+
+	return (ReturnValue);	
+	
+}
+
+void SetRFReg(PADAPTER padapter, int rfpath, u32 addr, u32 bitmask, u32 data)
+{	
+	u32 	Original_Value, BitShift, New_Value;
+
+#if 0//gtest
+	if (!Adapter->HalFunc.PHYCheckIsLegalRfPathHandler(Adapter, eRFPath))
+	{
+		return;
+	}
+#endif
+
+	//
+	// <Roger_Notes> Due to 8051 operation cycle (limitation cycle: 6us) and 1-Byte access issue, we should use 
+	// 4181 to access Base Band instead of 8051 on USB interface to make sure that access could be done in 
+	// infinite cycle.
+	// 2008.09.06.
+	//
+
+	if (bitmask != bMask20Bits) // RF data is 12 bits only
+	{
+		Original_Value = phy_QueryRFReg(padapter, rfpath, addr);
+		BitShift =  phy_CalculateBitShift(bitmask);
+		New_Value = ((Original_Value & (~bitmask)) | (data<< BitShift));
+		phy_SetRFReg(padapter, rfpath, addr, New_Value);
+	}
+	else
+	{
+		phy_SetRFReg(padapter, rfpath, addr, data);
+	}	
+	
+}
+
+u32 QueryRFReg(PADAPTER padapter, int rfpath, u32 addr, u32 bitmask)
+{
+	u32 Original_Value, Readback_Value, BitShift;
+
+	Original_Value = phy_QueryRFReg(padapter, rfpath, addr);
+
+	if(bitmask != bMask20Bits)
+	{
+		BitShift =  phy_CalculateBitShift(bitmask);
+		Readback_Value = (Original_Value & bitmask) >> BitShift;	
+	}
+	else
+	{
+		Readback_Value = Original_Value;
+	}
+	
+	return (Readback_Value);
+}
+
+static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+	for(i=0; i<=31; i++){
+		if ( ((bitmask>>i) &  0x1 ) == 1)	break;
+	}
+	return (i);
+}
+
+static u32 fw_iocmd_read(PADAPTER pAdapter , u32 iocmd)
+{
+	u32 cmd32 = 0, val32 = 0;	
+	int pollingcnts = 50;
+
+	
+	cmd32 = cpu_to_le32(iocmd);	
+		
+	write32(pAdapter, IOCMD_CTRL_ADDR, cmd32);
+	
+	//usleep_os(100);
+	
+	while( (0 != read32(pAdapter, IOCMD_CTRL_ADDR) ) && (pollingcnts>0) ){
+			
+		pollingcnts--;
+		usleep_os(10);
+	}
+
+	if( pollingcnts != 0){	
+		val32 = read32(pAdapter, IOCMD_DATA_ADDR);
+	}
+	else{//time out	
+		val32 = 0;
+		//DBG_8712 ("fw_iocmd_read timeout ........\n");
+	}
+			
+	return le32_to_cpu(val32);
+	
+}
+
+static u8 fw_iocmd_write(PADAPTER pAdapter , u32 iocmd, u32 value)
+{
+	u32 cmd32 = 0;
+	int	pollingcnts = 50;
+
+	while( (0 != read32(pAdapter, IOCMD_CTRL_ADDR)) && (pollingcnts>0) )
+	{
+		usleep_os(10);
+		pollingcnts--;
+	}
+	pollingcnts = 50;
+	
+	write32(pAdapter, IOCMD_DATA_ADDR, cpu_to_le32(value));
+	
+	//usleep_os(100);
+	
+	cmd32 = cpu_to_le32(iocmd);
+	
+	write32(pAdapter, IOCMD_CTRL_ADDR , cmd32);	  	
+	
+	//usleep_os(100);
+	
+	while( (0 != read32(pAdapter, IOCMD_CTRL_ADDR)) && (pollingcnts>0) )
+	{
+		usleep_os(10);
+		pollingcnts--;
+	}
+
+	return (pollingcnts == 0) ?_TRUE : _FALSE ;
+	
+}
+
+int set_ratid_cmd(PADAPTER pAdapter, unsigned short param, unsigned int bitmap)
+{	
+	u8 ret;
+	u32 iocmd =  0xfd0000a2 | ((param<<8)	&0x00ffff00) ; 
+	
+	ret = fw_iocmd_write(pAdapter, iocmd, bitmap);
+
+	return ((ret) ? _TRUE:_FALSE);
+}
+
+static u32 bb_read_cmd(PADAPTER pAdapter, u16 offset)// offset : 0X800~0XFFF 
+{	
+	u16 bb_addr = offset & 0x0FFF;
+	u32 bb_val, iocmd;
+	
+	iocmd = IOCMD_CLS_F0_IDX_00 | (bb_addr<<8) ; 
+		
+	bb_val = fw_iocmd_read(pAdapter, iocmd);
+	
+	return bb_val;	
+}
+
+static u8 bb_write_cmd(PADAPTER pAdapter, u16 offset, u32 value)// offset : 0X800~0XFFF 
+{
+	u32 iocmd;
+	u16 bb_addr = offset & 0x0FFF  ;
+
+	iocmd = IOCMD_CLS_F0_IDX_01 | (bb_addr<<8) ; 
+	
+	return fw_iocmd_write(pAdapter, iocmd , value);
+}
+
+static u32 rf_read_cmd(PADAPTER pAdapter, u8 path, u8 offset) // offset : 0x00 ~ 0xFF
+{	
+	u16 rf_addr;
+	u32 rf_data, iocmd;
+	
+	rf_addr = (path << 8 ) | offset;
+	iocmd = IOCMD_CLS_F0_IDX_02 | (rf_addr<<8) ; 
+
+	rf_data =  fw_iocmd_read(pAdapter, iocmd);
+	
+	return rf_data;
+	
+}
+static u8 rf_write_cmd(PADAPTER pAdapter, u8 path, u8 offset, u32 value)
+{	
+	u16 rf_addr;
+	u32 rf_data, iocmd;
+	
+	rf_addr = (path << 8 ) | offset;
+	iocmd = IOCMD_CLS_F0_IDX_03 | (rf_addr<<8) ;
+
+	return fw_iocmd_write(pAdapter, iocmd , value);	
+}
+
+u32 get_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask)	
+{
+	u32 org_value,bit_shift,new_value;
+	
+	org_value = bb_read_cmd(pAdapter ,offset);
+
+	bit_shift = bitshift(bitmask);
+		
+	new_value =( org_value & bitmask) >> bit_shift;
+	
+	return new_value;
+}
+u8 set_bbreg(PADAPTER pAdapter, u16 offset, u32 bitmask, u32 value)
+{
+	u32 org_value,bit_shift,new_value;
+	
+	if(bitmask!=bMaskDWord)
+	{		
+		org_value = bb_read_cmd(pAdapter ,offset);		
+		bit_shift = bitshift(bitmask);
+		new_value =  ((org_value &  (~bitmask)) | (value << bit_shift) );
+		//DBG_8712("set_bbreg #2  offset :0x%04x org:0x%08x  new:0x%08x.........\n",offset,org_value,new_value);
+	}
+	else
+	{
+		new_value = value;
+		//DBG_8712("set_bbreg #2  offset :0x%04x data:0x%08x.........\n",offset,new_value);
+	}
+	
+	return bb_write_cmd(pAdapter,offset,new_value);
+}
+
+u32 get_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask)
+{
+	u32 org_value,bit_shift,new_value;
+	
+	org_value = rf_read_cmd(pAdapter , path, offset) ;
+	
+	bit_shift = bitshift(bitmask);
+	
+	new_value =( org_value & bitmask) >> bit_shift;
+		
+	return new_value;
+} 
+
+u8 set_rfreg(PADAPTER pAdapter, u8 path, u8 offset, u32 bitmask, u32 value)
+{
+	u32 org_value,bit_shift,new_value;
+	
+	if(bitmask!=bMaskDWord)
+	{	
+		org_value = rf_read_cmd(pAdapter , path, offset) ;
+		bit_shift = bitshift(bitmask);
+		new_value =  ((org_value &  (~bitmask)) | (value << bit_shift) );
+		
+		//DBG_8712("set_rfreg #2  v:0x%08x org:0x%08x  new:0x%08x.........\n", value, org_value, new_value);
+	}
+	else
+	{
+		new_value = 	value ;
+		//DBG_8712("set_rfreg #2  v:0x%08x data:0x%08x.........\n", value, new_value);
+	}
+	
+	return rf_write_cmd(pAdapter,path,offset,new_value);
+	
+}
+
+
+u32 get_efuse_content(_adapter *padapter, u16 offset)
+{
+	u32 iocmd;	
+	u16 addr = offset & 0xFFFF;	
+	
+	iocmd = IOCMD_CLS_F0_IDX_04 | (addr<<8) ; 
+		
+	return fw_iocmd_read(padapter, iocmd);
+
+}
+
+void dump_efuse_content(_adapter *padapter, unsigned int *pbuf, int sz)
+{
+	int i, limit;
+	
+
+	limit = sz>>2;
+	
+
+	for(i=0; i<limit; i++)
+	{
+		*(pbuf+i) = get_efuse_content(padapter, (i<<2));		
+	}
+	
+}
+
diff --git a/drivers/net/wireless/8712u/rf/rtl871x_rf.c b/drivers/net/wireless/8712u/rf/rtl871x_rf.c
new file mode 100755
index 0000000..cbd390c
--- /dev/null
+++ b/drivers/net/wireless/8712u/rf/rtl871x_rf.c
@@ -0,0 +1,529 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_RF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+
+#define _A_BAND		BIT(1)
+
+void init_phyinfo(_adapter  *adapter, struct setphyinfo_parm* psetphyinfopara);
+
+#define channel2freq(starting_freq, channel) \
+	((starting_freq + (5 * channel)))
+
+u32 ch2freq(u32 ch)
+{
+	u32 starting_freq;
+	
+	if (ch <= 14)
+		starting_freq = 2412;
+		
+	else if (ch >= 180)
+		starting_freq = 4000;
+	
+	else 
+		starting_freq = 5000;
+		
+	return channel2freq(starting_freq, ch);
+		
+}
+
+u32 freq2ch(u32 freq)
+{
+	u32 starting_freq;
+	
+	if (freq > 5000)
+	
+		starting_freq = 5000;
+	
+	else if (freq > 4000)
+			
+		starting_freq = 4000;
+		
+	else
+	{
+		starting_freq = 2412;
+		return ((freq - starting_freq)/5 + 1);
+	}	
+		
+	return ((freq - starting_freq)/5);
+
+}
+
+
+void set_channelset_a(_adapter  *padapter, struct regulatory_class *reg_class, u8 index, u8 channel_set)
+{
+
+	struct eeprom_priv* peeprompriv = &padapter->eeprompriv;
+
+	reg_class->channel_set[index] = channel_set;
+	
+	reg_class->modem = OFDM_PHY;	
+
+	reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_a[channel_set];
+	
+	
+}
+
+
+void set_channelset_bg(_adapter  *padapter, struct regulatory_class *reg_class, u8 index, u8 channel_set)
+{
+	struct eeprom_priv* peeprompriv = &padapter->eeprompriv;
+
+	reg_class->channel_set[index] = channel_set;
+	
+	reg_class->modem = MIXED_PHY;	
+
+	switch(channel_set)
+	{	
+		case 1:
+		case 2:
+		case 3:
+			reg_class->channel_cck_power[index] = peeprompriv->tx_power_b[1];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[1];
+			break;
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+		case 8:
+			reg_class->channel_cck_power[index] =   peeprompriv->tx_power_b[6];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[6];
+			break;
+		case 9:
+		case 10:
+		case 11:
+		case 12:
+		case 13:
+			reg_class->channel_cck_power[index] = peeprompriv->tx_power_b[11];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[11];
+			break;
+		case 14:
+			reg_class->channel_cck_power[index] = peeprompriv->tx_power_b[14];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[14];
+			break;
+		default:
+			break;
+			
+	}
+	
+}
+
+		
+
+/*! \init_phyinfo:
+	Init data for country information element and regulatory classes.
+
+	If you need to add the additional countries/regions:
+	1.) Please add the case in the switch-case options for each necessary country/region.
+	2.) For each country/region, you can add 1~NUM_REGULATORYS regulatory class(es).
+	     (Driver's NUM_REGULATORYS must have the same value with FW corres. value)
+	3.) For each regulatory class, you need to supply these items:
+		- Channel starting frequency (MHz):
+		   psetphyinfopara->class_sets[class_index].starting_freq
+		- Channel sets:
+		   For each channel set, please call ->
+		   a.) 802.11b/g 
+			 set_channelset_bg(adapter, &psetphyinfopara->class_sets[class_index], channel_set_index, channel_set);
+		   b.) 802.11a
+			 set_channelset_a(adapter, &psetphyinfopara->class_sets[class_index], channel_set_index, channel_set);			 
+  		- Channel spacing (MHz):  
+         	   psetphyinfopara->class_sets[class_index].channel_spacing
+         	- Transmit power limit (dBm):   
+  		   psetphyinfopara->class_sets[class_index].txpower_limit
+*/     	   	  
+void init_phyinfo(_adapter  *adapter, struct setphyinfo_parm* psetphyinfopara)
+{
+
+	struct eeprom_priv* peeprompriv = &adapter->eeprompriv;
+	unsigned long country_string = (unsigned long)(peeprompriv->country_string[0])<<16 | (unsigned long)(peeprompriv->country_string[1])<<8 | (peeprompriv->country_string[2]);
+
+	switch(country_string)
+	{
+	
+		case USA:
+
+			/***** Regulatory domain for 802.11b/g *****/
+
+			//Regulatory domain in 802.11 b/g -> class_sets[0]
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 0, 1);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 1, 2);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 2, 3);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 3, 4);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 4, 5);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 5, 6);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 6, 7);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 7, 8);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 8, 9);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 9, 10);					
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 10, 11);
+
+
+			/***** Regulatory domain for 802.11A *****/
+			if(peeprompriv->sys_config & _A_BAND) //if A band exists in EEPROM setting
+			{
+			//Regulatory class 1-> class_sets[1]
+			psetphyinfopara->class_sets[1].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 0, 36);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 1, 40);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 2, 44);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 3, 48);		
+			psetphyinfopara->class_sets[1].channel_spacing = 20;
+			psetphyinfopara->class_sets[1].txpower_limit = 16;
+
+			//Regulatory class 2 -> class_sets[2]
+			psetphyinfopara->class_sets[2].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 0, 52);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 1, 56);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 2, 60);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 3, 64);		
+			psetphyinfopara->class_sets[2].channel_spacing = 20;
+			psetphyinfopara->class_sets[2].txpower_limit = 23;
+
+			//Regulatory class 3 -> class_sets[3]
+			psetphyinfopara->class_sets[3].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 0, 149);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 1, 153);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 2, 157);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 3, 161);		
+			psetphyinfopara->class_sets[3].channel_spacing = 20;
+			psetphyinfopara->class_sets[3].txpower_limit = 29;			
+			}
+				
+			break;
+			
+		case EUROPE:
+			
+			/***** Regulatory domain for 802.11b/g *****/
+
+			//Regulatory domain in 802.11 b/g -> class_sets[0]
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 0, 1);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 1, 2);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 2, 3);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 3, 4);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 4, 5);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 5, 6);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 6, 7);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 7, 8);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 8, 9);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 9, 10);					
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 10, 11);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 11, 12);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 12, 13);			
+
+
+			/***** Regulatory domain for 802.11a *****/
+		
+			if(peeprompriv->sys_config & _A_BAND) //if A band exists in EEPROM setting
+			{
+			//Regulatory class 1-> class_sets[1]
+			psetphyinfopara->class_sets[1].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 0, 36);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 1, 40);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 2, 44);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 3, 48);		
+			psetphyinfopara->class_sets[1].channel_spacing = 20;
+			psetphyinfopara->class_sets[1].txpower_limit = 23;
+
+			//Regulatory class 2 -> class_sets[2]
+			psetphyinfopara->class_sets[2].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 0, 52);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 1, 56);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 2, 60);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 3, 64);		
+			psetphyinfopara->class_sets[2].channel_spacing = 20;
+			psetphyinfopara->class_sets[2].txpower_limit = 23;
+
+			//Regulatory class 3 -> class_sets[3]
+			psetphyinfopara->class_sets[3].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 0, 100);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 1, 104);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 2, 108);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 3, 112);		
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 4, 116);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 5, 120);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 6, 124);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 7, 128);	
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 8, 132);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 9, 136);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 10, 140);			
+			psetphyinfopara->class_sets[3].channel_spacing = 20;
+			psetphyinfopara->class_sets[3].txpower_limit = 30;			
+			}	
+			
+			break;
+			
+		case JAPAN:
+			
+			/***** Regulatory domain for 802.11b/g *****/
+
+			//Regulatory domain in 802.11 b/g -> class_sets[0]
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 0, 1);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 1, 2);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 2, 3);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 3, 4);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 4, 5);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 5, 6);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 6, 7);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 7, 8);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 8, 9);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 9, 10);					
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 10, 11);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 11, 12);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 12, 13);			
+
+
+			/***** Regulatory domain for 802.11a *****/
+			if(peeprompriv->sys_config & _A_BAND) //if A band exists in EEPROM setting
+			{		
+			//Regulatory class 1-> class_sets[1]
+			psetphyinfopara->class_sets[1].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 0, 34);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 1, 38);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 2, 42);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 3, 46);		
+			psetphyinfopara->class_sets[1].channel_spacing = 20;
+			psetphyinfopara->class_sets[1].txpower_limit = 22;
+
+			//Regulatory class 2 -> class_sets[2]
+			psetphyinfopara->class_sets[2].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 2, 16);			
+			psetphyinfopara->class_sets[2].channel_spacing = 20;
+			psetphyinfopara->class_sets[2].txpower_limit = 24;
+
+			//Regulatory class 3 -> class_sets[3]
+			psetphyinfopara->class_sets[3].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 2, 16);			
+			psetphyinfopara->class_sets[3].channel_spacing = 20;
+			psetphyinfopara->class_sets[3].txpower_limit = 24;			
+
+			//Regulatory class 4 -> class_sets[4]
+			psetphyinfopara->class_sets[4].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[4], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[4], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[4], 2, 16);			
+			psetphyinfopara->class_sets[4].channel_spacing = 20;
+			psetphyinfopara->class_sets[4].txpower_limit = 24;				
+
+			//Regulatory class 5 -> class_sets[5]
+			psetphyinfopara->class_sets[5].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[5], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[5], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[5], 2, 16);			
+			psetphyinfopara->class_sets[5].channel_spacing = 20;
+			psetphyinfopara->class_sets[5].txpower_limit = 24;
+
+			//Regulatory class 6 -> class_sets[6]
+			psetphyinfopara->class_sets[6].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[6], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[6], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[6], 2, 16);			
+			psetphyinfopara->class_sets[6].channel_spacing = 20;
+			psetphyinfopara->class_sets[6].txpower_limit = 22;
+
+			//Regulatory class 7 -> class_sets[7]
+			psetphyinfopara->class_sets[7].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 3, 195);			
+			psetphyinfopara->class_sets[7].channel_spacing = 20;
+			psetphyinfopara->class_sets[7].txpower_limit = 24;
+
+			//Regulatory class 8 -> class_sets[8]
+			psetphyinfopara->class_sets[8].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 3, 196);			
+			psetphyinfopara->class_sets[8].channel_spacing = 20;
+			psetphyinfopara->class_sets[8].txpower_limit = 24;
+
+			//Regulatory class 9 -> class_sets[9]
+			psetphyinfopara->class_sets[9].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 3, 196);			
+			psetphyinfopara->class_sets[9].channel_spacing = 20;
+			psetphyinfopara->class_sets[9].txpower_limit = 24;
+
+			//Regulatory class 10 -> class_sets[9]
+			psetphyinfopara->class_sets[10].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 3, 196);			
+			psetphyinfopara->class_sets[10].channel_spacing = 20;
+			psetphyinfopara->class_sets[10].txpower_limit = 24;
+
+			//Regulatory class 11 -> class_sets[11]
+			psetphyinfopara->class_sets[11].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 3, 196);			
+			psetphyinfopara->class_sets[11].channel_spacing = 20;
+			psetphyinfopara->class_sets[11].txpower_limit = 22;
+
+			//Regulatory class 12 -> class_sets[12]
+			psetphyinfopara->class_sets[12].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 3, 11);			
+			psetphyinfopara->class_sets[12].channel_spacing = 10;
+			psetphyinfopara->class_sets[12].txpower_limit = 24;
+
+			//Regulatory class 13 -> class_sets[13]
+			psetphyinfopara->class_sets[13].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 3, 11);			
+			psetphyinfopara->class_sets[13].channel_spacing = 10;
+			psetphyinfopara->class_sets[13].txpower_limit = 24;
+
+			//Regulatory class 14 -> class_sets[14]
+			psetphyinfopara->class_sets[14].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 3, 11);			
+			psetphyinfopara->class_sets[14].channel_spacing = 10;
+			psetphyinfopara->class_sets[14].txpower_limit = 24;		
+	
+			//Regulatory class 15 -> class_sets[15]
+			psetphyinfopara->class_sets[15].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 3, 11);			
+			psetphyinfopara->class_sets[15].channel_spacing = 10;
+			psetphyinfopara->class_sets[15].txpower_limit = 24;		
+
+			//Regulatory class 16 -> class_sets[16]
+			psetphyinfopara->class_sets[16].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 5, 189);			
+			psetphyinfopara->class_sets[16].channel_spacing = 10;
+			psetphyinfopara->class_sets[16].txpower_limit = 24;		
+
+			//Regulatory class 17 -> class_sets[17]
+			psetphyinfopara->class_sets[17].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 5, 189);			
+			psetphyinfopara->class_sets[17].channel_spacing = 10;
+			psetphyinfopara->class_sets[17].txpower_limit = 24;		
+
+			//Regulatory class 18 -> class_sets[18]
+			psetphyinfopara->class_sets[18].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 5, 189);			
+			psetphyinfopara->class_sets[18].channel_spacing = 10;
+			psetphyinfopara->class_sets[18].txpower_limit = 24;		
+
+			//Regulatory class 19 -> class_sets[19]
+			psetphyinfopara->class_sets[19].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 5, 189);			
+			psetphyinfopara->class_sets[19].channel_spacing = 10;
+			psetphyinfopara->class_sets[19].txpower_limit = 24;		
+
+			//Regulatory class 20 -> class_sets[20]
+			psetphyinfopara->class_sets[20].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 5, 189);			
+			psetphyinfopara->class_sets[20].channel_spacing = 10;
+			psetphyinfopara->class_sets[20].txpower_limit = 17;		
+			}
+			
+			break;
+			
+		default:
+		
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Country string in EEPROM has not been defined."));
+			break;
+			
+	}
+
+}
+
+
+u8 writephyinfo_fw(_adapter *padapter, u32 addr)
+{
+	u32	i;
+	u32 *tmpWrite;
+	struct setphyinfo_parm*	psetphyinfopara;
+
+	psetphyinfopara = (struct setphyinfo_parm*)_malloc(sizeof(struct setphyinfo_parm)); 
+
+	if(psetphyinfopara==NULL){
+		return _FAIL;
+	}
+
+	_memset((unsigned char *)psetphyinfopara, 0, sizeof (struct setphyinfo_parm));
+	
+	init_phyinfo(padapter, psetphyinfopara);
+
+	tmpWrite = (u32 *)psetphyinfopara;
+
+	for(i = 0; i < sizeof(struct setphyinfo_parm); i = i + sizeof(u32)) 
+	{
+		write32(padapter, addr+i, *tmpWrite);
+		tmpWrite++;
+	}
+
+	_mfree((unsigned char *) psetphyinfopara, sizeof(struct	setphyinfo_parm));
+	
+	return _SUCCESS;
+}
+
+
+
+
diff --git a/drivers/net/wireless/8712u/runwpa b/drivers/net/wireless/8712u/runwpa
new file mode 100755
index 0000000..f825e8b
--- /dev/null
+++ b/drivers/net/wireless/8712u/runwpa
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+if [ "`which iwconfig`" = "" ] ; then 
+	echo "WARNING:Wireless tool not exist!"
+	echo "        Please install it!"
+	exit
+else
+	if [ `uname -r | cut -d. -f2` -eq 4 ]; then
+		wpa_supplicant -D ipw -c wpa1.conf -i wlan0	
+	else
+	if [ `iwconfig -v |awk '{print $4}' | head -n 1` -lt  18 ] ; then
+		wpa_supplicant -D ipw -c wpa1.conf -i wlan0  
+	else	  
+		wpa_supplicant -D wext -c wpa1.conf -i wlan0 
+	fi
+
+	fi
+fi
+
+
diff --git a/drivers/net/wireless/8712u/sta_mgt/rtl871x_sta_mgt.c b/drivers/net/wireless/8712u/sta_mgt/rtl871x_sta_mgt.c
new file mode 100755
index 0000000..06767ea
--- /dev/null
+++ b/drivers/net/wireless/8712u/sta_mgt/rtl871x_sta_mgt.c
@@ -0,0 +1,555 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_STA_MGT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#include <sta_info.h>
+
+
+static void _init_stainfo(struct sta_info *psta)
+{
+
+_func_enter_;
+
+	_memset((u8 *)psta, 0, sizeof (struct sta_info));
+
+	 _spinlock_init(&psta->lock);
+	_init_listhead(&psta->list);
+	_init_listhead(&psta->hash_list);
+	//_init_listhead(&psta->asoc_list);
+	//_init_listhead(&psta->sleep_list);
+	//_init_listhead(&psta->wakeup_list);	
+
+	_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_init_sta_recv_priv(&psta->sta_recvpriv);
+	
+#ifdef CONFIG_AP_MODE	
+	_init_listhead(&psta->asoc_list);
+	_init_listhead(&psta->auth_list);
+#endif	
+	
+_func_exit_;	
+
+}
+
+
+
+
+u32	_init_sta_priv(struct	sta_priv *pstapriv)
+{
+	struct sta_info *psta;
+	s32 i;
+	
+_func_enter_;	
+
+	pstapriv->pallocated_stainfo_buf = _vmalloc (sizeof(struct sta_info) * NUM_STA+ 4);
+
+	if(pstapriv->pallocated_stainfo_buf == NULL){
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("_init_sta_priv : alloc stainfo_buf  FAIL !\n"));
+		return _FAIL;
+	}
+
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 - 
+		((unsigned int)(pstapriv->pallocated_stainfo_buf ) & 3);
+
+	_init_queue(&pstapriv->free_sta_queue);
+
+	_spinlock_init(&pstapriv->sta_hash_lock);
+	
+	//_init_queue(&pstapriv->asoc_q);
+	pstapriv->asoc_sta_count = 0;
+	_init_queue(&pstapriv->sleep_q);
+	_init_queue(&pstapriv->wakeup_q);
+
+	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
+
+		
+	for(i = 0; i < NUM_STA; i++)
+	{
+		_init_stainfo(psta);
+
+		_init_listhead(&(pstapriv->sta_hash[i]));
+
+		list_insert_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));
+
+		psta++;
+	}
+
+#ifdef CONFIG_AP_MODE	
+	_init_listhead(&pstapriv->asoc_list);
+	_init_listhead(&pstapriv->auth_list);
+	//pstapriv->auth_to = ???;
+	//pstapriv->assoc_to = ???;
+	//pstapriv->expire_to = ???;
+#endif
+	
+_func_exit_;		
+
+	return _SUCCESS;
+	
+}
+
+void	_free_sta_xmit_priv_lock(struct sta_xmit_priv *psta_xmitpriv)
+{
+_func_enter_;
+
+	_spinlock_free(&psta_xmitpriv->lock);
+
+	_spinlock_free(&(psta_xmitpriv->be_q.sta_pending.lock));
+	_spinlock_free(&(psta_xmitpriv->bk_q.sta_pending.lock));
+	_spinlock_free(&(psta_xmitpriv->vi_q.sta_pending.lock));
+	_spinlock_free(&(psta_xmitpriv->vo_q.sta_pending.lock));
+_func_exit_;	
+}
+
+void	_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
+{
+_func_enter_;	
+
+	_spinlock_free(&psta_recvpriv->lock);
+
+	_spinlock_free(&(psta_recvpriv->defrag_q.lock));
+
+_func_exit_;
+
+}
+
+static void mfree_stainfo(struct sta_info *psta)
+{
+_func_enter_;
+
+	if(&psta->lock != NULL)
+		 _spinlock_free(&psta->lock);
+
+	_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
+	_free_sta_recv_priv_lock(&psta->sta_recvpriv);
+	
+_func_exit_;	
+}
+
+
+// this function is used to free the memory of lock || sema for all stainfos
+void mfree_all_stainfo(struct sta_priv *pstapriv )
+{
+	_irqL	 irqL;
+	_list	*plist, *phead;
+	struct sta_info *psta = NULL;
+	
+_func_enter_;	
+
+	_enter_critical(&pstapriv->sta_hash_lock, &irqL);
+
+	phead = get_list_head(&pstapriv->free_sta_queue);
+	plist = get_next(phead);
+		
+	while ((end_of_queue_search(phead, plist)) == _FALSE)
+	{
+		psta = LIST_CONTAINOR(plist, struct sta_info ,list);
+		plist = get_next(plist);
+
+		mfree_stainfo(psta);
+	}
+	
+	_exit_critical(&pstapriv->sta_hash_lock, &irqL);
+
+_func_exit_;	
+
+}
+
+
+void mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+{
+	 mfree_all_stainfo(pstapriv); //be done before free sta_hash_lock
+
+	_spinlock_free(&pstapriv->free_sta_queue.lock);
+
+	_spinlock_free(&pstapriv->sta_hash_lock);
+	_spinlock_free(&pstapriv->wakeup_q.lock);
+	_spinlock_free(&pstapriv->sleep_q.lock);
+
+}
+
+u32	_free_sta_priv(struct	sta_priv *pstapriv)
+{
+_func_enter_;
+	if(pstapriv){
+		mfree_sta_priv_lock(pstapriv);
+		if(pstapriv->pallocated_stainfo_buf)
+			_vmfree(pstapriv->pallocated_stainfo_buf, (sizeof(struct sta_info) * NUM_STA+ 4));
+	}
+_func_exit_;
+	return _SUCCESS;
+}
+
+
+//struct	sta_info *alloc_stainfo(_queue *pfree_sta_queue, unsigned char *hwaddr)
+struct	sta_info *alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr) 
+{
+	uint tmp_aid;
+	s32	index;
+	_list	*phash_list;
+	struct sta_info	*psta;
+	_queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int i = 0;
+	u16  wRxSeqInitialValue = 0xffff;
+	
+_func_enter_;	
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+	
+	_spinlock(&(pfree_sta_queue->lock));
+
+	if (_queue_empty(pfree_sta_queue) == _TRUE)
+	{
+		psta = NULL;
+	}
+	else
+	{
+		psta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue), struct sta_info, list);
+		
+		list_delete(&(psta->list));
+	
+		tmp_aid = psta->aid;	
+	
+		_init_stainfo(psta);
+
+		_memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
+
+		index = wifi_mac_hash(hwaddr);
+
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc_stainfo: index  = %x", index));
+
+		if(index >= NUM_STA){
+			RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("ERROR=> alloc_stainfo: index >= NUM_STA"));
+			psta= NULL;	
+			goto exit;
+		}
+		phash_list = &(pstapriv->sta_hash[index]);
+
+		_spinlock(&(pstapriv->sta_hash_lock));
+
+		list_insert_tail(&psta->hash_list, phash_list);
+
+		pstapriv->asoc_sta_count ++ ;
+
+		_spinunlock(&(pstapriv->sta_hash_lock));
+
+// Commented by Albert 2009/08/13
+// For the SMC router, the sequence number of first packet of WPS handshake will be 0.
+// In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable.
+// So, we initialize the tid_rxseq variable as the 0xffff.
+
+		for( i = 0; i < 16; i++ )
+		{
+                     _memcpy( &psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2 );
+		}
+
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x  \n", 
+		pstapriv->asoc_sta_count , hwaddr[0], hwaddr[1], hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]));
+
+		
+
+		//for A-MPDU Rx reordering buffer control
+		for(i=0; i < 16 ; i++)
+		{
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+
+			preorder_ctrl->padapter = pstapriv->padapter;
+		
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;       
+			//preorder_ctrl->wsize_b = (NR_RECVBUFF-2);
+			preorder_ctrl->wsize_b = 64;
+			preorder_ctrl->enable = _FALSE;
+
+			_init_queue(&preorder_ctrl->pending_recvframe_queue);
+
+			init_recv_timer(preorder_ctrl);
+		}
+
+	}
+	
+exit:
+
+	_spinunlock(&(pfree_sta_queue->lock));
+	
+_func_exit_;	
+
+	return psta;
+
+
+}
+
+
+// using pstapriv->sta_hash_lock to protect
+u32	free_stainfo(_adapter *padapter , struct sta_info *psta)
+{	
+	int i;
+	_irqL irqL0;
+	_queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct	sta_xmit_priv	*pstaxmitpriv;
+	struct	xmit_priv	*pxmitpriv= &padapter->xmitpriv;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	
+
+_func_enter_;	
+	
+	if (psta == NULL)
+		goto exit;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+
+
+	pstaxmitpriv = &psta->sta_xmitpriv;
+	
+	//list_delete(&psta->sleep_list);
+	
+	//list_delete(&psta->wakeup_list);
+	
+	_enter_critical(&(pxmitpriv->vo_pending.lock), &irqL0);
+
+	free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->vo_q.tx_pending));
+
+	_exit_critical(&(pxmitpriv->vo_pending.lock), &irqL0);
+	
+
+	_enter_critical(&(pxmitpriv->vi_pending.lock), &irqL0);
+
+	free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->vi_q.tx_pending));
+
+	_exit_critical(&(pxmitpriv->vi_pending.lock), &irqL0);
+
+
+	_enter_critical(&(pxmitpriv->bk_pending.lock), &irqL0);
+
+	free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->bk_q.tx_pending));
+
+	_exit_critical(&(pxmitpriv->bk_pending.lock), &irqL0);
+
+	_enter_critical(&(pxmitpriv->be_pending.lock), &irqL0);
+
+	free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->be_q.tx_pending));
+
+	_exit_critical(&(pxmitpriv->be_pending.lock), &irqL0);
+	
+	
+	list_delete(&psta->hash_list);
+	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
+	pstapriv->asoc_sta_count --;
+	
+	
+	// re-init sta_info; 20061114
+	_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_init_sta_recv_priv(&psta->sta_recvpriv);
+
+
+	//for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer
+	for(i=0; i < 16 ; i++)
+	{
+		preorder_ctrl = &psta->recvreorder_ctrl[i];
+		
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);		
+	}
+
+	_spinlock(&(pfree_sta_queue->lock));
+	// insert into free_sta_queue; 20061114
+	list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	_spinunlock(&(pfree_sta_queue->lock));
+	
+
+exit:	
+	
+_func_exit_;	
+
+	return _SUCCESS;
+	
+}
+
+// free all stainfo which in sta_hash[all]
+void free_all_stainfo(_adapter *padapter)
+{
+	_irqL	 irqL;
+	_list	*plist, *phead;
+	s32	index;
+	struct sta_info *psta = NULL;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info* pbcmc_stainfo =get_bcmc_stainfo( padapter);
+	
+_func_enter_;	
+
+	if(pstapriv->asoc_sta_count==1)
+		goto exit;
+
+	_enter_critical(&pstapriv->sta_hash_lock, &irqL);
+
+	for(index=0; index< NUM_STA; index++)
+	{
+		phead = &(pstapriv->sta_hash[index]);
+		plist = get_next(phead);
+		
+		while ((end_of_queue_search(phead, plist)) == _FALSE)
+		{
+			psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
+
+			plist = get_next(plist);
+
+			if(pbcmc_stainfo!=psta)					
+				free_stainfo(padapter , psta);
+			
+		}
+	}
+	
+	_exit_critical(&pstapriv->sta_hash_lock, &irqL);
+	
+exit:	
+	
+_func_exit_;	
+
+}
+
+/* any station allocated can be searched by hash list */
+struct sta_info *get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+
+	_irqL	 irqL;
+
+	_list	*plist, *phead;
+
+	struct sta_info *psta = NULL;
+	
+	u32	index;
+
+_func_enter_;
+
+	if(hwaddr==NULL)
+		return NULL;
+		
+
+	index = wifi_mac_hash(hwaddr);
+
+	_enter_critical(&pstapriv->sta_hash_lock, &irqL);
+	
+	phead = &(pstapriv->sta_hash[index]);
+	plist = get_next(phead);
+
+
+	while ((end_of_queue_search(phead, plist)) == _FALSE)
+	{
+	
+		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+		
+		if ((_memcmp(psta->hwaddr,hwaddr, ETH_ALEN))== _TRUE) 
+		{ // if found the matched address
+			break;
+		}
+		psta=NULL;
+		plist = get_next(plist);
+	}
+
+	_exit_critical(&pstapriv->sta_hash_lock, &irqL);
+_func_exit_;	
+	return psta;
+	
+}
+
+u32 init_bcmc_stainfo(_adapter* padapter)
+{
+
+	struct sta_info 	*psta;
+	struct tx_servq	*ptxservq;
+	u32 res=_SUCCESS;
+	NDIS_802_11_MAC_ADDRESS	bcast_addr= {0xff,0xff,0xff,0xff,0xff,0xff};
+	
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	_queue	*pstapending = &padapter->xmitpriv.bm_pending; 
+	
+_func_enter_;
+
+	psta = alloc_stainfo(pstapriv, bcast_addr);
+	
+	if(psta==NULL){
+		res=_FAIL;
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("alloc_stainfo fail"));
+		goto exit;
+	}
+	
+	ptxservq= &(psta->sta_xmitpriv.be_q);
+
+/*
+	_enter_critical(&pstapending->lock, &irqL0);
+
+	if (is_list_empty(&ptxservq->tx_pending))
+		list_insert_tail(&ptxservq->tx_pending, get_list_head(pstapending));
+
+	_exit_critical(&pstapending->lock, &irqL0);
+*/
+	
+exit:
+_func_exit_;		
+	return _SUCCESS;
+
+}
+
+
+struct sta_info* get_bcmc_stainfo(_adapter* padapter)
+{
+	struct sta_info 	*psta;
+	struct sta_priv 	*pstapriv = &padapter->stapriv;
+	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+_func_enter_;
+	 psta = get_stainfo(pstapriv, bc_addr);
+_func_exit_;		 
+	return psta;
+
+}
+
+
+u8 access_ctrl(struct wlan_acl_pool* pacl_list, u8 * mac_addr)
+{
+	return _TRUE;
+}
+
+
+
+
+
+
diff --git a/drivers/net/wireless/8712u/wlan0dhcp b/drivers/net/wireless/8712u/wlan0dhcp
new file mode 100755
index 0000000..6043382
--- /dev/null
+++ b/drivers/net/wireless/8712u/wlan0dhcp
@@ -0,0 +1,16 @@
+#!/bin/bash
+
+var0=`ps aux|awk '/dhclient wlan0/'|awk '$11!="awk"{print $2}'`
+
+kill $var0
+cp ifcfg-wlan0 /etc/sysconfig/network-scripts/
+
+dhclient wlan0
+
+var1=`ifconfig wlan0 |awk '/inet/{print $2}'|awk -F: '{print $2}'`
+
+
+rm -f /etc/sysconfig/network-scripts/ifcfg-wlan0
+
+echo "get ip: $var1"
+
diff --git a/drivers/net/wireless/8712u/wpa1.conf b/drivers/net/wireless/8712u/wpa1.conf
new file mode 100755
index 0000000..b2f94bb
--- /dev/null
+++ b/drivers/net/wireless/8712u/wpa1.conf
@@ -0,0 +1,11 @@
+ctrl_interface=/var/run/wpa_supplicant
+network={
+                        ssid="REALTEK"
+                        proto=WPA WPA2 
+                        key_mgmt=WPA-PSK
+                        pairwise=CCMP TKIP
+                        group=CCMP TKIP
+                        psk="12345678"
+                        priority=2
+         }
+
diff --git a/drivers/net/wireless/8712u/xmit/rtl8712_xmit.c b/drivers/net/wireless/8712u/xmit/rtl8712_xmit.c
new file mode 100755
index 0000000..2319f09
--- /dev/null
+++ b/drivers/net/wireless/8712u/xmit/rtl8712_xmit.c
@@ -0,0 +1,2015 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL8712_XMIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_byteorder.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#include <if_ether.h>
+#endif
+
+#ifdef  PLATFORM_LINUX
+#include <linux/rtnetlink.h>
+#ifdef CONFIG_SDIO_HCI
+#include <linux/mmc/sdio_func.h>
+#endif
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+sint _init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag)
+{
+
+_func_enter_;
+
+	phw_txqueue->ac_tag = ac_tag;
+
+	switch(ac_tag)
+	{
+		case BE_QUEUE_INX:
+			phw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;
+			break;
+
+		case BK_QUEUE_INX:
+			phw_txqueue->ff_hwaddr = RTL8712_DMA_BKQ;
+			break;
+
+		case VI_QUEUE_INX:
+			phw_txqueue->ff_hwaddr = RTL8712_DMA_VIQ;
+			break;
+
+		case VO_QUEUE_INX:
+			phw_txqueue->ff_hwaddr = RTL8712_DMA_VOQ;
+			break;	
+
+		case BMC_QUEUE_INX:
+			//phw_txqueue->ff_hwaddr = RTL8712_DMA_BMCQ;
+			phw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;
+			break;
+
+	}
+
+
+_func_exit_;
+
+	return _SUCCESS;
+
+}
+
+sint txframes_pending(_adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	return ((_queue_empty(&pxmitpriv->be_pending) == _FALSE) || 
+			 (_queue_empty(&pxmitpriv->bk_pending) == _FALSE) || 
+			 (_queue_empty(&pxmitpriv->vi_pending) == _FALSE) ||
+			 (_queue_empty(&pxmitpriv->vo_pending) == _FALSE));
+}
+
+int txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
+{
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;	
+	int priority = pattrib->priority;
+
+	psta = pattrib->psta;
+
+	switch(priority) 
+	{
+			case 1:
+			case 2:
+				ptxservq = &(psta->sta_xmitpriv.bk_q);
+				break;
+			case 4:
+			case 5:
+				ptxservq = &(psta->sta_xmitpriv.vi_q);
+				break;
+			case 6:
+			case 7:
+				ptxservq = &(psta->sta_xmitpriv.vo_q);
+				break;
+			case 0:
+			case 3:
+			default:
+				ptxservq = &(psta->sta_xmitpriv.be_q);
+			break;
+
+	}
+
+	return ptxservq->qcnt;
+}
+
+u32 get_ff_hwaddr(struct xmit_frame	*pxmitframe)
+{
+	u32 addr;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	_adapter *padapter = pxmitframe->padapter;
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+
+#ifdef CONFIG_USB_HCI
+
+	if(pxmitframe->frame_tag == TXAGG_FRAMETAG)
+	{
+		addr = RTL8712_DMA_H2CCMD;
+	}
+	else if(pxmitframe->frame_tag == MGNT_FRAMETAG)
+	{
+		addr = RTL8712_DMA_MGTQ;
+	}
+	else if(pdvobj->nr_endpoint == 6)
+	{
+		switch(pattrib->priority)
+		{
+			case 0:
+			case 3:
+				addr = RTL8712_DMA_BEQ;
+			 	break;
+			case 1:
+			case 2:
+				addr = RTL8712_DMA_BKQ;
+				break;
+			case 4:
+			case 5:
+				addr = RTL8712_DMA_VIQ;
+				break;
+			case 6:
+			case 7:
+				addr = RTL8712_DMA_VOQ;
+				break;
+
+			case 0x10:
+			case 0x11:
+			case 0x12:
+			case 0x13://
+				addr = RTL8712_DMA_H2CCMD;
+				break;
+
+			default:
+				addr = RTL8712_DMA_BEQ;
+				break;
+		}
+	}
+	else if(pdvobj->nr_endpoint == 4)
+	{		
+		switch(pattrib->qsel)
+		{
+			case 0:
+			case 3:
+			case 1:
+			case 2:
+				addr = RTL8712_DMA_BEQ;//RTL8712_EP_LO;
+				break;
+
+			case 4:
+			case 5:
+			case 6:
+			case 7:
+				addr = RTL8712_DMA_VOQ;//RTL8712_EP_HI;
+				break;
+
+			case 0x10:
+			case 0x11:
+			case 0x12:
+			case 0x13://
+				addr = RTL8712_DMA_H2CCMD;;
+				break;
+
+			default:
+				addr = RTL8712_DMA_BEQ;//RTL8712_EP_LO;
+				break;
+		}
+	}
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+
+	if(pxmitframe->frame_tag == TXAGG_FRAMETAG)
+	{
+		addr = RTL8712_DMA_H2CCMD;
+	}
+	else if(pxmitframe->frame_tag == MGNT_FRAMETAG)
+	{
+		addr = RTL8712_DMA_MGTQ;
+	}
+	else
+	{
+		switch(pattrib->priority)
+		{
+			case 0:
+			case 3:
+				addr = RTL8712_DMA_BEQ;
+				break;
+
+			case 1:
+			case 2:
+				addr = RTL8712_DMA_BKQ;
+				break;
+
+			case 4:
+			case 5:
+				addr = RTL8712_DMA_VIQ;
+				break;
+
+			case 6:
+			case 7:
+				addr = RTL8712_DMA_VOQ;
+				break;
+
+			case 0x13://
+				addr = RTL8712_DMA_H2CCMD;
+				break;
+
+			default:
+				addr = RTL8712_DMA_BEQ;
+				break;
+		}
+	}
+
+#endif
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("get_ff_hwaddr,pattrib->priority=%x ,addr:0x%08x\n", pattrib->priority,addr));
+	return addr;
+}
+
+struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue)
+{
+	_list	*xmitframe_plist, *xmitframe_phead;
+	struct	xmit_frame	*pxmitframe=NULL;
+	_adapter *padapter = pxmitpriv->adapter;
+
+	xmitframe_phead = get_list_head(pframe_queue);
+	xmitframe_plist = get_next(xmitframe_phead);
+
+	if ((end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+	{
+		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
+
+		list_delete(&pxmitframe->list);
+
+		//list_insert_tail(&pxmitframe->list, &phwxmit->pending);
+
+		ptxservq->qcnt--;
+		phwxmit->txcmdcnt++;
+	}
+
+	return pxmitframe;
+}
+
+struct xmit_frame *dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, sint entry)
+{
+	int inx;
+	_irqL irqL0;
+	_list	*sta_plist, *sta_phead;
+	struct tx_servq *ptxservq = NULL;
+	_queue *pframe_queue = NULL;
+	struct	xmit_frame	*pxmitframe=NULL;
+	_adapter *padapter = pxmitpriv->adapter;
+
+_func_enter_;
+
+	for(inx = 0; inx < entry; inx++, phwxmit++)
+	{
+		_enter_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = get_next(sta_phead);
+
+		while ((end_of_queue_search(sta_phead, sta_plist)) == _FALSE)
+		{
+			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
+
+			pframe_queue = &ptxservq->sta_pending;
+
+			//_enter_critical(&pframe_queue->lock, &irqL1);
+
+			if(1/*(bamsdu_enabled == _FALSE) && (btxagg_enabled == _FALSE)*/)
+			{
+				pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+			}
+			else if(0/* btxagg_enabled == _TRUE*/)
+			{
+				//pxmitframe = dequeue_agg_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+
+				//if(pxmitframe == NULL)
+				//{
+				//	pxmitframe = handle_single_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+				//}
+			}
+			else if(0/*bamsdu_enabled == _TRUE*/)
+			{
+				//pxmitframe = dequeue_amsdu_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);					
+			}
+
+			//_exit_critical(&pframe_queue->lock, &irqL1);
+
+			if(pxmitframe)
+			{
+				phwxmit->accnt--;
+
+				_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+				goto _exit_dequeue_one_xmitframe;
+			}
+			else
+			{
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("pxmitframe=0x%p\n", pxmitframe));	
+			}
+
+			sta_plist = get_next(sta_plist);
+
+			//Remove sta node when there is no pending packets.
+			if(_queue_empty(pframe_queue)) //must be done after get_next and before break
+				list_delete(&ptxservq->tx_pending);
+		}
+
+		_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+	}
+
+_exit_dequeue_one_xmitframe:
+
+_func_exit_;
+
+	return pxmitframe;
+}
+
+struct xmit_frame *dequeue_xframe_ex(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, sint entry)
+{
+	_irqL irqL0;
+	_list	*sta_plist, *sta_phead;
+	struct hw_xmit *phwxmit;
+	struct tx_servq *ptxservq = NULL;
+	_queue *pframe_queue = NULL;
+	struct	xmit_frame	*pxmitframe=NULL;
+	_adapter *padapter = pxmitpriv->adapter;
+	int i, inx[4];
+#ifdef CONFIG_USB_HCI
+	int j, tmp, acirp_cnt[4];
+#endif
+
+_func_enter_;
+
+#ifdef CONFIG_USB_HCI
+	//entry indx: 0->vo, 1->vi, 2->be, 3->bk.
+	inx[0] = 0; acirp_cnt[0] = pxmitpriv->voq_cnt;
+	inx[1] = 1; acirp_cnt[1] = pxmitpriv->viq_cnt;
+	inx[2] = 2; acirp_cnt[2] = pxmitpriv->beq_cnt;
+	inx[3] = 3; acirp_cnt[3] = pxmitpriv->bkq_cnt;
+
+	for(i=0; i<4; i++)
+	{
+		for(j=i+1; j<4; j++)
+		{
+			if(acirp_cnt[j]<acirp_cnt[i])
+			{
+				tmp = acirp_cnt[i];
+				acirp_cnt[i] = acirp_cnt[j];
+				acirp_cnt[j] = tmp;
+
+				tmp = inx[i];
+				inx[i] = inx[j];
+				inx[j] = tmp;
+			}
+		}
+	}
+
+#else
+ 	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
+#endif
+
+	_enter_critical(&pxmitpriv->lock, &irqL0);
+
+	for(i = 0; i < entry; i++)
+	{
+		phwxmit = phwxmit_i + inx[i];
+
+		//_enter_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = get_next(sta_phead);
+
+		while ((end_of_queue_search(sta_phead, sta_plist)) == _FALSE)
+		{
+
+			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
+
+			pframe_queue = &ptxservq->sta_pending;
+
+			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+
+			if(pxmitframe)
+			{
+				phwxmit->accnt--;
+
+				//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+				goto exit_dequeue_xframe_ex;
+			}
+
+			sta_plist = get_next(sta_plist);
+
+			//Remove sta node when there is no pending packets.
+			if(_queue_empty(pframe_queue)) //must be done after get_next and before break
+				list_delete(&ptxservq->tx_pending);
+
+		}
+
+		//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+	}
+
+exit_dequeue_xframe_ex:
+
+	_exit_critical(&pxmitpriv->lock, &irqL0);
+
+_func_exit_;
+
+	return pxmitframe;
+}
+
+void do_queue_select(_adapter	*padapter, struct pkt_attrib *pattrib)
+{
+
+#ifdef CONFIG_USB_HCI
+
+	unsigned int qsel;
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);	
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+
+	if(pdvobj->nr_endpoint == 6)
+	{
+		qsel = (uint)pattrib->priority;
+	}
+	else if(pdvobj->nr_endpoint == 4)
+	{
+		if (pregistrypriv->wifi_test == 0)
+	{
+		qsel = (uint)pattrib->priority;
+
+		if(qsel == 0 || qsel == 3)
+			qsel = 3;
+		else if(qsel==1 || qsel == 2)
+			qsel = 1;
+		else if(qsel == 4 || qsel == 5)
+			qsel =5;
+		else if(qsel == 6 || qsel == 7)
+			qsel =7;
+		else
+			qsel = 3;
+	}
+		else //wifi_test 
+	{
+		switch(pattrib->priority)
+		{
+			case 0:
+			case 3:
+				if(pxmitpriv->bkq_cnt!=0 && pxmitpriv->viq_cnt==0 && pxmitpriv->voq_cnt==0)
+				{
+					qsel = (uint)(0x07);//select vi/vo (high_q)
+				}
+				else
+				{
+					//qsel = (uint)pattrib->priority;
+					qsel = 3;
+				}
+				break;
+
+			case 1:
+			case 2:
+				//qsel = (uint)pattrib->priority;
+				qsel = 1;
+				break;
+
+			case 4:
+			case 5:
+				if(pxmitpriv->voq_cnt!=0)
+				{
+					qsel = (uint)(0x3);//selev be/bk (low_q)
+				}
+				else
+				{
+					//qsel = (uint)pattrib->priority;
+					qsel = 5;
+				}
+				break;
+
+			case 6:
+			case 7:
+				//qsel = (uint)pattrib->priority;
+				qsel = 7;
+				break;
+
+			case 0x10:
+			case 0x11:
+			case 0x12:
+			case 0x13://
+				//qsel = (uint)(0x13);
+				qsel = (uint)pattrib->priority;
+
+				break;
+
+			default:
+				qsel = (uint)(0x3);
+				break;
+		}
+			
+		}
+		
+	}
+
+	pattrib->qsel = qsel;
+
+#endif
+
+}
+
+static int toggle_be=0;
+static int toggle_bk=0;
+
+int check_xmit_resource(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int bq=0;
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	
+	//todo: accordding to the AC(TID) of  txframes to check the each txframes_pending queue. 
+	
+	//Notes: in winxp os, the usb_wirte_port_complete is at dispatch level, so it needs not to protect 
+	// 		when checking txframes_pending
+
+#ifdef CONFIG_USB_HCI
+	int ac_txirp_cnt, ac_cnt;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct hw_xmit *phwxmits =  pxmitpriv->hwxmits;
+
+	do_queue_select(padapter, pattrib);
+
+	switch(pattrib->priority)
+	{
+		case 1:
+		case 2:
+			//printk("pxmitpriv->bkq_cnt=%d\n", pxmitpriv->bkq_cnt);
+			ac_txirp_cnt=pxmitpriv->bkq_cnt;
+			ac_cnt = (phwxmits+3)->accnt;
+			break;
+
+		case 4:
+		case 5:
+			//printk("pxmitpriv->viq_cnt=%d\n", pxmitpriv->viq_cnt);	
+			ac_txirp_cnt = pxmitpriv->viq_cnt;
+			ac_cnt = (phwxmits+1)->accnt;
+			break;
+
+		case 6:
+		case 7:
+			//printk("pxmitpriv->voq_cnt=%d\n", pxmitpriv->voq_cnt);
+			ac_txirp_cnt = pxmitpriv->voq_cnt;
+			ac_cnt = (phwxmits+0)->accnt;
+			break;
+
+		case 0:
+		case 3:
+		default:
+			//printk("pxmitpriv->beq_cnt=%d\n", pxmitpriv->beq_cnt);
+			ac_txirp_cnt = pxmitpriv->beq_cnt;
+			ac_cnt = (phwxmits+2)->accnt;
+			break;
+	}
+
+	
+	if(pxmitpriv->free_xmitframe_cnt<(NR_XMITFRAME>>3))
+	{
+		switch(pattrib->priority)
+		{
+			case 1:
+			case 2:
+				if((toggle_bk++)%4==0)
+				{
+					//printk("irpcnt=%d, accnt=%d tid=%d,toggle=%d\n",ac_txirp_cnt, ac_cnt, pattrib->priority, toggle);
+					bq = (-1);//drop packet
+				}
+				else
+				{
+					bq = 1;
+				}
+
+				break;
+
+			case 4:
+			case 5:
+				bq = 1;
+				break;
+
+			case 6:
+			case 7:
+				bq = 1;
+				break;
+
+			case 0:
+			case 3:
+			default:
+				if((toggle_be++)%4==0)
+				{
+					//printk("irpcnt=%d, accnt=%d tid=%d,toggle=%d\n",ac_txirp_cnt, ac_cnt, pattrib->priority, toggle);					
+					bq = (-1);//drop packet
+				}
+				else
+				{
+					bq = 1;
+				}
+				break;
+		}
+	}
+	else if(txframes_pending(padapter))
+	{
+		if(pxmitpriv->txirp_cnt==1)
+		{
+			//printk("pxmitpriv->txirp_cnt==1\n");
+		}
+
+		bq = 1;//enqueue packet
+	}
+	else if(ac_txirp_cnt > 1)//pxmitpriv->txirp_cnt
+	{
+		bq = 1;//enqueue packet
+	}
+	else
+	{
+		bq = 0;//dump packet directly
+	}
+
+#endif //#ifdef CONFIG_USB_HCI
+
+#ifdef CONFIG_SDIO_HCI
+
+	u32 pkt_len;
+	u8 blk_num,pagenum_required;
+	struct hw_xmit *phwxmit=pxmitpriv->hwxmits;
+	struct hw_txqueue *ptxhwqueue;
+	pkt_len=pxmitframe->attrib.pktlen+pxmitframe->attrib.hdrlen+TXDESC_SIZE;
+	blk_num=(u8)((pkt_len>>9)+((pkt_len%512 ==0)? 0:1));
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_debug_,("pkt_len =%d;blk_num=%d",  pkt_len, blk_num));
+
+	pxmitframe->attrib.qsel = (uint)pxmitframe->attrib.priority;
+
+	switch(pxmitframe->attrib.priority){
+		case 0: //BE
+		case 3:
+			ptxhwqueue=&pxmitpriv->be_txqueue;
+			break;
+		case 1: //BK
+		case 2:
+			ptxhwqueue=&pxmitpriv->bk_txqueue;
+			break;
+		case 4: //VI
+		case 5:
+			ptxhwqueue=&pxmitpriv->vi_txqueue;
+			break;
+		case 6: //VO
+		case 7:
+			ptxhwqueue=&pxmitpriv->vo_txqueue;
+			break;
+	}
+	pagenum_required=blk_num*2;
+#if 0
+	if(ptxhwqueue->free_sz >(pagenum_required+5)){
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,(" drv's free_sz is  enough; 0x%x(%d) (need page num :%d)\n", ptxhwqueue->free_sz,ptxhwqueue->free_sz,pagenum_required));
+		ptxhwqueue->free_sz=ptxhwqueue->free_sz-pagenum_required;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,(" drv's free_sz is  enough; 0x%x(%d) (need page num :%d)\n", ptxhwqueue->free_sz,ptxhwqueue->free_sz,pagenum_required));
+	}
+	else {
+		s32	tmp;
+		if((ptxhwqueue->free_sz+pxmitpriv->public_pgsz) >(pagenum_required+5)) {
+		// drv_xmitbuf enough
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,(" drv's free_sz is  enough; ptxhwqueue->free_sz=%d   xmitpriv->public_pgsz=%d pagenum=%d\n", ptxhwqueue->free_sz,pxmitpriv->public_pgsz,pagenum_required));
+			if(pagenum_required>ptxhwqueue->free_sz){
+				tmp=pagenum_required-ptxhwqueue->free_sz;
+				pxmitpriv->public_pgsz-=(u8)(pagenum_required-ptxhwqueue->free_sz);
+				ptxhwqueue->free_sz=0;
+			}
+			else{
+				ptxhwqueue->free_sz-=pagenum_required;
+			}
+		}
+		else{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,(" drv's free_sz is not enough;  ptxhwqueue->free_sz=%d   xmitpriv->public_pgsz=%d pagenum=%d\n", ptxhwqueue->free_sz,pxmitpriv->public_pgsz,pagenum_required));
+			bq=1;
+//			read_free_ffsz();
+		}
+	}
+#else
+	pxmitframe->pg_num=0;
+	if(pxmitpriv->init_pgsz >(pxmitpriv->used_pgsz +pxmitpriv->required_pgsz +pagenum_required+5)){
+RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,(" drv's free_sz is enough;  pxmitpriv->required_pgsz=0x%x \n", pxmitpriv->required_pgsz ));
+
+		pxmitpriv->required_pgsz =pxmitpriv->required_pgsz +pagenum_required;
+	//	pxmitpriv->public_pgsz=pxmitpriv->public_pgsz-(u8)pagenum_required;
+		pxmitframe->pg_num=pagenum_required;
+
+	}
+	else{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,(" drv's free_sz is not enough;  ptxhwqueue->free_sz=%d   xmitpriv->public_pgsz=%d pagenum=%d\n", ptxhwqueue->free_sz,pxmitpriv->public_pgsz,pagenum_required));
+			bq=1;
+	}
+
+#endif
+#endif
+
+	return bq;
+}
+
+#ifdef CONFIG_HOSTAPD_MODE
+void update_txdesc_ex(struct xmit_frame *pxmitframe, struct tx_desc *ptxdesc)
+{
+	uint qsel;
+	struct sta_info *psta = NULL;
+	struct ht_priv	*pht = NULL;
+	_adapter	*padapter = pxmitframe->padapter;
+	struct security_priv *psecuritypriv=&padapter->securitypriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	int	bmcst = IS_MCAST(pattrib->ra);
+
+
+	if(bmcst)
+	{
+		psta = get_bcmc_stainfo(padapter);
+		pattrib->mac_id = 0;//default set to 0
+	}
+	else
+	{
+		psta = get_stainfo(pstapriv, pattrib->ra);
+	}
+
+	if(psta==NULL)
+		psta = pattrib->psta;
+
+	pht = &psta ->htpriv;
+
+	//ptxdesc->txdw1 |= cpu_to_le32((psta->mac_id)&0x1f);
+	ptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id)&0x1f);//psta->mac_id == pattrib->mac_id
+
+	qsel = (uint)(pattrib->qsel&0x0000001f);
+	ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
+
+	if(!psta->qos_option)
+		ptxdesc->txdw1 |= cpu_to_le32(BIT(16));//Non-QoS
+
+	if(pattrib->encrypt	>0 && !pattrib->bswenc)
+	{
+		switch(pattrib->encrypt)
+		{	//SEC_TYPE
+
+			case _WEP40_:
+			case _WEP104_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
+				//KEY_ID when WEP is used;
+				ptxdesc->txdw1 |= cpu_to_le32((psecuritypriv->dot11PrivacyKeyIndex<<17)&0x00060000);
+				break;
+			case _TKIP_:
+			case _TKIP_WTMIC_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x02<<22)&0x00c00000);
+					break;
+			case _AES_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x03<<22)&0x00c00000);
+					break;
+			case _NO_PRIVACY_:
+			default:
+					break;
+		}
+	}
+
+	if(bmcst)
+	{
+		ptxdesc->txdw2 |= cpu_to_le32(BMC);
+	}
+
+	ptxdesc->txdw3 = ((pattrib->seqnum<<SEQ_SHT)&0x0fff0000);
+
+
+	if( ( pattrib->ether_type != 0x888e ) && ( pattrib->ether_type != 0x0806 ) &&(pattrib->dhcp_pkt != 1) )
+	{
+		//Not EAP & ARP type data packet
+#ifdef CONFIG_80211N_HT	
+		if(pht->ht_option==1) //B/G/N Mode
+		{
+			if(pht->ampdu_enable != _TRUE)
+			{
+				ptxdesc->txdw2 |= cpu_to_le32(BK);
+			}
+
+			//ptxdesc->txdw4 = cpu_to_le32(0x80000000);//driver uses data rate
+			//ptxdesc->txdw4 |= cpu_to_le32(BIT(18)|BIT(20));
+			//ptxdesc->txdw5 = cpu_to_le32(0x001f2600);// MCS7
+			//ptxdesc->txdw5 = cpu_to_le32(0x001f3600);// MCS15
+		}
+		else
+#endif
+		{
+			//ptxdesc->txdw4 = 0x80000000;//driver uses data rate
+			//ptxdesc->txdw5 = 0x001f1600;// 54M
+			//ptxdesc->txdw5 = 0x001f2600;//MCS7
+			//ptxdesc->txdw5 = 0x001f9600;// 54M
+		}
+	}
+	else
+	{
+		// EAP data packet and ARP packet.
+		// Use the 1M data rate to send the EAP/ARP packet.
+		// This will maybe make the handshake smooth.
+
+		ptxdesc->txdw4 = cpu_to_le32(0x80000000);//driver uses data rate
+		ptxdesc->txdw5 = cpu_to_le32(0x001f8000);// 1M
+		
+	}
+
+}
+#endif
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+u8 construct_txaggr_cmd_desc(struct xmit_buf *pxmitbuf)
+{
+	struct xmit_frame	*pxmitframe	= (struct xmit_frame *)pxmitbuf->priv_data;
+	_adapter 			*padapter	= pxmitframe->padapter;
+		
+	struct cmd_priv		*pcmdpriv	= &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv	= &padapter->mlmepriv;
+
+	struct tx_desc 		* ptx_desc = NULL;
+_func_enter_;
+
+	ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;
+
+	// Fill up TxCmd Descriptor according as USB FW Tx Aaggregation info.
+	// dw0
+	//ptx_desc->txdw0 |= cpu_to_le32(0&0x0000ffff);
+	ptx_desc->txdw0 = cpu_to_le32(CMD_HDR_SZ&0xffff);
+	ptx_desc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);
+	ptx_desc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+
+	// dw1
+	ptx_desc->txdw1 |= cpu_to_le32((0x13<<QSEL_SHT)&0x00001f00);
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+u8 construct_txaggr_cmd_hdr(struct xmit_buf *pxmitbuf)
+{
+	struct xmit_frame	*pxmitframe	= (struct xmit_frame *)pxmitbuf->priv_data;
+	_adapter 			*padapter	= pxmitframe->padapter;
+
+	struct cmd_priv * pcmdpriv	= &(padapter->cmdpriv);
+	struct tx_desc	* ptx_desc	= (struct tx_desc *)pxmitbuf->pbuf;
+	struct cmd_hdr  * pcmd_hdr	= (struct cmd_hdr  *)(pxmitbuf->pbuf + TXDESC_SIZE);
+	u16				pkt_sz = 0;
+
+	// add cmd_hdr into tx_desc length
+	// may be update after dequeue loop end
+	//ptx_desc->txdw0 = cpu_to_le32((CMD_HDR_SZ&0x0000ffff)|(ptx_desc->txdw0&0xffff0000));
+
+	// Fill up Cmd Header for USB FW Tx Aggregation.
+	// dw0
+	pcmd_hdr->cmd_dw0 = cpu_to_le32((GEN_CMD_CODE(_AMSDU_TO_AMPDU)<< 16) | (pcmdpriv->cmd_seq <<24));			
+
+	pcmdpriv->cmd_seq++;
+
+
+	// dw1
+	//pcmd_hdr->cmd_dw1 = cpu_to_le32((aggr_num & 0xff));
+	//pcmd_hdr->cmd_dw1 = cpu_to_le32(((TXDESC_SIZE+CMD_HDR_SZ)&0xffff)<<16);
+	
+	return _SUCCESS;
+}
+
+u8 append_mpdu_unit(struct xmit_buf *pxmitbuf, struct xmit_frame *pxmitframe)
+{
+	_adapter		*padapter = pxmitframe->padapter;
+	struct tx_desc	*ptx_desc		= (struct tx_desc *)pxmitbuf->pbuf;
+	u16				current_offset	= (ptx_desc->txdw0&0x0000ffff);
+
+	int last_txcmdsz = 0;
+	int padding_sz = 0;
+
+
+	// 802.3->802.11 convertor
+	xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+
+	// free skb struct
+	os_xmit_complete(padapter, pxmitframe);
+
+#ifdef CONFIG_80211N_HT
+	if (pxmitframe->attrib.ether_type != 0x0806)
+	{
+		if ((pxmitframe->attrib.ether_type != 0x888e) && (pxmitframe->attrib.dhcp_pkt != 1))
+		{
+			issue_addbareq_cmd(padapter, pxmitframe->attrib.priority);
+		}
+	}
+#endif
+
+
+	pxmitframe->last[0] = 1;
+	update_txdesc(pxmitframe,(uint*)(pxmitframe->buf_addr),pxmitframe->attrib.last_txcmdsz);
+
+	//padding zero
+	last_txcmdsz = pxmitframe->attrib.last_txcmdsz;
+	padding_sz = (8 - (last_txcmdsz % 8));
+
+	if( (last_txcmdsz % 8) != 0)
+	{
+		int i;
+		for(i = 0; i < padding_sz; i++)
+			*(pxmitframe->buf_addr+TXDESC_SIZE+last_txcmdsz+i) = 0;
+		//pxmitframe->attrib.last_txcmdsz += 8 - (last_txcmdsz % 8);
+	}
+
+	//printk("Add mpdu length = %d + %d\n",last_txcmdsz,padding_sz);
+	// Add the new mpdu's length
+	//printk("Aggred sz = %d, going to add %d\n", (ptx_desc->txdw0&0x0000ffff),last_txcmdsz+padding_sz );
+	ptx_desc->txdw0 = cpu_to_le32((ptx_desc->txdw0&0xffff0000)|
+		( (ptx_desc->txdw0&0x0000ffff)+((TXDESC_SIZE+last_txcmdsz+padding_sz)&0x0000ffff)) );    
+
+	return _SUCCESS;
+
+}
+
+
+u8 xmitframe_aggr_1st(struct xmit_buf* pxmitbuf, struct xmit_frame * pxmitframe)
+{
+	//printk("xmitframe_complete xmitframe_aggr_1st...\n");
+	
+	// linux complete context doesnt need to protect
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitbuf->priv_data = pxmitframe;
+	
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	
+	// buffer addr assoc
+	pxmitframe->buf_addr = pxmitbuf->pbuf+TXDESC_SIZE+CMD_HDR_SZ;
+	
+	//RTL8712_DMA_H2CCMD
+	//printk("xmitframe_complete construct_txaggr_cmd_desc... %d\n", *(u16*)pxmitbuf->pbuf);
+	construct_txaggr_cmd_desc(pxmitbuf);
+	
+	//printk("xmitframe_complete construct_txaggr_cmd_hdr... %d\n",*(u16*)pxmitbuf->pbuf);
+	construct_txaggr_cmd_hdr(pxmitbuf);
+	
+	//printk("xmitframe_complete append_mpdu_unit...\n");
+	
+	if( append_mpdu_unit(pxmitbuf,pxmitframe)== _SUCCESS)
+	{
+		//printk("append_mpdu_unit %p\n",pxmitframe->pkt);
+		//free_xmitframe_ex(pxmitpriv, pxmitframe);
+		//printk(" %d \n", *(u16*)pxmitbuf->pbuf);
+		pxmitbuf->aggr_nr = 1;
+	}
+
+	return _SUCCESS;
+}
+
+u16 xmitframe_aggr_next(struct xmit_buf* pxmitbuf, struct xmit_frame * pxmitframe)
+{
+	//printk("xmitframe_complete do loop...\n");
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitbuf->priv_data = pxmitframe;
+	
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	
+	// buffer addr assoc
+	//pxmitframe->buf_addr = pxmitbuf->pbuf+TXDESC_SIZE+CMD_HDR_SZ+(((struct tx_desc*)pxmitbuf->pbuf)->txdw0&0x0000ffff);
+	pxmitframe->buf_addr = pxmitbuf->pbuf+TXDESC_SIZE+(((struct tx_desc*)pxmitbuf->pbuf)->txdw0&0x0000ffff);
+	
+	//printk("xmitframe_complete do loop append_mpdu_unit...\n");
+	if( append_mpdu_unit(pxmitbuf,pxmitframe)== _SUCCESS)
+	{
+		//printk("append_mpdu_unit %p\n",pxmitframe->pkt);
+		free_xmitframe_ex(&pxmitframe->padapter->xmitpriv, pxmitframe);
+		pxmitbuf->aggr_nr ++;
+	}
+
+	return TXDESC_SIZE+(((struct tx_desc*)pxmitbuf->pbuf)->txdw0&0x0000ffff);
+}
+
+u8 dump_aggr_xframe(struct xmit_buf* pxmitbuf, struct xmit_frame * pxmitframe)
+{
+	_adapter * padapter = pxmitframe->padapter;
+    struct dvobj_priv   *pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;
+	
+	struct tx_desc * ptxdesc = (struct tx_desc *)pxmitbuf->pbuf;
+	struct cmd_hdr	* pcmd_hdr	= (struct cmd_hdr  *)(pxmitbuf->pbuf + TXDESC_SIZE);
+	u16 total_length = (u16) (ptxdesc->txdw0& 0xffff);
+	
+	// use 1st xmitframe as media
+	xmitframe_xmitbuf_attach(pxmitframe,pxmitbuf);
+	
+	//ptxdesc->txdw0 = cpu_to_le32((ptxdesc->txdw0&0xffff0000)|(ptxdesc->txdw0&0x0000ffff) );
+	
+	pcmd_hdr->cmd_dw0 = cpu_to_le32(((total_length-CMD_HDR_SZ)&0x0000ffff)|(pcmd_hdr->cmd_dw0&0xffff0000));			
+
+	// urb length in cmd_dw1
+	pcmd_hdr->cmd_dw1 = cpu_to_le32((pxmitbuf->aggr_nr & 0xff)|((total_length+TXDESC_SIZE)<<16));
+	
+	//printk("xmitframe_complete cmd_dw1 = %X write_port length %d... \n", pcmd_hdr->cmd_dw1, total_length);
+	pxmitframe->last[0] = 1;
+	pxmitframe->bpending[0] = _FALSE;
+	pxmitframe->mem_addr = pxmitbuf->pbuf;
+
+    if( (pdvobj->ishighspeed && ((total_length+TXDESC_SIZE)%0x200)==0) || ((!pdvobj->ishighspeed && ((total_length+TXDESC_SIZE)%0x40)==0)) )
+    {
+        ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ+8)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc + 8 bytes pending
+    }
+    else
+    {
+	    ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
+    }
+
+	write_port(pxmitframe->padapter, RTL8712_DMA_H2CCMD, total_length+TXDESC_SIZE, (u8*)pxmitframe);
+	//write_port(padapter, RTL8712_DMA_H2CCMD, total_length, (u8*)pxmitframe);
+	//dump_xframe_txaggr(padapter, pxmitbuf);
+
+	return _SUCCESS;
+}
+
+
+#endif //CONFIG_USB_TX_AGGREGATION
+
+void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz)
+{
+	uint qsel;
+	_adapter		*padapter = pxmitframe->padapter;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct tx_desc		*ptxdesc = (struct tx_desc *)pmem;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;	
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+	struct cmd_priv		*pcmdpriv = ( struct cmd_priv  *)&padapter->cmdpriv;
+#endif //CONFIG_USB_TX_AGGREGATION
+
+	u8 blnSetTxDescOffset;
+
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+#ifdef CONFIG_80211N_HT
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+#endif
+
+#ifdef CONFIG_MP_INCLUDED
+	struct tx_desc txdesc_mp;
+	_memcpy(&txdesc_mp, ptxdesc, sizeof(struct tx_desc));
+#endif
+
+	_memset(ptxdesc, 0, sizeof(struct tx_desc));
+
+	//offset 0
+	ptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);
+
+	if ( pdvobj->ishighspeed )
+	{
+		if ( ( (sz + TXDESC_SIZE) % 512 ) == 0 ) {
+			blnSetTxDescOffset = 1;
+		} else {
+			blnSetTxDescOffset = 0;
+		}
+	}
+	else
+	{
+		if ( ( (sz + TXDESC_SIZE) % 64 ) == 0 ) 	{
+			blnSetTxDescOffset = 1;
+		} else {
+			blnSetTxDescOffset = 0;
+		}
+	}
+	
+	if ( blnSetTxDescOffset )
+	{
+		ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ+8)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc + 8 bytes pending
+	}
+	else
+	{
+		ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
+	}
+
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offset0-txdesc=0x%x\n", ptxdesc->txdw0));
+
+#ifdef CONFIG_HOSTAPD_MODE
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+		update_txdesc_ex(pxmitframe, ptxdesc);
+		return;
+	}
+#endif
+
+	if(pxmitframe->frame_tag == DATA_FRAMETAG)
+	{
+		//offset 4
+
+		//ptxdesc->txdw1 |= (0x05)&0x1f;//CAM_ID(MAC_ID), default=5;
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id)&0x1f);//CAM_ID(MAC_ID)
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+		// dirty workaround, need to check if it is aggr cmd.
+		if((u8*)pmem != (u8*)pxmitframe->pxmitbuf->pbuf)
+		{
+			//printk("update_txdesc for aggr frame here!\n");
+			ptxdesc->txdw0 |= cpu_to_le32((0x3 << TYPE_SHT)&TYPE_MSK);
+
+			//ptxdesc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) & 0x00001f00);
+			qsel = (uint)(pattrib->qsel & 0x0000001f);
+			if(qsel == 2) qsel = 0;
+                        ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+
+			ptxdesc->txdw2 = cpu_to_le32((qsel << RTS_RC_SHT)&0x001f0000);
+			
+			ptxdesc->txdw6 |= cpu_to_le32((0x5 << RSVD6_SHT)&RSVD6_MSK);
+		}
+		else
+		{
+			//printk("update_txdesc here!\n");
+			ptxdesc->txdw0 |= cpu_to_le32((0x3 << TYPE_SHT)&TYPE_MSK);
+
+			ptxdesc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) & 0x00001f00);
+			qsel = (uint)(pattrib->qsel & 0x0000001f);
+                        if(qsel == 2) qsel = 0;
+
+			ptxdesc->txdw2 = cpu_to_le32((qsel << RTS_RC_SHT)&0x0001f000);
+
+			ptxdesc->txdw7 |= cpu_to_le32( pcmdpriv->cmd_seq << 24 ); 
+			pcmdpriv->cmd_seq++;
+		}
+
+		pattrib->qsel = 0x13;
+#else
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+
+#endif //CONFIG_USB_TX_AGGREGATION
+
+		if (!pqospriv->qos_option)
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(16));//Non-QoS
+
+		if ((pattrib->encrypt > 0) && !pattrib->bswenc)
+		{
+			switch (pattrib->encrypt)
+			{	//SEC_TYPE
+				case _WEP40_:
+				case _WEP104_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
+
+					//KEY_ID when WEP is used;
+					ptxdesc->txdw1 |= cpu_to_le32((psecuritypriv->dot11PrivacyKeyIndex<<17)&0x00060000);
+					break;
+
+				case _TKIP_:
+				case _TKIP_WTMIC_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x02<<22)&0x00c00000);
+					break;
+
+				case _AES_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x03<<22)&0x00c00000);
+					break;
+
+				case _NO_PRIVACY_:
+				default:
+					break;
+			}
+		}
+
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offset4-txdesc=0x%x\n", ptxdesc->txdw1));
+
+		//offset 8
+		//ptxdesc->txdw2 |= AGG_EN;
+		//ptxdesc->txdw2 |= cpu_to_le32(BK);
+		if (bmcst) {
+			ptxdesc->txdw2 |= cpu_to_le32(BMC);
+		}
+
+		//offset 12
+		//f/w will increase the seqnum by itself, driver pass the correct priority to fw
+		//fw will check the correct priority for increasing the seqnum per tid.
+		//about usb using 4-endpoint, qsel points out the correct mapping between AC&Endpoint,		
+		//the purpose is that correct mapping let the MAC releases the AC Queue list correctly.		
+		//ptxdesc->txdw3 = ((pattrib->seqnum<<SEQ_SHT)&0x0fff0000);
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->priority<<SEQ_SHT)&0x0fff0000);
+
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("offsetC-txdesc=0x%x\n", ptxdesc->txdw3));
+
+		//offset 16
+		//ptxdesc->txdw4 = 0x80002040;//gtest
+		//ptxdesc->txdw4 |= TXBW;
+		//ptxdesc->txdw4 = 0x80000000;//gtest
+		//ptxdesc->txdw4 = 0x80000800;//CTS-TO-SELF
+		//ptxdesc->txdw4 = 0x00020000;//
+
+		//offset 20
+		//ptxdesc->txdw5 = 0x001f9600;//gtest//54M
+		//ptxdesc->txdw5 = 0x001f8000;//gtest//1M
+		//ptxdesc->txdw5 = 0x001f1600;//gtest//54M
+		//ptxdesc->txdw5 = 0x001f2600;//gtest//MCS7
+
+		if ((pattrib->ether_type != 0x888e) && (pattrib->ether_type != 0x0806) && (pattrib->dhcp_pkt != 1))
+		{
+			//Not EAP & ARP type data packet
+
+#ifdef CONFIG_80211N_HT	
+			if(phtpriv->ht_option==1) //B/G/N Mode
+			{
+				if(phtpriv->ampdu_enable != _TRUE) {
+					ptxdesc->txdw2 |= cpu_to_le32(BK);
+				}
+
+				//ptxdesc->txdw4 = cpu_to_le32(0x80000000);//driver uses data rate
+				//ptxdesc->txdw4 |= cpu_to_le32(BIT(18)|BIT(20));
+				//ptxdesc->txdw5 = cpu_to_le32(0x001f2600);// MCS7				
+				//ptxdesc->txdw5 = cpu_to_le32(0x001f3600);// MCS15
+			}
+			else
+#endif
+			{
+				//ptxdesc->txdw4 = 0x80000000;//driver uses data rate
+				//ptxdesc->txdw5 = 0x001f1600;// 54M
+				//ptxdesc->txdw5 = 0x001f2600;//MCS7						
+				//ptxdesc->txdw5 = 0x001f9600;// 54M
+			}
+		}
+		else
+		{
+			// EAP data packet and ARP packet.
+			// Use the 1M data rate to send the EAP/ARP packet.
+			// This will maybe make the handshake smooth.
+
+			ptxdesc->txdw4 = cpu_to_le32(0x80000000);//driver uses data rate
+			ptxdesc->txdw5 = cpu_to_le32(0x001f8000);// 1M
+		}
+
+#ifdef CONFIG_MP_INCLUDED
+		if (pattrib->pctrl == 1) // mp tx packets
+		{
+			struct tx_desc *ptxdesc_mp;
+
+			ptxdesc_mp = &txdesc_mp;
+
+			//offset 8
+			ptxdesc->txdw2 = cpu_to_le32(ptxdesc_mp->txdw2);
+			if (bmcst) ptxdesc->txdw2 |= cpu_to_le32(BMC);
+			ptxdesc->txdw2 |= cpu_to_le32(BK);	
+//RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("mp pkt offset8-txdesc=0x%8x\n", ptxdesc->txdw2));			
+
+			// offset 16
+			ptxdesc->txdw4 = cpu_to_le32(ptxdesc_mp->txdw4);
+//RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("mp pkt offset16-txdesc=0x%8x\n", ptxdesc->txdw4));
+
+			//offset 20
+			ptxdesc->txdw5 = cpu_to_le32(ptxdesc_mp->txdw5);
+//RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("mp pkt offset20-txdesc=0x%8x\n", ptxdesc->txdw5));				
+
+			pattrib->pctrl = 0;//reset to zero;
+		}
+#endif
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+		if ( pattrib->hw_tcp_csum == 1 ) {
+			// ptxdesc->txdw6 = 0; // clear TCP_CHECKSUM and IP_CHECKSUM. It's zero already!!
+			u8 ip_hdr_offset = 32 + pattrib->hdrlen + pattrib->iv_len + 8;
+			ptxdesc->txdw7 = (1 << 31) | (ip_hdr_offset << 16);
+			printk("ptxdesc->txdw7 = %08x\n", ptxdesc->txdw7);
+		}
+#endif
+	}
+	else if(pxmitframe->frame_tag == MGNT_FRAMETAG)
+	{
+		//printk("pxmitframe->frame_tag == MGNT_FRAMETAG\n");
+
+		//offset 4
+		ptxdesc->txdw1 |= (0x05)&0x1f;//CAM_ID(MAC_ID), default=5;
+		//ptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id)&0x1f);//CAM_ID(MAC_ID)
+		
+		qsel = (uint)(pattrib->qsel&0x0000001f);
+
+		ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
+
+		//if(!pqospriv->qos_option)
+		ptxdesc->txdw1 |= cpu_to_le32(BIT(16));//Non-QoS
+
+		//offset 8
+		//ptxdesc->txdw2 |= AGG_EN;
+		//ptxdesc->txdw2 |= cpu_to_le32(BK);
+		if(bmcst)
+		{
+			ptxdesc->txdw2 |= cpu_to_le32(BMC);
+		}
+
+		//offset 12
+		//f/w will increase the seqnum by itself, driver pass the correct priority to fw
+		//fw will check the correct priority for increasing the seqnum per tid.
+		//about usb using 4-endpoint, qsel points out the correct mapping between AC&Endpoint,		
+		//the purpose is that correct mapping let the MAC releases the AC Queue list correctly.		
+		//ptxdesc->txdw3 = ((pattrib->seqnum<<SEQ_SHT)&0x0fff0000);
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->priority<<SEQ_SHT)&0x0fff0000);
+
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offsetC-txdesc=0x%x\n", ptxdesc->txdw3));
+
+		//offset 16
+		ptxdesc->txdw4 = cpu_to_le32(0x80002040);//gtest
+		//ptxdesc->txdw4 = 0x80001000;//
+		//ptxdesc->txdw4 = 0x80000800;//
+		//ptxdesc->txdw4 = 0x80000000;//
+		//ptxdesc->txdw4 |= TXBW;
+
+		//offset 20
+		//ptxdesc->txdw5 = 0x001f8800;//gtest//6M
+		ptxdesc->txdw5 = cpu_to_le32(0x001f8000);//gtest//1M
+		//ptxdesc->txdw5 = 0x001f0000;//gtest//1M
+	}
+	else if(pxmitframe->frame_tag == TXAGG_FRAMETAG)
+	{
+		//printk("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
+
+		//offset 4
+		qsel = 0x13;
+		ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
+	}
+	else
+	{
+		//printk("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
+
+		//offset 4
+		qsel = (uint)(pattrib->priority&0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
+
+		//offset 8
+		//ptxdesc->txdw2 |= AGG_EN;
+
+		//offset 12
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->seqnum<<SEQ_SHT)&0x0fff0000);
+
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offsetC-txdesc=0x%x\n", ptxdesc->txdw3));
+
+		//offset 16
+		ptxdesc->txdw4 = cpu_to_le32(0x80002040);//gtest
+		//ptxdesc->txdw4 |= TXBW;
+
+		//offset 20
+		ptxdesc->txdw5 = cpu_to_le32(0x001f9600);//gtest
+	}
+
+}
+
+int xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	struct hw_xmit *phwxmits;
+	sint hwentry;
+	struct xmit_frame *pxmitframe=NULL;	
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+	struct xmit_frame *p2ndxmitframe = NULL;
+#endif //CONFIG_USB_TX_AGGREGATION
+
+	int res=_SUCCESS, xcnt = 0;
+
+	phwxmits = pxmitpriv->hwxmits;
+	hwentry = pxmitpriv->hwxmit_entry;
+
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete()\n"));
+
+	if(pxmitbuf==NULL)
+	{
+		pxmitbuf = alloc_xmitbuf(pxmitpriv);
+		if(!pxmitbuf)
+		{
+			return _FALSE;
+		}
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+		pxmitbuf->aggr_nr = 0;
+#endif //CONFIG_USB_TX_AGGREGATION
+
+	}
+
+	// 1st frame dequeued
+	pxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);
+	// need to remember the 1st frame
+
+	if(pxmitframe!=NULL)
+	{
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+		/*	1. dequeue 2nd frame
+		 *  2. aggr if 2nd xframe is dequeued, else dump directly
+		 */
+		if(AGGR_NR_HIGH_BOUND > 1)
+			p2ndxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);
+
+		if(pxmitframe->frame_tag != DATA_FRAMETAG)
+		{
+			//printk("pxframe is not data type.\n");
+			free_xmitbuf(pxmitpriv, pxmitbuf);
+			return _FALSE;
+		}
+
+		if(p2ndxmitframe!=NULL)
+			if(p2ndxmitframe->frame_tag!=DATA_FRAMETAG)
+			{
+		//		printk("p2ndxframe is not data type\n");
+				free_xmitbuf(pxmitpriv, pxmitbuf);
+				return _FALSE;
+			}
+
+		xmitframe_aggr_1st(pxmitbuf, pxmitframe);
+
+		if(p2ndxmitframe !=NULL)
+		{
+			u16 total_length;
+			total_length = xmitframe_aggr_next(pxmitbuf,p2ndxmitframe);
+			
+			do
+			{
+
+		//		printk("dequeue next.\n");
+				p2ndxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);
+			
+				if( p2ndxmitframe!=NULL )
+					total_length = xmitframe_aggr_next(pxmitbuf,p2ndxmitframe);
+				else
+					break;
+			}while(total_length <= 0x1800&& pxmitbuf->aggr_nr <= AGGR_NR_HIGH_BOUND);
+			//}while(total_length <= 0x1800);
+			//}while(pxmitbuf->aggr_nr <= AGGR_NR_HIGH_BOUND);
+		}
+
+		//printk("xmitframe_complete aggr. ed ...\n");
+		if (pxmitbuf->aggr_nr > 0)
+		{
+			dump_aggr_xframe(pxmitbuf,pxmitframe);
+		}
+
+#else
+
+		xmitframe_xmitbuf_attach(pxmitframe,pxmitbuf);
+
+		if(pxmitframe->frame_tag == DATA_FRAMETAG)
+		{
+			if(pxmitframe->attrib.priority<=15)//TID0~15
+			{
+				res = xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+			}
+
+			//always return ndis_packet after xmitframe_coalesce
+			//printk("xmitframe_complete(): os_xmit_complete\n");
+			os_xmit_complete(padapter, pxmitframe);
+		}
+
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete(): dump_xframe\n"));
+
+		//_enter_critical(&pxmitpriv->lock, &irqL);
+		if(res == _SUCCESS)
+		{
+			dump_xframe(padapter, pxmitframe);
+		}
+		else
+		{
+			free_xmitframe_ex(pxmitpriv, pxmitframe);
+		}
+	 	//_exit_critical(&pxmitpriv->lock, &irqL);
+
+		xcnt++;
+
+#endif //CONFIG_USB_TX_AGGREGATION
+	}
+	else // pxmitframe == NULL && p2ndxmitframe == NULL
+	{
+			//printk("xmitframe_complete()->free_xmitbuf()\n");
+		free_xmitbuf(pxmitpriv, pxmitbuf);
+		return _FALSE;
+	}
+
+	return _TRUE;
+}
+
+void dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int t, sz, w_sz;
+	u8 *mem_addr;
+	u32 ff_hwaddr;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;
+	
+//#ifdef CONFIG_USB_HCI		
+//	pxmitframe->irpcnt= pattrib->nr_frags;
+//#endif
+
+#ifdef CONFIG_80211N_HT
+	if (pxmitframe->attrib.ether_type != 0x0806)
+	{
+		if ((pxmitframe->attrib.ether_type != 0x888e))
+		{
+			issue_addbareq_cmd(padapter, pattrib->priority);
+		}
+	}
+#endif
+
+	//mem_addr = ((unsigned char *)pxmitframe->mem) + WLANHDR_OFFSET;
+	mem_addr = pxmitframe->buf_addr;
+
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("dump_xframe()\n"));
+	//printk("dump_xframe()\n");
+
+	for (t = 0; t < pattrib->nr_frags; t++)
+	{
+		if (t != (pattrib->nr_frags - 1))
+		{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
+
+			sz = pxmitpriv->frag_len;
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);					
+
+#ifdef CONFIG_USB_HCI
+			pxmitframe->last[t] = 0;
+#endif
+		}
+		else
+		{
+			sz = pattrib->last_txcmdsz;
+
+#ifdef CONFIG_USB_HCI
+			pxmitframe->last[t] = 1;
+#endif
+		}
+
+		update_txdesc(pxmitframe, (uint*)mem_addr, sz);
+
+		w_sz = sz + TXDESC_SIZE;
+
+#ifdef CONFIG_USB_HCI
+
+		pxmitframe->mem_addr = mem_addr;
+
+		//_enter_critical(&pxmitpriv->lock, &irqL);
+		//pxmitframe->irpcnt--;
+		//pxmitframe->fragcnt++;
+		pxmitframe->bpending[t] = _FALSE;
+		//_exit_critical(&pxmitpriv->lock, &irqL);
+
+#endif //#ifdef CONFIG_USB_HCI
+
+		ff_hwaddr = get_ff_hwaddr(pxmitframe);
+
+#ifdef PLATFORM_OS_CE
+		write_port(padapter, ff_hwaddr, w_sz, (unsigned char*)mem_addr);
+#else
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+		write_port(padapter, RTL8712_DMA_H2CCMD, w_sz, (unsigned char*)pxmitframe);
+#else
+		write_port(padapter, ff_hwaddr, w_sz, (unsigned char*)pxmitframe);
+#endif //CONFIG_USB_TX_AGGREGATION
+
+#endif
+
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("write_port, w_sz=%d\n", w_sz));
+		//printk("write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);      
+
+		mem_addr += w_sz;
+
+		mem_addr = (u8 *)RND4(((uint)(mem_addr)));
+	}
+
+	//xmitframe_complete(padapter, pxmitpriv);
+}
+
+#ifdef CONFIG_SDIO_HCI
+void update_free_ffsz(_adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,
+		("====(before)=padapter->xmitpriv.public_pgsz=0x%x====update_free_ffsz: free_pg=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\n",
+		pxmitpriv->public_pgsz,
+		pxmitpriv->free_pg[0],pxmitpriv->free_pg[1],pxmitpriv->free_pg[2],pxmitpriv->free_pg[3],
+		pxmitpriv->free_pg[4],pxmitpriv->free_pg[5],pxmitpriv->free_pg[6],pxmitpriv->free_pg[7]));
+
+	read_mem(padapter, SDIO_BCNQ_FREEPG, 8, pxmitpriv->free_pg);
+	pxmitpriv->public_pgsz = pxmitpriv->free_pg[0];
+	if (pxmitpriv->public_pgsz > pxmitpriv->init_pgsz) {
+		pxmitpriv->init_pgsz = pxmitpriv->public_pgsz;
+	}
+	{
+		u8 diff;
+		if (pxmitpriv->public_pgsz > (pxmitpriv->init_pgsz - pxmitpriv->used_pgsz)) {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,
+				 ("====(0)=====update_free_ffsz: pxmitpriv->public_pgsz=0x%x pxmitpriv->init_pgsz=0x%x pxmitpriv->used_pgsz=0x%x\n",
+				  pxmitpriv->public_pgsz, pxmitpriv->init_pgsz, pxmitpriv->used_pgsz));
+			diff = pxmitpriv->public_pgsz - (pxmitpriv->init_pgsz - pxmitpriv->used_pgsz);
+			pxmitpriv->used_pgsz = pxmitpriv->used_pgsz - diff;
+			//pxmitpriv->required_pgsz = pxmitpriv->required_pgsz - diff;
+			RT_TRACE(_module_hci_ops_c_,_drv_notice_,
+				 ("====(1)=====update_free_ffsz: pxmitpriv->public_pgsz=0x%x diff=0x%x pxmitpriv->used_pgsz=0x%x pxmitpriv->required_pgsz=0x%x\n",
+				  pxmitpriv->public_pgsz, diff, pxmitpriv->used_pgsz, pxmitpriv->required_pgsz));
+		} else {
+
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,
+		 ("====(after)=====update_free_ffsz: free_pg=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\n",
+		pxmitpriv->free_pg[0],pxmitpriv->free_pg[1],pxmitpriv->free_pg[2],pxmitpriv->free_pg[3],
+		pxmitpriv->free_pg[4],pxmitpriv->free_pg[5],pxmitpriv->free_pg[6],pxmitpriv->free_pg[7]));
+
+	return;
+}
+
+u8 check_fifosz(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	u8 res = _SUCCESS;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	u8 public_used=0,dedicated_sz=0;
+	u32 pkt_len;
+	u8 idx=0,blk_num,pagenum_required;
+	u8 ac_idx;
+
+	pkt_len=pxmitframe->attrib.pktlen+pxmitframe->attrib.hdrlen+TXDESC_SIZE;
+	blk_num=(u8)((pkt_len>>9)+((pkt_len%512 ==0)? 0:1));
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_debug_,("pkt_len = %d; blk_num = %d pkt_len mod 512 = %d\n", pkt_len, blk_num,pkt_len%512));
+
+	pxmitframe->attrib.qsel = (uint)pxmitframe->attrib.priority;
+
+	switch(pxmitframe->attrib.priority){
+		case 0: //BE
+		case 3:
+			ac_idx=BEQ_FREEPG_INX;
+			break;
+		case 1: //BK
+		case 2:
+			ac_idx=BKQ_FREEPG_INX;
+			break;
+		case 4: //VI
+		case 5:
+			ac_idx=VIQ_FREEPG_INX;
+			break;
+		case 6: //VO
+		case 7:
+			ac_idx=VOQ_FREEPG_INX;
+			break;
+	}
+	pagenum_required=blk_num*2;
+
+	pxmitframe->pg_num=pagenum_required;
+	dedicated_sz=pxmitpriv->free_pg[ac_idx]-pxmitpriv->free_pg[BCNQ_FREEPG_INX];
+	if(pxmitpriv->free_pg[ac_idx] >(pxmitframe->pg_num+5)){
+		if(dedicated_sz >=pxmitframe->pg_num){
+			public_used=0;
+		}
+		else{
+			public_used=pxmitframe->pg_num-dedicated_sz;
+		}
+
+		for(idx=0;idx<8;idx++){
+			if(idx==ac_idx){
+				pxmitpriv->free_pg[idx]-=pxmitframe->pg_num;
+			}
+			else{
+				pxmitpriv->free_pg[idx]-=public_used;
+			}
+		}
+	}
+	else{
+		res=_FAIL;
+	}
+	
+	return res;
+
+}
+void enqueue_xmitbuf(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf){
+	_irqL irqL;
+
+	_enter_critical(&pxmitpriv->pending_xmitbuf_queue.lock, &irqL);
+	list_delete(&pxmitbuf->list);
+	list_insert_tail(&(pxmitbuf->list), get_list_head(&pxmitpriv->pending_xmitbuf_queue));
+	_exit_critical(&pxmitpriv->pending_xmitbuf_queue.lock, &irqL);
+	RT_TRACE(_module_rtl8712_xmit_c_,_drv_notice_,("\n Enqueue xmitbuf ok!!!\n"));
+	return;
+}
+
+struct xmit_buf *dequeue_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	_irqL irqL;
+	struct xmit_buf *pxmitbuf=  NULL;
+	_list *plist, *phead;
+	_queue *pending_xmitbuf_queue = &pxmitpriv->pending_xmitbuf_queue;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl8712_xmit_c_,_drv_notice_,("+Dequeue_xmitbuf\n"));
+
+	_enter_critical(&pending_xmitbuf_queue->lock, &irqL);
+
+	if (_queue_empty(pending_xmitbuf_queue) == _TRUE) {
+		pxmitbuf = NULL;
+	} else {
+		phead = get_list_head(pending_xmitbuf_queue);
+
+		plist = get_next(phead);
+
+		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
+
+		list_delete(&pxmitbuf->list);
+	}
+
+	_exit_critical(&pending_xmitbuf_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxmitbuf;
+}
+
+u32 xmit_xmitframes(_adapter *padapter, struct xmit_priv *pxmitpriv)
+{
+	u32 tx_action = 0;
+	struct hw_xmit *hwxmits = pxmitpriv->hwxmits;
+	u8 no_res = _FALSE, idx, hwentry = pxmitpriv->hwxmit_entry;
+	_irqL irqL0, irqL1;
+	struct tx_servq *ptxservq = NULL;
+	_list *sta_plist, *sta_phead, *xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe = NULL;
+	_queue *pframe_queue = NULL;
+	struct xmit_buf *pxmitbuf = NULL;
+
+
+	for (idx = 0; idx < hwentry; idx++, hwxmits++)
+	{
+		if (NULL == pxmitbuf) {
+			RT_TRACE(_module_rtl8712_xmit_c_,_drv_notice_,("======xmit_xmitframe: idx=%d alloc xmitbuf\n",idx));
+			pxmitbuf = alloc_xmitbuf(pxmitpriv);
+			if (pxmitbuf == NULL) {
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmit_buf is not enough!!!!!\n"));
+				break;
+			}
+		} else {
+			RT_TRACE(_module_rtl8712_xmit_c_,_drv_notice_,("======xmit_xmitframe: idx=%d use the same xmitbuf\n",idx));
+		}
+
+		_enter_critical(&hwxmits->sta_queue->lock, &irqL0);
+
+		sta_phead = get_list_head(hwxmits->sta_queue);
+		sta_plist = get_next(sta_phead);
+
+		while (end_of_queue_search(sta_phead, sta_plist) == _FALSE)
+		{
+			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq , tx_pending);
+
+			pframe_queue = &ptxservq->sta_pending;
+
+			_enter_critical(&pframe_queue->lock, &irqL1);
+
+			xmitframe_phead = get_list_head(pframe_queue);
+			xmitframe_plist = get_next(xmitframe_phead);
+
+			while (end_of_queue_search(xmitframe_phead, xmitframe_plist) == _FALSE)
+			{
+				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
+				if (NULL == pxmitframe) {
+					//queue empty
+					break;
+				}
+#if 1
+				if (((pxmitframe->attrib.pktlen + pxmitframe->attrib.hdrlen + TXDESC_SIZE) + pxmitbuf->len) > MAX_XMITBUF_SZ)
+				{
+					enqueue_xmitbuf(pxmitpriv, pxmitbuf);
+					pxmitbuf = NULL;
+					pxmitbuf = alloc_xmitbuf(pxmitpriv);
+					if (pxmitbuf == NULL) {
+						RT_TRACE(_module_rtl871x_xmit_c_, _drv_emerg_, ("\n\n=========xmit_buf is not enough!!!!!\n"));
+						break;
+					}
+				}
+#endif
+				//check hw resource
+				// if ok
+				if (_SUCCESS == check_fifosz(padapter, pxmitframe))
+				{
+					//check the frag case
+					if (((pxmitframe->attrib.pktlen + pxmitframe->attrib.hdrlen + TXDESC_SIZE) + pxmitbuf->len) < MAX_XMITBUF_SZ)
+					{
+						list_delete(&pxmitframe->list);
+
+						//coalesce the xmitframe to xmitbuf
+						pxmitframe->pxmitbuf = pxmitbuf;
+						pxmitframe->buf_addr = pxmitbuf->ptail;
+
+						pxmitbuf->ff_hwaddr = get_ff_hwaddr(pxmitframe);
+
+						xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+#ifdef CONFIG_80211N_HT
+						if ((pxmitframe->attrib.ether_type != 0x888e) && (pxmitframe->attrib.dhcp_pkt != 1))
+							issue_addbareq_cmd(padapter, pxmitframe->attrib.priority);
+#endif
+						RT_TRACE(_module_rtl8712_xmit_c_, _drv_notice_, ("\n=before free_xmitframe=\n"));
+						// need to check the xmitbuf size
+#ifdef PLATFORM_LINUX
+						// why not do this at free_xmitframe? Lucas
+						dev_kfree_skb_any(pxmitframe->pkt);
+						pxmitframe->pkt = NULL;
+#endif
+						free_xmitframe(pxmitpriv, pxmitframe);
+						RT_TRACE(_module_rtl8712_xmit_c_, _drv_notice_, ("\n=after free_xmitframe=\n"));
+						pxmitframe = NULL;
+					}
+					else {
+						//xmitbuf is not enough
+						RT_TRACE(_module_rtl871x_xmit_c_,_drv_emerg_,("\n\n\n=000========xmit_buf is not enough!!!!!"));
+					}
+				}
+				// NOK
+				else {
+					//HW resource is not enough
+					RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\n\n\n========HW resource is not enough idx=%d!!!!!", idx));
+					tx_action = -1;
+					goto out1;
+				}
+				xmitframe_plist = get_next(xmitframe_phead);
+			}
+out1:
+			_exit_critical(&pframe_queue->lock, &irqL1);
+			sta_plist = get_next(sta_plist);
+
+			if (_queue_empty(pframe_queue)) //must be done after get_next and before break
+				list_delete(&ptxservq->tx_pending);
+		}
+
+		_exit_critical(&hwxmits->sta_queue->lock, &irqL0);
+		//dump xmit_buf to hw fifo
+		if (pxmitbuf->len > 0) {
+			RT_TRACE(_module_rtl8712_xmit_c_, _drv_notice_, ("\n ====pxmitbuf->len=%d enqueue\n",pxmitbuf->len));
+
+			//enqueue
+			enqueue_xmitbuf(pxmitpriv, pxmitbuf);
+			pxmitbuf = NULL;
+		} else {
+			RT_TRACE(_module_rtl8712_xmit_c_, _drv_notice_, ("\n ==[else]==pxmitbuf->len=%d\n",pxmitbuf->len));
+		}
+	}
+
+	if (pxmitbuf) {//add to prevent kernel panic if bk queue have packet to xmit
+		if (pxmitbuf->len == 0) {
+			free_xmitbuf(pxmitpriv, pxmitbuf);
+			RT_TRACE(_module_rtl8712_xmit_c_, _drv_notice_, ("\n ==[free xmitbuf]==pxmitbuf->len=%d\n", pxmitbuf->len));
+		}
+	}
+
+	while (_queue_empty(&pxmitpriv->pending_xmitbuf_queue) == _FALSE) {
+		pxmitbuf = dequeue_xmitbuf(pxmitpriv);
+		if (NULL != pxmitbuf) {
+			write_port(padapter, pxmitbuf->ff_hwaddr, pxmitbuf->len, (u8*)pxmitbuf);
+			pxmitbuf->len = 0;
+			free_xmitbuf(pxmitpriv,pxmitbuf);
+		}
+	}
+
+	return tx_action;
+}
+
+thread_return xmit_thread(thread_context context)
+{
+	u8 hwentry;
+	struct hw_xmit *hwxmits;
+	_adapter *padapter = (_adapter *)context;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+
+	alloc_hwxmits(padapter);
+
+	hwxmits = pxmitpriv->hwxmits;
+	hwentry = pxmitpriv->hwxmit_entry;
+
+	init_hwxmits(hwxmits, hwentry);
+
+#ifdef PLATFORM_LINUX
+	daemonize("%s", padapter->pnetdev->name);
+	allow_signal(SIGTERM);
+#endif
+
+	while(1)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("Before down xmit_sema\n"));
+		if (_down_sema(&pxmitpriv->xmit_sema) == _FAIL) {
+			//Error Case!!!
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_emerg_, ("down xmit_sema fail\n"));
+
+			if (txframes_pending(padapter) == _TRUE)
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_emerg_, ("xmit_priv still has data but we can't down xmit_sema"));
+
+			break;
+		}
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("down xmit_sema success\n"));
+
+_next:
+		if ((padapter->bDriverStopped == _TRUE) || (padapter->bSurpriseRemoved == _TRUE)) {
+			//DbgPrint("xmit_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved);
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmit thread => bDriverStopped or bSurpriseRemoved \n"));
+			break;
+		}
+
+		if (txframes_pending(padapter) == _FALSE) {
+			continue;
+		}
+
+		if (register_tx_alive(padapter) != _SUCCESS) {
+			continue;
+		}
+
+		update_free_ffsz(padapter);
+
+		// dequeue frame
+		xmit_xmitframes(padapter, pxmitpriv);
+
+		if ((txframes_pending(padapter)) == _TRUE) {
+			udelay_os(1);
+			goto _next;//no hw resource to send
+		} else {
+			unregister_tx_alive(padapter);
+		}
+
+#ifdef PLATFORM_LINUX
+		if (signal_pending(current)) {
+			flush_signals(current);
+		}
+#endif
+	}
+
+	//free_hwxmits(padapter);
+
+	_up_sema(&pxmitpriv->terminate_xmitthread_sema);
+
+	thread_exit();
+}
+#endif
+
+int xmit_direct(_adapter *padapter, struct xmit_frame *pxmitframe)
+{	
+	//struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	//_irqL irqL;	
+	int res = _SUCCESS;
+
+
+	res = xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+
+	pxmitframe->pkt = NULL;
+
+	//_enter_critical(&pxmitpriv->lock, &irqL);
+	if (res == _SUCCESS) {
+		dump_xframe(padapter, pxmitframe);
+	}
+	//_exit_critical(&pxmitpriv->lock, &irqL);   	
+
+	return res;
+}
+
+int xmit_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	if (xmit_classifier(padapter, pxmitframe) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("drop xmit pkt for classifier fail\n"));		
+		pxmitframe->pkt = NULL;
+		return _FAIL;
+	}
+
+	return _SUCCESS;
+}
+
diff --git a/drivers/net/wireless/8712u/xmit/rtl871x_xmit.c b/drivers/net/wireless/8712u/xmit/rtl871x_xmit.c
new file mode 100755
index 0000000..b07ed5d
--- /dev/null
+++ b/drivers/net/wireless/8712u/xmit/rtl871x_xmit.c
@@ -0,0 +1,1999 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/ 
+#define _RTL871X_XMIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl871x_byteorder.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#include <if_ether.h>
+#include <ip.h>
+#endif
+
+
+#ifdef  PLATFORM_LINUX
+#include <linux/rtnetlink.h>
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#endif
+#endif
+
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+
+static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+
+void _init_txservq(struct tx_servq *ptxservq)
+{
+_func_enter_;
+	_init_listhead(&ptxservq->tx_pending);
+	_init_queue(&ptxservq->sta_pending);
+	ptxservq->qcnt = 0;
+_func_exit_;		
+}
+
+
+void	_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
+{	
+	
+_func_enter_;
+
+	_memset((unsigned char *)psta_xmitpriv, 0, sizeof (struct sta_xmit_priv));
+
+	_spinlock_init(&psta_xmitpriv->lock);
+	
+	//for(i = 0 ; i < MAX_NUMBLKS; i++)
+	//	_init_txservq(&(psta_xmitpriv->blk_q[i]));
+
+	_init_txservq(&psta_xmitpriv->be_q);
+	_init_txservq(&psta_xmitpriv->bk_q);
+	_init_txservq(&psta_xmitpriv->vi_q);
+	_init_txservq(&psta_xmitpriv->vo_q);
+	_init_listhead(&psta_xmitpriv->legacy_dz);
+	_init_listhead(&psta_xmitpriv->apsd);
+	
+_func_exit_;	
+
+}
+
+sint	_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
+{
+
+	sint i;
+	struct xmit_buf* pxmitbuf;
+	struct xmit_frame*	pxframe;
+	sint	res=_SUCCESS;   
+
+_func_enter_;   	
+
+	_memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
+	
+	_spinlock_init(&pxmitpriv->lock);
+	_init_sema(&pxmitpriv->xmit_sema, 0);
+	_init_sema(&pxmitpriv->terminate_xmitthread_sema, 0);
+
+	/* 
+	Please insert all the queue initializaiton using _init_queue below
+	*/
+
+	pxmitpriv->adapter = padapter;
+	
+	//for(i = 0 ; i < MAX_NUMBLKS; i++)
+	//	_init_queue(&pxmitpriv->blk_strms[i]);
+	
+	_init_queue(&pxmitpriv->be_pending);
+	_init_queue(&pxmitpriv->bk_pending);
+	_init_queue(&pxmitpriv->vi_pending);
+	_init_queue(&pxmitpriv->vo_pending);
+	_init_queue(&pxmitpriv->bm_pending);
+
+	_init_queue(&pxmitpriv->legacy_dz_queue);
+	_init_queue(&pxmitpriv->apsd_queue);
+
+	_init_queue(&pxmitpriv->free_xmit_queue);
+
+
+	/*	
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME, 
+	and initialize free_xmit_frame below.
+	Please also apply  free_txobj to link_up all the xmit_frames...
+	*/
+
+	pxmitpriv->pallocated_frame_buf = _vmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+	
+	if (pxmitpriv->pallocated_frame_buf  == NULL){
+		pxmitpriv->pxmit_frame_buf =NULL;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_frame fail!\n"));	
+		res= _FAIL;
+		goto exit;
+	}
+	pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -
+							((uint) (pxmitpriv->pallocated_frame_buf) &3);
+
+	pxframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
+
+
+	for (i = 0; i < NR_XMITFRAME; i++)
+	{
+		_init_listhead(&(pxframe->list));
+
+		pxframe->padapter = padapter;
+		pxframe->frame_tag = DATA_FRAMETAG;
+
+		pxframe->pkt = NULL;		
+
+                pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+ 
+		list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));
+
+		pxframe++;
+	}
+
+	pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;
+
+	/*
+		init xmit hw_txqueue
+	*/	
+	_init_hw_txqueue(&pxmitpriv->be_txqueue, BE_QUEUE_INX);
+	_init_hw_txqueue(&pxmitpriv->bk_txqueue, BK_QUEUE_INX);
+	_init_hw_txqueue(&pxmitpriv->vi_txqueue, VI_QUEUE_INX);
+	_init_hw_txqueue(&pxmitpriv->vo_txqueue, VO_QUEUE_INX);
+	_init_hw_txqueue(&pxmitpriv->bmc_txqueue, BMC_QUEUE_INX);
+
+	//init_xmit_priv(pxmitpriv, padapter);
+
+	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
+
+#ifdef CONFIG_USB_HCI
+
+	pxmitpriv->txirp_cnt=1;
+
+	_init_sema(&(pxmitpriv->tx_retevt), 0);
+
+	//per AC pending irp
+	pxmitpriv->beq_cnt = 0;
+	pxmitpriv->bkq_cnt = 0;
+	pxmitpriv->viq_cnt = 0;
+	pxmitpriv->voq_cnt = 0;
+	
+#endif	
+
+	//init xmit_buf
+	_init_queue(&pxmitpriv->free_xmitbuf_queue);
+	_init_queue(&pxmitpriv->pending_xmitbuf_queue);
+
+	pxmitpriv->pallocated_xmitbuf = _malloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);	
+	if (pxmitpriv->pallocated_xmitbuf  == NULL){
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_buf fail!\n"));
+		res= _FAIL;
+		goto exit;
+	}
+
+	pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -
+							((uint) (pxmitpriv->pallocated_xmitbuf) &3);
+
+	pxmitbuf = (struct xmit_buf*)pxmitpriv->pxmitbuf;
+
+	for (i = 0; i < NR_XMITBUFF; i++)
+	{
+		_init_listhead(&pxmitbuf->list);
+
+		//pxmitbuf->priv_data = NULL;
+
+		pxmitbuf->pallocated_buf = _malloc(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
+		if (pxmitbuf->pallocated_buf == NULL)
+		{
+			res = _FAIL;
+			goto exit;
+		}
+
+		pxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -((uint) (pxmitbuf->pallocated_buf) &(XMITBUF_ALIGN_SZ-1));
+
+		os_xmit_resource_alloc(padapter, pxmitbuf);
+
+		list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
+
+		pxmitbuf++;
+	}
+
+	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
+
+	_init_workitem(&padapter->wkFilterRxFF0, SetFilter, padapter );
+
+#ifndef CONFIG_SDIO_HCI
+
+	alloc_hwxmits(padapter);
+	init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
+
+#endif
+
+#if defined (CONFIG_USB_HCI) && defined(PLATFORM_LINUX)
+
+	tasklet_init(&pxmitpriv->xmit_tasklet,
+	     (void(*)(unsigned long))xmit_bh,
+	     (unsigned long)padapter);
+
+#endif
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+void  mfree_xmit_priv_lock (struct xmit_priv *pxmitpriv)
+{
+	_spinlock_free(&pxmitpriv->lock);
+	_free_sema(&pxmitpriv->xmit_sema);
+	_free_sema(&pxmitpriv->terminate_xmitthread_sema);
+
+	_spinlock_free(&pxmitpriv->be_pending.lock);
+	_spinlock_free(&pxmitpriv->bk_pending.lock);
+	_spinlock_free(&pxmitpriv->vi_pending.lock);
+	_spinlock_free(&pxmitpriv->vo_pending.lock);
+	_spinlock_free(&pxmitpriv->bm_pending.lock);
+
+	_spinlock_free(&pxmitpriv->legacy_dz_queue.lock);
+	_spinlock_free(&pxmitpriv->apsd_queue.lock);
+
+	_spinlock_free(&pxmitpriv->free_xmit_queue.lock);
+	_spinlock_free(&pxmitpriv->free_xmitbuf_queue.lock);
+	_spinlock_free(&pxmitpriv->pending_xmitbuf_queue.lock);
+
+}
+
+void _free_xmit_priv (struct xmit_priv *pxmitpriv)
+{
+       int i;
+      _adapter *padapter = pxmitpriv->adapter;
+	struct xmit_frame*	pxmitframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
+	struct xmit_buf*	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+ _func_enter_;   
+ 
+	mfree_xmit_priv_lock (pxmitpriv);
+ 
+ 	if(pxmitpriv->pxmit_frame_buf==NULL)
+		goto out;
+	
+	for(i=0; i<NR_XMITFRAME; i++)
+	{	
+		os_xmit_complete(padapter, pxmitframe);		
+
+		//os_xmit_resource_free(padapter, pxmitframe);
+			
+		pxmitframe++;
+	}		
+	
+	for(i=0; i<NR_XMITBUFF; i++)
+	{
+		os_xmit_resource_free(padapter, pxmitbuf);
+		
+		_mfree(pxmitbuf->pallocated_buf, MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
+		
+		pxmitbuf++;
+	}
+	
+	if(pxmitpriv->pallocated_frame_buf)
+		_vmfree(pxmitpriv->pallocated_frame_buf, NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+
+	if(pxmitpriv->pallocated_xmitbuf)
+		_mfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
+
+	free_hwxmits(padapter);
+	
+out:	
+
+_func_exit_;		
+
+}
+
+sint update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattrib)
+{
+	uint i;
+	struct pkt_file pktfile;
+	struct sta_info *psta = NULL;
+	struct ethhdr etherhdr;
+
+	struct tx_cmd txdesc;
+
+	sint bmcast;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv= &pmlmepriv->qospriv;
+	sint res = _SUCCESS;
+
+ _func_enter_;
+
+	_open_pktfile(pkt, &pktfile);
+
+	i = _pktfile_read(&pktfile, (unsigned char*)&etherhdr, ETH_HLEN);
+
+	pattrib->ether_type = ntohs(etherhdr.h_proto);
+
+#ifdef CONFIG_PWRCTRL
+{
+	u8 bool;
+	//If driver xmit ARP packet, driver can set ps mode to initial setting. It stands for getting DHCP or fix IP.
+	if(pattrib->ether_type == 0x0806)
+	{
+		if(padapter->pwrctrlpriv.pwr_mode != padapter->registrypriv.power_mgnt){
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("update_attrib: get ARP Packet \n"));
+			_cancel_timer(&(pmlmepriv->dhcp_timer), &bool);
+			set_ps_mode(padapter, padapter->registrypriv.power_mgnt, padapter->registrypriv.smart_ps);
+		}
+	}
+}
+#endif
+
+	_memcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);
+	_memcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);
+
+	pattrib->pctrl = 0;
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+		_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	}
+	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
+		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	}
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);		
+
+	}
+#ifdef CONFIG_MP_INCLUDED
+	else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	{
+		//firstly, filter packet not belongs to mp
+		if (pattrib->ether_type != 0x8712) {
+			res = _FAIL;
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+				 ("IN WIFI_MP_STATE but the ether_type(0x%x) != 0x8712!!!\n",
+				 pattrib->ether_type));
+			goto exit;
+		}
+
+		//for mp storing the txcmd per packet,
+		//according to the info of txcmd to update pattrib
+		i = _pktfile_read(&pktfile, (u8*)&txdesc, TXDESC_SIZE);//get MP_TXDESC_SIZE bytes txcmd per packet
+
+		_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);		 
+
+		pattrib->pctrl = 1;
+	}
+#endif
+
+	pattrib->pktlen = pktfile.pkt_len;	// xmitframe_coalesce() overwirte this!
+
+	if (ETH_P_IP == pattrib->ether_type)
+	{
+		// The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time 
+		// to prevent DHCP protocol fail
+		u8 tmp[24];
+		_pktfile_read(&pktfile, &tmp[0], 24);
+		pattrib->dhcp_pkt = 0;
+		if (pktfile.pkt_len > 282) {//MINIMUM_DHCP_PACKET_SIZE) {
+			if (ETH_P_IP == pattrib->ether_type) {// IP header
+				if (((tmp[21] == 68) && (tmp[23] == 67)) ||
+					((tmp[21] == 67) && (tmp[23] == 68))) {
+					// 68 : UDP BOOTP client
+					// 67 : UDP BOOTP server
+					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("======================update_attrib: get DHCP Packet \n"));
+					// Use low rate to send DHCP packet.
+					//if(pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) 
+					//{
+					//	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee);//0xc;//ofdm 6m
+					//	tcb_desc->bTxDisableRateFallBack = false;
+					//}
+					//else
+					//	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate; 
+					//RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate)); 
+					pattrib->dhcp_pkt = 1;
+				}
+			}
+		}
+	}
+
+	bmcast = IS_MCAST(pattrib->ra);
+	// get sta_info
+	if (bmcast) {
+		psta = get_bcmc_stainfo(padapter);
+		pattrib->mac_id = 4;
+	} else {
+#ifdef CONFIG_MP_INCLUDED
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		{
+			psta = get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			pattrib->mac_id = 5;
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+				 ("update_attrib: [MP]xmit pkt:%d\n", padapter->mppriv.tx_pktcount));
+		}
+		else
+#endif
+		{
+			psta = get_stainfo(pstapriv, pattrib->ra);
+			if (psta == NULL)	{ // if we cannot get psta => drrp the pkt
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("update_attrib => get sta_info fail\n"));
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("ra:%x:%x:%x:%x:%x:%x\n",
+				pattrib->ra[0], pattrib->ra[1],
+				pattrib->ra[2], pattrib->ra[3],
+				pattrib->ra[4], pattrib->ra[5]));
+				res =_FAIL;
+				goto exit;
+			}
+
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+				pattrib->mac_id = 5;
+			} else {
+				pattrib->mac_id = psta->mac_id;
+			}
+		}
+	}
+
+	if (psta) {
+		pattrib->psta = psta;
+	} else {
+		// if we cannot get psta => drrp the pkt
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("update_attrib => get sta_info fail\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+			 ("ra:%x:%x:%x:%x:%x:%x\n",
+			  pattrib->ra[0], pattrib->ra[1], pattrib->ra[2],
+			  pattrib->ra[3], pattrib->ra[4], pattrib->ra[5]));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pattrib->ack_policy = 0;
+	// get ether_hdr_len
+	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4 ): 14; //vlan tag
+
+	if (pqospriv->qos_option) {
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) && psta->qos_option) 
+			set_qos(&pktfile, pattrib);
+		else
+			set_qos(&pktfile, pattrib);
+	} else {
+		pattrib->hdrlen = WLAN_HDR_A3_LEN;
+		pattrib->subtype = WIFI_DATA_TYPE;	
+		pattrib->priority = 0;
+	}
+	//pattrib->priority = 5; //force to used VI queue, for testing
+
+	if (psta->ieee8021x_blocked == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n psta->ieee8021x_blocked == _TRUE \n"));
+
+		pattrib->encrypt = 0;
+
+		if((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE))
+		{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npsta->ieee8021x_blocked == _TRUE pattrib->ether_type(%.4x) != 0x888\n",pattrib->ether_type));
+			res = _FAIL;
+			goto exit;
+		}
+	}
+	else
+	{
+		/*
+		if((psecuritypriv->ndisauthtype>2 && (psecuritypriv->ndisauthtype!=5)&&(psecuritypriv->ndisauthtype!=3)&&(psecuritypriv->ndisauthtype!=6) )&&(psecuritypriv->bgrpkey_handshake==_FALSE))
+		{
+			if(pattrib->ether_type== 0x888e){
+				psecuritypriv->bgrpkey_handshake=_TRUE;
+
+			}
+			else{
+				DbgPrint("\npsecuritypriv->bgrpkey_handshake==_FALSE\n");
+				res =_FAIL;
+				goto exit;
+			}
+		}
+		*/
+
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
+	}
+
+	switch (pattrib->encrypt)
+	{
+		case _WEP40_:
+		case _WEP104_:
+			pattrib->iv_len = 4;
+			pattrib->icv_len = 4;
+			break;
+
+		case _TKIP_:
+			pattrib->iv_len = 8;
+			pattrib->icv_len = 4;
+			
+			if(padapter->securitypriv.busetkipkey==_FAIL)
+			{
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npadapter->securitypriv.busetkipkey(%d)==_FAIL drop packet\n", padapter->securitypriv.busetkipkey));
+				res =_FAIL;
+				goto exit;
+			}
+					
+			break;			
+		case _AES_:
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n pattrib->encrypt=%d  (_AES_)\n",pattrib->encrypt));
+			pattrib->iv_len = 8;
+			pattrib->icv_len = 8;
+			break;
+			
+		default:
+			pattrib->iv_len = 0;
+			pattrib->icv_len = 0;
+			break;
+	}
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+		 ("update_attrib: encrypt=%d  securitypriv.sw_encrypt=%d\n",
+		  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
+
+	if (pattrib->encrypt &&
+	    ((padapter->securitypriv.sw_encrypt == _TRUE) || (psecuritypriv->hw_decrypted == _FALSE)))
+	{
+		pattrib->bswenc = _TRUE;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,
+			 ("update_attrib: encrypt=%d securitypriv.hw_decrypted=%d bswenc=_TRUE\n",
+			  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
+	} else {
+		pattrib->bswenc = _FALSE;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=_FALSE\n"));
+	}
+
+#ifdef CONFIG_MP_INCLUDED
+	//if in MP_STATE, update pkt_attrib from mp_txcmd, and overwrite some settings above.
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) {
+		pattrib->priority = (txdesc.txdw1 >> QSEL_SHT) & 0x1f;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+			 ("update_attrib: [MP]priority=0x%x\n", pattrib->priority));
+	}
+#endif
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+sint xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
+	sint 			curfragnum,length;
+	u32	datalen;
+	u8	*pframe, *payload,mic[8];
+	struct	mic_data		micdata;
+	struct	sta_info		*stainfo;
+	struct	qos_priv   *pqospriv= &(padapter->mlmepriv.qospriv);	
+	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	u8 priority[4]={0x0,0x0,0x0,0x0};
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if(pattrib->psta)
+	{
+		stainfo = pattrib->psta;
+	}
+	else
+	{
+		stainfo=get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
+	}	
+
+	
+
+_func_enter_;
+
+	if(pattrib->encrypt ==_TKIP_)//if(psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_) 
+	{
+		//encode mic code
+		if(stainfo!= NULL){
+			u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
+			datalen=pattrib->pktlen-pattrib->hdrlen;
+
+			//pframe=(u8 *)(pxmitframe->mem) + WLANHDR_OFFSET+TXDESC_OFFSET;
+			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;;
+			
+			if(bmcst)
+			{
+				if(_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==_TRUE){
+					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
+					//msleep_os(10);
+					return _FAIL;
+				}
+				//start to calculate the mic code
+				secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
+			}
+			else
+			{
+				if(_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==_TRUE){
+					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
+					//msleep_os(10);
+					return _FAIL;
+				}
+				//start to calculate the mic code
+				secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
+			}
+			
+			if(pframe[1]&1){   //ToDS==1
+				secmicappend(&micdata, &pframe[16], 6);  //DA
+				if(pframe[1]&2)  //From Ds==1
+					secmicappend(&micdata, &pframe[24], 6);
+				else
+				secmicappend(&micdata, &pframe[10], 6);		
+			}	
+			else{	//ToDS==0
+				secmicappend(&micdata, &pframe[4], 6);   //DA
+				if(pframe[1]&2)  //From Ds==1
+					secmicappend(&micdata, &pframe[16], 6);
+				else
+					secmicappend(&micdata, &pframe[10], 6);
+
+			}
+
+			if(pqospriv->qos_option==1)
+				priority[0]=(u8)pxmitframe->attrib.priority;
+
+			
+			secmicappend(&micdata, &priority[0], 4);
+	
+			payload=pframe;
+
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+				payload=(u8 *)RND4((uint)(payload));
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("===curfragnum=%d, pframe= 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
+					curfragnum,*payload, *(payload+1),*(payload+2),*(payload+3),*(payload+4),*(payload+5),*(payload+6),*(payload+7)));
+
+				payload=payload+pattrib->hdrlen+pattrib->iv_len;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",curfragnum,pattrib->hdrlen,pattrib->iv_len));
+				if((curfragnum+1)==pattrib->nr_frags){
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-( (psecuritypriv->sw_encrypt) ? pattrib->icv_len : 0);
+					secmicappend(&micdata, payload,length);
+					payload=payload+length;
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-( (psecuritypriv->sw_encrypt) ? pattrib->icv_len : 0);
+					secmicappend(&micdata, payload, length);
+					payload=payload+length+pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d length=%d pattrib->icv_len=%d",curfragnum,length,pattrib->icv_len));
+				}
+			}
+			secgetmic(&micdata,&(mic[0]));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: before add mic code!!!\n"));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: pattrib->last_txcmdsz=%d!!!\n",pattrib->last_txcmdsz));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: mic[0]=0x%.2x ,mic[1]=0x%.2x ,mic[2]=0x%.2x ,mic[3]=0x%.2x \n\
+  				mic[4]=0x%.2x ,mic[5]=0x%.2x ,mic[6]=0x%.2x ,mic[7]=0x%.2x !!!!\n",
+				mic[0],mic[1],mic[2],mic[3],mic[4],mic[5],mic[6],mic[7]));
+			//add mic code  and add the mic code length in last_txcmdsz
+
+			_memcpy(payload, &(mic[0]),8);
+			pattrib->last_txcmdsz+=8;
+			
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("\n ========last pkt========\n"));
+			payload=payload-pattrib->last_txcmdsz+8;
+			for(curfragnum=0;curfragnum<pattrib->last_txcmdsz;curfragnum=curfragnum+8)
+					RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,(" %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ",
+					*(payload+curfragnum), *(payload+curfragnum+1), *(payload+curfragnum+2),*(payload+curfragnum+3),
+					*(payload+curfragnum+4),*(payload+curfragnum+5),*(payload+curfragnum+6),*(payload+curfragnum+7)));
+		}
+		else{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: get_stainfo==NULL!!!\n"));
+		}
+	}
+	
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+sint xmitframe_swencrypt(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	
+_func_enter_;
+
+	//if((psecuritypriv->sw_encrypt)||(pattrib->bswenc))	
+	if(pattrib->bswenc)
+	{
+		//printk("start xmitframe_swencrypt\n");
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("### xmitframe_swencrypt\n"));
+		switch(pattrib->encrypt){
+		case _WEP40_:
+		case _WEP104_:
+			wep_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _TKIP_:
+			tkip_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _AES_:
+			aes_encrypt(padapter, (u8 * )pxmitframe);
+			break;
+		default:
+				break;
+		}
+	} else {
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_notice_,("### xmitframe_hwencrypt\n"));
+	}
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+
+sint make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
+{
+	u16 *qc;
+
+	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+
+//#ifdef CONFIG_PWRCTRL
+//	struct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);
+//#endif
+
+	sint res = _SUCCESS;
+	u16 *fctrl = &pwlanhdr->frame_ctl;
+
+_func_enter_;
+
+	_memset(hdr, 0, WLANHDR_OFFSET);
+
+	SetFrameSubType(fctrl, pattrib->subtype);
+
+	if (pattrib->subtype & WIFI_DATA_TYPE)
+	{
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == _TRUE)) {
+			//to_ds = 1, fr_ds = 0;
+			SetToDs(fctrl);
+			_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
+			_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+		}
+		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == _TRUE) ) {
+			//to_ds = 0, fr_ds = 1;
+			SetFrDs(fctrl);
+			_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			_memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
+			_memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
+		}
+		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+			_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+		}
+#ifdef CONFIG_MP_INCLUDED
+		else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) {
+			_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+		}
+#endif
+		else {
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
+			res = _FAIL;
+			goto exit;
+		}
+
+/*#ifdef CONFIG_PWRCTRL
+		if (pwrpriv->cpwm >= FW_PWR1 && !(padapter->mlmepriv.sitesurveyctrl.traffic_busy))
+			SetPwrMgt(fctrl);
+#else
+		if ((get_fwstate(pmlmepriv)) & WIFI_SLEEP_STATE)
+			SetPwrMgt(fctrl);
+#endif*/
+
+		if (pattrib->encrypt)
+			SetPrivacy(fctrl);
+
+		if (pqospriv->qos_option)
+		{
+			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
+
+			if (pattrib->priority)
+				SetPriority(qc, pattrib->priority);
+
+			SetAckpolicy(qc, pattrib->ack_policy);
+		}
+
+		//TODO: fill HT Control Field
+
+
+
+		//Update Seq Num will be handled by f/w
+		{
+			struct sta_info *psta;
+
+			sint bmcst = IS_MCAST(pattrib->ra);
+
+			if (pattrib->psta) {
+				psta = pattrib->psta;
+			} else {
+				if(bmcst) {
+					psta = get_bcmc_stainfo(padapter);
+				} else {
+					psta = get_stainfo(&padapter->stapriv, pattrib->ra);
+				}
+			}
+
+			if(psta)
+			{
+				psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
+				psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
+
+				pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
+
+				SetSeqNum(hdr, pattrib->seqnum);
+			}
+		}
+	}
+	else
+	{
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+void fillin_txdesc(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	u8 *ptxdesc;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+
+	sint frg_inx, frg_len;
+
+	u8 *pbuf_start;
+
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	pbuf_start = pxmitframe->buf_addr;
+	if (pbuf_start == NULL) return;
+
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;
+	while (1)
+	{
+		ptxdesc = pbuf_start;
+		frg_inx++;
+		if (bmcst || pattrib->nr_frags == frg_inx) {
+			update_txdesc(pxmitframe,(uint *) ptxdesc, pattrib->last_txcmdsz);
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("[2] fillin_txdesc:\n"));
+			break;
+		} else {
+			update_txdesc(pxmitframe,(uint *) ptxdesc,(frg_len - ((pattrib->bswenc) ? pattrib->icv_len : 0)));
+			pbuf_start += _RND512(frg_len);
+		}
+	}
+}
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+
+void xmitframe_tcp_checksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
+{
+	struct sk_buff *skb = (struct sk_buff *)pkt;
+	pattrib->hw_tcp_csum = 0;
+		
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+	{
+		if (skb_shinfo(skb)->nr_frags == 0)
+		{
+			const struct iphdr *ip = ip_hdr(skb);
+
+			if (ip->protocol == IPPROTO_TCP) 
+			{
+				// TCP checksum offload by HW
+				printk("CHECKSUM_PARTIAL TCP\n");
+				pattrib->hw_tcp_csum = 1;
+				//skb_checksum_help(skb);
+			} else if (ip->protocol == IPPROTO_UDP) {
+				//printk("CHECKSUM_PARTIAL UDP\n");
+#if 1                       
+				skb_checksum_help(skb);
+#else
+				// Set UDP checksum = 0 to skip checksum check
+				struct udphdr *udp = skb_transport_header(skb);
+				udp->check = 0;
+#endif
+			} else {
+				printk("%s-%d TCP CSUM offload Error!!\n", __FUNCTION__, __LINE__);
+								WARN_ON(1); 	/* we need a WARN() */
+			}
+		} else { // IP fragmentation case
+			printk("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __FUNCTION__, __LINE__);
+			skb_checksum_help(skb);
+		}	
+	}
+
+}
+#endif
+
+/*
+
+This sub-routine will perform all the following:
+
+1. remove 802.3 header.
+2. create wlan_header, based on the info in pxmitframe
+3. append sta's iv/ext-iv
+4. append LLC
+5. move frag chunk from pframe to pxmitframe->mem
+6. apply sw-encrypt, if necessary. 
+
+*/
+sint xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe)
+{
+	struct pkt_file pktfile;
+
+	sint frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;
+
+	uint addr;
+
+	u8 *pframe, *mem_start, *ptxdesc;
+
+	struct sta_info		*psta;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+
+	u8 *pbuf_start;
+
+	sint bmcst = IS_MCAST(pattrib->ra);
+	sint res = _SUCCESS;
+
+_func_enter_;
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	xmitframe_tcp_checksum_offload(pkt, pattrib);
+#endif
+
+	if (pattrib->psta == NULL)
+		return _FAIL;
+	psta = pattrib->psta;
+
+	if (pxmitframe->buf_addr == NULL)
+		return _FAIL;
+	pbuf_start = pxmitframe->buf_addr;
+
+	ptxdesc = pbuf_start;
+	mem_start = pbuf_start + TXDESC_OFFSET;
+
+	if (make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_coalesce: make_wlanhdr fail; drop pkt\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+	_open_pktfile(pkt, &pktfile);
+	_pktfile_read(&pktfile, NULL, (u32)pattrib->pkt_hdrlen);
+
+	//pbuf_start = (u8*)(pxmitframe->mem) + WLANHDR_OFFSET;
+	//mem_start = (u8*)(pxmitframe->mem) + WLANHDR_OFFSET + TXDESC_OFFSET;
+
+#ifdef CONFIG_MP_INCLUDED
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)/* && 
+	    (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == _TRUE)*/)
+	{	
+		//truncate TXDESC_SIZE bytes txcmd if at mp mode for 871x
+		if (pattrib->ether_type == 0x8712)
+			_pktfile_read(&pktfile, ptxdesc, TXDESC_SIZE); // take care update_txdesc overwrite this
+	}
+#endif
+
+	pattrib->pktlen = pktfile.pkt_len;
+
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;//2346-4 = 2342
+
+	while (1)
+	{
+		llc_sz = 0;
+
+		mpdu_len = frg_len;
+
+		pframe = mem_start;
+
+		//_memcpy(pframe, (u8 *)(pxmitframe->mem), pattrib->hdrlen);
+
+		SetMFrag(mem_start);
+
+		pframe += pattrib->hdrlen;
+		mpdu_len -= pattrib->hdrlen;
+
+		//adding icv, if necessary...
+		if (pattrib->iv_len)
+		{
+			//if (check_fwstate(pmlmepriv, WIFI_MP_STATE))
+			//	psta = get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			//else
+			//	psta = get_stainfo(pstapriv, pattrib->ra);
+
+			if (psta != NULL)
+			{
+				switch(pattrib->encrypt)
+				{
+					case _WEP40_:
+					case _WEP104_:
+						WEP_IV(pattrib->iv, psta->dot11txpn, (u8)psecuritypriv->dot11PrivacyKeyIndex);	
+						break;
+					case _TKIP_:			
+						if(bmcst)
+							TKIP_IV(pattrib->iv, psta->dot11txpn, (u8)psecuritypriv->dot118021XGrpKeyid);
+						else
+							TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
+						break;			
+					case _AES_:
+						if(bmcst)
+							AES_IV(pattrib->iv, psta->dot11txpn, (u8)psecuritypriv->dot118021XGrpKeyid);
+						else
+							AES_IV(pattrib->iv, psta->dot11txpn, 0);
+						break;
+				}
+			}
+
+			_memcpy(pframe, pattrib->iv, pattrib->iv_len);
+
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n xmitframe_coalesce:keyid= %d pattrib->iv[3]=%.2x pframe=%.2x %.2x %.2x %.2x \n",psecuritypriv->dot11PrivacyKeyIndex,pattrib->iv[3],*pframe, *(pframe+1),*(pframe+2),*(pframe+3)));
+
+			pframe += pattrib->iv_len;
+
+			mpdu_len -= pattrib->iv_len;
+		}
+
+		if (frg_inx == 0) {
+			llc_sz = rtl8711_put_snap(pframe, pattrib->ether_type);
+			pframe += llc_sz;
+			mpdu_len -= llc_sz;
+		}
+
+		if ((pattrib->icv_len >0) && (pattrib->bswenc)) {
+			mpdu_len -= pattrib->icv_len;
+		}
+
+
+		if (bmcst) {
+			mem_sz = _pktfile_read(&pktfile, pframe, pattrib->pktlen);
+		} else {
+			mem_sz = _pktfile_read(&pktfile, pframe, mpdu_len);
+		}
+
+		pframe += mem_sz;
+
+		if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
+			_memcpy(pframe, pattrib->icv, pattrib->icv_len); 
+			pframe += pattrib->icv_len;
+		}
+
+		frg_inx++;
+
+		if (bmcst || (endofpktfile(&pktfile) == _TRUE))
+		{
+			pattrib->nr_frags = frg_inx;
+
+			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags==1)? llc_sz:0) + 
+					((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;
+			ClearMFrag(mem_start);
+#ifdef CONFIG_SDIO_HCI
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("coalesce: pattrib->last_txcmdsz=%d pxmitframe->pxmitbuf->phead=0x%p  pxmitframe->pxmitbuf->ptail=0x%p pxmitframe->pxmitbuf->len=%d\n", pattrib->last_txcmdsz, pxmitframe->pxmitbuf->phead, pxmitframe->pxmitbuf->ptail, pxmitframe->pxmitbuf->len));
+			pxmitframe->pxmitbuf->ptail = pxmitframe->buf_addr + _RND512(pframe-pxmitframe->buf_addr);
+			pxmitframe->pxmitbuf->len += pxmitframe->pxmitbuf->ptail - pxmitframe->buf_addr;//(pframe-mem_start);
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("[2] coalesce: pattrib->last_txcmdsz=%d pxmitframe->pxmitbuf->ptail=0x%p pxmitframe->pxmitbuf->len=%d\n", pattrib->last_txcmdsz, pxmitframe->pxmitbuf->ptail, pxmitframe->pxmitbuf->len));
+#endif
+			break;
+		} else {
+#ifdef CONFIG_SDIO_HCI
+			pxmitframe->pxmitbuf->ptail = pxmitframe->buf_addr + _RND512(pframe-pxmitframe->buf_addr);
+			pxmitframe->pxmitbuf->len += pxmitframe->pxmitbuf->ptail - pxmitframe->buf_addr;
+                        pframe=pxmitframe->pxmitbuf->ptail;
+#endif
+		}
+
+		addr = (uint)(pframe);
+		//pbuf_start = (unsigned char *)RND4(addr);
+		//mem_start = pbuf_start + TXDESC_OFFSET;
+
+		mem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;
+		_memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);
+	}
+
+	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\nxmitframe_addmic(padapter, pxmitframe)==_FAIL\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+#ifdef CONFIG_SDIO_HCI
+	fillin_txdesc(padapter, pxmitframe);
+#endif
+
+	xmitframe_swencrypt(padapter, pxmitframe);
+	
+exit:	
+	
+_func_exit_;	
+
+	return res;
+}
+
+sint rtl8711_put_snap(u8 *data, u16 h_proto)
+{
+	struct ieee80211_snap_hdr *snap;
+	u8 *oui;
+_func_enter_;
+	snap = (struct ieee80211_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+	
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+
+	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+_func_exit_;
+	return SNAP_SIZE + sizeof(u16);
+}
+
+void update_protection(_adapter *padapter, u8 *ie, uint ie_len)
+{
+
+	uint	protection;
+	u8	*perp;
+	sint	 erp_len;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
+	
+_func_enter_;
+	
+	
+	switch(pxmitpriv->vcs_setting)
+	{
+		case DISABLE_VCS:
+			pxmitpriv->vcs = NONE_VCS;
+			break;
+	
+		case ENABLE_VCS:
+			break;
+	
+		case AUTO_VCS:
+		default:
+			perp = get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+			if(perp == NULL)
+			{
+			pxmitpriv->vcs = NONE_VCS;
+	}
+			else
+			{
+		protection = (*(perp + 2)) & BIT(1);
+		if (protection)
+				{
+					if(pregistrypriv->vcs_type == RTS_CTS)
+			pxmitpriv->vcs = RTS_CTS;
+		else
+						pxmitpriv->vcs = CTS_TO_SELF;
+				}
+				else
+				pxmitpriv->vcs = NONE_VCS;
+		}
+			break;			
+	
+	}
+
+_func_exit_;
+
+}
+
+struct xmit_buf *alloc_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	_irqL irqL;
+	struct xmit_buf *pxmitbuf =  NULL;
+	_list *plist, *phead;
+	_queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+_func_enter_;
+
+	//printk("+alloc_xmitbuf\n");
+
+	_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
+
+	if(_queue_empty(pfree_xmitbuf_queue) == _TRUE) {
+		pxmitbuf = NULL;
+	} else {
+
+		phead = get_list_head(pfree_xmitbuf_queue);
+
+		plist = get_next(phead);
+
+		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
+
+		list_delete(&(pxmitbuf->list));
+	}
+
+	if (pxmitbuf !=  NULL)
+	{
+		pxmitpriv->free_xmitbuf_cnt--;
+
+		//printk("alloc, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
+
+		//pxmitbuf->priv_data = NULL;
+#ifdef CONFIG_SDIO_HCI
+		pxmitbuf->len = 0;
+		pxmitbuf->phead = pxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->pbuf;
+		pxmitbuf->pend = pxmitbuf->pbuf + MAX_XMITBUF_SZ;
+#endif
+	}
+
+	_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxmitbuf;
+}
+
+int free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	_irqL irqL;
+	_queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;		
+	
+_func_enter_;	
+
+	//printk("+free_xmitbuf\n");
+
+	if(pxmitbuf==NULL)
+	{		
+		return _FAIL;
+	}
+	
+	_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
+	
+	list_delete(&pxmitbuf->list);	
+	
+	list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+
+	pxmitpriv->free_xmitbuf_cnt++;
+	//printk("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
+		
+	_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);	
+
+_func_exit_;	 
+
+	return _SUCCESS;
+	
+} 
+
+
+/*
+Calling context:
+1. OS_TXENTRY
+2. RXENTRY (rx_thread or RX_ISR/RX_CallBack)
+
+If we turn on USE_RXTHREAD, then, no need for critical section.
+Otherwise, we must use _enter/_exit critical to protect free_xmit_queue...
+
+Must be very very cautious...
+
+*/
+
+struct xmit_frame *alloc_xmitframe(struct xmit_priv *pxmitpriv)//(_queue *pfree_xmit_queue)
+{
+	/*
+		Please remember to use all the osdep_service api,
+		and lock/unlock or _enter/_exit critical to protect 
+		pfree_xmit_queue
+	*/
+
+	_irqL irqL;
+	struct xmit_frame *pxframe = NULL;
+	_list *plist, *phead;
+	_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+
+_func_enter_;
+
+	_enter_critical(&pfree_xmit_queue->lock, &irqL);
+
+	if (_queue_empty(pfree_xmit_queue) == _TRUE) {
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(pfree_xmit_queue);
+
+		plist = get_next(phead);
+
+		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+
+		list_delete(&(pxframe->list));
+	}
+
+	if (pxframe !=  NULL)
+	{
+		pxmitpriv->free_xmitframe_cnt--;
+
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("alloc_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
+
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		pxframe->attrib.psta = NULL;
+
+#ifdef CONFIG_USB_HCI
+		pxframe->pkt = NULL;
+#endif //#ifdef CONFIG_USB_HCI
+	}
+
+	_exit_critical(&pfree_xmit_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxframe;
+}
+
+struct xmit_frame *alloc_xmitframe_ex(struct xmit_priv *pxmitpriv, int tag)
+{
+	_irqL irqL;
+	struct xmit_frame *pxframe;
+	_list	*plist, *phead;
+	_queue *pfree_xmit_queue;
+	uint *pfree_cnt;
+	
+_func_enter_;	
+
+
+	if(tag == DATA_FRAMETAG)
+	{
+		pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+		pfree_cnt = &pxmitpriv->free_xmitframe_cnt;
+	}	
+	else if(tag == AMSDU_FRAMETAG)
+	{
+		pfree_xmit_queue = &pxmitpriv->free_amsdu_xmit_queue;
+		pfree_cnt = &pxmitpriv->free_amsdu_xmitframe_cnt;
+	}	
+	else if(tag == TXAGG_FRAMETAG)
+	{
+		pfree_xmit_queue = &pxmitpriv->free_txagg_xmit_queue;
+		pfree_cnt = &pxmitpriv->free_txagg_xmitframe_cnt;
+	}	
+	else 
+	{
+		return NULL;
+	}
+		
+	
+	_enter_critical(&pfree_xmit_queue->lock, &irqL);
+
+	if(_queue_empty(pfree_xmit_queue) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("free_xmitframe_cnt:%d\n", *pfree_cnt));
+		pxframe =  NULL;
+	
+	}
+	else
+	{
+
+		phead = get_list_head(pfree_xmit_queue);
+		
+		plist = get_next(phead);
+		
+		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+
+		list_delete(&(pxframe->list));
+	}
+
+	
+	if( pxframe !=  NULL ) 	
+	{	
+		if(pxframe->frame_tag == tag)
+		{
+			
+			*pfree_cnt--;
+#ifdef CONFIG_USB_HCI
+			pxframe->pkt = NULL;		
+#endif //#ifdef CONFIG_USB_HCI	
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("alloc_xmitframe_ex():tag=%d, free_xmitframe_cnt=%d\n", tag, *pfree_cnt));
+		}
+	}
+
+	_exit_critical(&pfree_xmit_queue->lock, &irqL);
+	
+_func_exit_;	
+
+	return pxframe;
+
+}
+
+sint free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{	
+	_irqL irqL;
+	_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;		
+	_adapter *padapter = pxmitpriv->adapter;
+	_pkt *pndis_pkt = NULL;
+
+_func_enter_;	
+
+	if (pxmitframe == NULL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("======free_xmitframe():pxmitframe==NULL!!!!!!!!!!\n"));
+		goto exit;
+	}
+
+	_enter_critical(&pfree_xmit_queue->lock, &irqL);
+
+	list_delete(&pxmitframe->list);	
+
+	if (pxmitframe->pkt){
+		pndis_pkt = pxmitframe->pkt;
+		pxmitframe->pkt = NULL;
+	}
+
+	list_insert_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));
+
+	pxmitpriv->free_xmitframe_cnt++;
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("free_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
+
+	_exit_critical(&pfree_xmit_queue->lock, &irqL);
+
+#ifdef PLATFORM_LINUX
+	if (netif_queue_stopped(padapter->pnetdev))
+		netif_wake_queue(padapter->pnetdev);
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	if (pndis_pkt)
+		NdisMSendComplete(padapter->hndis_adapter, pndis_pkt, NDIS_STATUS_SUCCESS);
+#endif
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+int free_xmitframe_ex(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{	
+			
+_func_enter_;	
+
+	if(pxmitframe==NULL){
+		goto exit;
+	}
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("free_xmitframe_ex()\n"));
+	
+	if(pxmitframe->frame_tag == DATA_FRAMETAG)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("free_xmitframe_ex(), free_xmitframe\n"));
+		free_xmitframe(pxmitpriv, pxmitframe);	  
+	}
+#ifdef CONFIG_DRVEXT_MODULE
+	else if(pxmitframe->frame_tag == L2_FRAMETAG)
+	{
+		free_l2xmitframe(&padapter->drvextpriv, (struct l2_xmit_frame *)pxmitframe);
+	}
+#endif	
+#ifdef CONFIG_MLME_EXT	
+	else if(pxmitframe->frame_tag == MGNT_FRAMETAG)
+	{
+		_adapter *padapter = pxmitpriv->adapter;
+		
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("free_xmitframe_ex(), free_mgnt_xmitframe\n"));
+		free_mgnt_xmitframe(&padapter->mlmeextpriv, (struct mgnt_frame *)pxmitframe);
+	}		
+#endif	
+	else if(pxmitframe->frame_tag == TXAGG_FRAMETAG)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("free_xmitframe_ex(), free_txagg_xmitframe\n"));
+		//free_txagg_xmitframe(pxmitpriv, (struct agg_xmit_frame *)pxmitframe);
+	}		
+	else if(pxmitframe->frame_tag == AMSDU_FRAMETAG)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("free_xmitframe_ex(), free_amsdu_xmitframe\n"));
+		//free_amsdu_xmitframe(pxmitpriv, (struct amsdu_xmit_frame *)pxmitframe);
+	}
+
+exit:
+	
+_func_exit_;	 
+
+	return _SUCCESS;
+	
+} 
+
+void free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue)
+{
+
+	_irqL irqL;
+	_list	*plist, *phead;
+	struct	xmit_frame 	*pxmitframe;
+_func_enter_;	
+
+	_enter_critical(&(pframequeue->lock), &irqL);
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+	
+	while (end_of_queue_search(phead, plist) == _FALSE)
+	{
+			
+		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+
+		plist = get_next(plist); 
+		
+		free_xmitframe(pxmitpriv,pxmitframe);
+			
+	}
+	_exit_critical(&(pframequeue->lock), &irqL);
+
+_func_exit_;
+}
+
+static __inline struct tx_servq *get_sta_pending
+	(_adapter *padapter, _queue **ppstapending, struct sta_info *psta, sint up)
+{
+
+	struct tx_servq *ptxservq;
+	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
+	
+_func_enter_;	
+
+#ifdef CONFIG_RTL8711
+
+	if(IS_MCAST(psta->hwaddr))
+	{
+		ptxservq = &(psta->sta_xmitpriv.be_q); // we will use be_q to queue bc/mc frames in BCMC_stainfo
+		*ppstapending = &padapter->xmitpriv.bm_pending; 
+	}
+	else
+#endif		
+	{
+		switch (up) 
+		{
+			case 1:
+			case 2:
+				ptxservq = &(psta->sta_xmitpriv.bk_q);
+				*ppstapending = &padapter->xmitpriv.bk_pending;
+				(phwxmits+3)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : BK \n"));
+				break;
+
+			case 4:
+			case 5:
+				ptxservq = &(psta->sta_xmitpriv.vi_q);
+				*ppstapending = &padapter->xmitpriv.vi_pending;
+				(phwxmits+1)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : VI\n"));
+				break;
+
+			case 6:
+			case 7:
+				ptxservq = &(psta->sta_xmitpriv.vo_q);
+				*ppstapending = &padapter->xmitpriv.vo_pending;
+				(phwxmits+0)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : VO \n"));			
+				break;
+
+			case 0:
+			case 3:
+			default:
+				ptxservq = &(psta->sta_xmitpriv.be_q);
+				*ppstapending = &padapter->xmitpriv.be_pending;
+				(phwxmits+2)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : BE \n"));				
+			break;
+			
+		}
+
+	}
+
+_func_exit_;
+
+	return ptxservq;	
+		
+}
+
+
+/*
+Will enqueue pxmitframe to the proper queue, and indicate it to xx_pending list.....
+*/
+sint xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	_irqL irqL0;
+	_queue *pstapending;
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	sint bmcst = IS_MCAST(pattrib->ra);
+	sint res = _SUCCESS;
+
+_func_enter_;
+
+	if (pattrib->psta) {
+		psta = pattrib->psta;		
+	} else {
+		if (bmcst) {
+			psta = get_bcmc_stainfo(padapter);
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmit_classifier: get_bcmc_stainfo\n"));
+		} else {
+#ifdef CONFIG_MP_INCLUDED
+			if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+				psta = get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			else
+#endif
+				psta = get_stainfo(pstapriv, pattrib->ra);
+		}
+	}
+
+	if (psta == NULL) {
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmit_classifier: psta == NULL\n"));
+		goto exit;
+	}
+
+	ptxservq = get_sta_pending(padapter, &pstapending, psta, pattrib->priority);
+
+	_enter_critical(&pstapending->lock, &irqL0);
+
+	if (is_list_empty(&ptxservq->tx_pending)) {
+		list_insert_tail(&ptxservq->tx_pending, get_list_head(pstapending));
+	}
+
+	//_enter_critical(&ptxservq->sta_pending.lock, &irqL1);
+
+	list_insert_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
+	ptxservq->qcnt++;
+
+	//_exit_critical(&ptxservq->sta_pending.lock, &irqL1);
+
+	_exit_critical(&pstapending->lock, &irqL0);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+void alloc_hwxmits(_adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY;
+
+	pxmitpriv->hwxmits = (struct hw_xmit *)_malloc(sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry);	
+	
+	if(pxmitpriv->hwxmits == NULL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc_hwxmits(): alloc hwxmits fail!!!!!!!!!!!!!!\n"));
+		return;
+	}
+	
+	hwxmits = pxmitpriv->hwxmits;
+
+	if(pxmitpriv->hwxmit_entry == 5)
+	{
+		pxmitpriv->bmc_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
+	
+		pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
+
+       	pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
+	
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+
+      		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
+		
+	}	
+	else if(pxmitpriv->hwxmit_entry == 4)
+	{
+
+       	pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
+
+       	pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
+
+		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
+	
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+	}
+	else
+	{
+		
+
+	}
+	
+
+}
+
+void free_hwxmits(_adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if(pxmitpriv->hwxmits)
+		_mfree((u8 *)pxmitpriv->hwxmits, (sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry));
+}
+
+void init_hwxmits(struct hw_xmit *phwxmit, sint entry)
+{
+	sint i;
+_func_enter_;	
+	for(i = 0; i < entry; i++, phwxmit++)
+	{
+		_spinlock_init(&phwxmit->xmit_lock);
+		_init_listhead(&phwxmit->pending);		
+		phwxmit->txcmdcnt = 0;
+		phwxmit->accnt = 0;
+	}
+_func_exit_;	
+}
+
+/*
+tx_action == 0 == no frames to transmit
+tx_action > 0 ==> we have frames to transmit
+tx_action < 0 ==> we have frames to transmit, but TXFF is not even enough to transmit 1 frame.
+*/
+static int dequeue_xmitframes(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, sint entry)
+{
+	sint tx_action;
+
+	return tx_action;
+	
+}
+static void dump_xmitframes(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, sint entry)
+{
+		
+}
+
+static void free_xmitframes(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, sint entry)
+{
+
+#ifndef CONFIG_USB_HCI	
+
+	sint i;
+
+	_list	*plist, *phead;
+	
+
+	struct xmit_frame	*pxmitframe;
+	struct	hw_txqueue	*phwtxqueue;
+
+_func_enter_;
+	for (i = 0; i < entry; i++, phwxmit++)
+	{
+
+		phwtxqueue = phwxmit->phwtxqueue;	
+
+		phead = &phwxmit->pending;
+
+		plist = get_next(phead);
+
+		while (end_of_queue_search(phead, plist) == _FALSE)
+		{
+			
+			pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+			
+			plist = get_next(plist);
+			
+			free_xmitframe(pxmitpriv,pxmitframe);
+
+		}
+	
+	}
+	
+_func_exit_;	
+
+#endif
+
+}
+
+void xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe, struct xmit_buf *pxmitbuf)
+{
+	// pxmitbuf attach to pxmitframe
+	pxmitframe->pxmitbuf = pxmitbuf;
+
+	// urb and irp connection
+#ifdef CONFIG_USB_HCI
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+#endif
+
+
+#ifdef PLATFORM_OS_XP
+	pxmitframe->pxmit_irp[0] = pxmitbuf->pxmit_irp[0];
+#endif
+
+#endif
+
+	// buffer addr assoc
+	pxmitframe->buf_addr = pxmitbuf->pbuf;
+
+	// pxmitframe attach to pxmitbuf
+	pxmitbuf->priv_data = pxmitframe;
+}
+
+#ifdef CONFIG_USB_HCI
+int pre_xmit(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	_irqL irqL;
+	int ret;
+	struct xmit_buf *pxmitbuf = NULL;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+
+	do_queue_select(padapter, pattrib);
+	
+
+	_enter_critical(&pxmitpriv->lock, &irqL);
+	
+	if(txframes_sta_ac_pending(padapter, pattrib) > 0)//enqueue packet	
+	{
+		ret = _FALSE;
+		
+		//printk("pre_xmit(1)\n");
+		
+		xmit_enqueue(padapter, pxmitframe);	
+
+		_exit_critical(&pxmitpriv->lock, &irqL);
+		
+		return ret;
+	}
+	
+
+	pxmitbuf = alloc_xmitbuf(pxmitpriv);	
+	
+	if(pxmitbuf == NULL)//enqueue packet
+	{
+		ret = _FALSE;
+		//printk("pre_xmit(2)\n");
+
+		xmit_enqueue(padapter, pxmitframe);	
+
+		_exit_critical(&pxmitpriv->lock, &irqL);
+	}
+	else //dump packet directly
+	{
+		_exit_critical(&pxmitpriv->lock, &irqL);
+
+		ret = _TRUE;
+
+		xmitframe_xmitbuf_attach(pxmitframe,pxmitbuf);
+
+		xmit_direct(padapter, pxmitframe); 
+	}
+
+	return ret;
+}
+
+#else   //SDIO
+int pre_xmit(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int bq = 0;
+	int ret = _TRUE;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if (xmit_enqueue(padapter, pxmitframe) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("~~~~~~~~~~~~~~~pre_xmit():xmit_enqueue  fail!!!!!!!!!!!!!!\n"));
+		ret = _TRUE;
+	} else
+		ret = _FALSE;
+
+	return ret;
+}
+#endif
+
+void check_xmit(_adapter *padapter)
+{
+
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+
+#ifdef CONFIG_SDIO_HCI
+	struct xmit_frame *pcur_xmitframe=NULL;
+	struct hw_xmit *phwxmits;
+	sint hwentry;
+
+
+	phwxmits = pxmitpriv->hwxmits;
+	hwentry = pxmitpriv->hwxmit_entry;
+	
+	if(txframes_pending(padapter)){
+	
+		while(pxmitpriv->init_pgsz >( pxmitpriv->public_pgsz +15))//while(pxmitpriv->public_pgsz >10)
+			{
+			pcur_xmitframe =  dequeue_xframe(pxmitpriv, phwxmits, hwentry);
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("<<<<<<<pre_xmit():xmit_dequeue  (xmit_frame=0x%p)\n",pcur_xmitframe));
+			if(pcur_xmitframe ==NULL){
+				break;
+			}
+			if(check_xmit_resource(padapter, pcur_xmitframe) <= 0){
+				xmitframe_coalesce(padapter, pcur_xmitframe->pkt, pcur_xmitframe);
+				
+				dump_xframe(padapter, pcur_xmitframe);		
+				//res = xmit_direct(padapter, pcur_xmitframe);	
+							
+			}
+			else{
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("~~~~~~~check_xmit~~~~~~~~pre_xmit():xmit_dequeue  error!!!!!!!!!!!!!!\n"));
+
+			}
+		}
+		
+		
+	}
+
+#endif //CONFIG_SDIO_HCI
+	return ;
+
+}
+
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index b4338f3..fd50c50 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -283,5 +283,6 @@ source "drivers/net/wireless/rtlwifi/Kconfig"
 source "drivers/net/wireless/wl1251/Kconfig"
 source "drivers/net/wireless/wl12xx/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
+source "drivers/net/wireless/8712u/Kconfig"
 
 endif # WLAN
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 9760561..855b855 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -55,3 +55,6 @@ obj-$(CONFIG_WL12XX)	+= wl12xx/
 obj-$(CONFIG_WL12XX_PLATFORM_DATA)	+= wl12xx/
 
 obj-$(CONFIG_IWM)	+= iwmc3200wifi/
+
+obj-$(CONFIG_RTL8712U) += 8712u/
+
-- 
1.7.9.5

